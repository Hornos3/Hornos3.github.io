<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hornos3.github.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="CoLin&#39;s BLOG">
<meta property="og:url" content="http://hornos3.github.com/page/2/index.html">
<meta property="og:site_name" content="CoLin&#39;s BLOG">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="CoLin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://hornos3.github.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-cn'
  };
</script>

  <title>CoLin's BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CoLin's BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC1%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC1%E7%AB%A0/" class="post-title-link" itemprop="url">操作系统原理——第1章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-03 09:12:14 / Modified: 09:16:18" itemprop="dateCreated datePublished" datetime="2023-03-03T09:12:14+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">操作系统原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>3.2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="chapter-1-操作系统概述"><a class="markdownIt-Anchor" href="#chapter-1-操作系统概述"></a> Chapter 1 操作系统概述</h1>
<h2 id="11-操作系统直观认识和定义"><a class="markdownIt-Anchor" href="#11-操作系统直观认识和定义"></a> 1.1 操作系统直观认识和定义</h2>
<h3 id="111-操作系统的直观认识"><a class="markdownIt-Anchor" href="#111-操作系统的直观认识"></a> 1.1.1 操作系统的直观认识</h3>
<p>操作系统提供以下几种直观功能：</p>
<ul>
<li>提供操作界面，用户可以利用一些可视化的元素来操作计算机，展示计算机的执行结果。</li>
<li>控制程序运行，利用图形化或命令行的方式启动一个程序、结束一个程序、强制结束没有响应的程序等。</li>
<li>管理系统资源，用户可以更新驱动程序或安装新的驱动、卸载不再需要的设备，访问打印机、硬盘等资源。</li>
<li>配置系统参数，设置或改变系统参数。</li>
<li>监控系统状态，通过任务管理器等可以观察系统的实时工作情况。</li>
<li>工具软件集合，提供用于系统管理的辅助工具和内置命令便于用户进行个性化配置、调优或测试。</li>
</ul>
<h3 id="112-操作系统的定义"><a class="markdownIt-Anchor" href="#112-操作系统的定义"></a> 1.1.2 操作系统的定义</h3>
<p>操作系统是一个大型的系统程序，它<font color=red>管理和分配计算机系统中软、硬件资源</font>，控制和协调并发活动，<font color=red>为用户提供接口</font>和良好的工作环境。</p>
<h2 id="12-操作系统的发展历史"><a class="markdownIt-Anchor" href="#12-操作系统的发展历史"></a> 1.2 操作系统的发展历史</h2>
<h3 id="121-手动操作阶段"><a class="markdownIt-Anchor" href="#121-手动操作阶段"></a> 1.2.1 手动操作阶段</h3>
<p>即电子管时代（1946-1955），此时没有操作系统，一个程序需要程序员通过打孔的方式写在纸带上，然后将纸带装入到设备中，启动输入设备将程序和数据输入到计算机内存中，然后控制台开关启动程序开始处理数据。整个过程中计算机被一个程序员占用。</p>
<p>特点：用户独占、缺少交互、效率低下（如运行一次程序可能需要提前几十分钟将设备全部装好，运行完之后还需要几十分钟将设备全部拆卸）</p>
<h3 id="122-单道批处理系统"><a class="markdownIt-Anchor" href="#122-单道批处理系统"></a> 1.2.2 单道批处理系统</h3>
<p>即晶体管时代（1955-1965）。单道批处理能够控制计算机自动处理一批作业，逐个加载、运行和撤出其中的每一个作业，直到全部作业处理完毕。批处理系统的特点：<font color=red>成批、自动、单道</font>。缺点是平均周转时间长、无交互能力。</p>
<p>单道批处理系统两种实现方式：<font color=red>联机批处理系统和脱机批处理系统</font>。联机批处理系统的输入输出过程都由主机控制，主机和输入设备之间添加一个磁带作为存储设备。运行于主机上的监督程序控制成批地将输入机上的用户作业读入磁带并形成作业队列，然后依次将磁带上的用户作业逐个装入主机运行并将结果输出到输出机，直到该批作业完成。脱机批处理系统增加一台与主机不直接相连而专门用于输入输出的卫星机，主机的作用是利用批处理方式自动按批处理磁带上的作业并将结果存放到输出磁带上。</p>
<h3 id="123-多道批处理系统"><a class="markdownIt-Anchor" href="#123-多道批处理系统"></a> 1.2.3 多道批处理系统</h3>
<p>集成电路时代（1965-1980），多道批处理系统利用多道程序处理技术，在内存中存放多道程序，当某道程序因为某种原因不能继续运行时监控程序会调度另一个程序运行，使得CPU尽量处于忙碌状态。多道批处理系统可以让CPU与外设，外设与外设之间处于并行状态。缺点是作业处理时间长，运行过程不确定，交互能力差。</p>
<h3 id="124-分时操作系统"><a class="markdownIt-Anchor" href="#124-分时操作系统"></a> 1.2.4 分时操作系统</h3>
<p>60年代中断技术的出现、80年代后大规模集成电路的出现、事务性程序和任务的出现允许CPU进行更加复杂的作业调度。现在的操作系统要求能够进行多任务多用户的调度。主机采用分时技术轮流为每一个终端服务，每一个终端都认为自己独占了整台计算机。</p>
<p>主机<font color=red>以很短的时间片为单位将CPU循环地轮流分配给每一个作业使用</font>，直到全部作业运行完毕。时间片是较短的时间间隔，使得主机的响应时间较短。分时系统的特点：多路调制性、独占性（用户认为独占计算机）、交互性（能够及时响应用户请求）</p>
<h3 id="125-分时操作系统衍化"><a class="markdownIt-Anchor" href="#125-分时操作系统衍化"></a> 1.2.5 分时操作系统衍化</h3>
<ul>
<li>微型计算机操作系统</li>
<li>实时操作系统（可靠性、安全性、强调作业完成时限和可预测性）
<ul>
<li>硬实时系统：必须按时完成</li>
<li>软实时系统：尽量按时完成</li>
</ul>
</li>
<li>嵌入式操作系统</li>
<li>网络操作系统</li>
<li>分布式操作系统</li>
</ul>
<h2 id="13-操作系统的功能"><a class="markdownIt-Anchor" href="#13-操作系统的功能"></a> 1.3 操作系统的功能</h2>
<h3 id="131-处理机管理"><a class="markdownIt-Anchor" href="#131-处理机管理"></a> 1.3.1 处理机管理</h3>
<p>处理机是计算机系统的核心资源，处理机管理即为进程管理或CPU管理。一个操作系统应该能够进行<font color=red>进程控制、进程同步、进程通信与进程调度</font>。</p>
<ul>
<li>进程控制：为一个作业创建一个或多个进程，并分配必要的资源。进程运行结束后应该撤销该进程并回收该进程占用的各种资源。主要功能是为作业创建进程、撤销已经结束的进程。</li>
<li>进程同步：保证进程之间有条不紊地进行，协调多个进程之间的运行。</li>
<li>进程通信：用于合作进程之间交换信息，操作系统使用合适的机制完成信息传输。</li>
<li>进程调度：操作系统需要根据某种策略选择合适的进程占用CPU。</li>
</ul>
<h3 id="132-存储管理"><a class="markdownIt-Anchor" href="#132-存储管理"></a> 1.3.2 存储管理</h3>
<p>操作系统需要能够合理调度内存，内存管理需要支持多道程序设计，包含<font color=red>内存分配、内存共享、内存保护、地址映射和虚拟存储</font>。</p>
<ul>
<li>内存分配：程序运行需要将其存放在内存中，在程序运行前和运行时需要为其分配一定大小的内存。</li>
<li>内存共享：允许多道程序存放在内存中，实现内存的共享。另外实现多个进程共用一块内存空间，如dll文件所在的内存。</li>
<li>内存保护：保证进程在自己的内存空间中运行而不互相干扰，需要检查进程对内存的访问是否越界或越权。</li>
<li>地址映射：操作系统提供地址映射机构将进程地址空间的逻辑地址转化为内存空间对应的物理地址，地址映射可以使用户不必关心物理存储空间的分配细节。</li>
<li>虚拟存储：内存扩充功能，避免因为物理内存太小而导致大型程序无法运行或限制了多个进程的并发运行。实现了物理内存在逻辑上进行扩充，在不增加物理内存的情况下使用虚拟存储技术获得内存扩充的效果。</li>
</ul>
<h3 id="133-设备管理"><a class="markdownIt-Anchor" href="#133-设备管理"></a> 1.3.3 设备管理</h3>
<p>操作系统不能让用户直接使用这些设备，这会使得用户的使用变得困难，因此操作系统需要使用合适的方式为进程分配这些资源，提高CPU和设备的使用率。操作系统<font color=red>提供统一规范的接口给应用程序使用</font>，完成进程对设备的输入输出请求并方便用户添加新设备或删除旧设备。</p>
<ul>
<li>分配设备：为申请设备的进程分配设备，记录设备的使用情况。</li>
<li>设备控制：通过合适的方式完成设备与CPU之间的数据传输。</li>
<li>设备映射：使用所谓的逻辑设备而不是物理设备，可以极大提高程序的灵活性、可移植性和可阅读性。用户可以使用友好名和不同的配置选项选择一个逻辑设备。</li>
<li>缓冲区管理：提高CPU的利用率，提高系统吞吐量，在内存中设置缓冲区并对缓冲区中的读写更新等操作进行有效管理以获得更好的系统性能。</li>
</ul>
<h3 id="134-文件管理"><a class="markdownIt-Anchor" href="#134-文件管理"></a> 1.3.4 文件管理</h3>
<p>操作系统需要实现按名存取文件和目录，并向用户提供一条存取文件和目录的标准操作接口。除了基本的文件操作（如读写复制删除等）还需要实现文件的共享、保护和保密，保证文件的安全性和不被越权访问。</p>
<h2 id="15-操作系统评价指标"><a class="markdownIt-Anchor" href="#15-操作系统评价指标"></a> 1.5 操作系统评价指标</h2>
<ul>
<li>吞吐量：系统在单位时间内处理信息的能力或可以处理的任务数量。是用于衡量系统性能的重要指标。操作系统合理分配和调度资源可以提高系统的吞吐量。</li>
<li>响应能力：表现为系统从接收数据到输出结果的时间间隔长短，时间间隔越长说明响应能力越差。系统响应时间与用户数量和时间片的大小有关。用户数量越多响应时间越长，时间片越短响应时间越短。</li>
<li>资源利用率：设备在单位时间内被利用的百分比。</li>
<li>可移植性：改变硬件环境，操作系统仍能正常工作的能力。一般在新的硬件环境中需要改写或增加一些代码来使得操作系统能够在新的环境下工作，这个修改工作中的<font color=red>代码修改量</font>越少说明可移植性越好。</li>
<li>可靠性：即系统发生错误的概率大小和操作系统发现、诊断和恢复系统故障能力的大小。错误率越小可靠性越高。</li>
</ul>
<h2 id="17-操作系统的逻辑结构"><a class="markdownIt-Anchor" href="#17-操作系统的逻辑结构"></a> 1.7 操作系统的逻辑结构</h2>
<h3 id="171-整体式结构"><a class="markdownIt-Anchor" href="#171-整体式结构"></a> 1.7.1 整体式结构</h3>
<p>整体式结构又称为模块化结构或宏内核结构，操作系统的常用设计模式和应用软件的基本设计模式。以模块为基本单位进行构建，系统中每一个过程都有明确的入口参数列表和返回值列表，大多数过程可以相互调用不受约束。如UNIX系统、Linux系统的单体内核。<br />
优点：模块设计、编码和调试独立，模块之间可以自由调用<br />
缺点：错误容易扩散，开发和维护困难，可伸缩性差</p>
<h3 id="172-层次式结构"><a class="markdownIt-Anchor" href="#172-层次式结构"></a> 1.7.2 层次式结构</h3>
<p>层次式结构将操作系统中所有功能模块按照调用次序分别排成若干层，确保各层之间只能单向依赖或单向调用。分层原则主要：</p>
<ul>
<li>硬件相关放在最底层</li>
<li>与用户策略和交互有关的放在最顶层</li>
<li>中间各层按照调用次序或消息传递顺序安排</li>
<li>共性的和活跃的服务放在较低的层次</li>
</ul>
<p>优点：结构清晰、整体问题局部化、有利于维护扩充和移植。</p>
<h3 id="173-微内核结构"><a class="markdownIt-Anchor" href="#173-微内核结构"></a> 1.7.3 微内核结构</h3>
<p>微内核结构又称为客户-服务机结构，分为两个部分：微内核和核外服务器。微内核足够小，只提供最基本的OS核心功能和服务，核外服务器完成OS绝大部分功能，等待客户提出请求。如Harmony-OS、Windows-NT（分层结构+微内核）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC6%E7%AB%A0%E4%B9%A0%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC6%E7%AB%A0%E4%B9%A0%E9%A2%98/" class="post-title-link" itemprop="url">计算机组成原理——第6章习题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-03 00:02:25 / Modified: 00:05:10" itemprop="dateCreated datePublished" datetime="2023-03-03T00:02:25+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="61"><a class="markdownIt-Anchor" href="#61"></a> 6.1</h3>
<ul>
<li>指令周期：一条指令从取出到执行完成所需要的时间。</li>
<li>数据通路：数据在各功能部件之间传送的路径。</li>
<li>机器周期：将指令周期划分为多个机器周期（又称CPU周期）。</li>
<li>时钟周期：每个机器周期包含若干个时钟周期。</li>
</ul>
<h3 id="62"><a class="markdownIt-Anchor" href="#62"></a> 6.2</h3>
<ol>
<li>B</li>
<li>B<br />
三个寄存器都是通用寄存器，因此需要通用寄存器组。加法运算需要使用算数逻辑单元。寻址需要向存储器中获取数据。指令译码器不是在取数和执行过程中使用的，译码发生在取数之前。</li>
<li>B<br />
主存空间为4GB，字长32位，因为指令按字边界对齐保存，所以PC至少为30位，指令寄存器IR的位数至少为32位，它是用来保存当前指令的内容的。</li>
<li>D<br />
A正确，B正确，C正确，时钟周期不能太短，D错误，一条指令可能需要不止一个时钟脉冲信号完成（多周期处理器），因此不是所有的时钟脉冲信号都开始执行一条新的指令。</li>
<li>A<br />
A错误，因为单总线结构数据通路无法让某些指令在一个时钟周期内完成。应该采用专用数据通路结构。B正确，要想在一个时钟周期之内完成一条指令的联系，因此一个时钟周期需要时间稍长一些，其时长取决于执行速度最慢的指令。C正确，在指令执行过程中控制信号不变。D正确，每个时钟周期执行一条指令，故CPI=1。</li>
<li>B<br />
A正确。B错误，CS在CPU内部，存放的是微指令，按照微指令地址进行访问。C正确。D正确。</li>
<li>D<br />
硬布线控制器的指令执行速度快，指令功能的修改和扩展难。</li>
<li>C</li>
<li>C</li>
<li>C</li>
</ol>
<h3 id="63"><a class="markdownIt-Anchor" href="#63"></a> 6.3</h3>
<ol>
<li>CPU的基本功能有程序控制、操作控制、时序控制、数据加工、中断处理。</li>
<li>CPU内部有：</li>
</ol>
<ul>
<li>IR寄存器保存当前执行的指令的内容</li>
<li>PC寄存器保存将要执行指令的字节地址</li>
<li>AR存储器地址寄存器保存CPU访问主存的单元地址</li>
<li>DR存储器数据寄存器保存从主存中读取或将向主存写入的数据</li>
<li>GR通用寄存器组</li>
<li>PSW保存由运算指令创建的各种条件标志</li>
</ul>
<p>其中GR、PSW是程序员可见的，AR、DR、IR不是必需的。<br />
3. 取指周期是从开始取指令到取指令完成的一段周期，完成的操作：访问PC指定的主存地址处的指令，形成后续指令地址。<br />
4. 计算机设计时序系统的原因是指令执行过程中的所有操作必需遵守严格的顺序，对操作的开始时间和持续时间有严格的控制，以保证指令的正确执行。机器周期是指主存取出一条指令的最短时间。<br />
5. 传统三级时序采用时钟周期、节拍电位和节拍脉冲来对操作控制信号进行定时控制，其中状态周期用电位来表示当前处于指令执行的哪个机器周期，节拍电位用电位表示当前处于机器周期的第几个节拍。采用三级时序的好处是可以简化控制器的设计。完成了时序发生器的设计后，所有控制信号都是状态周期电位、节拍电位、指令译码信号、状态反馈信号的组合逻辑。<br />
现代时序系统的定时信号就是基本时钟，一个时钟周期就是一个节拍，指令需要多少个时钟周期就分配多少个时钟周期。其采用有限状态机来描述指令的执行过程，将不同指令执行的每个时钟周期均对应一个状态，每一个状态会对应特定的微操作控制信号。控制器的核心模块是有限状态机，由一个状态寄存器和有限状态机组合逻辑控制单元构成。有限状态机组合逻辑控制单元的输入包括现态、指令的译码信号和反馈信号，输出为次态，送入状态寄存器输入端，在时钟信号的作用下输入状态寄存器中，作为下一时刻的现态；所有操作控制信号的输出都只与现态有关。<br />
6. 略<br />
7. 组合逻辑控制器又称微程序控制器，控制器由各种类型的逻辑门电路和触发器构成，与微程序控制器相比，组合逻辑控制器具有结构复杂但速度快的特点，但指令功能修改和扩展较难。<br />
微程序控制器的设计采用存储技术和程序设计技术，使复杂的控制逻辑得到简化，计算机通过读出存放在微程序控制器中微指令产生指令执行过程中所需要的控制信号，与硬布线控制器相比速度较慢。<br />
8. 微程序是多条微指令的集合，用于实现指令的功能，属于机器指令级别，对用户透明，存放在CPU内的控制存储器中；程序则是为了完成某一应用功能所编写的指令（包括机器语言指令或高级语言指令）集合，运行时存放在计算机的主存中。<br />
指令是指挥计算机执行某种功能的命令，是构成程序的基本单位，由操作码和地址字段构成；而微指令则用于微程序控制器中产生指令执行过程中所需要的微指令，是构成微程序的基本单位，由操作控制字段、判别测试字段和下址字段等组成。<br />
9. 微指令编码方法有直接表示法、编码表示法和混合表示法3种。<br />
10. 微程序控制器设计方法：</p>
<ul>
<li>分析指令执行的数据通路，列出每一条指令在所有寻址方式下的执行操作流程和每一步需要的控制信号。</li>
<li>对指令的操作流程进行细化，将每条指令的每个微操作分配到具体机器周期的各个时间节拍信号上。</li>
<li>以时钟周期为单位，构建指令执行状态图。</li>
<li>设计微指令格式、微命令编码方法。</li>
<li>根据指令执行状态图编制每条指令的微程序，按照状态机组织微程序并存放到控制寄存器中。</li>
<li>根据微程序组织方式构建微程序控制器中的地址转移逻辑、微地址寄存器、控制存储器之间的通路，实现微程序控制器。</li>
</ul>
<p>硬布线控制器设计方法：</p>
<ul>
<li>分析指令执行的数据通路，列出每条指令在所有寻址方式下的执行操作流程和每一步需要的控制信号。</li>
<li>对指令的操作流程细化，将每条指令的每个微操作分配到具体机器周期的具体时间节拍信号上，即对操作控制信号进行同步控制。</li>
<li>根据控制信号同步控制方式构造合适的时序发生器。</li>
<li>对每一个控制信号进行逻辑综合，得到每个控制信号的逻辑表达式。</li>
<li>采用逻辑门、PLA或ROM实现逻辑表达式的功能。</li>
</ul>
<ol start="11">
<li>略</li>
<li>略</li>
<li>略</li>
</ol>
<h3 id="64"><a class="markdownIt-Anchor" href="#64"></a> 6.4</h3>
<ol>
<li>观察到d旁边有一个+1，推断其是PC。d有箭头指向c，c有箭头指向主存，因此推断c为AR，故a为DR，b为IR。</li>
<li>取指阶段：PC→AR→主存M→DR→IR；PC++<br />
执行阶段：IR(A)→AR→主存M→DR→AC</li>
</ol>
<h3 id="65"><a class="markdownIt-Anchor" href="#65"></a> 6.5</h3>
<p>略</p>
<h3 id="66"><a class="markdownIt-Anchor" href="#66"></a> 6.6</h3>
<ol>
<li>当RegWrite出现恒0故障时，寄存器组全部不可写，因此会导致所有需要写回寄存器的指令故障。当RegWrite出现恒1故障时，寄存器组全部可写，会导致所有不需要写回寄存器的指令故障。</li>
<li>RegDst出现恒0故障时，写入寄存器的编号无法传入，导致所有需要写回rd的指令出现故障（无法写回）。RegDst出现恒1故障时，会错误地传入rd寄存器编号，所有需要写回rt的指令会出现故障（选择写入的寄存器不是rt而错误地变成了rd）。</li>
<li>MemWrite出现恒0故障时，数据存储器全部不可写，所有需要写存的指令会出现故障。MemWrite出现恒1故障时，所有不需要写存的指令会引起写存故障。</li>
</ol>
<h3 id="67"><a class="markdownIt-Anchor" href="#67"></a> 6.7</h3>
<p>略</p>
<h3 id="68"><a class="markdownIt-Anchor" href="#68"></a> 6.8</h3>
<p>略</p>
<h3 id="69"><a class="markdownIt-Anchor" href="#69"></a> 6.9</h3>
<p>略</p>
<h3 id="610"><a class="markdownIt-Anchor" href="#610"></a> 6.10</h3>
<p>对于单总线CPU，数据通路的最小时钟周期必须大于T<sub>clk_to_q</sub>+T<sub>max</sub>+T<sub>setup</sub>，即180ps。最大频率为5.56GHz。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC5%E7%AB%A0%E4%B9%A0%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC5%E7%AB%A0%E4%B9%A0%E9%A2%98/" class="post-title-link" itemprop="url">计算机组成原理——第5章习题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-03 00:02:13 / Modified: 00:05:10" itemprop="dateCreated datePublished" datetime="2023-03-03T00:02:13+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="52"><a class="markdownIt-Anchor" href="#52"></a> 5.2</h3>
<ol>
<li>A<br />
三地址指令29条，需要18位作为地址和至少5位作为地址码。二地址指令107条，需要12位作为地址和至少7位作为地址码。指令字长至少应该是24（按照字节编址）</li>
<li>A<br />
寄存器直接寻址需要4位寄存器标号，基址寻址也需要4位寄存器标号，剩余16位可用于表示偏移量，使用补码表示则范围为-32768~32767。</li>
<li>A<br />
16位定长指令，48条指令至少需要6位指令码，4种寻址方式需要2位标识，剩余8位可寻址范围为0~255。</li>
<li>C</li>
<li>C</li>
<li>A</li>
<li>D</li>
<li>D</li>
<li>D<br />
注意本题为大端序，LSB位于高地址处。</li>
<li>B</li>
<li>C<br />
无符号整数大于则ZF=0，CF=0。</li>
<li>A</li>
<li>略</li>
</ol>
<h3 id="53"><a class="markdownIt-Anchor" href="#53"></a> 5.3</h3>
<ol>
<li>指令是用户使用计算机与计算机本身运行的基本功能单位。指令系统是计算机系统性能的几种体现，是计算机软、硬件的设计基础。</li>
<li>计算机设计多种操作数寻址方式是为了提升寻址的灵活性，同时可以在一定程度上减少地址寻址所使用的指令位数。</li>
<li>作为寻址方式字段给出。</li>
<li>基址寻址面向系统，用于程序的重定位和扩展程序空间。变址寻址面向用户，主要解决程序循环问题。二者在计算有效地址的方式上相似，但基址寄存器的基址值一般不变且形式地址表示的偏移量位数较短，偏移范围较小；而变址寄存器的值可以改变，偏移量位数足以表示整个存储空间。</li>
<li>略</li>
<li>定长指令便于机器解码执行，结构规整，有利于设计硬件，但不容易扩展。变长指令灵活，但不易解码。</li>
<li>指令的地址码指的是指令中用于寻址的地址值，通常指定操作数的地址，地址码的字段的作用随着指令类型和寻址方式的不同而不同。指令中的操作码用于区分不同功能的指令，标识指令的种类。</li>
</ol>
<h3 id="54"><a class="markdownIt-Anchor" href="#54"></a> 5.4</h3>
<ol>
<li>立即数</li>
<li>直接</li>
<li>寄存器</li>
<li>寄存器间接</li>
</ol>
<p>注：寻址方式区分技巧<br />
需要两次找其他值的是间接。间接寻址指的是操作数地址的地址在主存，寄存器间接寻址指的是操作数地址在寄存器，前一个需要两次访问主存，后一个需要首先访问寄存器再访问主存。</p>
<h3 id="55"><a class="markdownIt-Anchor" href="#55"></a> 5.5</h3>
<ol>
<li>操作数地址码由寻址方式字段和寄存器号字段组成。16个通用寄存器需要4位标识，8种寻址方式需要3位标识，剩余字段数量为9位，故单操作数指令最多为512条。</li>
<li>4条。</li>
<li>0~7，对于直接寻址，应该是使用寻址方式这3位来寻址。</li>
<li>变址寻址考虑到寄存器16位，因此寻址范围为2<sup>16</sup>个字即64KW。</li>
</ol>
<h3 id="56"><a class="markdownIt-Anchor" href="#56"></a> 5.6</h3>
<ol>
<li>若操作码字段不固定，已经设计出m条双操作数指令，n条无操作数指令。对于双操作数指令，有4位可用于标识指令码，现在已经设计了m条，还剩下16-m种前4位的组合可以用于单操作数指令和无操作数指令。对于单操作数指令，有10位可用于标识指令码，去除前4位，不管无操作数指令，可知单操作数指令对于指令前10位一共有(16-m)×64种组合可用。还需要考虑到无操作数指令，无操作数指令全部16位都可以用于标识指令码，则前10位的一种组合可设计64条无操作数指令，那么n条无操作数指令一共需要占用单操作数指令前10位组合中的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mfrac><mi>n</mi><mn>64</mn></mfrac><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil\frac{n}{64}\rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌉</span></span></span></span>种组合，故单操作数指令一共可以设计<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>16</mn><mo>−</mo><mi>m</mi><mo stretchy="false">)</mo><mo>×</mo><mn>64</mn><mo>−</mo><mo stretchy="false">⌈</mo><mfrac><mi>n</mi><mn>64</mn></mfrac><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">(16-m)\times 64-\lceil\frac{n}{64}\rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌉</span></span></span></span>条。</li>
<li>双操作数指令取最大数为15，因为要留出一种前4位的组合给单操作数指令和无操作数指令，单操作数指令取最大数为63，因为要留出一种前10位的组合给无操作数指令。此时无操作数指令最多只能设计64条。</li>
</ol>
<h3 id="57"><a class="markdownIt-Anchor" href="#57"></a> 5.7</h3>
<ol>
<li>290-256-3=31，转移指令第二个字节为0x1F，第三个字节为0。</li>
<li>110-128-3=-31，转移指令第二个字节为0xE1，第三个字节为0xFF。</li>
</ol>
<h3 id="58"><a class="markdownIt-Anchor" href="#58"></a> 5.8</h3>
<ol>
<li>4420H=0100 0100 0010 0000=010001 00 00100000，寻址方式为直接寻址，形式地址为0x20，有效地址为0x20。</li>
<li>2244H=0010 0010 0100 0100=001000 10 01000100，寻址方式为变址寄存器X2变址，形式地址为0x44，有效地址为0x1122+0x44=0x1166。</li>
<li>1322H=0001 0011 0010 0010=000100 11 00100010，寻址方式为相对寻址，形式地址为0x22，有效地址为0x1234+2+0x22=0x1258。</li>
<li>3521H=0011 0101 0010 0001=001101 01 00100001，寻址方式为变址寄存器X1变址，形式地址为0x21，有效地址为0x37+0x21=0x58。</li>
</ol>
<h3 id="59"><a class="markdownIt-Anchor" href="#59"></a> 5.9</h3>
<ol>
<li>增加的32条指令中的前6位不能与原来的60条指令中的任意一条的前6位相等，否则会冲突，因此这32条指令的前6位只有4种可能的值，每一种可能的值需要设计8条指令，因此扩展操作码总共9位，这32条指令的操作码为111100000~111111111。</li>
<li>平均长度为(60×6+32×9)/92≈7.04。</li>
</ol>
<h3 id="510"><a class="markdownIt-Anchor" href="#510"></a> 5.10</h3>
<p>add $s0, $a1, $t7。</p>
<h3 id="511"><a class="markdownIt-Anchor" href="#511"></a> 5.11</h3>
<p>略</p>
<h3 id="512"><a class="markdownIt-Anchor" href="#512"></a> 5.12</h3>
<ol>
<li>最多有16条指令，该计算机最多有8个通用寄存器。</li>
<li>16位，因为主存空间128KB，含64KW。</li>
<li>0~2<sup>16</sup>-1</li>
<li>0010 0011 0001 0101=2315H。</li>
</ol>
<h3 id="513"><a class="markdownIt-Anchor" href="#513"></a> 5.13</h3>
<p>略</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC4%E7%AB%A0%E4%B9%A0%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC4%E7%AB%A0%E4%B9%A0%E9%A2%98/" class="post-title-link" itemprop="url">计算机组成原理——第4章习题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-03 00:02:09 / Modified: 00:05:10" itemprop="dateCreated datePublished" datetime="2023-03-03T00:02:09+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>5k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>5 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="41"><a class="markdownIt-Anchor" href="#41"></a> 4.1</h2>
<ul>
<li>存取时间：存取器的访问时间，指一次存储器操作到该操作完成所经历的时间。读写时间可能不同。</li>
<li>存取周期：连续两次启动访问操作之间的最短时间间隔。</li>
<li>存储器带宽：单位时间内存储器能够传输的信息量，注意<font color=red>不能理解为存储器一个存储单元能够存储的比特位数，存储器带宽指的是速度，与网络带宽可以类比</font>。</li>
<li>存储单元：存储器中的最小存储单位。也称为存储元。</li>
<li>边界对齐的数据存放：按照数据类型的大小进行边界对齐。不同数据类型的变量都会包含一个或多个字节单元，这些变量在进行主存地址空间分配时从理论上讲可以从任何字节地址开始，但当一个多字节变量分布在不同的字存储单元时，访问该变量就需要多个存储周期，为了提高访问效率对数据进行边界对齐存放。</li>
<li>大端存储：数据的高位位于地址的低位。</li>
<li>小端存储：数据的低位位于地址的低位。</li>
<li>静态存储器：存储体以静态存储元构成的存储器。</li>
<li>动态存储器：存储体以动态存储元构成的存储器。</li>
<li>刷新：在动态存储器中，由于存储元内部构造问题，数据只能保持较短的时间，为避免数据丢失需要定期采用类似读操作的方式对存储单元补充电荷，称为刷新。</li>
<li>刷新周期：动态存储器连续两次刷新的时间间隔。</li>
<li>字扩展：为增加存储器存储容量增加一个字的比特数量的扩展方式，又称为容量扩展或地址总线扩展。</li>
<li>位扩展：增加存储器可寻址的范围，而不改变字长的扩展方式。</li>
<li>高速缓冲存储器：为进一步提升CPU的性能在CPU和内存之间添加的小块SRAM。</li>
<li>相联存储器：一种按内容访问的存储器，用于存放查找表，其内部存储数据的基本单位是键值对。</li>
<li>时间局部性：同一块地址的存储数据如果在一个时刻被访问，那么在这个时刻未来的短时间内很有可能还会被访问。</li>
<li>地址映射：将主存地址映射到cache的地址空间，将存放在主存中的程序或数据块载入cache块的规则。<font color=red>注意这里的地址映射指的不是虚拟地址与内存物理地址的映射</font>。</li>
<li>直接相联映射：每一个主存块地址只能被映射到cache中固定的行。</li>
<li>全相联映射：每一个主存块地址可以被映射到cache中的任意行。</li>
<li>组相联映射：每一个主存块地址可以被映射到cache中的某些行。</li>
<li>命中率：主存访问时能够通过cache访问成功的概率。</li>
<li>虚拟存储器：包含虚拟地址空间、主存地址空间和辅存地址空间，将虚拟地址空间映射到主存空间，建立虚地址和实地址之间的对应关系。可便于编程、解决主存容量不足的问题。</li>
<li>页框号：主存地址空间中的一页空间的编号。</li>
<li>页表（慢表）：一张保存虚拟页号和物理页号对应关系的查找表。</li>
<li>页表项：页表中的一条记录。</li>
<li>TLB（快表）：转换旁路缓冲区，用于缓冲经常访问的页表项，本质是一个容量较小的cache，可以提高页表的查找速度。</li>
<li>LRU算法：近期最少使用算法，淘汰最久远使用的项。</li>
<li>LFU算法：最不经常使用算法。</li>
<li>cache一致性：cache中的数据需要与对应地址的主存数据相同。</li>
<li>写回法：写cache时不同时修改主存的内容，每一个cache行必须设置一个脏位判断该位是否被修改。某行被换出时根据脏位决定是否需要更新主存。</li>
<li>写穿法：写cache的同时写主存。</li>
</ul>
<h3 id="42"><a class="markdownIt-Anchor" href="#42"></a> 4.2</h3>
<ol>
<li>A<br />
分析：RAM是易失性存储器，ROM是非易失性存储器，正确。RAM作为随机存储器一般用于内存等，只有在上电时才能够保存数据，而ROM作为只读存储器，其内容是在烧录时写死的，即使掉电也不会丢失数据。RAM和ROM都可以使用随机存取方式进行信息访问，正确。ROM不能用于cache，且不需要刷新。</li>
<li>A<br />
分析：DRAM芯片为4M×8位，一块芯片容量为4MB，存储器容量为256MB，故一共有64块芯片。假设其为位扩展，一块芯片有4M个字，故地址线宽度为11位。数据引脚为8位。注意<font color=red>DRAM地址线一般采用复用技术，即CPU分时传送行、列地址，并分别由行选通信号RAS和列选通信号CAS连通</font>。原本4M需要22位地址才能寻址，但将其看做一个矩阵，行和列都只有2<sup>11</sup>行，因此复用只需要11位地址线。</li>
<li>D<br />
4KB的ROM需要2块ROM芯片，4K×4的RAM芯片一块只能存储2KB，因此需要30块。</li>
<li>D<br />
需要进行字位扩展，将字长从4比特扩展为8比特，一共需要8个芯片，分为4组，一组两个进行位扩展。第2组可以寻址0800H~0FFFH的地址，其最小地址为0800H。</li>
<li>C<br />
为了保证其地址引脚数量最少，行数与列数的最大值需要尽可能小，2K=32×64，因此可以选择32行64列或64行32列，又需要考虑减少刷新开销，因此行数应该尽可能少，选择32行64列。</li>
<li>B<br />
工作频率1333MHz，即每秒可以访存1333M次，总线宽度64位，一次访存可获得8字节数据。又因为采用的是3通道地址总线，因此总带宽为1333M×3×8 B/s=32GB/s。</li>
<li>D</li>
<li>B</li>
<li>B<br />
注意CDROM指的是光盘，是顺序存储。</li>
<li>A</li>
<li>A</li>
<li>C<br />
cache有16块用2路组相联，因此一共有8组，一组32B，因此主存第129号单元所在的主存块应该位于第4组。</li>
<li>C</li>
<li>C<br />
分析：主存块大小4个字，一个字32位，能存放4K字数据，就有1K行，每一行保存的信息有：直接相联映射应该主存映射地址的区地址18位1个字，4个字的数据。考虑到采用写回的方式，需要1位有效位和1位脏位，一行一共有18+128+2=148位数据，1K行就有148K位。本题易错点：<font color=red>求的是位数不是字数，写回方式有脏位，直接相联映射应该保存地址的多少位</font>。</li>
<li>D</li>
<li>B<br />
分析：采用页式存储管理方式，且有TLB，那么该指令首先需要访问x处的数据。首先访问TLB，如果TLB命中，则物理地址已知，然后访问cache。如果cache命中，则写cache，同时需要写主存，这个过程访存次数为1（注意TLB和cache不属于主存）。不妨可以另外计算最多需要多少次访问主存：如果TLB没有命中，那么首先需要访问主存中的页表（假设为一级页表），获取物理地址之后到cache中查找没有找到，还需要从主存中调入这部分数据到cache，然后写cache写主存，一共访存3次。</li>
<li>D<br />
cache就是主存中内容的部分复制，cache如果命中page一定会命中。</li>
<li>A</li>
<li>D<br />
缺页中断处理完成之后应该重新执行触发缺页中断的那条指令。</li>
</ol>
<h3 id="43"><a class="markdownIt-Anchor" href="#43"></a> 4.3</h3>
<ol>
<li>采用层次化体系可以在提高CPU的性能同时最大限度地降低成本。</li>
<li>用于进行位扩展。</li>
<li>其中的数据不稳定，长时间不刷新会丢失。进行一次类似读操作让其电容重新充电。</li>
<li>略</li>
<li>cache对程序员不可见。</li>
<li>因为直接相联映射规定一块主存地址只能被映射到唯一的一个cache行，如果映射时产生冲突直接换掉即可。</li>
<li>防止cache与主存中数据不一致问题。</li>
<li>略</li>
</ol>
<h3 id="44"><a class="markdownIt-Anchor" href="#44"></a> 4.4</h3>
<p>32KB容量按照16位字编址则有16K个字，地址寄存器应为14位，数据寄存器为16位。</p>
<h3 id="45"><a class="markdownIt-Anchor" href="#45"></a> 4.5</h3>
<p>可以设计出32K×32位、64K×16位、128K×8位。图略。</p>
<h3 id="46"><a class="markdownIt-Anchor" href="#46"></a> 4.6</h3>
<p>256K×8位存储器中最高64KB为只读，低192KB可读可写，因此考虑使用6片32K×8位RAM位扩展加2片64K×4位字扩展。</p>
<h3 id="47"><a class="markdownIt-Anchor" href="#47"></a> 4.7</h3>
<p>128K字中最高32K字只读，低96K字可读可写，考虑使用12片16K×8位静态RAM芯片进行字位扩展，1组2片共6组；加2片16K×16位ROM芯片进行位扩展。</p>
<h3 id="48"><a class="markdownIt-Anchor" href="#48"></a> 4.8</h3>
<p>DRAM是时分复用的地址线，64K=256×256，即一共有256行，每个芯片需要在2ms之内将这256行全部刷新至少一次，按照异步刷新的规则，间隔时间应该为2ms/256=7.8125μs。<br />
如果采用集中刷新方式，则存储器刷新一次需要使用256个读写周期，CPU的“死”时间为0.5×256=128ms。</p>
<h3 id="49"><a class="markdownIt-Anchor" href="#49"></a> 4.9</h3>
<p>DRAM芯片时分复用，有256行256列，故地址线输入需要8个引脚，数据线1个引脚，加上读写标志2个引脚，共11个。</p>
<h3 id="410"><a class="markdownIt-Anchor" href="#410"></a> 4.10</h3>
<p>异步刷新。<br />
16K=128×128，刷新周期为2ms/128=15.625μs。</p>
<h3 id="411"><a class="markdownIt-Anchor" href="#411"></a> 4.11</h3>
<p>cache容量为2<sup>14</sup>块，每块32位字。<br />
按照全相联映射，将这些数据按照地址顺序依次装入cache后cache的内容：<br />
000000 87568756<br />
000002 87792301<br />
004001 9ABEFCD0<br />
007FFF 4FFFFC68<br />
3FFFFE 01BF2460<br />
按照直接相联映射：<br />
00 0000 87568756<br />
01 0001 9ABEFCD0<br />
00 0002 87792301<br />
01 3FFF 4FFFFC68<br />
FF 3FFE 01BF2460<br />
按照四路组相联映射：<br />
000 000 87568756<br />
000 002 87792301<br />
001 001 9ABEFCD0<br />
001 FFF 4FFFFC68<br />
3FF FFE 01BF2460</p>
<h3 id="412"><a class="markdownIt-Anchor" href="#412"></a> 4.12</h3>
<p>主存4096×128=512K个字，地址19位。<br />
cache 64×128=8K个字，地址13位。<br />
主存地址分为3个部分，组内偏移7位，标识一个组中的128个字。组号4位，标识cache中的16个组。组标记8位，标识地址的最高8位。</p>
<h3 id="413"><a class="markdownIt-Anchor" href="#413"></a> 4.13</h3>
<p>cache容量16KB，一块8个字，每个字32位，即32B，则cache共有512行。映射方式采用4路组相联，可分为128组。<br />
CPU每一次读一个字，其中第0~7号单元应该在同一块，8~15号单元在同一块，以此类推，100个字只在第一次访问第0、8、16、…、96号单元时没有命中，共13次没有命中，共访问了1000次，没有使用LRU算法淘汰某一行，因此命中率为98.7%。<br />
若cache比主存快10倍，其访问时间就是0.1倍。设主存一次访问时间为t，则使用cache后一次访问的平均时间为t×1.3%+0.1t×98.7%=11.17%t，速度提升了8.95倍。</p>
<h3 id="414"><a class="markdownIt-Anchor" href="#414"></a> 4.14</h3>
<ol>
<li>对于第一段代码，数组访问按行优先访问，对于内存空间而言是线性按序访问，具有较好的空间局部性。但每一个数组元素只使用一次，因此对于数组元素而言没有时间局部性。第二段代码数组按照列优先访问，在内存空间中的访问是跳跃式的，因此没有很好的空间局部性，同样也不存在时间局部性。</li>
<li>在两段代码中，变量sum均被频繁访问，因此具有很好的时间局部性，由于变量sum是单个变量，与其邻近地址空间的数据没有直接关系，因此不存在空间局部性。</li>
<li>for循环体对指令访问具有时间局部性，一条指令会被循环执行多次，而for循环有多条指令，这些指令之间具备一定的空间局部性。</li>
</ol>
<h3 id="415"><a class="markdownIt-Anchor" href="#415"></a> 4.15</h3>
<p>VPN：虚拟页号数量为2GB/4KB=512M，需要29位<br />
VPO：虚拟页偏移4KB，需要12位<br />
PPN：物理页号数量为8MB/4KB=2K，需要11位<br />
PPO：物理页偏移位数与虚拟页偏移相等，12位</p>
<h3 id="416"><a class="markdownIt-Anchor" href="#416"></a> 4.16</h3>
<ol>
<li>失效的有2、3、5、7页</li>
<li>分别为3072、无效、4095、无效、3072、无效</li>
</ol>
<h3 id="417"><a class="markdownIt-Anchor" href="#417"></a> 4.17</h3>
<p>TLB采用4路组相联技术，共16项，可分为4组。cache容量16KB，每块32B，共512组，采用4路组相联，共128组。</p>
<ol>
<li>页大小为128KB，需要使用17位保存页内偏移，虚拟页号需要使用14位保存。虚拟页号中高12位表示TLB标记，低2位表示TLB索引。</li>
<li>物理地址中18位表示物理页号，14位表示偏移地址。</li>
<li>要使得物理地址与cache建立映射，cache中每一组存放32字节，行内地址偏移为物理地址的最低5位。往上7位是组索引，用于标识cache中的128组，其余的20位为组标记。</li>
</ol>
<h3 id="418"><a class="markdownIt-Anchor" href="#418"></a> 4.18</h3>
<ol>
<li>页式虚拟存储管理中一页大小8KB，需要13位表示页内偏移，虚拟地址其余的19位表示页号，即A=19。TLB采用全相联映射，因此B与A的位数相同，B=19。物理地址中高11位表示页框号，C=11。低13位表示物理地址页内偏移，D=13。cache采用二路组相联，数据区大小64KB，主存块大小64B，需要块内索引6位，G=6。cache一共有1024行，512组，需要9位标识块索引，F=H=9。剩余的9位用于物理地址块标识，E=9。B存放的是虚拟页号。</li>
<li>cache组号为4099 mod 512=3。H字段的值为4099 / 512 = 8。</li>
<li>缺页处理的开销大，因为缺页需要从辅存中调入页面，访问速度比访问主存速度慢很多。</li>
<li>提高效率。</li>
</ol>
<h3 id="419"><a class="markdownIt-Anchor" href="#419"></a> 4.19</h3>
<ol>
<li>主存的实页号共16位，页内地址12位，物理地址占28位。</li>
<li>TLB采用的是全相联映射方式，使用SRAM实现。</li>
<li>2路组相联映射。共8组，数据位32B。还需要添加脏位和1位LRU位用于标识LRU淘汰块。总容量：数据512B，tag有20×16/8=40B，脏位和有效位、LRU位3×16/8=6B，共558B。</li>
<li>首先找到tag=0008C的页框号，为0040H，那么物理地址为40040H。其tag为400，不命中（有效位为0）。虚拟地址为0007C260H时，低位页偏移为260，应该映射到第3组。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC3%E7%AB%A0%E4%B9%A0%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC3%E7%AB%A0%E4%B9%A0%E9%A2%98/" class="post-title-link" itemprop="url">计算机组成原理——第3章习题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-03 00:02:06 / Modified: 00:05:10" itemprop="dateCreated datePublished" datetime="2023-03-03T00:02:06+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="32"><a class="markdownIt-Anchor" href="#32"></a> 3.2</h3>
<ol>
<li>D</li>
<li>B</li>
<li>A<br />
补充：补码负数乘以2相当于将数据位左移1位，当原数数据位的最高位为1时，乘以2会产生溢出。补码负数除以2相当于将数据位右移1位，并在最高位补1（也即算数右移），当最低位为1时，除2有余数1。</li>
<li>C</li>
<li>B</li>
<li>D<br />
计算过程：首先对阶，Y=2<sup>7</sup>×5/32，与X相加得到2<sup>8</sup>×34/64，溢出。</li>
<li>D<br />
对阶操作不会引起阶码上溢或下溢。因为对阶仅仅是让阶码小的数将阶码增加到与另一个数的阶码相等，而另一个数的阶码此时显然不是溢出的。I正确。右规和尾数舍入都可能引起阶码上溢，右规是向右规格化操作，即将尾数右移，发生于尾数运算上溢时，当阶码值为最大阶码时即上溢；当尾数为全1时，入操作可能会导致上溢。II正确。左规时可能引起阶码下溢，左规发生在尾数过小时，即将尾数左移，III正确。尾数溢出时结果不一定溢出，IV正确。</li>
</ol>
<h3 id="33"><a class="markdownIt-Anchor" href="#33"></a> 3.3</h3>
<ol>
<li>并行进位能够让所有的一位全加器并行进行计算，而串行加法器的高位全加器只能在低位的全加器计算完成之后才能计算。</li>
<li>在规范化之后阶码是否发生了溢出。</li>
<li>运算结果的尾数位如果是11.0…或00.1…则为规格化数，否则不是。尾数符号位为01或10时向右规格化，尾数为11.1…或00.0…时向左规格化。</li>
</ol>
<h3 id="34"><a class="markdownIt-Anchor" href="#34"></a> 3.4</h3>
<ol>
<li>x=00.11010，y=00.10111，计算结果为01.10001溢出。</li>
<li>x=00.11101，y=11.01100，计算结果为00.01001无溢出</li>
<li>x=11.01001，y=11.01000，计算结果为10.01001溢出。</li>
</ol>
<h3 id="35"><a class="markdownIt-Anchor" href="#35"></a> 3.5</h3>
<ol>
<li>x=00.11011，-y=11.00011，计算结果为11.11110无溢出</li>
<li>x=00.10111，-y=11.00010，计算结果为11.11001无溢出</li>
<li>x=11.00001，-y=00.11001，计算结果为11.11010无溢出</li>
</ol>
<h3 id="36"><a class="markdownIt-Anchor" href="#36"></a> 3.6</h3>
<ol>
<li></li>
</ol>
<p>00.00000 <strong>11101</strong><br />
00.11111<br />
——————<br />
00.11111 11101<br />
00.01111 1<strong>1110</strong><br />
00.00000<br />
——————<br />
00.01111 11110<br />
00.00111 11<strong>111</strong><br />
00.11111<br />
——————<br />
01.00110 11111<br />
00.10011 011<strong>11</strong><br />
00.11111<br />
——————<br />
01.10010 01111<br />
00.11001 0011<strong>1</strong><br />
00.11111<br />
——————<br />
01.11000 00111<br />
00.11100 00011</p>
<p>计算结果：-0.1110000011</p>
<p>2略</p>
<h3 id="37"><a class="markdownIt-Anchor" href="#37"></a> 3.7</h3>
<ol>
<li></li>
</ol>
<p>x<sub>补</sub>=00.10110，-x<sub>补</sub>=11.01010，y<sub>补</sub>=11.11101<br />
00.00000 <strong>11110<mark>10</mark></strong><br />
11.01010<br />
——————<br />
11.01010<br />
11.10101 0<strong>1111<mark>01</mark></strong><br />
00.10110<br />
——————<br />
00.01011<br />
00.00101 10<strong>111<mark>10</mark></strong><br />
11.01010<br />
——————<br />
11.01111<br />
11.10111 110<strong>11<mark>11</mark></strong><br />
00.00000<br />
——————<br />
11.10111<br />
11.11011 1110<strong>1<mark>11</mark></strong><br />
00.00000<br />
——————<br />
11.11011<br />
11.11101 11110 <strong><mark>11</mark></strong></p>
<p>结果为1.1110111110</p>
<p>2略</p>
<h3 id="38"><a class="markdownIt-Anchor" href="#38"></a> 3.8</h3>
<ol>
<li></li>
</ol>
<p>x=0.10101，y=0.11011，-y=1.00101<br />
00.10101 0.0000<br />
11.00101<br />
——————<br />
11.11010 0.0000<strong>0</strong><br />
11.10100 0.00<strong>0</strong> (2<sup>-1</sup>)<br />
00.11011<br />
——————<br />
00.01111 0.000<strong>01</strong><br />
00.11110 0.0<strong>01</strong> (2<sup>-2</sup>)<br />
11.00101<br />
——————<br />
00.00011 0.00<strong>011</strong><br />
00.00110 0.0<strong>011</strong> (2<sup>-3</sup>)<br />
11.00101<br />
——————<br />
11.01011 0.0<strong>0110</strong><br />
1<font color=red>0</font>.10110 0.<strong>0110</strong> (2<sup>-4</sup>)<br />
00.11011<br />
——————<br />
11.10001 0.<strong>01100</strong><br />
11.00010 <strong>0.1100</strong> (2<sup>-5</sup>)<br />
00.11011<br />
——————<br />
11.11101 <strong>0.11000</strong><br />
这里余数为负数，因此还需要加一次。<br />
00.11011<br />
——————<br />
00.11000 (2<sup>-5</sup>)</p>
<p>结果为0.11000，余数为0.11×2<sup>-5</sup></p>
<h3 id="39"><a class="markdownIt-Anchor" href="#39"></a> 3.9</h3>
<ol>
<li></li>
</ol>
<p>对阶，y=2<sup>011</sup>×(-0.001101)<br />
加：x+y=2<sup>011</sup>×0.010111<br />
规格化：=2<sup>010</sup>×0.101110</p>
<ol start="2">
<li></li>
</ol>
<p>对阶，x=2<sup>-100</sup>×(-0.010001)<br />
加：x+y=2<sup>-100</sup>×1.011001<br />
规格化：2<sup>-100</sup>×(-0.100111)</p>
<h3 id="310"><a class="markdownIt-Anchor" href="#310"></a> 3.10</h3>
<p>略</p>
<h3 id="311"><a class="markdownIt-Anchor" href="#311"></a> 3.11</h3>
<p>略</p>
<h3 id="312"><a class="markdownIt-Anchor" href="#312"></a> 3.12</h3>
<p>略</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC2%E7%AB%A0%E4%B9%A0%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC2%E7%AB%A0%E4%B9%A0%E9%A2%98/" class="post-title-link" itemprop="url">计算机组成原理——第2章习题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-03 00:02:03 / Modified: 00:05:10" itemprop="dateCreated datePublished" datetime="2023-03-03T00:02:03+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>3.5k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="21"><a class="markdownIt-Anchor" href="#21"></a> 2.1</h3>
<ul>
<li>真值：使用加号或减号表示数据符号的数据书写格式被称为真值。<font color=red>注意真值指的不是数据的值，而是数据的一种书写格式。一个数据必须要有一个书写格式才能展示出来。</font></li>
<li>机器码：在计算机中采用0或1表示数据的正负，由符号和数值一起编码表示的二进制数称为机器数或机器码。</li>
<li>原码：符号化的数值，正数符号位为0，负数为1，其余为与真值表示相同。</li>
<li>反码：又称1的补码，符号位与原码相同，真值为正数时，反码与原码相同；真值为负数时，反码数值与真值数值位相反。</li>
<li>补码：当真值为正数时，补码等于真值；当真值为负数时，真值加上模数即为补码，或者是反码加1。</li>
<li>移码：只用于定点整数的表示，通常用于表示浮点数阶码。编码方式是直接将真值x加上一个常数偏移量。移码可以直接比较大小。</li>
<li>模：模数，数值计量系统的计量范围。</li>
<li>定点数：约定计算机中所有数据的小数点位置固定。将小数点的位置固定在数据的最高数位之前的数据称为定点小数，将小数点固定在最低数位之后的数据称为定点整数。</li>
<li>浮点数：浮点数中的小数位不固定。</li>
<li>溢出：当数据超过计算机能够表示的数据范围时产生了溢出。</li>
<li>精度溢出：数轴上所有不在数值刻度上面的纯小数都超过了定点小数所能够表示的精度，无法表示，此时定点小数发生精度溢出。</li>
<li>浮点数规格化：使得浮点数的尾数真值最高有效位为1，即尾数的绝对值应该大于0.1<sub>2</sub>。</li>
<li>隐藏位：在规格化浮点数中由于尾数的最高有效位一定为1，因此这一位可以不用保存到数据中，这就是被隐藏的一位，即隐藏位。</li>
<li>码距：在编码系统中，两个编码一一对应的所有二进制位中不同的二进制位数，又称海明距离。</li>
<li>校验码：具有发现错误或纠正错误能力的数据编码，用于提升数据在时间和空间两个维度上的可靠性传输的机制。</li>
<li>多重奇偶校验：对数据中的某一位数据位都有多个奇偶校验码对其进行校验的校验方式。</li>
<li>海明码：一种既能检错又能纠错的校验码。</li>
<li>CRC码：循环冗余校验码。</li>
</ul>
<h3 id="22"><a class="markdownIt-Anchor" href="#22"></a> 2.2</h3>
<ol>
<li>B<br />
3个1和5个0能够表示的最小整数为10000011，值为131-256=-125。</li>
<li>A</li>
<li>B<br />
65530是无符号数，这里进行无符号扩展后真值依然为65530，因此为0000FFFAH</li>
<li>C</li>
<li>A<br />
IEEE754标注规定32位浮点数含1位符号位、8位阶码和23位尾数位。-8.25=-1000.01<sub>2</sub>=-1.00001×2<sup>11</sup>（二进制），因此符号位为1，阶码为3+127=130=10000010，尾数为00001000 00000000 0000000。因此存储的值为：11000001 00000100 00000000 00000000，即C1040000H。</li>
<li>A<br />
C6400000即为1100 0110 0100 0000 0000 0000 0000 0000，符号位1，阶码为10001100=140，阶数为13，尾数为0.1，加上1变成1.1<sub>2</sub>。因此值为-1.5×2<sup>13</sup>。</li>
<li>D<br />
按照IEEE754标准，float型能够表示最大整数时，阶码对应的阶数为254-127=127，尾数为1.111…，易知尾数+2<sup>-23</sup>=2，因此尾数的值为2-2<sup>23</sup>。最终的值为2<sup>127</sup>×(2-2<sup>23</sup>)=2<sup>128</sup>-2<sup>104</sup>。</li>
<li>A<br />
按照IEEE754标准，最小的规格化正数阶码对应的阶数为1-127=-126，尾数全0，最终的值为2<sup>-126</sup>。</li>
<li>A<br />
CC900000的符号为1，阶码为10011001=152。B0C00000的符号为1，阶码为01100001=97，二者均为负数，且前者绝对值更大，因此前者小于后者。</li>
<li>B<br />
将浮点数类型转换为int类型之后小数部分会丢失，但i本来就没有小数部分，因此A正确，B错误。C由于f的表示范围在float之内，因此转为double之后再转回到float没有影响，C正确。D错误，d比f大得多，会导致f+d时f丢失。</li>
<li>C</li>
</ol>
<h3 id="23"><a class="markdownIt-Anchor" href="#23"></a> 2.3</h3>
<ul>
<li>
<ol>
<li>因为二进制的数据使用硬件表示较为方便，其容易与简单的物理状态对应，算数逻辑运算电路更容易实现。</li>
</ol>
</li>
<li>
<ol start="2">
<li>首先最为明显的一点代价就是校验码的位数大大增加。单纯的奇偶校验只需要1位校验码，而交叉奇偶校验需要行数+列数个校验位。其次就是校验过程较普通的奇偶校验复杂，需要提取每一行每一列的数据进行校验。</li>
</ol>
</li>
<li>
<ol start="3">
<li>补码计算加减法较原码和反码更方便。</li>
</ol>
</li>
<li>
<ol start="4">
<li>表示范围由阶码位数决定，精度由尾数位数决定。</li>
</ol>
</li>
<li>
<ol start="8">
<li>浮点数的正负只需要看最高位符号位即可。</li>
</ol>
</li>
<li>
<ol start="9">
<li>浮点数有两个0指的是浮点数的尾数采用原码表示，因此存在正0和负0两种0。在比较上需要另外进行判断，增加了硬件和软件设计的复杂性。</li>
</ol>
</li>
<li>
<ol start="10">
<li>选择一个合适的信息多项式，需要满足多项式最高次数r（也是校验位数）与原始数据信息之和k小于2<sup>r</sup>-1，将原来的数据左移r位之后进行模2除法运算，将余数填入最终数据的最低r位作为校验位。在校验时依然进行模2除法，如果余数为0认为没有错误，否则发现错误。CRC可以纠正一位错误。</li>
</ol>
</li>
</ul>
<h3 id="24"><a class="markdownIt-Anchor" href="#24"></a> 2.4</h3>
<table>
<thead>
<tr>
<th style="text-align:center">真值</th>
<th style="text-align:center">原码</th>
<th style="text-align:center">反码</th>
<th style="text-align:center">补码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0.000…</td>
<td style="text-align:center">0.000…</td>
<td style="text-align:center">0.000…</td>
</tr>
<tr>
<td style="text-align:center">-0</td>
<td style="text-align:center">1.000…</td>
<td style="text-align:center">1.111…</td>
<td style="text-align:center">0.000…</td>
</tr>
<tr>
<td style="text-align:center">0.10101</td>
<td style="text-align:center">0.10101</td>
<td style="text-align:center">0.10101</td>
<td style="text-align:center">0.10101</td>
</tr>
<tr>
<td style="text-align:center">-0.10101</td>
<td style="text-align:center">1.10101</td>
<td style="text-align:center">1.01010</td>
<td style="text-align:center">1.01011</td>
</tr>
<tr>
<td style="text-align:center">0.11111</td>
<td style="text-align:center">0.11111</td>
<td style="text-align:center">0.11111</td>
<td style="text-align:center">0.11111</td>
</tr>
<tr>
<td style="text-align:center">-0.11111</td>
<td style="text-align:center">1.11111</td>
<td style="text-align:center">1.00000</td>
<td style="text-align:center">1.00001</td>
</tr>
<tr>
<td style="text-align:center">-0.10000</td>
<td style="text-align:center">1.10000</td>
<td style="text-align:center">1.01111</td>
<td style="text-align:center">1.10000</td>
</tr>
<tr>
<td style="text-align:center">0.10000</td>
<td style="text-align:center">0.10000</td>
<td style="text-align:center">0.10000</td>
<td style="text-align:center">0.10000</td>
</tr>
</tbody>
</table>
<h3 id="25"><a class="markdownIt-Anchor" href="#25"></a> 2.5</h3>
<ul>
<li>0.10010的真值为0.10010</li>
<li>1.00000的真值为-1.00000（减2，反码无法表示这个数）</li>
<li>1.10010的真值为-0.01110</li>
<li>0.10001的真值为0.10001</li>
<li>1.11111的真值为-0.00001</li>
<li>1.00001的真值为-0.11111</li>
</ul>
<h3 id="26"><a class="markdownIt-Anchor" href="#26"></a> 2.6</h3>
<p>略</p>
<h3 id="27"><a class="markdownIt-Anchor" href="#27"></a> 2.7</h3>
<p>16位无符号数：0-65535<br />
16位原码定点小数：1位作为符号位，数据范围为-32767/32768-32767/32768<br />
16位补码定点小数：数据范围为-1-32767/32768<br />
16位补码定点整数：数据范围为-32768-32767</p>
<h3 id="28"><a class="markdownIt-Anchor" href="#28"></a> 2.8</h3>
<p>补码的模为2<sup>最高位的进位位权值</sup>=256</p>
<h3 id="29"><a class="markdownIt-Anchor" href="#29"></a> 2.9</h3>
<p>-6.625=-110.101，符号位1，阶码127+2=10000001<sub>2</sub>，尾数10101000…，结果：11000000 11010100 0…=C0D40000<sub>16</sub></p>
<p>3.1415927需要首先计算尾数。尾数省略最高的1后为10010010 00011111 1011010，后面一位为1，因此进位为1011011。</p>
<p>64000=11111010 00000000</p>
<h3 id="210"><a class="markdownIt-Anchor" href="#210"></a> 2.10</h3>
<p>单精度浮点数43940000H=0100 0011 1001 0100 0…，符号位0，阶码10000111=135，阶数8，位数0010100…，结果为1.00101×2<sup>8</sup>=100101000=296。</p>
<h3 id="211"><a class="markdownIt-Anchor" href="#211"></a> 2.11</h3>
<p>单精度浮点数能够表示的最大数为2<sup>128</sup>-2<sup>104</sup>，能够表示的最小数是上面数字的相反数。最小正数为非规格化浮点数，尾数为00…01，阶码为0，阶数为<font color=red>-126（不是-127！）</font>。表示的数为2<sup>-126</sup>×2<sup>-23</sup>=2<sup>-149</sup>。</p>
<h3 id="212"><a class="markdownIt-Anchor" href="#212"></a> 2.12</h3>
<ol>
<li>可能</li>
<li>不可能</li>
</ol>
<h3 id="213"><a class="markdownIt-Anchor" href="#213"></a> 2.13</h3>
<p>3位阶码，移码为4。（尾数中没有隐藏位的设定，尾数和阶码均为补码）<br />
最大正数为2<sup>3</sup>×(1-2<sup>6</sup>)<br />
最小正数为2<sup>-4</sup>×2<sup>-6</sup><br />
最大负数为-2<sup>-4</sup>×2<sup>-6</sup><br />
最小负数为2<sup>-3</sup></p>
<h3 id="214"><a class="markdownIt-Anchor" href="#214"></a> 2.14</h3>
<p>57=111001，57/128=0.0111001，阶码为-2=1110，尾数为01.11001，最高的0为符号位，结果为1110 0111001000，第二个数略。</p>
<h3 id="215"><a class="markdownIt-Anchor" href="#215"></a> 2.15</h3>
<p>01011011的奇校验码为0，偶校验码为1。将收到的信息中的所有位统计1的个数或进行异或运算，奇校验异或结果为1则没有错误，偶校验异或结果为0则没有错误。</p>
<h3 id="216"><a class="markdownIt-Anchor" href="#216"></a> 2.16</h3>
<p>略</p>
<h3 id="217"><a class="markdownIt-Anchor" href="#217"></a> 2.17</h3>
<p>01101110计算海明校验码：<br />
海明校验码前面几位的第1、2、4、8位为校验码位，其余为数据位。<br />
因此结果必然为：??0?110?1110。<br />
第1位校验码校验第3、5、7、9、11位数据位，值为1。<br />
第2位校验码校验第3、6、7、10、11位数据位，值为1。<br />
第3位校验码校验第5、6、7、12位数据位，值为0<br />
第4位校验码校验第9、10、11、12位数据位，值为1。<br />
结果为110011011110。</p>
<p>如果第8位数据位出错，那么第3和第4个指错字值为1出错，定位到海明码中的第12位，即第8位数据位出错，将对应位取反即可。</p>
<h3 id="218"><a class="markdownIt-Anchor" href="#218"></a> 2.18</h3>
<p>数据为1001，生成多项式1101。<br />
对数据左移3位为1001000，除以1101的余数为011，故校验值为011。<br />
若接收到的数据信息为1101，则使用1101011除以011余数不为0，错误。纠错方法：对余数补零继续除获得余数，直到余数为1未知，除的次数即为错误的比特位的位置（左起第几位）。</p>
<p>原理：总校验码的第i位出错时，相除得到的余数补零再除得到的余数等于总校验码的第i+1位出错时相除得到的余数值。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC1%E7%AB%A0%E4%B9%A0%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC1%E7%AB%A0%E4%B9%A0%E9%A2%98/" class="post-title-link" itemprop="url">计算机组成原理——第1章习题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-03 00:02:00 / Modified: 00:05:10" itemprop="dateCreated datePublished" datetime="2023-03-03T00:02:00+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.9k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="11-解释下列名词"><a class="markdownIt-Anchor" href="#11-解释下列名词"></a> 1.1 解释下列名词</h3>
<ul>
<li>摩尔定律：指在计算机发展时期中，当价格不变时，集成电路上可以容纳的晶体管数量大约在18~24个月翻一番，性能也将提升一倍。其表现在：
<ul>
<li>单个芯片集成度提高之后，其成本变化不大，因此总体成本明显下降。</li>
<li>高集成度的芯片中，电路之间的距离更近，其连线更短，工作速度可以更高。</li>
<li>增加了芯片内部的连线，从而减少了外部连线，可靠性得以提高。</li>
<li>计算机体积越来越小，减少了电能的消耗，适应性更好。</li>
</ul>
</li>
<li>汇编器：将汇编语言翻译成机器语言目标程序的汇编程序，称为汇编器。</li>
<li>编译器：将高级语言翻译为汇编语言的程序，称为编译器。</li>
<li>解释器：将源程序中的语句按照顺序逐条翻译为机器语言目标程序并执行，且不生成目标程序的程序称为解释器。</li>
<li>链接器：将汇编器产生的多个可重定向目标程序整合为一个可执行的二进制程序的链接程序，称为链接器。</li>
<li>时钟周期：计算机最基本、最小的时间单位，在一个时钟周期之内，CPU仅完成一个最基本的动作。</li>
<li>机器字长：CPU一次处理的数据位数，一般等于计算机内部寄存器、运算器、数据总线的位宽。</li>
<li>主存容量：主存能够存储的最大信息量，一般用M（存储单元数）×N（每一个存储单元存储的二进制位数）表示。</li>
<li>CPI：Clock Cycles Per Instruction，CPU执行一条指令所需要的平均时钟周期数量。</li>
<li>IPC：CPI的倒数，一个时钟周期平均执行的指令数量。</li>
<li>MIPS：Million Instructions Per Second，每秒执行的指令数量（以百万计数）</li>
<li>MFLOPS：Million Floating-Point Operations Per Second，每秒执行的浮点数运算数量（以百万计数）</li>
<li>CPU时间：指某段程序执行的总时间（按照秒计算），等于程序执行需要的时钟周期数量乘以时钟周期长。（注意与程序的运行时间不同，程序运行时不止有CPU在工作，还有IO设备等，因此程序的运行时间大于等于CPU时间）</li>
</ul>
<h3 id="12-选择题"><a class="markdownIt-Anchor" href="#12-选择题"></a> 1.2 选择题</h3>
<ol>
<li>D</li>
<li>C</li>
<li>C</li>
<li>A</li>
<li>D</li>
<li>D</li>
<li>C<br />
<font color=red>错误的计算方法：根据CPI和计算机主频可以计算出每种指令的执行速度：MIPS<sub>A</sub>=600，MIPS<sub>B</sub>=400，MIPS<sub>C</sub>=300，MIPS<sub>D</sub>=240，然后计算加权平均：MIPS=600×0.5+400×0.2+300×0.1+240×0.2=458</font><br />
<font color=00F000>正确的计算方法：首先应该对CPI求加权平均为3，然后计算MIPS=400</font><br />
错误原因：MIPS=f/CPI，第一种方法相当于先除再加权，与第二种方法先加权再除的结果不同。第一种方法相当于是将一秒钟分为0.5、0.2、0.1、0.2四份，每一份执行一种指令，但是很显然这样执行的结果是四种指令的比例必然是不正确的。</li>
<li>D<br />
注意：这里是CPU速度提高50%，CPU时间是原来的1/150%=2/3，即60秒。</li>
<li>D<br />
执行时间=指令数量×CPI×时钟周期，优化后的执行时间是原来时间的1.2×70%=84%，即16.8秒。</li>
<li>C<br />
二者的MIPS分别为750和1200，因此比值为750/1200=0.625。但是题目问的是时间的比值，因此取倒数为1.6。</li>
</ol>
<h3 id="13"><a class="markdownIt-Anchor" href="#13"></a> 1.3</h3>
<p>冯诺依曼计算机的基本思想是：存储程序和程序控制的思想，存储程序将解题的步骤编制为程序，然后将程序和运行程序所需要的数据以二进制的形式存放到存储器中，方便执行。程序控制指计算机中的控制器逐条取出存储器中的指令并按顺序执行，控制各个功能部件进行相应的操作，完成数据的加工处理。<br />
部件包含：运算器、控制器、存储器、输入设备和输出设备五大部件。</p>
<h3 id="14"><a class="markdownIt-Anchor" href="#14"></a> 1.4</h3>
<p>从功能上可以分为：逻辑门层次、微代码层次、指令集架构层次、操作系统层次、汇编语言层次、高级语言层次。</p>
<ul>
<li>逻辑门层次是最为底层的计算机系统，由逻辑门、触发器等逻辑电路构成。</li>
<li>微代码层为实际的机器层，该层的用户使用微代码编写程序，写的程序由硬件直接执行。</li>
<li>指令集架构层次可以通过机器语言编写程序实现对计算机硬件的控制，也称为传统机器层或ISA层，是计算机硬件和软件之间的界面和纽带。</li>
<li>操作系统层用于对计算机的硬件和软件资源进行统一管理和调度，提高计算机的使用效率并方便用户使用计算机。</li>
<li>汇编语言层为用户提供助记符表示的汇编语言编程，与机器结构直接相关。</li>
<li>高级语言层是面向用户的抽象层次，用户使用与机器无关的高级语言编程，编程过程中不需要知道机器的技术细节，大大降低了用户学习和使用计算机的难度。</li>
</ul>
<h3 id="15"><a class="markdownIt-Anchor" href="#15"></a> 1.5</h3>
<p>CPI<sub>1</sub>=2×0.4+3×0.2+4×0.15+5×0.25=3.25<br />
CPI<sub>2</sub>=2.65<br />
MIPS<sub>1</sub>=184.6<br />
MIPS<sub>2</sub>=301.9</p>
<h3 id="16"><a class="markdownIt-Anchor" href="#16"></a> 1.6</h3>
<ol>
<li>优化前程序的CPI为1.6，优化后为1.75</li>
<li>优化前程序的MIPS为312.5，优化后为285.7</li>
<li>这次优化效果欠佳，最好应该减少CPI大的指令。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC6%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC6%E7%AB%A0/" class="post-title-link" itemprop="url">计算机组成原理——第6章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-03 00:01:45 / Modified: 00:05:10" itemprop="dateCreated datePublished" datetime="2023-03-03T00:01:45+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>4.1k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第6章-中央处理器"><a class="markdownIt-Anchor" href="#第6章-中央处理器"></a> 第6章 中央处理器</h1>
<h2 id="61-概述"><a class="markdownIt-Anchor" href="#61-概述"></a> 6.1 概述</h2>
<p>CPU的基本组成：运算器、控制器<br />
CPU的主要功能：程序控制、操作控制、时序控制、异常控制、数据加工等</p>
<p>主要寄存器：</p>
<ul>
<li>PC：程序计数器，即EIP(x86/x86-64)/PC(ARM/MIPS)</li>
<li>IR：指令寄存器，保存当前正在执行的指令</li>
<li>AR：地址寄存器，用于保存CPU访问主存的单元地址</li>
<li>DR：数据寄存器，用于保存从主存读入或将写入主存的数据</li>
<li>AC：累加寄存器</li>
<li>PSW：程序状态字，保存由某些指令建立的条件标志</li>
</ul>
<h2 id="62-指令周期"><a class="markdownIt-Anchor" href="#62-指令周期"></a> 6.2 指令周期</h2>
<p>指令执行时，首先以PC为地址访问主存取指令，同时更新PC的值作为后续指令的地址。若为分支指令且满足分支条件，则重新修改PC值作为分支目标地址，否则经历<font color=red>取操作数、执行指令、存操作数</font>的基本过程。</p>
<ul>
<li>时钟周期=节拍脉冲=震荡周期，可以完成一次微操作</li>
<li>机器周期=CPU周期，从主存读出一条指令的最短时间，可以完成一次复杂操作</li>
<li>指令周期，从主存取一条指令并执行指令的时间，由若干机器周期构成，机器周期包含若干时钟周期。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/18348aec40574fe5867cf25c61a083f7.png" alt="" /></p>
<p>时间控制的方式：</p>
<ul>
<li>定长指令周期：早期三级时序系统，机器周期数固定，节拍数固定，按照机器周期同步，mips单周期。</li>
<li>变长指令周期：现代时序系统，机器周期数可变，节拍数可变，按照时钟周期同步，mips多周期。</li>
</ul>
<p>将一条指令从取出到执行完成所需要的时间称为指令周期，指令周期可分为：</p>
<ul>
<li>取指周期：以PC的内容为地址从主存中取出指令，并计算后续指令的地址。对于变长指令需要经过指令译码得到指令的实际字节长度之后才能计算并修改PC的值。</li>
<li>译码/取操作数周期：对指令寄存器中的指令字进行指令译码，识别指令类型。根据指令地址码生成操作数有效地址，然后访问相应寄存器或主存单元。若为间接寻址则还需要加入间址周期（访存周期）得到操作数的地址。该周期内不能并行读取操作数，因此可能会经历多次取操作数周期。</li>
<li>执行周期：向运算器等部件发送操作控制命令，对已经取出的操作数进行加工处理，并将处理状态送入PSW中。不同指令的执行周期不同。</li>
<li>写回周期：将运算结果写回到目的寄存器或存储器中，将运算结果写回存储器较慢。</li>
</ul>
<h2 id="63-数据通路及指令操作流程"><a class="markdownIt-Anchor" href="#63-数据通路及指令操作流程"></a> 6.3 数据通路及指令操作流程</h2>
<p>数据通路——执行部件之间传输信息的路径。</p>
<ul>
<li>通路的建立由控制信号控制，受到时钟驱动。</li>
<li>不同指令，同一指令在执行的不同阶段的数据通路不同。</li>
<li>数据通路可以分为共享通路和专用通路。</li>
</ul>
<h3 id="631-数据通路模型与定时"><a class="markdownIt-Anchor" href="#631-数据通路模型与定时"></a> 6.3.1 数据通路模型与定时</h3>
<p>时钟信号上升沿时刻到寄存器输出稳定时刻之间有一段时延，称为<font color=red>寄存器延迟（clk_to_q）</font>。数据处理单元处理寄存器内容有一定时延，将所有输出信号稳定的延迟，也即所需稳定时间最长的输出信号的稳定时间，称为<font color=red>关键路径延迟（max）</font>。将计算结果保存到寄存器之后还需要稳定一段时间才能够接受下一个上升沿，称为<font color=red>寄存器建立时间（setup）</font>。时钟上升沿到来之前的数据输入需要保持一定时间的稳定，称为<font color=red>寄存器保持时间（hold）</font>。故<font color=red>数据通路的最小时钟周期必须大于T<sub>clk_to_q</sub>+T<sub>max</sub>+T<sub>setup</sub></font>，其中T<sub>max</sub>占主导。</p>
<p><img src="https://img-blog.csdnimg.cn/de0f98f42136464585ebed5fce96d6d5.png" alt="" /></p>
<p>保持时间违例：两个寄存器在一个上升沿同时更新新值，其中一个寄存器经过寄存器延迟和最短路径延迟（T<sub>min</sub>）到达另一个寄存器输入端，为了不让该信号修改寄存器的值，应该满足<font color=red>寄存器保持时间T<sub>hold</sub>&lt;寄存器延迟T<sub>clk_to_q</sub>+组合逻辑最短路径延迟T<sub>min</sub></font>。</p>
<h3 id="632-单总线结构的数据通路"><a class="markdownIt-Anchor" href="#632-单总线结构的数据通路"></a> 6.3.2 单总线结构的数据通路</h3>
<p>数据通路的分类：</p>
<ul>
<li>共享通路（总线型）：主要部件都连接在公共总线上，各个部件之间通过总线进行数据传输。其结构简单，实现容易，但并发性较差，需要分时使用总线，效率较低。</li>
<li>专用通路：并发度高，性能好，但设计复杂，成本高。可以看做多总线结构。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/3f0cfe89124c43659c4411dc548d251a.png" alt="" /></p>
<p>CPU的运算器、控制器、寄存器堆等核心部件均由一条内部的公共总线连接起来，构成单总线结构的数据通路。这条内部公共总线称为CPU的内总线。将连接CPU、内存及输入输出设备等部件构成计算机系统的总线称为系统总线或外总线。</p>
<p>考虑执行指令add r0, r1，首先需要从寄存器堆中取出两个寄存器的值并输入到ALU的两个输入端，ALU的两个输入端连接有两个锁存器，可以分别保存两个寄存器的值，取出两个寄存器的值需要使用两个时钟周期，两次取值操作分别占用总线一个周期。之后ALU计算得到结果，通过总线输入到寄存器堆中，共需要3个周期和2个锁存器。</p>
<p>如果能够添加一条总线直接连接ALU的一个输入和寄存器堆，则只需要两个时钟周期即可执行上述指令。第一步将一个寄存器的值保存到ALU一端的锁存器，第二步第二条总线将第二个寄存器的值输入到ALU另一端，ALU进行计算并通过第一条总线输出到寄存器堆中。共需2个时钟周期和1个锁存器。</p>
<h4 id="指令执行示例"><a class="markdownIt-Anchor" href="#指令执行示例"></a> 指令执行示例</h4>
<p><strong>LOAD R0, 6#</strong><br />
功能：将主存地址为6的内容写入R0寄存器</p>
<ul>
<li>取指令数据通路：
<ul>
<li>T1：PC保存到AR和X中，准备访问AR处地址的指令内容</li>
<li>T2：X+1保存到Z中，程序计数器+1，准备将Z写到PC，Z即为下一条指令地址</li>
<li>T3：Z保存到PC，从主存取出指令内容保存到DR</li>
<li>T4：将DR保存到IR，至此取指完成，指令内容已经被保存到IR。</li>
</ul>
</li>
<li>译码周期：略</li>
<li>执行周期，完成指令要求的任务，即首先取内存地址为6的数据，再保存到寄存器R0
<ul>
<li>T1：将IR中的地址操作数部分（值为6）保存到AR，X保存PC的值</li>
<li>T2：主存读取</li>
<li>T3：主存将读取的数据保存到DR</li>
<li>T4：将DR的内容保存到寄存器R0</li>
</ul>
</li>
</ul>
<p><strong>MOVE R1, 10</strong></p>
<ul>
<li>执行周期：
<ul>
<li>T1：将指令中的地址操作数部分（值为10）保存到R1</li>
</ul>
</li>
</ul>
<p><strong>ADD R0, R1</strong></p>
<ul>
<li>执行周期
<ul>
<li>T1：将寄存器R0保存到X</li>
<li>T2：R1的值输出到总线，ALU接收X和总线的数据，计算结果并保存到Z</li>
<li>T3：将Z的值写入到R0</li>
</ul>
</li>
</ul>
<p><strong>STORE R0, (R2)</strong></p>
<ul>
<li>执行周期，将R0的值保存到地址为R2的内存空间
<ul>
<li>T1：将R2的值保存到AR</li>
<li>T2：将R0的值保存到DR</li>
<li>T3：将DR的值写入到内存地址为AR的空间</li>
</ul>
</li>
</ul>
<p><strong>JMP 1000</strong></p>
<ul>
<li>执行周期
<ul>
<li>T1：将IR中的地址操作数（1000）保存到PC</li>
</ul>
</li>
</ul>
<h2 id="65-硬布线控制器"><a class="markdownIt-Anchor" href="#65-硬布线控制器"></a> 6.5 硬布线控制器</h2>
<p>硬布线控制器可以看成产生固定时序控制信号的逻辑电路。<br />
输入信号：指令译码，时钟信号，反馈信号<br />
输出信号：功能部件控制信号序列<br />
设计目标：最少元件，最快速度<br />
理论基础：布尔代数<br />
组成器件：门电路、触发器</p>
<ul>
<li>定长指令周期：使用2个机器周期，8个时钟周期，由于一些指令并不需要所有8个时钟周期，因此速度较慢（会浪费时间），但设计简单</li>
<li>变长指令周期：时钟周期数量可变，速度快，但设计较复杂</li>
</ul>
<p>硬布线控制器模型：包含指令寄存器和指令译码器，时序发生器、硬布线控制器组合逻辑单元等几个部分，其中硬布线控制器组合逻辑单元用于产生指令执行所需要的所有控制信号序列，是控制器的核心。<br />
输入来自：</p>
<ul>
<li>指令译码器的输出</li>
<li>执行部件以及IO总线的反馈信号</li>
<li>时序发生器的状态周期电位信号和节拍电位信号</li>
</ul>
<p>输出信号：微操作控制信号序列，可以看做所有输入信号的逻辑函数，每个控制信号都是由不同的指令译码信号、状态周期信号、节拍定位信号、状态反馈信号构成的逻辑与操作的和。（积之和范式）</p>
<p>固定指令周期硬布线控制器设计过程</p>
<ul>
<li>设计三级时序产生器：所有指令固定机器周期数，节拍数</li>
<li>列出所有机器指令的指令周期流程图，明确每个节拍的控制信号</li>
<li>找出产生同一个微操作控制信号的条件</li>
<li>写出各个微操作控制信号的布尔表达式</li>
<li>化简各个表达式</li>
<li>利用组合逻辑电路实现</li>
</ul>
<p>可变周期硬布线控制器设计步骤</p>
<ul>
<li>列出所有机器指令的指令周期流程图，明确每一个节拍的控制信号</li>
<li>绘制指令执行状态转换图</li>
<li>根据状态转换图构建状态集真值表，实现有限状态机组合逻辑</li>
<li>实现控制器组合逻辑电路</li>
</ul>
<h2 id="66-微程序控制器"><a class="markdownIt-Anchor" href="#66-微程序控制器"></a> 6.6 微程序控制器</h2>
<h3 id="661-微程序控制器的基本概念"><a class="markdownIt-Anchor" href="#661-微程序控制器的基本概念"></a> 6.6.1 微程序控制器的基本概念</h3>
<p>硬布线为同步逻辑，设计复杂，速度快，贵，且难以修改。一条指令有多个时钟周期，一个时钟周期对应一个状态，一个状态对应一组并发信号。<br />
微程序为存储逻辑，设计简单，速度慢，偏移，容易修改。将并发信号实现保存为微指令，一条指令对应于多条微指令，状态等同于存储器地址。</p>
<p>微地址寄存器μAR为控制存储器提供微指令地址，初始化为0，控制存储器0号单元应该为取指令微程序的第一条微指令。</p>
<h3 id="662-微程序控制器组成原理"><a class="markdownIt-Anchor" href="#662-微程序控制器组成原理"></a> 6.6.2 微程序控制器组成原理</h3>
<p>利用软件方法设计硬件的技术，将完成指令所需的控制信号按照格式编写为微指令，并存放到<font color=red>控制存储器（控存ROM）</font>，一条机器指令对应于一段微程序，微程序中有多条微指令。<br />
将存储技术与程序设计相结合，可以回避复杂的同步时序逻辑设计。</p>
<p>单总线CPU的微指令构造：</p>
<ul>
<li>操作控制字段：用于存储操作控制信号，每一位对应一个控制信号，也称微命令，可以同时给出多个操作信号。</li>
<li>顺序控制字段：用于控制微程序的执行顺序，判别逻辑为0，下一条微指令地址从<font color=red>下址字段</font>获取，否则按照约定规则生成。一个微程序的最后一条微指令的判别字段非零，代表地址跳转。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/b777065d983a410c8cc1d0af5fcd6870.png" alt="" /></p>
<h3 id="663-微程序控制器设计"><a class="markdownIt-Anchor" href="#663-微程序控制器设计"></a> 6.6.3 微程序控制器设计</h3>
<p>微指令包含操作控制字段和顺序控制字段，一条微指令对应于一个时钟周期，微指令操作控制字段的信号在该时钟周期之内有效。指令需要多少时钟周期就包含多少微指令。操作控制字段的每一位都代表一个控制结构的开启与否。在一个时钟周期内，需要开启的控制字段在操作控制字段中的对应位会被设置为1。</p>
<p>上面的顺序控制字段中P<sub>1</sub>表示下址字段是否有效，在取指周期的最后一个时钟周期，下址字段就无效，因为下一条微命令的地址不确定。其他的微程序的最后一个微命令的下址字段基本都为0。</p>
<p>微指令设计原则：</p>
<ul>
<li>有利于缩短微指令字长度</li>
<li>有利于减少控存容量</li>
<li>有利于提高微程序执行速度</li>
<li>有利于对微程序进行修改</li>
<li>有利于提高微程序设计的灵活性</li>
</ul>
<p>微指令的直接表示法简单直观，便于输出控制，但微指令长度太长，控存容量大。优化方法：</p>
<ul>
<li>修改直接表示为编码表示，压缩互斥性的微指令，如4个互斥性的微指令可以不用4个二进制位表示，而是用2个二进制位替换。</li>
<li>去掉下址字段，采用μPC=μPC+1的方式生成微指令地址。
<ul>
<li>微指令地址的形成方法有两种，一种是通过下址字段，另一种就是计数器法。前者微指令长，但控存容量大，后者微指令短，但需要加法器。</li>
</ul>
</li>
<li>修改水平型微指令为垂直型微指令，牺牲了并行性。
<ul>
<li>水平型微指令：在一个微指令周期内能够同时给出多个微命令的微指令。并行操作能力强，效率高，灵活性强，字较长，微程序短，控存容量大，性能好。</li>
<li>垂直型微指令：采用完全编码方法，将全部微命令编码化。字长短，微程序长，控存容量小，性能差，与指令相似，易于掌握，已经基本被淘汰。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC5%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC5%E7%AB%A0/" class="post-title-link" itemprop="url">计算机组成原理——第5章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-03 00:01:40 / Modified: 00:05:10" itemprop="dateCreated datePublished" datetime="2023-03-03T00:01:40+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="51-指令系统概述"><a class="markdownIt-Anchor" href="#51-指令系统概述"></a> 5.1 指令系统概述</h2>
<p>指令是用户使用计算机与计算机本身运行的基本功能单位。指令是计算机能够直接识别、执行的操作命令，是冯诺依曼结构计算机程序控制原理实现的载体。</p>
<p>指令系统是一台计算机中所有机器指令的集合。</p>
<h2 id="52-指令格式"><a class="markdownIt-Anchor" href="#52-指令格式"></a> 5.2 指令格式</h2>
<h3 id="521-指令字长度"><a class="markdownIt-Anchor" href="#521-指令字长度"></a> 5.2.1 指令字长度</h3>
<ul>
<li><mark>指令字长</mark>：指令中包含的二进制位数</li>
<li>计算机根据指令字长是否固定可以分为<mark>定长和变长指令系统</mark>
<ul>
<li>定长指令系统的指令长度固定，结构简单，有利于CPU取指令、译码和指令顺序寻址，但平均指令长度较长，冗余状态较多，不容易扩展。</li>
<li>变长指令系统的指令长度可变，结构灵活，冗余状态较少，平均指令长度较短，但取指令和译码有很多不便。</li>
</ul>
</li>
</ul>
<h2 id="522-指令地址码"><a class="markdownIt-Anchor" href="#522-指令地址码"></a> 5.2.2 指令地址码</h2>
<p>根据指令中地址码字段的个数可将指令分为：</p>
<ul>
<li>三地址指令——A<sub>3</sub>←(A<sub>1</sub>)OP(A<sub>2</sub>)</li>
<li>双地址指令——A<sub>1</sub>←(A<sub>1</sub>)OP(A<sub>2</sub>)</li>
<li>单地址指令——A<sub>1</sub>←OP(A<sub>1</sub>)，AC←(AC)OP(A<sub>1</sub>)</li>
<li>零地址指令</li>
</ul>
<p>按照指令中操作数的物理位置分类可以分为：</p>
<ul>
<li>存储器-存储器型</li>
<li>寄存器-寄存器型</li>
<li>寄存器-存储器型</li>
</ul>
<p>根据指令的功能可以分为：</p>
<ul>
<li>传送指令</li>
<li>定点算数运算指令</li>
<li>位运算指令</li>
<li>控制转移指令</li>
</ul>
<p>指令格式：操作码字段+寻址方式+地址码字段<br />
操作码字段的位数与支持的最大指令数有关，对于定长操作码而言，最大指令数m与操作码字段长n满足n≥log<sub>2</sub>m。对于变长操作码，可以向不用的地址码字段进行扩展。寻址方式字段的位数与支持的寻址方式种类有关。地址码字段的作用及影响与位数和寻址方式有关。</p>
<h2 id="53-寻址方式"><a class="markdownIt-Anchor" href="#53-寻址方式"></a> 5.3 寻址方式</h2>
<p>指令的寻址方式只有顺序寻址和跳跃寻址两种。</p>
<h3 id="531-指令寻址方式"><a class="markdownIt-Anchor" href="#531-指令寻址方式"></a> 5.3.1 指令寻址方式</h3>
<h4 id="顺序寻址方式"><a class="markdownIt-Anchor" href="#顺序寻址方式"></a> 顺序寻址方式</h4>
<p>程序的指令序列在主存顺序存放，执行时从第一条指令开始逐条取出并执行，这种程序的顺序执行过程被称为顺序寻址方式。<br />
CPU通过设置<mark>程序计数器</mark>对指令顺序号进行计数。每一次执行一条指令PC加1并指出下一条指令的地址，直到程序结束。</p>
<h4 id="跳跃寻址方式"><a class="markdownIt-Anchor" href="#跳跃寻址方式"></a> 跳跃寻址方式</h4>
<p>程序出现分支或转移时会改变程序的执行顺序，此时下条指令的地址不一定通过PC+1获得。</p>
<h3 id="532-操作数寻址方式"><a class="markdownIt-Anchor" href="#532-操作数寻址方式"></a> 5.3.2 操作数寻址方式</h3>
<ul>
<li>立即数寻址：地址码字段就是操作数本身。如MOV RAX, 200H中的200H。取指操作将数据和指令一并读入CPU内部的寄存器，指令执行速度快，便于程序设计，但数据大小受到字段的位数限制。</li>
<li>寄存器寻址：操作数在CPU内部寄存器中。如MOV RAX, RBX。操作数在寄存器中，指令执行速度快，但能访问的数据大小一般与计算机字长有关，地址字段的位数与计算机通用寄存器数量相关。</li>
<li>直接寻址：操作数在主存储器中，地址码字段给出操作数在内存中的地址。如MOV RAX, [4000H]。提供了访问主存的操作，获得数据需要访问主存，因此指令的执行速度较慢，地址字段的位数决定了访存的空间大小。</li>
<li>间接寻址：地址码字段给出操作数主存地址的地址。即需要进行两次寻址，相当于二重指针。解决了直接寻址方式下字段的位数限制访存范围大小的问题，但需要访问主存两次，指令执行速度慢。</li>
<li>寄存器间接寻址：地址码字段给出寄存器编号。如MOV RAX, [RBX]，需要首先访问寄存器获取寄存器的值，然后根据该值到主存中访存。其解决了直接寻址方式下地址字段的位数限制访存范围大小的问题，且获得数据只需要访问一次主存。</li>
<li>相对寻址：将程序计数器PC中的内容加上指令中的形式地址，形成操作数的有效地址。如JMP指令。该寻址方式可节省指令中的地址位数，便于程序在内存中成块移动，注意PC的改变对计算有效地址的影响，有效地址值应该为当前指令的地址+偏移量+<mark>当前指令的长度</mark>。</li>
<li>基址寻址：指定基址寄存器，与本指令地址无关。如MOV RAX, [RBP+10H]。使用基址寄存器可以访问更大的主存空间，对某一程序而言，<mark>基址值设定后不变</mark>，故要访问不同数据需要修改偏移量的值。</li>
<li>变址寻址：指定一个变址寄存器，与本指令地址无关。因此首先需要根据寄存器编号找到寄存器，再将寄存器值与偏移相加获得有效地址，之后访存。如MOV RAX, [RSI+10H]。</li>
</ul>
<h2 id="55-指令格式设计"><a class="markdownIt-Anchor" href="#55-指令格式设计"></a> 5.5 指令格式设计</h2>
<ul>
<li>根据指令数量的要求及是否支持操作码扩展，确定操作码字段的位数</li>
<li>根据对操作数的要求确定地址码字段的个数</li>
<li>根据寻址方式的要求，为每个地址码字段确定寻址方式字段位数</li>
<li>确定采用定长指令还是变长指令</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC4%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC4%E7%AB%A0/" class="post-title-link" itemprop="url">计算机组成原理——第4章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-03 00:01:37 / Modified: 00:05:10" itemprop="dateCreated datePublished" datetime="2023-03-03T00:01:37+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>4.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="41-存储器概述"><a class="markdownIt-Anchor" href="#41-存储器概述"></a> 4.1 存储器概述</h2>
<p>存储器可以分为：</p>
<ul>
<li>随机存储器RAM，按照地址随机读写数据存储单元，且存取访问时间与存储单元的位置无关。</li>
<li>顺序存储器SAM，存储单元中的内容只能按照顺序访问，且访问速度与存储单元的位置有关。</li>
<li>直接存储器DAM，不必经过顺序搜索就能够在存储器中直接存取信息的存储器，兼有随机存储器和顺序存储器的访问特性。</li>
<li>只读存储器ROM。</li>
</ul>
<h4 id="存储系统的层次结构"><a class="markdownIt-Anchor" href="#存储系统的层次结构"></a> 存储系统的层次结构</h4>
<p>现实世界中，一个存储器的存储速度、存储容量和成本往往是相互矛盾的，因此需要多种不同类型的存储器。典型的存储系统是一个金字塔结构，从上到下依次为<mark>寄存器、高速缓存、主存、磁带、磁盘等</mark>。越往上访问速度越快，单位容量的成本越高，越往下存储容量越大。</p>
<p>存储体系层次化结构的理论基础：时间局部性原理和空间局部性原理。</p>
<h4 id="主存中数据的存放"><a class="markdownIt-Anchor" href="#主存中数据的存放"></a> 主存中数据的存放</h4>
<ul>
<li>存储字长：主存的一个存储单元能够存储的二进制位数。</li>
<li>数据字长：计算机一次能处理的二进制数的位数。</li>
<li>数据的边界对齐：在数据对齐的情况下，访问主存的次数相对于不对齐会减少一些，虽然浪费了一些空间，但是能够提升速度。以32位系统为例，双字数据的地址应该以8为倍数对齐，字数据地址应该以4为倍数对齐，以此类推。</li>
<li>大小端存储：采用多字节方式访问主存时主存中的字节顺序。存储器的低字节单元中存放的是数据的高字节时，称为大端，反之称为小端。</li>
</ul>
<h2 id="42-半导体存储器"><a class="markdownIt-Anchor" href="#42-半导体存储器"></a> 4.2 半导体存储器</h2>
<h3 id="421-静态mos存储器"><a class="markdownIt-Anchor" href="#421-静态mos存储器"></a> 4.2.1 静态MOS存储器</h3>
<p>存储器以静态MOS存储元为基本单元构成的存储器称为静态MOS存储器（SRAM）。</p>
<p><img src="https://img-blog.csdnimg.cn/d81df6d4e65d4db7b38b6124e0362f81.png" alt="" /></p>
<h4 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h4>
<ul>
<li>要想获取该单元存储的数据是0还是1，需要看A点和B点的电位。当A点为高电平而B点为低电平时，存储1，反之存储0。当A点为高电位时，T<sub>2</sub>导通，T<sub>1</sub>断路。</li>
<li>T<sub>3</sub>和T<sub>4</sub>为补充电荷使用。无论A还是B为高电平，这两个三极管一定导通，当A为高电平时，B接地，因此从T<sub>4</sub>过来的电荷都漏掉了，B点的电压还是0V，而A点则可以维持高电平。反之同理。</li>
<li>读取：当X地址译码线与Y地址译码线均导通时，4个三极管均导通，A的电平输出到左边，B的电平输出到右边。</li>
<li>写入：两个地址线导通后左边与右边一个输入高电平，一个输入低电平。设原来单元中存储1，现需要将其写为0，则需要向左边输入0V，右边输入高电平，这样放走了左边A的电荷之后，右边的T<sub>2</sub>就断路，B不再接地，其电荷量增加，导通T<sub>1</sub>使A的电荷完全被导走，以此达到新的稳态。注意这其中的步骤顺序。</li>
</ul>
<p>单译码结构：一维的线性结构，索引一个存储单元只需要一个地址线。索引2<sup>n</sup>地址空间需要2<sup>n</sup>条地址线。<br />
双译码结构：二维的地址结构，索引一个单元需要两个地址线。索引2<sup>n</sup>地址空间需要2<sup>n/2+1</sup>条地址线。</p>
<h3 id="422-动态mos存储器"><a class="markdownIt-Anchor" href="#422-动态mos存储器"></a> 4.2.2 动态MOS存储器</h3>
<p>SRAM的不足之处有：晶体管数量较多，存储密度低，功耗大。<br />
<img src="https://img-blog.csdnimg.cn/f7aa512bdb234f61aeb467eec7ffda55.png" alt="" /><br />
<img src="https://img-blog.csdnimg.cn/5f21cadb698247aebf6be87ab01dccf8.png" alt="" /></p>
<h4 id="工作原理-2"><a class="markdownIt-Anchor" href="#工作原理-2"></a> 工作原理</h4>
<ul>
<li>处于保持状态时，预充、两条译码线均为低电平，若此时A为高电平，B为低电平，则B接地，A上有大量电荷，因此电容C<sub>2</sub>带电，可以让A的高电平状态维持一段时间，但电荷还是会有流失，因此保持状态如果时间过长，其中的数据就会丢失。</li>
<li>刷新状态：预充和一条译码线（X译码线）导通，进行充电。如果原来A上带有电荷，但由于泄露已经较为微弱。在导通X译码线和预充之后，A得到了直接的电荷补充，而B由于此时仍然接地，因此无法得到电荷。双地址结构的DRAM刷新是按行进行的。</li>
<li>读数据：首先导通预充信号充电，使得左右两个C<sub>D</sub>充满电。若此时A为高电平，充电完成后先导通X地址译码线，这样左边C<sub>D</sub>会为C<sub>2</sub>充电，<mark>自身电荷量增加</mark>，而右边的C<sub>D</sub>将电荷部分转移到C<sub>1</sub>中，<mark>自身电荷量减少</mark>。然后导通Y地址译码线，左边输出的电平略高于V<sub>CC</sub>/2，右边输出的电平略低于V<sub>CC</sub>/2。</li>
<li>写数据：首先导通Y地址译码线，并写入高电平和低电平，设向原来保存1的单元写入数据0，则右边输入高电平，左边输入低电平，因此右边C<sub>D</sub>带电荷。然后导通X地址译码线。先是C<sub>2</sub>上的电荷量大量减少，使得B不再接地，然后B接收到右边C<sub>D</sub>的电荷，让A接地。</li>
</ul>
<h4 id="dram的刷新"><a class="markdownIt-Anchor" href="#dram的刷新"></a> DRAM的刷新</h4>
<ul>
<li>最大刷新周期：信息存储到丢失之前的这段时间，两次刷新时间间隔不能超过最大刷新周期。</li>
<li>刷新周期：存储器实际上完成两次刷新的之间的时间间隔。</li>
<li>DRAM按行进行刷新，为减少刷新的周期，可以减少存储矩阵行数，增加列数。</li>
<li>读操作也有刷新功能，但只能刷新一个单元。</li>
</ul>
<p>刷新的不同方式：</p>
<ul>
<li>集中刷新：将所有行在连续的一段时间内全部刷新完成。设刷新周期为2ms，2ms内一共可以进行4000次读写与保持操作，DRAM共256行，则集中刷新法是在前3744个读写周期内进行读写，而在后256个读写周期进行每一行的刷新。优点：读写操作期间不受刷新操作的影响，速度较快。缺点：存在较长时间无法进行访问的情况，“死区”。</li>
<li>分散刷新：将存储周期（时间较短，1μs左右）分为两个部分，第一个部分用于读写，第二个部分用于刷新。优点：不存在死区。缺点：速度慢。</li>
<li>异步刷新：将所有行的刷新平均分配到刷新周期之内，如刷新周期为2ms，共有256行，则将刷新周期分为256等份，每一个等份的前面所有存储周期用于读写，最后的一个存储周期用于刷新。</li>
</ul>
<h2 id="43-主存的组织和cpu的连接"><a class="markdownIt-Anchor" href="#43-主存的组织和cpu的连接"></a> 4.3 主存的组织和CPU的连接</h2>
<h3 id="432-存储器的扩展"><a class="markdownIt-Anchor" href="#432-存储器的扩展"></a> 4.3.2 存储器的扩展</h3>
<ul>
<li>位扩展：又称为字长扩展或数据总线扩展，将所有存储芯片的地址线、读写控制线并联，将输出合并得到数据内容，可以理解为，如果一块芯片的一个单元只能保存一位信息，则第一块芯片只保存所有地址中的第一位信息，第二块芯片只保存所有地址的第二位信息，等等。</li>
<li>字扩展：又称容量扩展或地址总线扩展，其不会增加数据的位宽，每一次寻址只会访问一块芯片，其他芯片没有被访问，输出也只是接受一个芯片的输出。将扩展出来的数据位线（地址的高位）连接到译码器来确定访问哪一块存储芯片。</li>
<li>字位同时扩展：上面两种方式的结合。</li>
</ul>
<h2 id="45-高速缓冲存储器"><a class="markdownIt-Anchor" href="#45-高速缓冲存储器"></a> 4.5 高速缓冲存储器</h2>
<p>cache：在CPU与主存之间添加一块小容量的快速的SRAM，以提升访问主存的性能。依据的原理是空间局部性。</p>
<h3 id="453-cache的基本原理"><a class="markdownIt-Anchor" href="#453-cache的基本原理"></a> 4.5.3 cache的基本原理</h3>
<p>CPU通过字节地址访问快速的cache，首先需要确定需要访问的数据是否在cache中。</p>
<ul>
<li>数据命中：数据在cache中。</li>
<li>命中访问时间：当数据命中时数据的访问时间，包括查找时间和cache访问时间两部分。</li>
<li>数据缺失：需要访问的数据不在cache中。需要将缺失的数据从主存调入到cache中才能访问数据。</li>
<li>缺失补偿：数据缺失时的访问时间，包括数据查找时间、主存访问时间、cache访问时间。</li>
<li>命中率：所有访问中成功命中的次数占总访问次数的比例。</li>
<li>缺失率：1-命中率。</li>
<li>访问效率：cache的命中访问时间与cache/主存系统的平均访问时间的比值。</li>
</ul>
<h3 id="454-cache读-写流程与关键技术"><a class="markdownIt-Anchor" href="#454-cache读-写流程与关键技术"></a> 4.5.4 cache读、写流程与关键技术</h3>
<h4 id="读"><a class="markdownIt-Anchor" href="#读"></a> 读</h4>
<p>读入时查找cache中是否有需要读取的数据，有则读取，没有则调入这一块数据后再读取。</p>
<h4 id="写"><a class="markdownIt-Anchor" href="#写"></a> 写</h4>
<p>写比读复杂一些。<br />
首先查找目标地址处的数据是否保存在cache，如果有则写入数据到cache。这里有两种策略：<mark>写回策略和写穿策略</mark>，写回策略在将数据写入cache之后立即结束操作，会导致cache与主存中数据的不一致；写穿策略在cache中数据被修改后再将数据写入到主存中，速度较慢。<br />
如果目标地址处的数据不在cache，则也有两种选择：一种是将数据直接写入到主存，另一种是将这一块地址的内容载入到cache后写入到cache，至于之后是否需要写入主存使用的就是写回策略和写穿策略两种策略了。</p>
<h3 id="455-相联存储器"><a class="markdownIt-Anchor" href="#455-相联存储器"></a> 4.5.5 相联存储器</h3>
<p>相联存储器可用于判断对应地址的数据是否保存在该存储器中，基本数单元是键值对，键是主存地址，值是主存地址下的数据。由于相联存储器可以进行所有键值对的并行查找，因此只需查找一次就可以确定一个键值对。</p>
<p><img src="https://img-blog.csdnimg.cn/11f8cf36bbcf4f479515775306c6d33b.png" alt="" /></p>
<h3 id="456-地址映射"><a class="markdownIt-Anchor" href="#456-地址映射"></a> 4.5.6 地址映射</h3>
<p>地址映射即为将主存地址空间映射到cache的地址空间，将存放在主存的程序或数据载入到cache块的规则。</p>
<ul>
<li>全相联：各个主存块都可以映射到cache中的任意一个数据块。</li>
<li>直接相联：各个主存块只能映射到cache的固定某一块。</li>
<li>组相联：各个主存块只能映射到cache固定组中的任意块。</li>
</ul>
<h4 id="全相联映射"><a class="markdownIt-Anchor" href="#全相联映射"></a> 全相联映射</h4>
<p>主存中每一个数据块都可以放置到cache中的任意一个数据块中，是一对多的映射关系。新的数据块可以载入到cache中任意一个空闲位置，只有cache满时才会进行数据块置换。</p>
<p>在全相联映射中，主存地址被划分为两部分：块号和块内地址。如果一块的大小为1024字节，则块内地址共10位，高位为块号。在cache中会保存块号和主存中该块号下的数据内容。</p>
<p>优点：cache利用率高，块冲突率低。缺点：淘汰算法复杂。适用于小容量的cache。</p>
<h4 id="直接相联映射"><a class="markdownIt-Anchor" href="#直接相联映射"></a> 直接相联映射</h4>
<p>在直接相联映射中，主存地址分为三部分：区号、区内块号、块内地址。其中区内块号为x，cache行数为y，则该块在cache中应该保存在第x行的位置。区内块号表示的数值应该与cache中的行数相同。</p>
<p>优点：淘汰算法简单。缺点：利用率较低，块冲突率高。使用率大容量cache。</p>
<h4 id="组相联映射"><a class="markdownIt-Anchor" href="#组相联映射"></a> 组相联映射</h4>
<p>组相联映射将主存地址分为3部分：组号、组内块号、块内地址。cache中所有行分为若干组，设一组有m行，共n组，则主存地址组号为x时应该保存在cache中的第x mod n组，组内块号为y的地址处应该保存在cache中的保存该组号的组中的任意一行。</p>
<h3 id="457-替换算法"><a class="markdownIt-Anchor" href="#457-替换算法"></a> 4.5.7 替换算法</h3>
<ul>
<li>先进先出算法</li>
<li>最不经常使用算法：替换访问次数最少的cache</li>
<li>近期最少使用算法：为每一行维持一个计数器，命中时计数器清零，否则加1，将计数器最大的行换出。</li>
<li>随机替换算法</li>
</ul>
<h2 id="46-虚拟存储器"><a class="markdownIt-Anchor" href="#46-虚拟存储器"></a> 4.6 虚拟存储器</h2>
<p>虚拟存储器处于主存-辅存存储层次，为了解决主存容量不足的问题，为程序设计者提供比主存空间大的编程空间。<br />
虚拟存储器可以分为：页式、段式和段页式。<br />
三种地址空间：虚拟地址空间、主存的地址空间、辅存地址空间。</p>
<p>在虚拟存储系统中运行时，CPU以虚拟地址访问主存，使用存储管理部件<mark>MMU</mark>找到虚拟地址与物理地址的对应关系，并判断该虚拟地址对应的物理地址是否在主存中，如果在则将虚拟地址转化为物理地址，CPU直接访问主存单元；否则将包含这个字的一页或一段调入主存，并在MMU中填写相关的标记信息。</p>
<h3 id="463-页式虚拟存储器"><a class="markdownIt-Anchor" href="#463-页式虚拟存储器"></a> 4.6.3 页式虚拟存储器</h3>
<p>虚拟地址被划分为虚拟页号VPN和虚拟页偏移VPO两部分，同时物理地址按照相同的划分方式分为物理页号PPN（页框号）和物理页偏移PPO。</p>
<p>页面命中时CPU硬件执行的步骤：</p>
<ul>
<li>CPU将虚拟地址传送给MMU。</li>
<li>MMU用页表基址寄存器PTBR和虚页号生成页表项地址PTEA，通过这个页表项地址可以找到目标虚拟地址对应的物理地址值保存在什么位置。</li>
<li>cache或主存向MMU返回页表项PTE。</li>
<li>如果返回的PTE中有效位为1，则MMU利用返回的PTE构造物理地址PA，并利用构造出的物理地址PA访问cache或主存。</li>
<li>cache或主存返回数据给CPU。</li>
</ul>
<p>缺页处理流程：前3步与上面相同</p>
<ul>
<li>PTE中有效位为0，所访问的页不在主存中，MMU触发异常调用内核的缺页中断处理程序。</li>
<li>如果主存页满，需要根据算法确定换出哪一个页，如果换出的页的有效位为1，则需要将其换出到磁盘。</li>
<li>缺页中断处理程序从磁盘中调入新的页，更新存储器中的页表项PTE。</li>
<li>返回原来进行继续执行。</li>
</ul>
<p>如果存储系统中包含cache，则可以将部分页表的内容保存到cache中。</p>
<p>转换旁路缓冲区：<mark>TLB</mark>，用于缓冲经常访问的页表项PTE，实质是一个小容量的cache，大多采用全相联或组相联形式以提高访问速度，且采用随机替换算法。通常<mark>称TLB中保存的表为快表，主存中保存的表称为慢表</mark>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CoLin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">112</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Hornos3" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Hornos3" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_54218833?spm=1000.2115.3001.5343" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_54218833?spm&#x3D;1000.2115.3001.5343" rel="noopener" target="_blank"><i class="fa fa-crosshairs fa-fw"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CoLin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">987k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">14:58</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
