<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hornos3.github.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="CoLin&#39;s BLOG">
<meta property="og:url" content="http://hornos3.github.com/page/2/index.html">
<meta property="og:site_name" content="CoLin&#39;s BLOG">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="CoLin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://hornos3.github.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-cn'
  };
</script>

  <title>CoLin's BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CoLin's BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC2%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC2%E7%AB%A0/" class="post-title-link" itemprop="url">计算机组成原理——第2章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-03 00:01:30 / Modified: 00:05:10" itemprop="dateCreated datePublished" datetime="2023-03-03T00:01:30+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="2-2-数值数据的表示"><a href="#2-2-数值数据的表示" class="headerlink" title="2.2 数值数据的表示"></a>2.2 数值数据的表示</h2><ul>
<li><font color=red>真值</font>：使用”+”、”-“表示正负号的数值表示方式。</li>
<li><font color=red>机器数</font>：符号数值化的数据表示方法，使用0、1表示符号。</li>
<li>三种常见机器数（整数）：<ul>
<li><font color=red>原码</font>：最高位为符号位，其余位值为数值的绝对值，符号位正数为0，负数为1。原码表示方便，但计算复杂，且有+0和-0两种0的表示方式。</li>
<li><font color=red>反码</font>：最高位符号位规则与原码相同，当数值为负数时，其余位值相对于原码全部取反。表示相对于原码较复杂，但计算简单，但0的表示同样不唯一。</li>
<li><font color=red>补码</font>：表示负数时为反码+1。</li>
<li>规则：对于总位数为n的二进制数，三种码对于正数的表示方法相同，可表示正数范围均为0~2^n-1^-1。原码表示负数x，二进制数的值为2^n-1^-x，反码表示为2^n^+x-1，补码表示为2^n^+x。反码的加法计算方法：二进制数直接相加后再加1。</li>
</ul>
</li>
<li><font color=red>移码</font>：非符号位与补码相同，符号位与补码相反。编码方式是直接将真值加上一个常数偏移量，因此得名。</li>
<li>定点数表示：X~0~.X~1~X~2~…，其表示范围为-1~1-2^-n^（使用补码形式进行编码）</li>
<li>浮点数表示：一般格式为E~S~E~1~E~2~…E~n~M~S~M~1~M~2~…M~k~，其中E为阶码位，确定数据的范围，M为尾数，表示数的精度。其中阶码位和尾数位的最高位均表示符号。浮点数表示的不足之处是不同机器可能从相同的二进制数中提取出不同的浮点数。<ul>
<li>IEEE754标准规定单精度浮点数阶码8位，有效尾数23位（<font color=red>不含尾数中的符号位，尾数中的符号位位于阶码前面，在最高位</font>）；双精度浮点数阶码11位，有效尾数52位。<font color=red>阶码采用移码的方式表示，常数为127。</font>其中有效尾数的整数位1被省略。对于单精度浮点数，若其偏指数（带有符号位的阶码的无符号值）为E，尾数为M，则真值可表示为2^E-127^×(-1)^S^×1.M。<ul>
<li>当E=0、M=0时表示机器零，无论S等于0还是1。</li>
<li>当E=0、M≠0时，真值为非规格化的浮点数，2^-126^×(-1)^S^×0.M。即这个数太接近0，即使阶码为0也必须让尾数的整数位为0才能表示，这样会影响数的表示精度。</li>
<li>当1≤E≤254时，正常表示，是规格化的浮点数。</li>
<li>当E=255、M=0时表示无穷大。</li>
<li>当E=255、M≠0时表示NaN。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-4-数据信息的校验"><a href="#2-4-数据信息的校验" class="headerlink" title="2.4 数据信息的校验"></a>2.4 数据信息的校验</h2><h3 id="2-4-1-码距与校验"><a href="#2-4-1-码距与校验" class="headerlink" title="2.4.1 码距与校验"></a>2.4.1 码距与校验</h3><font color=red>码距</font>：信息编码中两个编码对应的二进制位不同的位的个数。如10101和10001的码距为1，只有1个二进制位不同。码距越大、抗干扰、纠错能力越强，数据冗余越大，编码效率越低。
码距越大，纠错就越容易，当码距变大时，将一个合法编码转化为另一个合法编码需要修改多位，概率较低，且可以根据不合法编码与合法编码之间的码距，选择与不合法编码的码距最小的合法编码纠错。

- 当码距d≥e+1时，可以检测出e个错误
- 当码距d≥2t+1时，可以纠正t个错误
- 当码距d≥e+t+1时（e≥t），可以在检测e个错误的同时纠正t个错误。

### 2.4.2 奇偶校验
检测二进制代码中1的个数的奇偶性进行校验。
<font color=red>奇校验要让数据位和校验位整个的1的个数为奇数，偶校验则让1的个数为偶数</font>。因此奇校验是1的个数为偶数时校验码为1，而偶校验时1的个数为奇数时校验码为1。

优点：检错简单，编码效率高。
缺点：不能获取错误位置，只是一种检错码，无错结论不可靠（如果两位同时错误无法检测出来）

改进：<font color=red>交叉奇偶校验</font>，将原始数据信息构建为行列矩阵式结构，每一行和每一列都产生一个偶校验位，最后生成一个公共校验位。当有一位出错时，可以根据行校验位和列校验位的检查判断出是哪一位出错。但当两位数据同事出错时，不能确定到底是哪两位出错（有两种情况）。<font color=red>可纠正1位错误、检查部分偶数位错误、不能检测出错误发生在数据位中任意一个矩形4个顶点上的错误。</font>

<h3 id="2-4-3-CRC校验"><a href="#2-4-3-CRC校验" class="headerlink" title="2.4.3 CRC校验"></a>2.4.3 CRC校验</h3><p>Cyclic Redundancy Check，循环冗余校验，是一种基于模2运算建立编码规则的校验码。其中模2运算与异或运算的规则相同，在加的基础上不用进位。在此基础上可以获取模2乘法运算和除法运算的规则。</p>
<p>编码规则：设CRC码长度n位，原始数据C~k-1~C~k-2~…C~0~共k位，校验位P~r-1~P~r-2~…P~0~共r位，则<font color=red>n=k+r≤2^r^-1</font>。生成一个多项式G(x)，将待发送的二进制数据用该多项式表示：G(x)=C~k-1~x^k-1^+C~k-2~x^k-2^+…+C~1~x+C~0~。G(x)需要满足：</p>
<ul>
<li>最高位和最低位必须为1。</li>
<li>被传送信息任意一位出错时，被生成多项式除之后余数均不为0。</li>
<li>不同位发生错误时，模2除运算后余数不同。</li>
<li>对不为0的余数进行模2除运算能够使余数循环。</li>
</ul>
<p>编码方法：</p>
<ul>
<li>根据待校验信息的长度k按照k+r≤2^r^-1确定校验码位数。</li>
<li>根据r和生成多项式的选择原则，选择一个位数为r+1的生成多项式。</li>
<li>将有效信息左移r位得到r+k位的二进制数Q。</li>
<li>对Q除生成多项式，以余数替换Q的低r位。</li>
</ul>
<p>校验方法：<br>用数据除生成多项式，余数为0即为正确。</p>
<font color=red>CRC校验码的循环特性</font>：第i位出错的数据除以生成多项式获得的余数R~i~与第i+1位出错的数据除以生成多项式获得的余数R~i+1~满足：<font color=red>R~i+1~=R~i~左移1位后除以生成多项式获得的余数。</font>

<p>纠错方法：<br>记录当数据最高位错误时除以生成多项式获取的余数R。<br>当待检测数据除以生成多项式获得的余数不是0也不是R时，一边对余数补零继续除，另一边对待检测数据循环左移，当余数的值为R时，将当前循环移位后的待检测数据的最高位取反，再移位回来即可完成纠错。</p>
<h3 id="2-4-3-海明校验"><a href="#2-4-3-海明校验" class="headerlink" title="2.4.3 海明校验"></a>2.4.3 海明校验</h3><p>一种既能检错又能纠错的校验码，本质是多重奇偶校验。（海明码为偶校验）</p>
<p>设海明校验码共n位，原始数据k位，校验位r位，满足k+r≤2^r^-1。<br>r位校验码（P~i~，i=1,2,…,r）分别位于海明编码的第2^i-1^位。海明码第i位的数据由若干个位于小于i的校验位校验。<font color=red>注意：第i位如果为数据位，那么参与检验该位的海明码的计算方式是——获取i的二进制表示，二进制中若第j位为1，则第j个海明码参与检验该值。如海明校验码的第11位，二进制表示为1011，则第1、2、4个校验码位参与校验该值。</font>当有1位出错时，只需要将指错字的所有位转换为一个数值，该数值即为出错的位的索引。如第11位出错，则4个指错字中第1、2、4位必然为1，4个指错字结合为1011，即为出现错误的那一位。这种纠错方式可以纠正海明校验码中任何一位的错误，包括校验位。但海明校验不一定能够分辨出一位错与两位错。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC1%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC1%E7%AB%A0/" class="post-title-link" itemprop="url">计算机组成原理——第1章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-03 00:01:21 / Modified: 00:05:10" itemprop="dateCreated datePublished" datetime="2023-03-03T00:01:21+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-2-计算机系统的组成"><a href="#1-2-计算机系统的组成" class="headerlink" title="1.2 计算机系统的组成"></a>1.2 计算机系统的组成</h2><p>计算机系统由硬件系统和软件系统组成。</p>
<font color=red>冯诺依曼计算机的工作原理</font>：
冯诺依曼计算机由两部分：存储程序和程序控制构成。
- 存储程序将程序存放在计算机的存储器中。
- 程序控制按指令地址访问存储器并取出指令，经译码依次产生指令执行所需的控制信号，实现对计算的控制，完成指令的功能。

## 1.3 计算机系统的层次结构

可将计算机的层次结构分为6个基本层次：
- 高级语言层
- 汇编语言层
- 操作系统层
- 指令集架构层
- 微代码层
- 逻辑门层

其中上三层属于软件层，下三层属于硬件层。高层是低层功能的扩展，低层是高层的基础。

- 不同的用户位于不同的层次
- 不同层次具有不同属性
- 不同层次使用不同工具
- 不同层次代码效率不同

透明性概念：用户在高层中所看到的计算机并不会展现出计算机低层的特性，但并不代表这些特性不存在。

## 1.4 计算机性能指标与评价
### 1.4.1 基本性能指标
<font color=red>字长</font>：CPU一次处理的数据位数，用二进制数的长度来衡量。字长一般与计算机内部寄存器、运算器、数据总线的位宽相等。

字长影响计算精确度，字长越长精确度越高。另外还影响数据的表示范围和精度。字长越长，定点数的表示范围就越大，浮点数的表示范围越大，精度越高。

<font color=red>总线宽度</font>：数据总线一次并行传输的最大信息位数。

<font color=red>主存容量</font>：主存中能够存储的最大信息量，一般以M×N表示，M表示存储单元数（字容量），N表示每个存储单元存储的二进制位数（位容量）。

<font color=red>存储带宽</font>：单位时间内与主存交换的二进制数据量，单位B/s。（影响存储带宽的指标包括数据位宽和数据传输速率）

### 1.4.2 与时间有关的性能指标
<font color=red>时钟周期</font>：计算机中最基本的最小的时间单位，一个时钟周期内CPU仅完成一个基本的动作。是时钟频率的倒数，常记为T。CPU内核工作的时钟频率称为<font color=red>主频</font>，常记作f。<font color=red>外频</font>：指CPU(内存)与主板之间同步的时钟频率(系统总线的工作频率)；<font color=red>倍频</font>：CPU主频与外频之间的倍数；<font color=red>主频=外频×倍频</font>。

<font color=red>CPI</font>：Clock Cycles Per Instruction，执行每一条指令所需要的平均时钟周期数。
<font color=red>CPI = 程序中所有指令的时钟周期数之和 / 程序指令总数 = Σ(程序中各类指令的CPI × 程序中该类指令的比例)</font>

<p><font color=red>CPU时间</font>：即执行一个程序所需的物理时间，等于执行程序所需的时间周期数量 × 时间周期 = CPI × 程序中的指令数量 × 时间周期。</p>
<p><font color=red>IPC</font>：CPI的倒数，每个时钟周期能够执行的指令条数。</p>
<p><font color=red>MIPS</font>：Million Instructions Per Second，每秒多少百万条指令。计算公式：<script type="math/tex">MIPS=\frac{IC}{T_{cpu}\times10^6}</script>其中IC表示程序中指令数量。$T_{cpu}$表示程序的CPU时间。如果上面的公式去掉10^6^，则表示的是每秒可以执行多少条指令。公式变形：<script type="math/tex">MIPS=\frac{f}{CPI}=IPC\times f</script>这里时钟频率f的单位为MHz。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%AC%AC6%E7%AB%A0%E4%B9%A0%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%AC%AC6%E7%AB%A0%E4%B9%A0%E9%A2%98/" class="post-title-link" itemprop="url">计算机网络——第6章习题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-02 23:52:41 / Modified: 23:53:17" itemprop="dateCreated datePublished" datetime="2023-03-02T23:52:41+08:00">2023-03-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>4.5k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="课后习题和问题"><a href="#课后习题和问题" class="headerlink" title="课后习题和问题"></a>课后习题和问题</h2><h3 id="6-1-6-2"><a href="#6-1-6-2" class="headerlink" title="6.1~6.2"></a>6.1~6.2</h3><ol>
<li>具体的交通工具</li>
<li>如果链路层能够实现TCP协议能够实现的所有可靠性，那么TCP可靠传输服务才是多余的。这些可靠性包括内容可靠、拥塞控制、流量控制等。</li>
<li>链路层能够提供的可能服务包括：</li>
</ol>
<ul>
<li>成帧，在每一个网络层数据报经链路传送之前，几乎所有的链路层协议都要将其使用链路层帧封装起来。</li>
<li>链路接入，媒体访问控制（MAC）协议规定了帧在链路上传输的规则。</li>
<li>可靠交付，当链路层协议提供可靠交付服务时，能够保证无差错地经过链路层移动每一个网络层数据报。</li>
<li>差错检测和纠正，通过让发送节点在帧中包括差错检测比特，让接收节点进行差错检查。<h3 id="6-3"><a href="#6-3" class="headerlink" title="6.3"></a>6.3</h3></li>
</ul>
<ol>
<li>d(prop)&lt;L/R，意味着传播时延小于传输时延。当传播距离很大时，一方将自己的分组发送完毕之后才会收到对方发送过来的分组，此时不会出现碰撞。当传播距离较小时，一方的分组还未完全发送完毕就已经检测到了对方分组的数据，此时就发生了碰撞。</li>
<li>广播信道4种希望的特性：</li>
</ol>
<ul>
<li>仅有一个节点发送时，该结点能够独占所有的带宽。</li>
<li>多个节点发送时，能够平均分配带宽且充分利用带宽。</li>
<li>协议是分散的，任何一个节点的故障不会影响到整个系统的运作。</li>
<li>协议是简单的，实现成本低。<br>时隙ALOHA能够实现第1、3、4种特性，但无法满足第2种。当有多个节点发送时，会产生碰撞。<br>令牌传递能够实现第1、2种特性，无法满足第3、4种。当一个节点产生故障时，传递令牌的链路就会断裂，整个系统将会失效。另外每一种令牌传输协议都需要解决一些棘手的问题（P301原话）</li>
</ul>
<ol>
<li>第5次碰撞后，节点应该在0~31中选择一个数字延时，因此选择4的概率为1/32。选择4时，网卡将会等待4×512bit时间，在10Mbps以太网中的时延为2048/10^7^=2.048×10^-4^s。</li>
<li>略</li>
<li>当局域网周长很大时，令牌传递一个周期可能需要很长时间，当整个局域网中只有一台主机需要广播时，其不能一直广播，必须等待若干个周期的时间才能完成其广播，降低了效率。<h3 id="6-4"><a href="#6-4" class="headerlink" title="6.4"></a>6.4</h3></li>
<li>MAC地址是48bit值，空间大小为2^48^。IPv4为2^30^，IPv6为2^128^。</li>
<li>不会处理这些帧（丢弃）。也不会将这些帧传递给C的网络层。如果A使用广播，则会处理，也会传递给网络层。</li>
<li>因为ARP的功能是查询给定IP地址主机的MAC地址，此时发起请求的主机还不知道该IP地址对应的MAC地址是什么，因此只能通过广播的方式让ARP请求在整个网络中传播，期望目标IP地址主机能够给出回应。ARP响应报文已经知道了源、目的主机的IP地址以及MAC地址，因此不需要另外使用广播帧增加链路的负担，而是使用普通的链路层帧直接发送即可。</li>
<li>不可能，两张ARP表对应的是两个子网中主机的MAC地址。</li>
<li>没有什么不同，新的以太网和已经安装的以太网设备基础保持完全兼容。</li>
<li>5个</li>
<li>这取决于交换机一共有多少个端口。802.1Q标准中在标准以太网帧中加入了4字节的VLAN标签，理论上这个标签的空间为2^32^，但一台交换机不可能有这么多端口，因此取决于这个交换机的端口数量。</li>
<li>略<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2></li>
<li>偶校验方法，对于16个比特的检验，4×4校验使用的检验位最少。<br>1110 1<br>0110 0<br>1001 0<br>1101 1<br>1100 0</li>
<li>对于单比特差错，二维奇偶校验的行校验码和列校验码必然各有一位出错，根据出错的行和列可以定位错误位，取反即可纠正。如将上一题修改为：<br>1110 1<br>0110 0<br>10==1==1 0<br>1101 1<br>1100 0<br>此时容易发现第3行的行校验码错误，第3行的列校验码错误。<br>某些双比特差错能够监测但不能纠正。如：<br>1110 1<br>0==1==10 0<br>1001 0<br>11==0==1 1<br>1100 0<br>这里的第2、4行的校验码出错，第2、3列的校验码出错。但是，有两种错误都可能会导致这种校验错误：第2行第2列和第4行第3列的2位出错，第2行第4列和第4行第3列2位出错。</li>
<li>这个字符串对应的比特数据为：<br>0100 1110 0110 0101<br>0111 0100 0111 0111<br>0110 1111 0111 0010<br>0110 1011 0110 1001<br>0110 1110 0110 0111<br>以16比特分组求和，结果为0000 1100 0010 0000，取反得到1111 0011 1101 1111</li>
<li>a. 和为0001 1001 0001 1110，取反为1110 0110 1110 0001<br>b. 和为0110 0100 0101 1111，取反为1001 1011 1010 0000<br>c. 和为0000 0101 0000 0000，取反为1111 1010 1111 1111</li>
<li>余数为100，R=100=4</li>
<li>略</li>
<li>a. 因为任何单比特差错都会导致校验码除以生成多项式的余数改变。设第 i 位反转，0&lt;=i&lt;=d+r-1，则接收到的数据 K = D*2^r^ XOR R + 2^i^，如果用 G 除 K，那么余数一定不为 0<br>b. 能。这里的G可以被11（二进制）整除，但是，任何奇数个比特错误（不论是否连续）所造成的偏差必然不可被11（二进制）整除。</li>
<li>a. 求导得$N(1-p)^{N-1}+N(N-1)p(1-p)^{N-2}=0$，计算得到$(1-p)-(N-1)p=0$，$p=\frac{1}{N}$。<br>b. 使用该p值，效率为$\frac{N}{N}(\frac{N-1}{N})^{N-1}$，当N趋近于无穷时，其值趋近于1/e。</li>
<li>同样的流程。</li>
<li>a. 在一个时隙，结点A成功占用信道的概率为$P_A(1-P_B)$，总体效率为$P_A(1-P_B)+P_B(1-P_A)$<br>b. 如果$p_A=2p_B$，则发生碰撞后，在后面的一个时隙A重传成功的概率为$p_A(1-p_B)$，B重传成功的概率为$p_B(1-p_A)$，二者并不是两倍关系。要使得二者为两倍关系，则$p_A-p_Ap_B=2p_B-2p_Ap_B$，$p_A+p_Ap_B=2p_B$，$p_A=\frac{2p_B}{1+p_B}$<br>c. 节点A的平均吞吐量为$2p(1-p)^{N-1}$，其他节点：$p(1-2p)(1-p)^{N-2}$</li>
<li>a. 一个节点没能在一个时隙传输数据的概率为$1-p(1-p)^3$，故节点A在时隙5首次成功的概率为$p(1-p)^3(1-p(1-p)^3)^4$。<br>b. 某个节点在时隙4成功的概率为$1-p(1-p)^3$。<br>c. 在时隙3中出现首个成功的概率为$4p(1-p)^3(1-p(1-p)^3)^2$。<br>d. 效率为$4(1-p(1-p)^3)$</li>
<li>略</li>
<li>一个结点的传输时间为Q/R，一个轮询周期的时间为N(Q/R+t~poll~)，在这段时间内可传输NQ比特数据，故吞吐量为Q/(Q/R+t~poll~)</li>
<li>a. 从A到F依次为：192.168.1.1、192.168.1.3、192.168.2.1、192.168.2.4、192.168.3.1、192.168.3.3<br>b. 从A：00-00-00-00-00-00、左路由器左接口：11-11-11-11-11-11、B：22-22-22-22-22-22、左路由器右接口：33-33-33-33-33-33、C：44-44-44-44-44-44、右路由器左接口：55-55-55-55-55-55、D：66-66-66-66-66-66、右路由器右接口：77-77-77-77-77-77、E：88-88-88-88-88-88、F：99-99-99-99-99-99。<br>c. 主机E发送数据报，其以太网帧中目的MAC地址为右路由器的右接口MAC，即77-77-77-77-77-77，IP报头的目的IP地址为192.168.1.3。交换机注意到MAC地址为路由器的MAC，将其转发到路由器，第一步完成。右路由器接收到这个帧之后传递到其网络层，查询完成之后将其从左边接口发送出去，MAC地址修改为左路由器的右接口，即44-44-44-44-44-44。然后左边路由器接收到帧，将MAC修改为B的MAC即33-33-33-33-33-33，转发到B。<br>d. 首先发送ARP报文广播获取192.168.3.2的MAC地址，然后发送。</li>
<li>a. 不用，因为二者在同一个子网。源IP为E的IP，目的IP为F的IP，源MAC为E的MAC，目的MAC为F的MAC。<br>b. 不用，二者不在同一个子网。源IP为E的IP，目的IP为B的IP，源MAC为E的MAC，目的MAC为R1右端口的MAC。<br>c. 广播查询B的MAC，会收到，不会转发，B不会发送一个ARP请求查询A的MAC，因为A发出的帧中已经包含了A的MAC地址。S1会在转发表中记录B的地址并向A转发。</li>
<li>a. 同15.a<br>b. 会，因为此时E不知道B和它是不是在一个子网中。目的MAC地址为广播MAC。<br>c. 会向子网3发送报文，其他同15.c</li>
<li>10Mbps等待51200比特时间需要5.12ms，0.512ms。</li>
<li>A将会在512+64=576比特时刻完成帧的传输，在A传输结束之前B开始传输一帧，因此在B开始传输时，A的传输信号还没有到达B，也即B传输开始的时刻在0~324比特时间之内。最坏情况下，B的信号将在324+325=649比特时间到达A，而A此时已经完成了传输，因此A能够完成传输。</li>
<li>两者在245比特时间时同时检测到碰撞，因此会等待K×512比特时间，其中K取0或1。如果两者选取的K相同，那么重传依然会碰撞。如果选择的K不同，不妨设A选择的是0，B选择的是1，二者在检测到碰撞后发送48比特时间的干扰数据，在293比特时间同时停止发送数据，然后在293+245=538比特时间A和B停止检测到信号，然后A开始传输数据，需要96比特时间，即在634比特时间完成传输。同时B等待到293+512=805比特时间。而A的重传数据在538+245=783比特时间时被B检测到，一直到634+245=879比特时间才结束接收信号，B也在这个比特时间开始传输其数据。</li>
<li>a. 一帧需要k个时隙才能传输完成。设Y为连续X个空闲时隙，直到出现一个工作时隙，Y=X+1。则$E(Y)=\frac{1}{P_{working}}=\frac{1}{Np(1-p)^{N-1}}$，故$E(X)=E(Y)-1$。故效率=$\frac{k}{k+x}$可求出。<br>b. 求导计算得到p=1/N时得到最大值。<br>c. N趋于无穷时，效率为$\frac{k}{k+e-1}$<br>d. 帧长度变大时，发送一个帧需要的时隙增加，有其他节点等待发送数据的可能性越大，空闲时隙的数量就越少。</li>
<li>略，易得。</li>
<li>略</li>
<li>1100Mbps。转发设备是交换机，因此无碰撞。</li>
<li>使用集线器代替则下面的3个100Mbps光纤只能以100Mbps的总带宽服务下面的主机，故一共500Mbps。</li>
<li>100Mbps。</li>
<li>第一步完成后，交换机学习到B的MAC地址以及接口。然后将这个帧发送到其他所有接口，因为此时交换机还不知道E在哪。第二步完成后，交换机学习到E的MAC地址以及接口。然后将这个帧发送给B。第三步完成后，交换机学习到A的MAC地址以及接口，然后将这个帧发送给B。第四步完成后，交换机没有学习。</li>
<li>略</li>
<li>EE发送的帧到达交换机时，交换机将帧转发到路由器，然后路由器修改目的MAC地址将其发送到交换机，然后交换机将该帧通过CS的VLAN发送出去。</li>
<li>略</li>
<li>略</li>
<li>以太网、DHCP、ARP、DNS、TCP、HTTP。</li>
<li>略</li>
<li>略</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%AC%AC6%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%AC%AC6%E7%AB%A0/" class="post-title-link" itemprop="url">计算机网络——第6章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-02 23:52:16 / Modified: 23:52:35" itemprop="dateCreated datePublished" datetime="2023-03-02T23:52:16+08:00">2023-03-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>9.8k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>9 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>链路层服务的原则：</p>
<ul>
<li>错误检测，校正</li>
<li>共享广播信道：多址访问</li>
<li>链路层寻址</li>
<li>局域网：以太网，VLAN</li>
</ul>
<p>实例化，各种链路层技术的实现</p>
<h2 id="6-1-链路层概述"><a href="#6-1-链路层概述" class="headerlink" title="6.1 链路层概述"></a>6.1 链路层概述</h2><ul>
<li>节点：主机和路由器</li>
<li>链路：沿着通信路径连接相邻节点的通信信道，分为有线和无线链路</li>
<li>帧：数据链路层的分组单元</li>
</ul>
<p>数据链路层的主要功能：负责将数据包通过链路从一个结点传输到物理上相邻的节点</p>
<p>数据链路层的简单模型：一个主机向另一个主机发送数据，期间经过多个路由器，通过了多个网络，数据在这些网络中流动。</p>
<p>说明：</p>
<ul>
<li>数据报咋不同链路上可能由不同的链路层协议进行处理<ul>
<li>如第一段链路由PPP处理，最后一段链路由以太网处理等</li>
</ul>
</li>
<li>不同的链路层协议可能提供不同的服务，如可靠传递等</li>
</ul>
<h3 id="6-1-1-链路层提供的服务类型"><a href="#6-1-1-链路层提供的服务类型" class="headerlink" title="6.1.1 链路层提供的服务类型"></a>6.1.1 链路层提供的服务类型</h3><ul>
<li>成帧、链路访问<ul>
<li>将数据加上头部和尾部，以此封装为数据帧</li>
<li>共享介质的信道访问</li>
<li>帧头部用MAC地址标识源和目的，不同于IP地址</li>
</ul>
</li>
<li>可靠传递<ul>
<li>很少用于误码率低的链路（光纤、双绞线链路）</li>
<li>用于误码率高的链路（无线链路）</li>
</ul>
</li>
<li>流量控制<ul>
<li>在相邻的收发节点之间限制流量</li>
</ul>
</li>
<li>差错检测<ul>
<li>信号衰减和电磁干扰噪声容易导致出错，接收方检测到错误存在时，会给发送方发送信号要求重传或者丢弃该数据帧</li>
</ul>
</li>
<li>差错纠正<ul>
<li>接收方检测和纠正帧中错误，不用重传</li>
</ul>
</li>
<li>半双工和全双工<ul>
<li>半双工时链路两段的节点都能够传输分组但不能同时传输</li>
</ul>
</li>
</ul>
<h3 id="6-1-2-链路层在何处实现"><a href="#6-1-2-链路层在何处实现" class="headerlink" title="6.1.2 链路层在何处实现"></a>6.1.2 链路层在何处实现</h3><p>链路层的主体部分是在网络适配器中实现的，网络适配器有时也称为网络接口卡，位于网络适配器的核心是链路层控制器，其中实现了多个链路层服务。</p>
<p>适配器通信</p>
<ul>
<li>在每一台设备上都有一个适配器（主机、交换机、路由器等）</li>
<li>链路层在适配器或芯片上实现</li>
<li>直接与主机的系统总线相连，与其他连接主机的IO设备相同</li>
<li>是硬件、软件和固件的结合体</li>
<li>适配器是半自治单元<ul>
<li>网络接口卡或芯片是适配器</li>
<li>帧的发送和接收、检错、丢弃都是适配器自主进行的</li>
<li>向上提交数据时，需要节点干预</li>
<li>最终受控于节点</li>
</ul>
</li>
<li>发送方在一个帧内封装数据报，增加差错检测位，可靠交付，流量检测等；接收方查找错误，可靠交付，进行流量控制，取出数据报并交给网络层。</li>
</ul>
<h2 id="6-2-差错检测和纠正技术"><a href="#6-2-差错检测和纠正技术" class="headerlink" title="6.2 差错检测和纠正技术"></a>6.2 差错检测和纠正技术</h2><p>在发送节点，为了保护比特免受差错，使用<font color=red>差错检测和纠正比特EDC</font>来增强数据D。通常要保护的数据不仅从网络层传递下来需要通过链路传输的数据报，而且包括链路层首部中的链路级的寻址信息、序号和其他字段。链路级帧中的D和EDC都被发送到接收节点。<font color=red>差错检测不是100%可靠的，EDC越长可靠程度越高，检错和纠错的能力越强</font>。</p>
<h3 id="6-2-1-奇偶校验"><a href="#6-2-1-奇偶校验" class="headerlink" title="6.2.1 奇偶校验"></a>6.2.1 奇偶校验</h3><p>最简单的差错检测方式就是单个比特的奇偶校验，但是检错能力太差了，因此可以使用二维奇偶校验方法，包含比特值改变的列和行的校验值都将会出现差错，因此接收方不仅可以检查到单个比特出错，还可以纠正。</p>
<p>接收方检测和纠正差错的能力被称为<font color=red>前向纠错</font>。</p>
<h3 id="6-2-2-检验和方法"><a href="#6-2-2-检验和方法" class="headerlink" title="6.2.2 检验和方法"></a>6.2.2 检验和方法</h3><p>因特网检查和</p>
<ul>
<li>目标：检测发送包中的错误，仅用于运输层</li>
<li>发送方：<ul>
<li>将数据段的内容作为16比特的整数序列</li>
<li>校验和：累加求和，计算和的反码</li>
<li>发送方将得到的校验和值放入到PDU校验和字段</li>
</ul>
</li>
<li>接收方<ul>
<li>计算收到的数据段的校验和</li>
<li>检查计算出的校验和与校验和字段中的值是否相同<ul>
<li>如果不同则检测到错误</li>
<li>如果相同则<font color=red>认为</font>没有监测错误（不代表就一定没有错误）</li>
</ul>
</li>
</ul>
</li>
<li>仅用于TCP、UDP和IPv4协议之中</li>
</ul>
<h3 id="6-2-3-循环冗余纠错CRC"><a href="#6-2-3-循环冗余纠错CRC" class="headerlink" title="6.2.3 循环冗余纠错CRC"></a>6.2.3 循环冗余纠错CRC</h3><p>对于d个比特的数据D，选择r+1比特模式（生成多项式）表示为G，目标是选择r个CRC比特R使得：</p>
<pre><code>- &lt;D,R&gt;刚好能够被G整除（模2计算）
- 接收方已知G，用G去除&lt;D,R&gt;，如果余数不为0则检测到错误
- 能检测到所有小于r+1个比特的错误
</code></pre><h2 id="6-3-多路访问（即多址访问）链路与协议"><a href="#6-3-多路访问（即多址访问）链路与协议" class="headerlink" title="6.3 多路访问（即多址访问）链路与协议"></a>6.3 多路访问（即多址访问）链路与协议</h2><p>链路分为两种：</p>
<ul>
<li>点到点链路，由链路一端的单个发送方和链路另一端的单个接收方组成。如PPP、以太网交换机和主机之间点到点的链路</li>
<li>广播链路，能够让多个发送和接收节点连接到相同的、单一的、共享的广播信道上。如传统以太网、802.11无线LAN。<ul>
<li>特点：<ul>
<li>单个共享广播信道</li>
<li>当两个或多个节点同时传输时，会产生相互干扰。</li>
<li>碰撞：一个节点同时收到两个或多个信号</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>多址访问协议：</p>
<ul>
<li>分布式算法决定节点如何共享信道，如结点何时可以传输数据</li>
<li>特别注意：有关共享信道的通信需要使用信道本身，没有额外的信道用于协调</li>
<li>理想的多址访问协议需要满足：<ul>
<li>假定：信道为速率为Rb/s的广播信道</li>
<li>当只有一个节点有数据发送时，该结点的吞吐量为R</li>
<li>当M个节点有数据发送时，每一个结点的吞吐量为R/M</li>
<li>分散，没有特定节点用于调整传输，没有时钟同步</li>
<li>简单，容易实现</li>
</ul>
</li>
<li>多路访问协议的分类：<ul>
<li>信道划分协议<ul>
<li>将信道划分为多个小片（使用时隙、频率、编码等划分）</li>
<li>将不同的片分配给不同的节点使用</li>
</ul>
</li>
<li>随机访问协议<ul>
<li>信道没有被分割，允许碰撞</li>
<li>需要有碰撞恢复的技术</li>
</ul>
</li>
<li>轮流协议<ul>
<li>节点轮流传送，但是数据量大的节点轮流更长时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-3-1-信道划分协议"><a href="#6-3-1-信道划分协议" class="headerlink" title="6.3.1 信道划分协议"></a>6.3.1 信道划分协议</h3><p>信道划分分为时分复用、统计时分复用、频分复用和随机访问这几种。</p>
<p>信道划分协议TDMA</p>
<ul>
<li>时分复用TDM<ul>
<li>循环访问信道，每一个结点在每一次循环中得到固定长度的时隙（时隙长度=传输单个分组的时间）</li>
<li>没有数据发送的时隙空闲</li>
</ul>
</li>
<li>统计时分复用STDM<ul>
<li>使用STDM帧作为基本单位，一个STDM帧可以容纳多个分组，时隙数量小于用户数量。</li>
<li>每当用户需要发送分组时将其发送到集中器中的集中缓存</li>
<li>集中器按照一定的顺序依次扫描用户是否输入，将缓存中的输入数据放到STDM帧中，没有数据的缓存跳过，当一个帧的数据放满时发送。</li>
<li>是时分复用的改进</li>
</ul>
</li>
<li>信道划分协议FDMA<ul>
<li>信道按照频谱分为若干个频段</li>
<li>每一个节点分配固定的频段</li>
<li>在频段不用时该部分信道就被闲置浪费了</li>
</ul>
</li>
</ul>
<h3 id="6-3-2-随机访问协议"><a href="#6-3-2-随机访问协议" class="headerlink" title="6.3.2 随机访问协议"></a>6.3.2 随机访问协议</h3><ul>
<li>当节点有数据发送时<ul>
<li>以信道全部速率R传输</li>
<li>没有主节点起到协调作用</li>
</ul>
</li>
<li>两个或多个节点传送时会发送碰撞</li>
<li>需要有检测碰撞和恢复碰撞的技术，如延时之后重传</li>
<li>ALOHA，时隙ALOHA等</li>
</ul>
<h4 id="ALOHA"><a href="#ALOHA" class="headerlink" title="ALOHA"></a>ALOHA</h4><p>Additive Link On-Line HAwaii system，是计算机网络早期发展中一个著名的网络，至今还在运行。</p>
<p>特征：</p>
<ul>
<li>网络拓扑采用星形结构</li>
<li>为了节省费用和易于组网，网络中各个站点的通信采用无线传输介质</li>
<li>由于采用无线电信道。考虑到无法申请更多的频率点，因此所有站点都使用同一的频率通过主机交换信息</li>
</ul>
<p>工作原理：</p>
<ul>
<li>当一帧首次到达（即一个网络层数据报在发送节点从网络层传递下来），节点立刻将该帧完整地传输到广播信道中，取帧传输时间为时间单元。</li>
<li>在任何给定时间，某个结点传输一个帧的概率为p。在其传输过程中其他节点不能传输，根据计算，一次传输成功的概率为p(1-p)^2(N-1)^。ALOHA协议的最大效率为1/2e。</li>
<li>如果发生了碰撞，节点等待随机的一段时间之后重新发送分组。</li>
<li><font color=red>ALOHA系统中一个节点并不会关心其他结点是否正在发送帧，这也就是为什么纯ALOHA一次传输成功的概率为p(1-p)^2(N-1)^，对于一个在t时刻开始传输的帧（所有帧传输时间为1）而言，需要从t-1到t+1的这段时间内都没有其他的帧开始传输，可见如果传播速率足够快，在该帧还没有发送完的时候，已经有节点能够接收该帧了，但它不会因此而阻止自己不发送自己需要发送的帧。</font>

</li>
</ul>
<h4 id="时隙ALOHA"><a href="#时隙ALOHA" class="headerlink" title="时隙ALOHA"></a>时隙ALOHA</h4><p> 将整个链路以时隙分割，每一个主机如果要发送分组，则必须在每一个时隙之内将分组发送完成。如果有冲突则随机等待几个时隙之后重发。</p>
<h4 id="载波侦听多路访问CSMA"><a href="#载波侦听多路访问CSMA" class="headerlink" title="载波侦听多路访问CSMA"></a>载波侦听多路访问CSMA</h4><p>在时隙和纯ALOHA中，一个节点传输的决定独立于连接到这个广播信道上的其他节点的活动。特别是一个结点不关心在它开始传输时是否有其他节点正在传输。</p>
<p>载波侦听：在传输前首先对链路进行监听，如果信道空闲，则传输整个帧，否则等待。<font color=red>但是碰撞还是可能发生。如果一个信道的延迟时间比较长，当其他主机开始发送分组时，这个分组可能不会很快地传到当前主机，使得当前主机误以为信道中没有分组正在传输，因此可能存在其传输还未完成时发现有碰撞的情况。</font></p>
<p>CSMA分类：</p>
<ul>
<li>非坚持CSMA，一旦监听到信道忙，就不再继续监听，而是根据协议的算法延迟一个随机的时间之后重新监听。如果进行载波监听时发现信道空闲，则将准备好的帧发送出去。</li>
<li>时隙非坚持CSMA，采用划分时隙的随机接入CSMA协议，协议规定只能在每一个时隙开始时才能发送帧。</li>
<li>1坚持CSMA，一个站点要传送数据之前首先监听信道，如果忙则持续等待到监听到信道空闲时发送数据，如果发生冲突则站点等待一个随机长的时间然后重新开始。</li>
<li>P坚持CSMA，一个站点要传送数据之前首先监听信道，如果忙则持续等待到监听到信道空闲时，以概率P发送数据，而以（1-P）延迟一段时间τ（网络中最远的端到端传播时延），重新监听信道。如果发生冲突，站点等待一个随机长的时间，然后重新开始。</li>
</ul>
<p>CSMA比较：</p>
<ul>
<li>非坚持：不能充分利用信道刚刚转入空闲期的这段时间</li>
<li>1坚持：容易在上述这段时间之内产生冲突，实际网络常用</li>
<li>P坚持：很难选择一个用于各种通信量度的P值</li>
</ul>
<h4 id="具有碰撞检测的载波监听多路访问（CSMA-CD）"><a href="#具有碰撞检测的载波监听多路访问（CSMA-CD）" class="headerlink" title="具有碰撞检测的载波监听多路访问（CSMA/CD）"></a>具有碰撞检测的载波监听多路访问（CSMA/CD）</h4><ul>
<li>在短时间内碰撞能够被检测<ul>
<li>在有线LANs中比较容易：测量信号强度，比较收发的信号</li>
<li>在无线LANs中比较困难：传输时接收器关闭，接收的信号远小于发送的信号强度</li>
</ul>
</li>
<li>碰撞之后停止传输，减少信道浪费</li>
<li>强化碰撞<ul>
<li>当发送数据的站一旦发现产生碰撞，除了立即停止发送数据之外，还要继续发送若干比特的人为干扰信号，以便让所有的用户都知道现在已经发生了碰撞</li>
</ul>
</li>
</ul>
<p>争用期：</p>
<ul>
<li>最先发送数据帧的站，在发送数据帧之后至多经过2τ（最长的端到端时延）时间就可以知道发送的数据帧是否遭受碰撞</li>
<li>以太网的端到端往返时延2τ称为争用期，或碰撞窗口</li>
<li>经过争用期这段时间还没有检测到碰撞，就可以确认这次发送没有碰撞</li>
</ul>
<p>以太网CSMA/CD算法：</p>
<ul>
<li>网卡从网络层接收数据报，并创建数据帧</li>
<li>如果网卡检测信道空闲，则开始进行帧传输</li>
<li>如果网卡检测信道忙，则等待直到信道关闭，然后发送</li>
<li>如果网卡发送整个帧没有探测到另一个传输，则网卡完成帧发送</li>
<li>如果网卡检测到另一个传输，则传输终止并发送干扰信号</li>
<li>传输终止之后，使用二进制退避（网卡随机从0/1/2/3/…/2^m^-1之中选择K，网卡等待K*512bit时间，返回第2步）越多的碰撞决定越大的退避间隔</li>
</ul>
<h3 id="6-3-3-轮流协议"><a href="#6-3-3-轮流协议" class="headerlink" title="6.3.3 轮流协议"></a>6.3.3 轮流协议</h3><p>为了满足：当有M个节点活跃时，每一个活跃节点的吞吐量接近R/M bps，开发了此协议。</p>
<ul>
<li>信道划分协议的特点：<ul>
<li>在负荷重时，共享信道有效公平</li>
<li>在负荷轻时效率低，信道访问延时，即使只有一个活动结点也只能分配到1/N的带宽</li>
</ul>
</li>
<li>随机访问协议的特点：<ul>
<li>在负荷轻时效率高，只有一个节点也能够充分利用信道</li>
<li>在负荷重时将会产生巨大的碰撞开销</li>
</ul>
</li>
</ul>
<h4 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a>轮询协议</h4><ul>
<li>要求这些节点之一要被指定为主节点。</li>
<li>主节点以循环的方式轮询每一个节点。主节点首先向节点1发送一个报文说明其能够传输的帧的最多数量，然后在节点1传输了某些帧之后，主节点再发送报文向节点2说明，以此类推。</li>
<li>这个协议引入了轮询时延的开销，且如果主节点故障，整个网络都将崩溃。</li>
</ul>
<h4 id="令牌传递协议"><a href="#令牌传递协议" class="headerlink" title="令牌传递协议"></a>令牌传递协议</h4><ul>
<li>没有主节点，一个称为令牌的小的特殊帧在节点之间以某种固定的次序进行交换。</li>
<li>当一个节点收到令牌时，仅当它有一些帧要发送时，它才持有这个令牌，否则立即向下一个节点转发该令牌。当一个节点收到令牌时，如果它确实有帧要传输，它发送最大数目的帧数，然后把令牌转发给下一个节点。</li>
<li>令牌传递分散，并高效，但一个节点的故障可能会使整个信道崩溃。如果一个节点偶然忘记了释放令牌，则必须调用某些恢复步骤使得令牌返回到循环。</li>
</ul>
<h4 id="总结：对共享介质的处理"><a href="#总结：对共享介质的处理" class="headerlink" title="总结：对共享介质的处理"></a>总结：对共享介质的处理</h4><ul>
<li>信道划分，可基于时间、频率、编码，分为时分和频分</li>
<li>随机划分（动态）<ul>
<li>ALOHA，S-ALOHA，CSMA，CSMA/CD</li>
<li>载波侦听：有线较容易，无线较困难</li>
<li>CSMA/CD 用于以太网</li>
<li>CSMA/CA 用于802.11</li>
</ul>
</li>
<li>轮流<ul>
<li>主节点轮询，令牌传递</li>
</ul>
</li>
</ul>
<h2 id="6-4-交换局域网"><a href="#6-4-交换局域网" class="headerlink" title="6.4 交换局域网"></a>6.4 交换局域网</h2><h3 id="6-4-1-链路层寻址与ARP"><a href="#6-4-1-链路层寻址与ARP" class="headerlink" title="6.4.1 链路层寻址与ARP"></a>6.4.1 链路层寻址与ARP</h3><h4 id="MAC地址（LAN地址，物理地址）"><a href="#MAC地址（LAN地址，物理地址）" class="headerlink" title="MAC地址（LAN地址，物理地址）"></a>MAC地址（LAN地址，物理地址）</h4><p>作用：在数据链路层表示每一块网络适配器，使得能够在广播信道上寻找目标节点<br>组成：</p>
<ul>
<li>48 bit</li>
<li>前24bit由IEEE分配管理——OUI号</li>
<li>后24bit由厂商自行分配</li>
<li>IEEE管理MAC地址空间</li>
</ul>
<font color=red>MAC地址是烧在网络适配器的ROM中，不可修改（软件模拟的可以修改）</font>

<p>与IP地址比较：</p>
<ul>
<li>MAC地址是平面地址，类似于身份证号</li>
<li>IP地址是层次地址，类似于邮政通信地址</li>
<li>MAC地址在不同的网络之间迁移时，不会改变</li>
<li>IP地址在不同的网络之间迁移时，需要改变以适应新的网络配置</li>
<li>无线网络中进行漫游时，如果在不同的网络之间切换时，改变网络设置会导致连接中断。</li>
</ul>
<p>MAC地址的重要性：</p>
<ul>
<li>局域网设备不能识别IP地址，因为其工作在链路层，因此只能够通过MAC地址寻找主机。</li>
<li>进程产生的套接字是端口号+IP地址，在局域网中是通过IP地址获得MAC地址。</li>
<li>通过ARP（地址解析协议）可以在已知IP地址的情况下，获得MAC地址。</li>
</ul>
<h4 id="地址解析协议（ARP）"><a href="#地址解析协议（ARP）" class="headerlink" title="地址解析协议（ARP）"></a>地址解析协议（ARP）</h4><p>目标：根据目标的IP地址获取其MAC地址<br>ARP高速缓存（ARP表）</p>
<ul>
<li>每一个IP节点（主机、路由器）都有ARP表</li>
<li>局域网节点的IP/MAC地址映射：<IP; MAC; TTL></li>
<li>TTL：时限，Time to Live，超过TTL的地址映射会被删除（一般20分钟）</li>
</ul>
<p>ARP协议工作流程：</p>
<ul>
<li>建立ARP请求包</li>
<li>广播发送该ARP请求包，其中包含目标的IP地址。广播的MAC地址为全1，即FF:FF:FF:FF:FF:FF</li>
<li>目的主机接收到该ARP请求包，建立包含自己的MAC地址的ARP应答包（请求包和应答包的源、目标是不一致的）并发送</li>
<li>发出请求的主机接收到该数据包之后，更新ARP高速缓存</li>
</ul>
<p>当一台主机需要发送数据到另一个子网的主机时，首先需要通过ARP报文获取目标主机的MAC地址，然后在发送IP报文时，<font color=red>MAC地址不应该填目标主机的MAC，而应该是路由器的MAC，这样路由器才能将这个报文转发到另外一个子网。</font></p>
<h3 id="6-4-2-以太网"><a href="#6-4-2-以太网" class="headerlink" title="6.4.2 以太网"></a>6.4.2 以太网</h3><p>类型：</p>
<ul>
<li>总线式以太网：所有的主机都与一条总线连接，接收到不是发送到本机的报文则不予理会。</li>
<li>交换式以太网：主机与主机通过交换机连接为网状结构。</li>
</ul>
<h4 id="以太网帧结构"><a href="#以太网帧结构" class="headerlink" title="以太网帧结构"></a>以太网帧结构</h4><ul>
<li>数据字段：46~1500字节</li>
<li>前同步码：8字节，前面7个字节的格式为10101010，最后一个字节为10101011，用于同步发送方与接收方的时钟</li>
<li>地址：6字节，若适配器收到以太网帧，目的地址为自己的MAC地址或广播地址，就将帧中的数据传给网络层，否则适配器丢弃该帧</li>
<li>类型：上层协议类型（大多为IP协议，也支持其他协议）</li>
<li>CRC：由接收方检查，如果检测到错误就将该帧丢弃</li>
</ul>
<p>以太网提供的服务：</p>
<ul>
<li>无连接服务：在发送适配器和接收适配器之间不需要另外的连接操作</li>
<li>不可靠服务：接收适配器不发送确认帧或否认帧给发送方</li>
<li>交给网络层的数据包可能存在间隙，如果应用使用TCP，间隙会被填充，否则应用会看见间隙</li>
</ul>
<p>以太网使用的CSMA/CD</p>
<ul>
<li>没有时隙</li>
<li>当适配器侦听到其他的适配器在传输时，它不传输帧，即载波侦听</li>
<li>正在传输的适配器如果检测到其他适配器也在传输，则其终止自己的传输，即碰撞检测</li>
<li>在重新传输之前，适配器等待一段随机时间，即随机访问</li>
</ul>
<p>算法流程：</p>
<ul>
<li>适配器收到来自网络层的数据包，创建帧</li>
<li>若适配器检测到信道空闲，则开始传输帧；若检测到信道忙，就开始等待，直到信道空闲时才开始传输该帧</li>
<li>若适配器传输了整个帧而没有检测到其他适配器的传输，则该适配器完成该帧的传输</li>
<li>若适配器在传输时检测到其他适配器也在传输，则停止传输并发出拥塞信号</li>
<li>终止传输之后适配器进入指数回退阶段，在经历第m次碰撞之后，适配器随机从{0, 1, 2, …, 2^m-1^}中选择k值。适配器等待k*512比特时间之后返回第2步</li>
</ul>
<p>拥塞信号：用于确保所有传输者都能检测到碰撞而传输的信号，共48比特<br>比特时间：传输1个比特所用的时间</p>
<p>指数回退算法</p>
<ul>
<li>目的：适配器重传时试图估计正确的负载。</li>
<li>重载：随机等待的时间可能会更长。</li>
<li>第一次碰撞：从{0, 1}中选择K；延迟是K*512比特传输时间</li>
<li>第二次碰撞：从{0, 1, 2}中选择K</li>
<li>…</li>
</ul>
<p>重要特性：</p>
<ul>
<li>使用CSMA/CD协议的以太网不能进行全双工通信，而只能使用双向交替通信（半双工通信）</li>
<li>每一个站在发送数据之后的一小段时间之内存在遭遇碰撞的可能性</li>
<li>这种发送的不确定性使得整个以太网的平均通信量远小于以太网的最高数据率</li>
</ul>
<p>争用期长度：</p>
<ul>
<li>10Mb/s的以太网取51.2μs为争用期的长度，100Mb/s为其1/10</li>
<li>对于10Mb/s的以太网，在争用期之内可以发送512比特（64字节）</li>
<li>以太网在发送数据时，如果前64字节没有发生碰撞，则后续的数据旧不会发生碰撞</li>
</ul>
<p>最短有效帧长</p>
<ul>
<li>如果发生碰撞，就一定会发生在发送的前64字节内</li>
<li>由于一检测到碰撞就立刻中止发送，则此时已经发送出去的数据量一定小于64字节</li>
<li>以太网规定<font color=red>最短的有效帧长为64字节</font>，凡是长度小于64字节的帧都是由于冲突而异常中止的无效帧</li>
</ul>
<h4 id="物理层简介"><a href="#物理层简介" class="headerlink" title="物理层简介"></a>物理层简介</h4><p>信号编码：</p>
<ul>
<li>曼彻斯特编码：设置0为上升沿，1为下降沿</li>
<li>差分曼彻斯特编码：0翻转，1不翻转</li>
</ul>
<p>集线器互联</p>
<ul>
<li>主干集线器互联LAN网段</li>
<li>扩展了节点之间的最大距离</li>
<li>原先独立的网段碰撞域变成了一个大的碰撞域</li>
<li>不能将10BaseT和100BaseT的以太网互联<ul>
<li>10和100代表速率，T代表使用双绞线</li>
<li>节点连接到集线器，是一个星形的拓扑形状。在节点和集线器之间的最大距离为100m</li>
<li>10Base5代表粗同轴电缆，可靠性好，抗干扰能力强。<ul>
<li>收发器：用于发送、接收数据，冲突检测，电气隔离等。</li>
<li>AUI：连接件单元接口</li>
<li>这种电缆一般使用总线型拓扑，用于网络骨干连接</li>
</ul>
</li>
<li>10Base2代表细同轴电缆，可靠性稍差<ul>
<li>使用BNC T型接头连接，使用总线型拓扑，可用于办公室LAN</li>
</ul>
</li>
</ul>
</li>
<li>集线器<ul>
<li>集线器本质上是物理层的中继器</li>
<li>从一个接口收到的比特流会传给其他所有接口</li>
<li>同样速率</li>
<li>没有帧缓存</li>
<li>集线器没有CSMA/CD，由适配器检测碰撞</li>
<li>提供网络管理功能（可网管、智能、网络分段）</li>
</ul>
</li>
<li>千兆以太网<ul>
<li>使用标准以太网帧格式</li>
<li>允许点对点链路和共享的广播信道</li>
<li>共享信道时使用CSMA/CD，为了得到可接受的效率，节点之间的距离需要短一些</li>
<li>对于点到点链路可以以1Gbps的速率全双工工作</li>
</ul>
</li>
</ul>
<h3 id="6-4-3-链路层交换机"><a href="#6-4-3-链路层交换机" class="headerlink" title="6.4.3 链路层交换机"></a>6.4.3 链路层交换机</h3><ul>
<li>链路层设备<ul>
<li>存储、转发以太网帧</li>
<li>查看输入帧的MAC地址，选择性地将帧输出到一个或多个输出链路，使用CSMA/CD</li>
<li>对外透明，主机不知道交换机的存在</li>
<li>即插即用，自学习，交换机无需配置</li>
</ul>
</li>
<li>交换机：多路同时传输<ul>
<li>主机直接连接到交换机</li>
<li>交换机缓存到数据包</li>
<li>每一条链路都采用了以太网协议，但之间没有冲突，全双工通信<ul>
<li>每一条链路是其自身的冲突碰撞域</li>
<li><font color=red>这里的全双工通信指的是当两个主机之间存在至少一台交换机时，可以进行全双工通信，其中的每一条物理链路都是半双工的，但由于交换机可以进行存储转发工作，所以两边的两个分组在某一个交换机会相遇，然后各自继续在链路中传输。</font></li>
</ul>
</li>
<li>交换机中存在一个交换表<ul>
<li>表结构：主机MAC地址，连接主机的接口，时间戳（产生表项的时间）</li>
<li>与路由表类似</li>
</ul>
</li>
<li>交换机通过学习可知通过哪一个接口可以到达哪一个主机<ul>
<li>当数据帧进入交换机时，交换机学习发送方连接的接口，并将发送方/接口对记录到交换表</li>
</ul>
</li>
<li>交换机：帧过滤/转发<ul>
<li>使用发送方输入接口与MAC地址</li>
<li>使用目标MAC地址检索交换表</li>
<li>如果检索到目标地址对应的接口，当目标地址接口不是来源接口时，从该接口转发数据帧，否则丢弃该数据帧。如果没有检索到接口则向所有非来源接口转发数据帧广播</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>网桥互联</p>
<ul>
<li>网桥实质上就是一种存储-转发设备，用于实现MAC层的LAN互连</li>
<li>工作原理：<ul>
<li>不断监听各端口是否有信号</li>
<li>收到无差错的帧则缓存，反之将差错帧丢弃</li>
<li>若所收帧的目的MAC地址属于另一网段，则通过站表决定向何端口转发</li>
<li>网桥不转发同一“网段”内通信的帧<ul>
<li>目的主机和源主机不连接在网桥的同一个接口上才会转发</li>
</ul>
</li>
<li>网桥不会修改所转发的帧的源地址</li>
</ul>
</li>
<li>网桥的优势<ul>
<li>过滤通信量</li>
<li>扩大了局域网的物理范围</li>
<li>提高可靠性</li>
<li>可互联不同物理层、不同MAC子层和不同速率的局域网</li>
</ul>
</li>
<li>网桥的缺点<ul>
<li>接收和转发产生时延</li>
<li>MAC子层没有流量控制功能，网络负荷重时，网桥缓存空间可能发生溢出，产生帧丢失现象</li>
<li>不同MAC子层的网段桥接时，在转发帧之前要修改帧的某些字段，这也需要时间</li>
<li>广播风暴。网桥只适合用户少于几百个和通信量不太大的局域网，当广播信息过多时会产生拥塞</li>
</ul>
</li>
<li>网桥和集线器的区别<ul>
<li>集线器只是将网络覆盖距离简单地延长，且距离有限，实现在物理层。网桥不仅具有将LAN的覆盖距离延长的作用，而且理论上可以做到无限延长，具体实现在MAC层</li>
<li>集线器仅具有简单的信号整形和放大功能，网桥属于一种智能互联设备，主要提供信号的存储、转发、数据过滤、路由选择等能力</li>
<li>集线器仅是一种硬件设备，网桥还有软件</li>
<li>集线器只能互联同类的LAN，而网桥可以互联不同类型的LAN</li>
</ul>
</li>
<li>透明网桥：网桥对于局域网其他的站点时不可见的</li>
<li>网桥的问题：当一个局域网中有不止一个网桥时，一个帧可能从一个网桥传到另一个网桥，然后另一个网桥又传回来，导致兜圈子现象<ul>
<li>解决方法：支撑树算法<ul>
<li>互联在一起的网桥彼此通信后，能够找出原来的网络拓扑的一个子集，在这个子集里面整个连通的网络中不存在回路。一旦支撑树确定，网桥会断开某些端口，以确保原来的拓扑是一个支撑树。</li>
<li>支撑树算法选择一个网桥为树的根，然后以最短路径为依据，找到树上的每一个结点</li>
<li>为了让支撑树能够反映网络拓扑的变化，每隔几秒钟每个网桥要广播其标识号，和它知道的所有其他网桥</li>
<li>缺点：互联的局域网数量很大时，支撑树算法开销会显著增加</li>
</ul>
</li>
</ul>
</li>
<li>多端口网桥<ul>
<li>链路层可以实现直通交换：帧从入端口转发到出端口不需要收集整个帧，实际上只需要找到帧开头的目的地址即可，这样能够少量减少延迟。</li>
</ul>
</li>
<li>以太网交换机与路由器的比较<ul>
<li>两者都是存储转发设备，但路由器是网络层设备，交换机是链路层设备</li>
<li>路由器维护的是路由表，实现路由算法，而交换机维护交换表，实现MAC地址过滤和自学习</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/0974156f60dc4b888f0145997aa9e220.png" alt=""></p>
<h3 id="6-4-4-虚拟局域网VLAN"><a href="#6-4-4-虚拟局域网VLAN" class="headerlink" title="6.4.4 虚拟局域网VLAN"></a>6.4.4 虚拟局域网VLAN</h3><p>在一个局域网内，所有的第二层广播流量都将穿过整个局域网，这对于安全性不利，并且传播的数据报数量较大，也会影响效率。</p>
<p>虚拟局域网VLAN：是基于接口的VLAN，交换机对接口进行分组使得单一的交换机设备可以为多个虚拟的局域网工作，像是多台交换机实现的功能。</p>
<p>功能：</p>
<ul>
<li>流量隔离，一个VLAN内的帧不能传递到其他的VLAN中</li>
<li>动态分组，交换机的接口可以动态组合，因此VLAN也是可以动态分配的</li>
<li>数据转发，通过VLAN间路由转发</li>
</ul>
<p>trunk接口：多个物理交换机上多个VLAN中的帧发送。VLAN中跨交换机进行转发的帧不能够简单地使用802.1帧格式，而是必须携带VLAN ID信息。802.1q协议（VLAN标记协议）可在trunk接口处增加/删除附加的帧的首部字段</p>
<h2 id="6-7-回顾Web页面请求的历程"><a href="#6-7-回顾Web页面请求的历程" class="headerlink" title="6.7 回顾Web页面请求的历程"></a>6.7 回顾Web页面请求的历程</h2><ul>
<li>沿着协议向下依次为应用层、传输层、网络层、链路层</li>
<li>目标：通过请求www页面场景，识别、回顾、理解协议</li>
<li>场景：学生在校园网中用笔记本电脑访问www.google.com并接收信息</li>
</ul>
<h3 id="Step-1-计算机连接到Internet"><a href="#Step-1-计算机连接到Internet" class="headerlink" title="Step 1: 计算机连接到Internet"></a>Step 1: 计算机连接到Internet</h3><p>正在连接的笔记本需要获得校园网局域网的IP地址、网关、DNS服务器等信息。</p>
<ul>
<li>DHCP请求依次进行UDP封装、IP封装、802.3以太网帧封装</li>
<li>以太网向局域网发送广播，由运行DHCP server的网关路由器收到</li>
<li>以太帧解封装，IP解封装，UDP解封装，得到DHCP请求</li>
<li>DHCP server生成DHCP ACK报文，包含客户端IP、掩码、网关、DNS服务器</li>
<li>DHCP server进行封装，将数据帧通过局域网转发（交换机自学习），在客户端进行解封装</li>
<li>DHCP client收到DHCP ACK应答，现在学生笔记本拥有了自己的IP地址以及DNS服务器、网关</li>
</ul>
<h3 id="Step-2-ARP协议获取网关路由器MAC"><a href="#Step-2-ARP协议获取网关路由器MAC" class="headerlink" title="Step 2: ARP协议获取网关路由器MAC"></a>Step 2: ARP协议获取网关路由器MAC</h3><ul>
<li>广播发送ARP请求，路由器收到之后发送ARP应答，给出路由器接口的MAC地址</li>
<li>客户端知道了网关路由器的MAC地址之后就可以发送包含DNS请求的数据帧了</li>
</ul>
<h3 id="Step-3-DNS查询"><a href="#Step-3-DNS查询" class="headerlink" title="Step 3: DNS查询"></a>Step 3: DNS查询</h3><ul>
<li>将包含DNS查询的IP数据报通过局域网交换机转发到网关路由器</li>
<li>校园网的IP数据包路由转发到comcast网络（路由表由RIP、OSPF、IS-IS和/或BGP协议产生的DNS服务器）</li>
<li>多路分解到DNS server</li>
<li>DNS server向客户端发送包含www.google.com的IP的DNS应答</li>
</ul>
<h3 id="Step-4-TCP连接"><a href="#Step-4-TCP连接" class="headerlink" title="Step 4: TCP连接"></a>Step 4: TCP连接</h3><ul>
<li>客户端首先创建到web服务器的TCP套接字</li>
<li>TCP SYN报文的域间路由到web server</li>
<li>web server回应TCP SYNACK</li>
<li>建立TCP连接</li>
</ul>
<h3 id="Step-5-HTTP请求与响应"><a href="#Step-5-HTTP请求与响应" class="headerlink" title="Step 5: HTTP请求与响应"></a>Step 5: HTTP请求与响应</h3><ul>
<li>将HTTP请求发送到TCP socket</li>
<li>包含HTTP请求的IP数据报路由转发到 www.google.com</li>
<li>web server进行HTTP reply响应，包含web page</li>
<li>包含HTTP响应的IP数据报被路由转发回客户端</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%AC%AC5%E7%AB%A0%E4%B9%A0%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%AC%AC5%E7%AB%A0%E4%B9%A0%E9%A2%98/" class="post-title-link" itemprop="url">计算机网络——第5章习题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-02 23:49:04 / Modified: 23:52:10" itemprop="dateCreated datePublished" datetime="2023-03-02T23:49:04+08:00">2023-03-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="课后习题和问题"><a href="#课后习题和问题" class="headerlink" title="课后习题和问题"></a>课后习题和问题</h2><h3 id="5-2"><a href="#5-2" class="headerlink" title="5.2"></a>5.2</h3><ol>
<li>集中式路由选择算法用完整的、全局性的网络知识计算出从源到目的地之间的最低开销路径，该算法以所有结点之间的连通性以及所有链路的开销为输入。这要求该算法在真正开始计算之前要以某种方式获取这些信息。<font color=red>具有全局状态信息的算法常被称为链路状态算法（LS）</font>。分散式路由选择算法中路由器以迭代、分布式的方式计算出最低开销路径。没有节点拥有关于所有网络链路开销的完整信息。每个节点仅有与其直接相连链路的开销知识即可开始工作。<font color=red>距离向量算法（DV）属于分散式路由选择算法</font>。OSPF协议属于集中式路由选择算法，BGP协议属于分散式路由选择算法。</li>
<li>这两种算法一个是集中式的，另一种是分布式的。</li>
<li>无穷计数问题与DV算法中“坏消息传得慢”这一特性有关。当一条链路的代价增加时，该链路两端的某一个路由器检测到代价增加，开始重新计算其到其他路由器的代价最小路由，但这个计算过程需要使用该路由器之前计算得到的到其他路由器的代价最小路由，而随着这一条链路的代价增加，这些最小路由很可能不再是最小的路由，因此每一次更新只能够将最短路由增加1，从而导致无穷计数问题的产生。无穷计数问题会导致代价增加这个“坏消息”的处理时间大大增加，严重影响到整个网络的性能。</li>
<li>没有必要，不同的AS的内部路由器互相不关联，因此无论当前AS使用什么内部路由选择算法，其对外部的路由器都是透明不可见的。<h3 id="5-2-5-3"><a href="#5-2-5-3" class="headerlink" title="5.2~5.3"></a>5.2~5.3</h3></li>
<li>考虑到了以下3点因素：（P263）<br>策略。有些AS可能不希望其他AS的流量经过自身，也可能希望经过，但这种策略问题在AS内部选择路由算法中并不重要，强行设计则会增加系统的冗余度。<br>规模。在一个AS之内，通常网络的规模不会太大，如果一个AS内的网络规模超出了该AS内部路由选择算法的承载能力，完全可以将这个AS分割为多个AS，并通过AS间路由选择协议进行管理。这使得AS内部路由选择算法没有必要考虑当网络规模特别大时产生的诸多问题。<br>性能。在AS之间基本没有与路由相关的开销概念，而在AS内部，一切的路由选择都需要将性能放在至关重要的位置，因此AS间路由选择算法与AS内路由选择算法对于性能的要求不同。</li>
<li>错误，OSPF属于集中式路由选择算法，其自身发送的链路状态信息需要被这个网络中的所有路由器知悉，因此该信息将会在网络中不断传递，直到被所有路由器接收确认为止。</li>
<li>一个区域指的是AS中的一组路由器，一个区域内可以实现自己的OSPF算法，不同区域之间通过边界路由器实现互相通信。引入区域的概念主要是用于构建大型网络，简化路由器中的路由表，并提升路由选择算法的效率。</li>
<li>子网是一个更大的网络中的一部分，一定隶属于某个网络，<font color=red>其不包含路由器，其边界是由路由器和主机接口所定义的。</font>前缀表示的是一个子网或一个子网的集合，是CIDR化的网络部分。CIDR即无类别域间路由选择，是因特网的地址分配策略。BGP路由指的是前缀及其属性。属性包含有AS-PATH、NEXT-HOP等。当路由器通过BGP连接通告前缀时，在前缀中会包括一些BGP属性。</li>
<li>NEXT-HOP是AS-PATH起始的路由器接口的IP地址，是BGP要前往的下一个AS中的第一个路由器地址，作用是配置路由表的下一条为NEXT-HOP指向的地址。AS-PATH记录了到目的地的一系列地址前缀，作用有检测环路、多路选择。</li>
<li>如果一个一级ISP不得在另两个ISP（A和B）之间运输中转流量，而该ISP与另外两个ISP有对等传输协议，该ISP只需要不将通过A的路由通知给B，不将通过B的路由通知给A，那么该ISP在A和B看来就是透明的。</li>
<li>错误。有时为了特殊需求，BGP路由器可以选择不将自己的表示添加到已经接受的路径之中，此时该BGP将不会作为中转路由器工作。<h3 id="5-6"><a href="#5-6" class="headerlink" title="5.6"></a>5.6</h3></li>
<li>ICMP报文有：ping报文（回显报文）、traceroute（目标端口不可达报文、TTL过期报文）、用于拥塞控制的源抑制报文。</li>
<li>TTL过期报文和目标端口不可达报文。解释：Traceroute用ICMP报文实现，源主机的数据报中携带了一个具有不可达UDP端口号的UDP报文段，第1个数据报的TTL为1，第2个为2，等等。当TTL为0时，接收到该数据报的路由器应该向源主机发送一个ICMP警告报文给源主机。如果有数据报到达了目的主机，那么该目的主机将向源发送一个端口不可达的ICMP报文，以标志路由探测完毕。<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2></li>
<li>y→x→u，y→w→x→u，y→w→v→u，y→w→v→x→u，y→z→w→v→x→u，y→z→w→v→u，y→z→w→x→u等。</li>
<li>略</li>
<li>|节点|x|y|v|w|t|u|<br>|:-:|:-:|:-:|:-:|:-:|:-:|:-:|<br>|z|==8.z==|12.z||||<br>|zx|8.z|12.z|==11.x==|14.x|||<br>|zxv|8.z|==12.z==|11.x|14.x|15.v|14.v|<br>|zxvyw|8.z|12.z|11.x|==14.x==|15.v|14.v|<br>|zxvywu|8.z|12.z|11.x|14.x|15.v|==14.v==|<br>|zxvywut|8.z|12.z|11.x|14.x|==15.v==|14.v|</li>
<li>略</li>
<li>DV算法流程：</li>
</ol>
<p>z表<br>||x|y|z|u|v|<br>|:-:|:-:|:-:|:-:|:-:|:-:|<br>|x|∞|∞|∞|∞|∞|<br>|z|2|∞|0|∞|6|</p>
<h2 id="v-∞-∞-∞-∞-∞"><a href="#v-∞-∞-∞-∞-∞" class="headerlink" title="|v|∞|∞|∞|∞|∞|"></a>|v|∞|∞|∞|∞|∞|</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">x</th>
<th style="text-align:center">y</th>
<th style="text-align:center">z</th>
<th style="text-align:center">u</th>
<th style="text-align:center">v</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">x</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">∞</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">z</td>
<td style="text-align:center">2</td>
<td style="text-align:center">5</td>
<td style="text-align:center">0</td>
<td style="text-align:center">7</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">v</td>
<td style="text-align:center">3</td>
<td style="text-align:center">∞</td>
<td style="text-align:center">6</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</div>
<hr>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">x</th>
<th style="text-align:center">y</th>
<th style="text-align:center">z</th>
<th style="text-align:center">u</th>
<th style="text-align:center">v</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">x</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">z</td>
<td style="text-align:center">2</td>
<td style="text-align:center">5</td>
<td style="text-align:center">0</td>
<td style="text-align:center">7</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">v</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">6</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</div>
<hr>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">x</th>
<th style="text-align:center">y</th>
<th style="text-align:center">z</th>
<th style="text-align:center">u</th>
<th style="text-align:center">v</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">x</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">z</td>
<td style="text-align:center">2</td>
<td style="text-align:center">5</td>
<td style="text-align:center">0</td>
<td style="text-align:center">7</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">v</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">6</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>最大迭代次数为这个网络中最长无环路径的长度，迭代到这个值时网络中所有的路径都能够被遍历到。</li>
<li>a. D~x~(w)=2，D~x~(y)=4，D~x~(u)=7。<br>b. 若让x通知邻居有一条通往u的新的最低开销路径，则可以将c(x,w)的值增大，只要让c(x,w)+c(w,u)&gt;=c(x,y)+c(y,u)，即c(x,w)&gt;6即可。或者让c(x,y)的值变为1。<br>c. 只能让c(x,w)的值增加到7或以上才可以。</li>
<li></li>
</ol>
<p>初始向量表：<br>x：<br>||x|y|z|<br>|:-:|:-:|:-:|:-:|<br>|x|0|3|4|<br>|y|∞|∞|∞|</p>
<h2 id="z-∞-∞-∞"><a href="#z-∞-∞-∞" class="headerlink" title="|z|∞|∞|∞|"></a>|z|∞|∞|∞|</h2><p>y：<br>||x|y|z|<br>|:-:|:-:|:-:|:-:|<br>|x|∞|∞|∞|<br>|y|3|0|6|</p>
<h2 id="z-∞-∞-∞-1"><a href="#z-∞-∞-∞-1" class="headerlink" title="|z|∞|∞|∞|"></a>|z|∞|∞|∞|</h2><p>z：<br>||x|y|z|<br>|:-:|:-:|:-:|:-:|<br>|x|∞|∞|∞|<br>|y|∞|∞|∞|</p>
<h2 id="z-4-6-0"><a href="#z-4-6-0" class="headerlink" title="|z|4|6|0|"></a>|z|4|6|0|</h2><p>第一次迭代后：<br>x：<br>||x|y|z|<br>|:-:|:-:|:-:|:-:|<br>|x|0|3|4|<br>|y|3|0|6|</p>
<h2 id="z-4-6-0-1"><a href="#z-4-6-0-1" class="headerlink" title="|z|4|6|0|"></a>|z|4|6|0|</h2><p>y：<br>||x|y|z|<br>|:-:|:-:|:-:|:-:|<br>|x|0|3|4|<br>|y|3|0|6|</p>
<h2 id="z-4-6-0-2"><a href="#z-4-6-0-2" class="headerlink" title="|z|4|6|0|"></a>|z|4|6|0|</h2><p>z：<br>||x|y|z|<br>|:-:|:-:|:-:|:-:|<br>|x|0|3|4|<br>|y|3|0|6|</p>
<h2 id="z-4-6-0-3"><a href="#z-4-6-0-3" class="headerlink" title="|z|4|6|0|"></a>|z|4|6|0|</h2><ol>
<li>不会。将没有链路的两个节点连接，相当于距离从无穷大降到了有限值。</li>
<li>每一次更新，至少有一个距离向量的某维度的值减小。(假如没有任何距离向量发生改变，更新就停止。)<br>由于这些值都是整数、不可能增加、也不可能小于0、所以减小的次数必然是有限的，所以更新也必然是有限的。</li>
<li>a. 考虑增加了毒性逆转。y将通知w和z其到x的最短距离为4。z将通知w，其到x的距离为无穷大，因为z此时到x的最短路径是通过w的。另外z通知y其到x的距离为6（因为z只保存了其下一跳，因此并不知道它到x最短路径经过y，因此不发送无穷大）。w通知z其到x的距离为5，通知y其到x的距离为无穷大。<br>b. 不能。问题出在z上，因为z和x的最短路径经过了y，z却告知y的Dz(x)=6（这是毒性逆转作用不到的地方），y就会把Dy(x)更新成9（实际上并不是）,然后陷入了无穷计数。<br>c. 设置为无穷大即可。</li>
<li>BGP是ISP之间的路由选择，如果在寻路时发现了自己所在ISP的路由器，则说明产生了环路。</li>
<li>不是。路由器将偏向于本地偏好值。</li>
<li>a. 路由器3c从eBGP中学习到了前缀x，因为其与AS4直接相连。<br>b. 路由器3a从iBGP学习到前缀x，其需要通过iBGP与3c通信。<br>c. 路由器1c从eBGP学习到前缀x。<br>d. 路由器1d从iBGP学习到。</li>
<li>a. I~1~，距离1c更近。<br>b. I~2~，根据热土豆路由选择算法其距离2a更近。<br>c. I~1~，这样AS-PATH更短。</li>
<li>考虑到B将流量传给C的西海岸路由器，因此为了减少西海岸路由器的负担，C可以只告诉D它的东海岸路由器。</li>
<li>因为B不希望C通过它自身转发分组，因此B和C的这条链路对于w是不可见的。同理x为了不想通过自身转发C和B之间的分组，不会告诉B自己与C连接，因此C和w的这条链路对于w也不可见。同理，为了不让x经过自己转发到w的流量，C到A的链路对于x不可见，且C到B的链路对于x不可见。</li>
<li>BitTorrent</li>
<li>A会向B通告其有到w的路由，不会向c通告，A会向B和C通告有到v的路由。</li>
<li>不允许。</li>
<li>略</li>
<li>略</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%AC%AC4%E7%AB%A0%E4%B9%A0%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%AC%AC4%E7%AB%A0%E4%B9%A0%E9%A2%98/" class="post-title-link" itemprop="url">计算机网络——第4章习题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-02 23:48:47 / Modified: 23:48:57" itemprop="dateCreated datePublished" datetime="2023-03-02T23:48:47+08:00">2023-03-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>3.5k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="课后习题和问题"><a href="#课后习题和问题" class="headerlink" title="课后习题和问题"></a>课后习题和问题</h2><h3 id="4-1"><a href="#4-1" class="headerlink" title="4.1"></a>4.1</h3><ol>
<li>网络层的分组名为数据报，路由器能够在网络层处理数据报，而链路层交换机只能在链路层处理链路层帧。</li>
<li>数据平面的主要功能是转发和路由，控制平面的主要功能是连接建立。</li>
<li>路由选择指的是路由器指定一条到目的主机的路由的过程，转发指的是路由器内部将输入端口的分组正确转移到指定的输出端口。</li>
<li>转发表中保存了若干个&lt;目标，端口&gt;数据对，便于路由器根据这些数据确定需要将数据报转发到哪一个端口。</li>
<li>因特网的网络层提供单一的服务，称为尽力而为服务。传送的分组既不能保证以它们发送的顺序被接收，也不能保证它们最终交付；既不能保证端到端时延，也不能保证有最小的带宽。<h3 id="4-2"><a href="#4-2" class="headerlink" title="4.2"></a>4.2</h3></li>
<li>输入端口、输出端口、交换端口由硬件实现，其数据表处理功能比软件快很多；路由选择处理器由软件实现，维护路由表以及其他的路由信息，并计算转发表。数据平面使用硬件实现，控制平面使用软件实现。</li>
<li>在高速路由器的输入端口存储转发表的副本可以大大减少路由器进行路由选择的时间，无需每一次都计算一次路径。转发决策能在每个输入端口本地做出，无须基于每个分组调用集中式路由选择处理器，因此避免了集中式处理的瓶颈。</li>
<li>基于目的地转发意味着路由器仅会根据数据报的目的IP地址来决定转发端口，通用转发除了数据报的最终目的地之外还有其他的影响因素，如转发决策可以基于数据报的TCP/UDP源端口号和目的端口号进行转发。</li>
<li>使用最长前缀匹配原则来确定应该转发到哪一个端口。</li>
<li>经过内存交换：在输入端口与输出端口之间的交换是在CPU的直接控制之下完成的，一个分组到达一个输入端口时，该端口会通过中断方式向路由选择处理器发出信号，该分组从输入端口处被复制到处理器内存中，理由选择处理器提取目的地址，在转发表中查找到适当的转发端口，并将该分组复制到输出端口的缓存中。<br>经过总线交换：输入端口经过一条共享总线将分组直接传送到输出端口，不需要路由选择处理器的干预。让输入端口为分组预先计划一个交换机内部标签，指示本地输出端口，使分组在总线上传送和传输到输出端口。该分组能够由所有输出端口收到，但只有与该标签匹配的端口才能保存该分组。<br>经互联网络交换：使用一个更为复杂的互联网络，如纵横式交换机结构，每条垂直的总线在交叉点与每条水平的总线交叉，交叉点通过交换结构控制器能够在任何时候开启和闭合。当分组到达端口A需要转发到Y时，交换机控制器闭合A和Y总线交叉部分的交叉点，然后即可转发。只有互联网络交换可以并行交换多个分组。</li>
<li>如果数据报到达的速率大于数据报处理的速率，当输入端口的数据报缓存满时，后面到达的数据报就可能会丢失。加快路由器处理器的处理速率即可消除排队。</li>
<li>如果数据报被大量送入输入端口，速率大于转发速率时，会导致输出端口排队，到达一定程度后出现丢失。无法防止这种丢失。</li>
<li>HOL阻塞，即线头阻塞，即在一个输入端口的缓存中，后面的分组由于前面的分组等待转移到输出端口而产生等待时延的现象，又称线路前部阻塞。出现于输入端口。</li>
<li>FIFO</li>
<li>不同的数据报中的数据的重要程度不同，对时延的要求也不同，因此需要为分组设置优先权。</li>
<li>RR指循环排队原则，WFQ指加权公平排队原则，二者的基本差异是RR将所有类通信都一视同仁地看待，而WFQ则将通信分为多个不同优先权的分组，优先权表现在一个循环周期内某一类分组处理的时间比例。当WFQ中所有类具有相同的服务权重时，与RR相同。<h3 id="4-3"><a href="#4-3" class="headerlink" title="4.3"></a>4.3</h3></li>
<li>IP数据报首部中含有上层协议字段，可用于标识上层协议。</li>
<li>TTL（time to live），每一次转发都会减1，当该值被减为0时即丢弃。</li>
<li>不用，IP数据报只检验其头部信息。</li>
<li>当数据报中数据部分的长度大于MTU，即链路的最大传送单元时，需要对数据报进行分割，较小的数据报在最终目的主机装配。</li>
<li>路由器有IP地址，有多个IP地址，数量等于其有效接口数量。</li>
<li>11011111  00000001  00000011  00011011</li>
<li>略</li>
<li>8个接口，3个</li>
<li>IP数据报头部20字节，TCP报文段头部20字节，一个数据报中头部信息占40字节，还有40字节为数据，因此开销为50%，即发送的内容只有1-50%是有效数据，应用数据所占百分比为50%</li>
<li>通过路由器的DHCP服务器为5台PC分配IP地址，该无线路由器使用NAT，因为ISP只给了它一个IP地址，它必须自己构建一个局域网。</li>
<li>路由聚合指使用单个网络前缀通告多个网络的能力，其使用一个具有公共前缀的地址来汇聚许多的子网。</li>
<li>能够自动配置主机的IP地址。</li>
<li>专用网络地址指在各个子网中可以重复使用的网络IP地址。具有专用网络地址的数据报不会出现在大型公共因特网中，否则数据报将无法确定到底应该发送到哪一台主机。</li>
<li>有，如源IP和目的IP。</li>
<li>是，因为IPv6载荷包裹在IPv4数据报中。<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2></li>
<li>a. 路由器A的转发表：其中1项的目的地址为H3，转发端口为3。<br>b. 无法实现，因为路由器转发仅根据目的地址转发，而不根据数据来源转发。</li>
<li>a. 不能，因为交换结构是共享总线时，一次只能转发一个分组。<br>b. 不能，因为交换结构是内存交换时，一次也只能转发一个分组。<br>c. 不能，因为两个分组转发到相同的输出端口，交换结构为纵横式时，允许不同端口同时转发不同分组，但一个端口在一个时刻不能同时转发多个分组。</li>
<li>内存和总线交换结构：每一次只能转发一个分组，因此最大时延为(n-1)D。纵横式：不同端口的输出可以交互进行，因此最大时延为0。</li>
<li>在第一个时隙，第一个输入端口的X分组到达X输出端口，另外剩余两个端口的最前两个Y分组选择一个到达Y输出端口，之后的分组还需要两个时隙完成传输，故最少需要3个时隙。最大也是3个时隙。</li>
<li>a.<br>目的地址为192.0.0.0/10时输出到0端口，前缀11100000 00<br>目的地址为192.64.0.0/16时输出到1端口，前缀11100000 01000000<br>目的地址为192.0.0.0/7且不属于端口0、1的地址范围时输出到2端口，前缀1110000<br>其余输出到3端口<br>b. 第一个地址根据最长前缀匹配原则匹配到其他，输出到3端口<br>第二个地址可匹配端口2，且不匹配端口0、1，输出到2端口<br>第三个地址匹配到其他，输出到3端口</li>
<li>首先看前缀长的。<br>接口1前缀010，匹配64~95，地址数量为32。<br>接口2前缀011，匹配96~127，地址数量为32。<br>接口0前缀00，匹配0~63，地址数量为64。<br>接口2前缀10，匹配128~191，地址数量为64。<br>接口2可匹配96~191，地址数量为96。<br>接口3前缀11，匹配192~255，地址数量为64。</li>
<li>首先看前缀长的。<br>接口2前缀111，匹配224~255，地址数量为32。<br>接口1前缀10，匹配128~191，地址数量为64。<br>接口0前缀1，匹配192~223，地址数量为32。<br>接口3匹配0~127，地址数量为128。</li>
<li>首先分配需求大的子网，子网2分配一个25地址，即223.1.17.0/25，子网1分配一个26地址，即223.1.17.128/26，子网3分配剩余地址，即223.1.17.192/26。</li>
<li>略</li>
<li><p>244.0.0.0/10 → 端口0<br>224.64.0.0/16 → 端口1<br>224.0.0.0/7 → 端口2<br>0.0.0.0/0 → 端口3</p>
</li>
<li><p>128.119.40.(64\80\96\112)/28</p>
</li>
<li>子网1：214.97.254.0/24<br>子网2：214.97.255.0/25 - 214.97.255.0/29<br>子网3：214.97.255.128/25<br>子网4：214.97.255.0/31<br>子网5：214.97.255.2/31<br>子网6：214.97.255.4/30</li>
<li>略</li>
<li>将会产生4个分片，表示均为422，偏移分别为0、85、170、255，前3个分片的MF为1，数据量700字节，最后一个为0，数据量300字节。</li>
<li>5MB=5×10^6^字节，首部字段的长度为40字节（含IP首部和TCP首部），故每个数据报最大数据量为1460字节，需要将5MB分为3425个数据报。</li>
<li>a. 192.168.1.1~192.168.1.3<br>b. 源IP地址：192.168.1.1，端口3345；转换IP地址：24.34.112.235，端口4000。其余5个类似。</li>
<li>a. 通过标识号识别，由于每一台主机的标识号都是连号的，可以将所有的分组编号提取出来，检测其中连号或单号的数量，可以大致检测出主机的数量，通过这样的方式检测出的主机数量不会大于实际的主机数量，因为不同主机在不同的时间段可能会使用同一个编号。<br>b. 不能。这样就无法通过标识号的规律对数据报进行源关联。</li>
<li>不可能设计这种技术。TCP首先需要创建一个连接，一方通过NAT地址转换可以找到另一方NAT的网关，但不能定位到NAT内部子网的另一方。</li>
<li>略</li>
<li>略</li>
<li>略</li>
<li>略</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%AC%AC4,5%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%AC%AC4,5%E7%AB%A0/" class="post-title-link" itemprop="url">计算机网络——第4,5章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-02 23:47:13 / Modified: 23:48:42" itemprop="dateCreated datePublished" datetime="2023-03-02T23:47:13+08:00">2023-03-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>9.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>9 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Chapter-4-网络层——数据平面"><a href="#Chapter-4-网络层——数据平面" class="headerlink" title="Chapter 4 网络层——数据平面"></a>Chapter 4 网络层——数据平面</h1><h2 id="4-1-网络层概述"><a href="#4-1-网络层概述" class="headerlink" title="4.1 网络层概述"></a>4.1 网络层概述</h2><font color=red>网络层的任务：完成主机到主机之间的通信</font>

<p>网络层是五层架构中的第三层，为运输层（进程之间的通信）提供支持。</p>
<p>为实现从源主机到目标主机成功的移动数据分组，整个路径上每一台分组交换机上均需要实现网络层，才能实现通信。</p>
<p>网络层功能：</p>
<ul>
<li>在全局范围内对主机通信进行选路，结果反映为分组交换机上的转发表（理解为每一台设备尝试获取整个网络的拓扑结构，控制层面）</li>
<li>分组交换机上的网络层根据转发表以及分组头部信息，将分组向合适的链路进行转发（数据层面）</li>
<li>对于面向连接的网络层服务，提供连接建立的功能</li>
</ul>
<p>分组交换机分类：</p>
<ul>
<li>根据链路层首部信息进行转发的——链路层结点交换机</li>
<li>根据网络层首部信息进行转发的——路由器</li>
</ul>
<p><font color=red>注意：链路层结点交换机和路由器的区别的理解：链路层在网络层之下，通过以太网（Ethernet）协议工作，链路层结点交换机根据MAC地址找到主机，而路由器通过IP地址找到主机。在一个内网之中，可能存在有多个交换机，交换机在内网主机之间的通信效率高于路由器（主机与路由器直接相连也可以实现交换机的功能，但效率不如交换机）。</font>参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/baidu_32045201/article/details/78305586?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166865182216800184174368%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166865182216800184174368&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-78305586-null-null.142^v63^control,201^v3^control_1,213^v2^t3_esquery_v1&amp;utm_term=%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB&amp;spm=1018.2226.3001.4187">路由器与交换机的区别与联系_WhataNerd的博客-CSDN博客_交换机和路由器的区别</a></p>
<p>网络层可能提供的服务：</p>
<ul>
<li>确保交付：确保分组最终到达目的地（与以太网协议不同，以太网协议为尽力传输）</li>
<li>具有时延上界的确保交付：在时延上限以内交付</li>
<li>有序分组交付：以发送顺序到达</li>
<li>确保最小带宽：以低于特定比特率速率传输时分组不会丢失而且在时延内可达</li>
<li>确保最大时延抖动：连续分组间隔时间不超过特定值</li>
<li>安全性服务：机密性、完整性和源鉴别（如TLS）</li>
</ul>
<p>网络层提供的服务可以分为：（下面两种只能提供一种，而运输层可通知提供两种）</p>
<ul>
<li>面向有连接的服务：虚电路，需要事先握手</li>
<li>面向无连接的服务：数据报，不需事先握手</li>
</ul>
<p><font color=red>网络层与运输层中相应服务的区别</font>：</p>
<ul>
<li>网络层是向运输层提供主机到主机的服务，而运输层是向应用层提供进程到进程的服务。</li>
<li>网络层仅提供上述两种服务中的一种，不同时提供两种，而运输层则同时提供两种。</li>
<li>运输层的服务在网络边缘的端系统中实现，而网络层的服务则在整个网络中实现，含路由器。</li>
</ul>
<h4 id="虚电路网络"><a href="#虚电路网络" class="headerlink" title="虚电路网络"></a>虚电路网络</h4><p>虚电路的目标是使首发双方之间的路径表现得如同电话线路一般。<br>工作机制：</p>
<ul>
<li>数据开始流动之前，呼叫建立，流动结束后要断开</li>
<li>每一个分组携带虚电路的标识（而不是目的主机的地址）</li>
<li>路径上的每一个路由器必须为进行中的连接维持连接状态信息</li>
<li>链路，路由器资源可以分配给虚电路，为了达到类似线路交换的性能</li>
</ul>
<p>虚电路的组成：</p>
<ul>
<li>从源到目的主机的路径，含有一系列链路和路由器</li>
<li>VC号，沿着该路径的每段链路的一个号码<ul>
<li>一条虚电路在每条链路上具有不同的VC号</li>
<li>每台中间路由器必须用一个新的VC号替代每个传输分组的VC号</li>
</ul>
</li>
<li>沿着该路径的每台路由器中的转发表<ul>
<li>创建一条新的虚电路，转发表增加一个新表项</li>
<li>终止一条虚电路，表中相应项被删除</li>
</ul>
</li>
</ul>
<h4 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h4><p>数据报网络在网络层没有连接建立过程。路由器在端到端的连接中不维护连接状态信息（在网络层不存在“连接”的概念）。传输报文时使用目的主机地址信息，同一对主机之间的报文可能会走不同的路径。</p>
<p>虚电路网络与数据报网络的对比：虚电路网络将重点放在网络，数据报网络将重点放在终端。数据报网络互联不同类型的网络更加容易，启用新服务的速度更快更简单。</p>
<h2 id="4-2-路由器工作原理"><a href="#4-2-路由器工作原理" class="headerlink" title="4.2 路由器工作原理"></a>4.2 路由器工作原理</h2><p>路由器关键组成：</p>
<ul>
<li>运行路由算法/协议（如RIP选路算法）</li>
<li>从入口到出口的转发</li>
</ul>
<p><font color=red>路由器的分散式交换：</font></p>
<ul>
<li>按照给定的目标地址，使用输入端口内存中存储的路由表，查找输出端口</li>
<li>路由器需要以“线路速度”完成输入输出端口的处理</li>
<li>如果数据报到达的速度超过了输入输出端口将数据报转交给交换结构的速度，则会产生排队现象。<ul>
<li>基于目标的转发：仅基于目标IP地址的转发，以<font color=red>最长前缀匹配方法</font>确定向何处转发。</li>
<li>通用转发：基于任意首部字段值转发</li>
</ul>
</li>
</ul>
<h3 id="输入端口"><a href="#输入端口" class="headerlink" title="输入端口"></a>输入端口</h3><p>输入端口排队：</p>
<ul>
<li>输入端口处理速率超过交换结构速率时产生</li>
<li>当输入缓冲区溢出时可能会导致排队丢包和时延</li>
<li><font color=red>线头阻塞</font>：在输入队列中排队的分组必须等待通过交换结构发送，因为它被位于线头的另一个分组阻塞了。</li>
</ul>
<p>交换结构工作原理：</p>
<ul>
<li>经总线交换：输入端口通过一根共享总线直接传送到输出端口，缺点是<font color=red>总线的带宽是交换速度的瓶颈</font>。一次处理一个分组。</li>
<li>经内联网络：将长度变化的IP分组分片为固定尺寸的信元，通过交换结构对信元进行转发。克服了总线带宽的限制。</li>
<li>经内存交换：在输入端口和输出端口之间的交换是在CPU的直接控制下完成的。分组被拷贝到系统内存中，CPU提出报头中的目标地址，查找路由表中的输出接口，将数据包拷贝到输出接口。其转发速度受限于内存的带宽（吞吐量&lt;带宽/2），一次转发一个分组。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2cd2649418ff4561b35808c705a039e2.png" alt=""></p>
<h3 id="输出端口"><a href="#输出端口" class="headerlink" title="输出端口"></a>输出端口</h3><p>输出端口需要缓存管理和调度原则。当交换结构将分组交付给输出端口的速率超过输出链路速率时进行缓存管理，在数据报队列中选择数据报进行传输时需要调度原则。</p>
<p>输出端口排队：</p>
<ul>
<li>当通过交换结构到达的分组速率超过输出链路速率时产生。</li>
<li>需要对分组进行缓存，超过缓存缓冲区大小会造成排队和丢包。</li>
</ul>
<h3 id="拥塞问题的解决方法"><a href="#拥塞问题的解决方法" class="headerlink" title="拥塞问题的解决方法"></a>拥塞问题的解决方法</h3><p>缓冲区设置问题：</p>
<ul>
<li>经过试验认为对于有N条TCP连接经过的链路而言，缓冲区大小应为：<script type="math/tex">B=\frac{\operatorname{RTT}\times R}{\sqrt{N}}</script>其中R为带宽，RTT为往返时间。</li>
</ul>
<p>输出端口分组调度策略：</p>
<ul>
<li>先来先服务策略（First Come First Serve，FIFO的队列策略）<ul>
<li>当缓冲区满时，有几种丢弃方法：<ul>
<li>尾部丢弃</li>
<li>按照优先级丢弃</li>
<li>随机丢弃</li>
</ul>
</li>
</ul>
</li>
<li>优先级排队策略<ul>
<li>针对高优先级和低优先级的数据报创建多个不同队列</li>
</ul>
</li>
<li>循环调度策略<ul>
<li>循环扫描不同类的队列，轮流发送数据包</li>
</ul>
</li>
<li>加权公平队列策略<ul>
<li>每一个类赋予对应的权重，在一个周期之内可以获得一定数量的服务，既可以保证高优先级队列获得最大优先权，又可以防止低优先级队列等待时间过长。</li>
</ul>
</li>
</ul>
<p>分组丢弃策略</p>
<ul>
<li>被动策略<ul>
<li>丢弃尾部</li>
<li>随机丢弃已排队分组</li>
</ul>
</li>
<li>主动策略<ul>
<li>随时计算平均队列长度，并设置一个最小和最大阈值。</li>
<li>当队列长度小于最小阈值时，无条件允许分组入队列。</li>
<li>当队列长度大于最大阈值时，无条件禁止分组入队列。</li>
<li>当队列长度在两个阈值之间时，按照概率标记或丢弃分组。</li>
</ul>
</li>
</ul>
<h2 id="4-3-网际协议"><a href="#4-3-网际协议" class="headerlink" title="4.3 网际协议"></a>4.3 网际协议</h2><p><font color=red><strong>IPv4协议数据报格式：</strong></font><br><img src="https://img-blog.csdnimg.cn/4d9498e0c9024f3a908ffc12db15464f.jpeg#pic_center" alt=""></p>
<h3 id="IP分片和重组"><a href="#IP分片和重组" class="headerlink" title="IP分片和重组"></a>IP分片和重组</h3><p>MTU：最大传送单元，一个网络层数据包的最大长度（包含网络层协议头）</p>
<p>受限于MTU，大的数据包在一些链路中会被拆分为多个数据包。<font color=red>网络中的交换机都有可能会拆分数据包，但只有目标主机会对数据包进行重组，具有较大MTU的链路即使接收到小数据包也不会进行重组。</font> 重组后由于数据包头部数量增加，因此总的传输的字节数量会增加。</p>
<p><font color=red><strong>IP地址</strong></font></p>
<ul>
<li>结构：网络号（子网号）+主机号，在同一个网络下的主机和路由器的IP地址中的网络号必须相同，同一网络下的主机可以直接通信。</li>
<li>接口：连接主机、路由器之间的物理链路，一般路由器有多个接口，主机也有可能有多个接口，IP地址只和接口有关而与主机、路由器没有太多关联。</li>
<li>传统形式下的IP地址分类：<ul>
<li>A类：0.0.0.0~127.255.255.255，网络号7位，主机号24位</li>
<li>B类：128.0.0.0~191.255.255.255，网络号14位，主机号16位</li>
<li>C类：192.0.0.0~223.255.255.255，网络号21位，主机号8位</li>
<li>D类：224.0.0.0~239.255.255.255，组播地址</li>
<li>E类：240.0.0.0~255.255.255.255，保留</li>
</ul>
</li>
<li>路由器的IP地址：为完成分组转发功能，路由器至少拥有两个IP地址，接入不同的子网之中，用于不同子网之间的通信。</li>
<li>子网划分方法：在主机号中借用一部分位数作为子网号</li>
<li>子网掩码：对内用于指示网络号和子网号的位置，对外可以隐藏子网的存在。获得方法：通过在网络号的子网号相应的位置全部置为1，主机号相应的位置全部置为0，即可得到子网掩码。</li>
<li>在同一个局域网上的主机或路由器的IP地址中的网络号必须是一样的，图中的网络号就是IP地址中的net-id。路由器总是具有两个或两个以上的IP地址，路由器的每一个接口都有一个不同网络号的IP地址。</li>
</ul>
<h3 id="IPv4编址"><a href="#IPv4编址" class="headerlink" title="IPv4编址"></a>IPv4编址</h3><p>网络地址=IP地址 逻辑与 子网掩码。<br>采用子网掩码之后，路由器的寻址过程将演变为一个两级寻址过程：</p>
<ul>
<li>检查分组目的IP地址中的网络号，若网络号不是本网络，则从路由表中找出相应的的转发节点地址将其转发出去。</li>
<li>检查子网号：当网络号是本网络时，路由器将检查子网号，向相应的子网转发此分组。</li>
</ul>
<p>IP地址扩展：构造超网，从网络号中借用一部分位数作为主机号。</p>
<h4 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h4><p>无类别域间路由选择。应用于地址空间的利用率低，地址空间面临耗尽时。</p>
<p>编址格式：IP地址::={网络前缀，主机号}<br>斜线记法：192.168.0.1/24<br>简写记法：10.0.0.0/10可以简写为10/10</p>
<p>最长前缀匹配：</p>
<ul>
<li>使用CIDR时，路由表中的每一个项目由“网络前缀”和“下一条地址”组成，在查找路由表时可能会得到不止一个匹配结果。</li>
<li>应当从匹配结果中选择具有最长网络前缀的路由：最长前缀匹配。</li>
<li>网络前缀越长，其地址块就越小，因而路由就越具体。</li>
<li>最长前缀匹配又被称为最长匹配或最佳匹配。</li>
</ul>
<p>主机获得IP地址的方法：手工配置，或使用DHCP协议动态获取。</p>
<h4 id="DHCP：动态主机配置协议"><a href="#DHCP：动态主机配置协议" class="headerlink" title="DHCP：动态主机配置协议"></a>DHCP：动态主机配置协议</h4><p>允许主机在加入网络时动态地从网络服务器中获取其网络地址。</p>
<ul>
<li>能够在使用过程中更新地址</li>
<li>允许地址重用</li>
<li>支持移动用户</li>
</ul>
<p>主要流程</p>
<ul>
<li>主机广播DHCP发现报文。</li>
<li>DHCP服务器使用“DHCP提供”报文进行应答（广播方式，由于现在主机还没有获取IP地址，因此只能广播）。</li>
<li>主机使用DHCP请求报文请求IP地址。</li>
<li>DHCP服务器使用DHCP ACK报文响应。</li>
</ul>
<p>DHCP除了可以获取IP地址，还可以获取网关地址、DNS地址、子网掩码。其<font color=red>工作在应用层</font>，是引导程序协议的一种，属于局域网的网络协议，使用UDP协议工作。<br>DHCP有3个端口，67和68作为正常的DHCP服务端口，分别是服务器和客户端的服务端口，546号端口用于DHCPv6客户端，这是为了特别开启DHCP failover服务。</p>
<h3 id="网络地址转换（NAT）"><a href="#网络地址转换（NAT）" class="headerlink" title="网络地址转换（NAT）"></a>网络地址转换（NAT）</h3><p>其目的是让本地网络只使用一个IP地址就可以和外部网络相连，且不需要从ISP获取大批的IP地址，所有的设备可以使用同一个IP地址，可以在不通知外部网络的情况下改变内网主机的IP地址，即使改变了ISP也无需改变内网主机的IP地址，且内网主机对于外网主机是不可见的，不可寻址的。</p>
<p>实现方法：</p>
<ul>
<li>发送数据报：将每个外出报文的源IP地址和端口号替换为NAT的IP地址以及新的端口号，远程客户机或服务器将以NAT IP地址以及新的端口号作为目的地址进行响应。</li>
<li>网关存储每一个地址转换对，在接收数据报时根据NAT转换表将每一个进入报文的NAT IP地址和端口号替换为相应的源IP地址以及端口号。</li>
</ul>
<p>三种地址转换方式：</p>
<ul>
<li>静态NAT：一个本地地址对应于一个全球地址</li>
<li>动态NAT：一个全球地址对应于多个本地地址</li>
<li>端口NAT：一个本地地址的端口对应到一个全球地址的端口</li>
</ul>
<p>争议：</p>
<ul>
<li>端口号是用于进程编址而不是用于主机编址的</li>
<li>路由器仅应当处理高达第三层的分组</li>
<li>NAT协议违反了端到端原则，即主机彼此应当相互直接对话，结点不应该介入。</li>
<li>应该使用IPv6来解决IP地址的短缺问题</li>
</ul>
<h4 id="ICMP：因特网控制报文协议"><a href="#ICMP：因特网控制报文协议" class="headerlink" title="ICMP：因特网控制报文协议"></a>ICMP：因特网控制报文协议</h4><p>用于主机、路由器、网关之间交换网络层信息，其传递的信息包括：</p>
<ul>
<li>错误报告，如主机、网络、端口、协议不可达等</li>
<li>回声请求/回答，如ping</li>
</ul>
<p>从体系结构上看其位于IP层之上，被封装在IP分组中。报文种类有两种：ICMP差错报告报文和询问报文。</p>
<h2 id="5-2-路由选择算法"><a href="#5-2-路由选择算法" class="headerlink" title="5.2 路由选择算法"></a>5.2 路由选择算法</h2><p><font color=red>默认路由器</font>：一台主机直接连接到的路由器</p>
<p><font color=red>源路由器</font>：源主机的默认路由器</p>
<p><font color=red>目的路由器</font>：目的主机的默认路由器</p>
<p>选路算法的目的：</p>
<ul>
<li>给定一组路由器以及连接路由器的链路，从中找到一条从源路由器到目标路由器的“好的”路径，这条路径通常需要拥有最低的成本。</li>
</ul>
<p>选路算法分类：</p>
<ul>
<li>根据信息是全局性还是分散性的进行分类<ul>
<li>全局选路算法<ul>
<li>所有路由器都知道整个网络的拓扑图以及链路的费用信息</li>
<li>链路状态算法</li>
</ul>
</li>
<li>分散式选路算法<ul>
<li>每一个路由器仅有与其相连的链路的费用信息</li>
<li>通过迭代计算过程与相邻结点交换信息</li>
<li>距离向量算法</li>
</ul>
</li>
</ul>
</li>
<li>根据信息是静态还是动态进行分类<ul>
<li>静态选路算法<ul>
<li>随着时间的流逝，路由的变化很慢</li>
</ul>
</li>
<li>动态选路算法<ul>
<li>路由信息可以很快地发生变化</li>
<li>需要对路由信息进行周期性的更新</li>
<li>可以相应拓扑或链路费用的变化</li>
</ul>
</li>
</ul>
</li>
<li>根据是否对负载敏感进行分类<ul>
<li>负载敏感算法<ul>
<li>链路费用会动态地变化以反映出链路的当前状况</li>
</ul>
</li>
<li>负载迟钝算法<ul>
<li>链路费用不明显地反映链路的当前状况</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><p>条件：</p>
<ul>
<li>所有结点都知道网络拓扑和链路费用<ul>
<li>通过链路状态广播获得信息</li>
<li>所有结点具有该网络的同一个完整的视图</li>
</ul>
</li>
<li>计算从某结点到网络中所有其他结点的最低费用<ul>
<li>为该结点提供转发表</li>
</ul>
</li>
<li>迭代：经过算法的K次迭代之后，可以知道到K个目的节点的最低费用路径。</li>
<li>通过跟踪前一跳结点可以构造最短路径树。</li>
</ul>
<p>复杂性：</p>
<ul>
<li>对于第一次迭代，需要搜索所有的n个结点以确定出结点w，w具有最低费用</li>
<li>在所有迭代中需要搜索的结点总数为n(n+1)/2，所以链路状态算法在最差情况下的复杂性为O(n^2^)</li>
<li>该算法的一种更复杂的实现（堆）可以降到O(nlogn)</li>
</ul>
<p>缺点：当路径的价值在不断变化时，每一次都需要重新进行计算，耗费资源。<br>解决方案：</p>
<ul>
<li>强制链路费用不依赖于所承载的流量，但这无法解决高拥塞的问题</li>
<li>确保并非所有的路由器同时运行LS算法（链路状态路由选择算法），这样因特网上的路由器能够自同步，随机化路由器发送链路通告的时间。</li>
</ul>
<h2 id="5-3-OSPF协议"><a href="#5-3-OSPF协议" class="headerlink" title="5.3 OSPF协议"></a>5.3 OSPF协议</h2><p>OSPF协议是公开发表的，用于因特网中自治系统内部的路由选择。<br>最短路径优先是因为使用了Dijkstra提出的最短路径算法SPF。这是一个分布式的链路状态协议。</p>
<p>链路状态在路由器之间交流使用的方法：洪泛法，其向本自治系统中所有路由器发送信息，<font color=red>发送的信息就是与本路由器相邻的所有路由器的链路状态</font>。只有当链路状态发生变化时，路由器采用洪泛法向所有路由器发送此信息。</p>
<p>由于各个路由器之间频繁交换链路状态信息，所有的路由器最终都能够建立一个<font color=red>链路状态数据库</font>。这个数据库实际上描述了全网的拓扑结构图，在全网范围是一致的。OSPF的链路状态数据能够较快地进行更新，使得各个路由器能够及时更新其路由表。<font color=red>OSPF的更新过程收敛快就是其重要优点</font>。</p>
<h4 id="OSPF协议特点："><a href="#OSPF协议特点：" class="headerlink" title="OSPF协议特点："></a>OSPF协议特点：</h4><ul>
<li>不强制如何设置链路权值的策略，但是提供对给定链路权值集合确定最低费用路径的机制。</li>
<li>即使链路状态未发生变化，每30分钟广播一次链路状态。</li>
<li>链路状态以OSPF通告形式封装于OSPF报文中，由IP分组承载，协议号89。</li>
<li>OSPF路由器之间的交换都是经过鉴别的，以确认OSPF通告的真实性以防止伪造和篡改。</li>
<li>OSPF通告具有序列号，可防止重放攻击。</li>
<li>OSPF中支持多条具有相同费用的路径。</li>
<li>OSPF支持多播选路和层次路由。</li>
</ul>
<h3 id="OSPF距离向量选路算法"><a href="#OSPF距离向量选路算法" class="headerlink" title="OSPF距离向量选路算法"></a>OSPF距离向量选路算法</h3><p>特点：迭代、分布、自我终止、异步<br>思想：</p>
<ul>
<li>d~x~(y)=min~v~{c(x, v)+d~v~(y)}</li>
<li>每一个路由器中都有一张路由表，包含3个内容：目的网络号、经过的邻居路由器、距离</li>
<li>路由器定期向其邻居路由器传送路由表的拷贝</li>
</ul>
<p>路由表更新算法：将每条边的权值都定义为1</p>
<ul>
<li>路由器X得到相邻路由器Y的路由表，从而得知：Y到网络Z的最短距离为N</li>
<li>如果路由器X没有到网络Z的路由条目，则添加一条经由路由器Y到网络Z距离为N+1的路由条目</li>
<li>如果路由器X已经有到网络Z的路由条目，其距离为M，如果M&gt;N+1，则更新该条目为经由路由器Y到网络Z距离为N+1，否则不更新。</li>
<li>特点：<ul>
<li>好消息传播快，每一次发现距离更新的路径，都能够很快通知到邻居：<ul>
<li>在t0时刻，y检测到链路费用变化，更新自己的距离向量，同时将这个变化通知给它的邻居</li>
<li>在t1时刻，z收到来自y的更新报文并更新了自己的距离向量表，计算出到x的新的最低费用，并向邻居发送它的新距离向量</li>
<li>在t2时刻，y收到来自z的更新并更新其距离向量表，Y的最低费用不变，因此y不发送任何报文给z。</li>
</ul>
</li>
<li>坏消息传播慢，如果一条链路的权值增大，每一次更新只能让链路最短距离增加1，这会导致路由选择环路（P252）。解决方案：毒性逆转，即如果z通过y选路到达目的地x，则z通告y其到x的距离为无穷大，这样在比较时不会产生上述情况，但仍然没有解决不可记数问题。涉及3个或更多结点的环路将无法使用毒性逆转技术检测到。</li>
</ul>
</li>
</ul>
<h3 id="链路状态路由选择算法LS-amp-距离向量路由选择算法DV"><a href="#链路状态路由选择算法LS-amp-距离向量路由选择算法DV" class="headerlink" title="链路状态路由选择算法LS &amp; 距离向量路由选择算法DV"></a>链路状态路由选择算法LS &amp; 距离向量路由选择算法DV</h3><ul>
<li>从报文的复杂性来看：<ul>
<li>LS：对于n个结点和E条链路，需要发送O(nE)个报文</li>
<li>DV：只对直连的邻居发送报文</li>
</ul>
</li>
<li>从收敛速度来看：<ul>
<li>算法收敛时间依赖于许多因素，因此可变</li>
<li>LS：是一个要求O(nE)个报文的O(n^2^)算法，可能会存在震荡</li>
<li>DV：收敛时间不确定。可能会遇到环路选路和无穷记数问题</li>
</ul>
</li>
<li>从健壮性来看：<ul>
<li>LS：结点能够向其连接的链路广播不正确费用，每一个结点只计算自己的转发表</li>
<li>DV：一个结点可以向任意或所有目的结点通告其不正确的最低费用路径，每一个结点的计算都会传递给它的邻居</li>
</ul>
</li>
</ul>
<h2 id="RIP协议"><a href="#RIP协议" class="headerlink" title="RIP协议"></a>RIP协议</h2><ul>
<li>相邻两点间链路上的费用定义为1，即只考虑源到目标经过多少个路由器，或多少“跳”</li>
<li>一条路径的最大费用限制为15</li>
<li>选路更新信息每30s在邻居之间以RIP响应报文的形式进行交换</li>
<li>路由器经过180s没有收到来自某个邻居的RIP通告，则认为该邻居已经离线，修改选路表，向其他邻居广播</li>
<li><font color=red>RIP是一个运行在UDP上的应用层协议</font>（端口520）</li>
</ul>
<h2 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h2><p>当因特网规模过大时，路由器无法存储每一台主机的选路信息，路由表更新的报文广播太多占用带宽。另外路由器也需要有一个子网管理的功能，每个网络管理员可能希望能够按照自己的愿望进行管理其网络。</p>
<p>解决方法：</p>
<ul>
<li>将路由器聚合到一个区域，形成一个自治系统（AS）</li>
<li>在相同AS内的路由器可以全部运行同样的选路算法：自治系统内部选路协议，最常用的是内部网关协议IGP，包含RIP和OSPF</li>
<li>在不同AS内的路由器可以运行不同的自治系统内部选路协议</li>
<li>转发表是由AS内部选路算法与AS间选路算法共同决定的，AS内部选路算法为内部目的地址设置转发表信息，AS内部选路算法与AS外部选路算法共同为外部目的地址设置转发表信息</li>
</ul>
<p>自治系统间路由器的任务：<br>需要知道自己所在AS通过某个相邻的AS能够到达哪些AS，并将这些可达性信息向自身AS中的所有路由器传播。</p>
<p>当从源到目标在AS粒度下只有一条路可选时，源知道其哪一个接口在到AS边缘路由器的最低费用路径上，因此将接口与目标作为一对放入转发表。如果不止一条路可选，那么源必须确定通过哪一个网关路由器转发报文，其策略是<font color=red>将报文发送到最近的路由器</font>，即热土豆选路原则</p>
<h3 id="因特网中的AS内层次路由：层次OSPF"><a href="#因特网中的AS内层次路由：层次OSPF" class="headerlink" title="因特网中的AS内层次路由：层次OSPF"></a>因特网中的AS内层次路由：层次OSPF</h3><ul>
<li>为了使得OSPF能够用于规模更大的网络，OSPF将一个自治系统再划分为若干个更小的范围，称为区域</li>
<li>每一个区域都有一个32bit的区域标识符</li>
<li>区域不能太大，一个区域内最好不要有200个以上路由器</li>
<li>划分区域的好处就是将利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个自治系统，这就减少了整个网络上的通信量。</li>
<li>在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域内的网络拓扑的情况。</li>
<li>OSPF使用层次结构的区域划分。在上层的区域叫做主干区域。主干区域的标识符规定为0.0.0.0，主干区域的作用是用于连通其他在下层的区域。</li>
</ul>
<h3 id="因特网上的AS间路由：BGP4"><a href="#因特网上的AS间路由：BGP4" class="headerlink" title="因特网上的AS间路由：BGP4"></a>因特网上的AS间路由：BGP4</h3><ul>
<li>在自治系统之间寻找最佳路由的代价很大，不现实，因此需要考虑有关策略。</li>
<li>BGP为每一个AS提供一种手段，来处理<ul>
<li>从相邻AS获取子网可达性信息</li>
<li>向该AS内部所有路由器传播这些可达性信息</li>
<li>基于该可达性信息和AS策略，决定达到子网的好路由</li>
<li>注意BGP只是寻找一个较好的路由，而不一定是最好的路由</li>
</ul>
</li>
</ul>
<p>每一个自治系统的管理员要选择至少一个路由器作为该自治系统的BGP发言人，一般两个发言人都是通过一个共享网络连接在一起的，而BGP发言人往往是BGP边界路由器，但也可以不是。</p>
<p>一个BGP发言人与其他自治系统中的BGP发言人交换路由信息，首先需要建立TCP连接，然后在此连接基础上交换BGP报文以建立BGP会话，利用BGP会话交换路由信息</p>
<p>使用TCP连接能够提供可靠服务，也简化了路由选择协议。</p>
<p>使用TCP连接交换路由信息的两个发言人彼此成为对方的邻站或对等站。</p>
<ul>
<li>BGP路由通告<ul>
<li>一个AS可以集合多个前缀为一个，并使用BGP向其他AS通告单一前缀，则当前AS承诺它将沿着朝向该前缀的路径，转发指向该前缀的任何数据报。</li>
</ul>
</li>
<li>选路算法<ul>
<li>在不同AS的网关路由器之间使用eBGP，一个AS向另一个AS发送一个自其自身可达的前缀列表。</li>
<li>而另一个AS的网关路由器使用iBGP对话向该AS中的其他路由器发布这些前缀。</li>
<li>这个AS内的其他网关路由器使用eBGP会话将学习到的前缀信息发布到与其直接相连的其他AS的网关路由器中。</li>
<li>当一个路由器得知一个新的前缀，它为该前缀在其转发表中创建一个表项。</li>
</ul>
</li>
<li>路径和BGP路由<ul>
<li>当路由器通告一个前缀时，它随着前缀包含一些BGP属性，前缀+属性=路由。</li>
<li>两个重要属性：<ul>
<li>AS_PATH：该属性包含了前缀的通告已经通过的那些AS</li>
<li>NEXT_HOP：指明到下一跳AS的具体的路由器（从当前AS到下一跳AS之间可能有多条链路）</li>
</ul>
</li>
<li>当一台网关路由器接收到一个路由器通告时，它使用输入策略决定是否接收或过滤该路由。</li>
</ul>
</li>
<li>BGP路由选择<ul>
<li>一台路由器可能知道到一条前缀的多条路由路，路由器必须在可能的路由之中选择一条。消除规则：<ul>
<li>本地偏好值：策略决定，具有最高本地偏好值的路由将被选择</li>
<li>最短AS-PATH：在余下的路由之中，具有最短AS-PATH的路由将被选择</li>
<li>从余下的路由中，选择具有最靠近NEXT-HOP路由器的路由：热土豆路由。</li>
<li>如果依然剩下多条路由，该路由器使用BGP标识来选择路由</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>步骤：</p>
<ul>
<li>路由器知晓前缀的存在性：通过BGP通告得知</li>
<li>确定此前缀的转发端口：使用BGP路由选择确定最佳域间路由，使用IGP路由选择确定最佳域内路由，确定最佳路由的转发端口</li>
<li>将（前缀，端口）表项放入转发表中</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/b0c5406d99d74ce6acff9f1951647399.png" alt=""></p>
<h2 id="IP组播"><a href="#IP组播" class="headerlink" title="IP组播"></a>IP组播</h2><p>组播：将数据分发给网络中处于同一个组的多台主机上的应用进程。</p>
<h2 id="5-5-SDN"><a href="#5-5-SDN" class="headerlink" title="5.5 SDN"></a>5.5 SDN</h2><p>传统网络的问题：</p>
<ul>
<li>各个设备厂家网络层实现的方式各不相同，架构封闭，导致接口模糊封闭，功能单元界面不清晰。封闭架构导致设备制造商对新技术的驱动力不强，协议更新慢。</li>
</ul>
<p>路由器实现的控制平面：每一个路由器都具备独立的路由功能和数据转发功能，路由算法组件分布在不同的路由器上，彼此交互，计算生成转发表，构成分布式的控制平面。</p>
<p>实现目标：</p>
<ul>
<li>确定性路由：从固定源到固定目标要求经过固定的路由</li>
<li>负载均衡路由：从源到目标的多条路径上实现负载均衡</li>
</ul>
<p>解决方案：分层<br>路由控制功能从本地路由器分离，汇聚到远程控制器，与路由器中的本地控制代理进行交互，来计算转发表。</p>
<p>SDN架构包含数据平面与控制平面，数据平面负责处理和转发数据包，根据转发状态和数据报头决定转发决策，而控制平面负责计算路由器的转发状态，确定数据报应该如何转发和转发到哪里，对路由、流量工程和防火墙状态管理控制，实现分布路由协议、手工配置或集中计算。不同的平面需要分别进行抽象，以满足SDN需求。</p>
<p><img src="https://img-blog.csdnimg.cn/7ad8eca1f6f44aeaac7b88047fc8723a.png" alt=""></p>
<h3 id="OpenFlow流表"><a href="#OpenFlow流表" class="headerlink" title="OpenFlow流表"></a>OpenFlow流表</h3><p>由多个流条目组成，流条目包括：</p>
<ul>
<li>头域：用于匹配规则确定输入报文是否与本条目匹配</li>
<li>计数器：用于与本流相关的跟踪统计</li>
<li><p>动作：描述交换机针对匹配报文采取的动作</p>
</li>
<li><p>OpenFlow交换机由OpenFlow协议、安全通道、报文匹配、流表与动作等构成。</p>
</li>
<li>报文匹配功能基于流表对输入报文进行匹配，将其引导至动作箱。</li>
<li>动作包括三种可选动作<ul>
<li>转发报文输出，可能先修改头域字段</li>
<li>丢弃报文</li>
<li>通过报文输入消息将报文转发至控制器</li>
</ul>
</li>
<li>控制器和交换机之间的报文通过安全通道传输</li>
<li>当控制器有报文需要通过交换机输出时采用PACKET_OUT消息</li>
<li>控制器直接指定输出端口</li>
<li>控制器通过报文匹配逻辑决定转发策略</li>
</ul>
<p>SDN控制平面：包括SDN控制器和SDN网络控制应用程序。</p>
<ul>
<li>控制平面基于网络的抽象，简化了网络编程控制</li>
<li>SDN控制平面包括两个层面的抽象：<ul>
<li>流抽象-交换机API，通过OpenFlow协议与数据平面交互</li>
<li>映射抽象-网络API，控制器与网络控制应用程序之间交互</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%AC%AC3%E7%AB%A0%E4%B9%A0%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%AC%AC3%E7%AB%A0%E4%B9%A0%E9%A2%98/" class="post-title-link" itemprop="url">计算机网络——第3章习题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-02 23:46:40 / Modified: 23:47:10" itemprop="dateCreated datePublished" datetime="2023-03-02T23:46:40+08:00">2023-03-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>9 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="课后习题和问题"><a href="#课后习题和问题" class="headerlink" title="课后习题和问题"></a>课后习题和问题</h2><h3 id="3-1-3-3"><a href="#3-1-3-3" class="headerlink" title="3.1~3.3"></a>3.1~3.3</h3><ol>
<li>略</li>
<li>略</li>
<li>对于主机B发送到主机A的报文段，源端口号为y，目的端口号为x。</li>
<li>UDP的速度快，有些应用如实时视频可能不需要数据完全可靠，不希望受到拥塞控制。</li>
<li>因为语音和图像要求数据可靠准确，而UDP不能保证。标准答案：大多数防火墙被配置为阻止UDP通信，因此使用TCP处理视频和语音通信可以让通信通过防火墙。</li>
<li>可能，需要在应用层设置另外的校验程序，UDP本身是不提供可靠数据传输的。</li>
<li>是。注意<font color=red>UDP数据包中是没有IP地址的</font>，主机C是通过应用中的套接字来确定，在套接字接口处，有操作系统向进程提供IP地址，以确定各个报文段的源。</li>
<li>不同的套接字。对于每一个持久连接，Web服务器都会创建一个单独的“连接套接字”，每一个连接套接字都由一个四元组表示：源IP地址、源端口号、目的IP地址、目的端口号。当主机C接收IP数据报时，检查报文中的这4个字段，以确定将这个数据报上传到哪一个套接字。用于连接两台主机的套接字中都以80作为目的端口。注意<font color=red>当传输层将TCP报文段的有效负载传递给应用程序进程时，不会指定源IP地址，因为这是由套接字标识符隐式指定的，这与UDP不同。可以理解为，TCP会将从不同源发送的报文段分到不同的套接字，因此不需要另外指定源IP。</font><h3 id="3-4"><a href="#3-4" class="headerlink" title="3.4"></a>3.4</h3></li>
<li>标识一个ACK是对应于哪一个报文段的。<font color=red>接收方的确认报文如果在链路中发生了错误，发送方就只能重新发送一次这个报文，但是接收方不知道这个报文是一个新的报文还是上一个报文的重传，因此需要标识。</font></li>
<li>如果报文丢失，就需要重传报文，设置定时器的目的是防止丢包导致无限等待，在定时器到达一定的时间之后认定为丢包，即直接重传。如果收到了ACK，则重启该定时器。</li>
<li>是，在往返时延固定的情况下，定时器只要检测到在往返时延之内没有接收到希望的ACK报文即可重传报文。</li>
<li><a target="_blank" rel="noopener" href="https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/go-back-n-protocol/index.html">小程序</a><br>a. 毁掉第一个分组之后，会发送4个序号相同的ACK报文，并开启定时器，在一段时间之后发送方重新发送5个报文。这里解释一下，由于第一个报文被毁，因此接收方只能够发送上一次成功接收的序号的ACK，发送方能够收到4个相同序号的ACK，其需要等待一段时间确认第5个ACK是否正在发送，如果能够成功收到第5个报文，则说明发送方发送数据报到接收方时出现了失序，序号最小的数据报反而是最后被接收的；如果计时器结束，就全部进行重传。<br>b. 此时窗口会移动，因为发送方接收到了序号更大的ACK，这说明前面的数据报都已经被成功接收，即使第一个ACK丢失也不影响窗口右移。<br>c. 无法发送第6个分组，因为窗口大小只有5。</li>
<li><a target="_blank" rel="noopener" href="https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html">小程序</a><br>选择重传的不同之处在于，其ACK报文与GBN的ACK报文表达的含义不同了，选择重传的ACK报文只能表示该序号的数据报正常接收，而GBN的ACK报文表示该序号及小于该序号的所有数据报均已经被正常接收。因此选择重传只会重传没有收到ACK的序号的数据报，并在窗口的第一个数据报收到时调整窗口的位置，使得窗口的第一个序号永远处于没有被确认的状态。<h3 id="3-5"><a href="#3-5" class="headerlink" title="3.5"></a>3.5</h3></li>
<li>a. 错误，TCP协议中接收方需要发送确认数据报，与随数据捎带确认没有关系。<br>b. 错误，rwnd全称为receive window，即接收窗口，其值等于接收缓存-（接收到的字节数-主机应用进程从缓存读出的字节数），因此该值是一直在动态变化的。<br>c. 正确。<br>d. 错误，报文段的序号是按照字节编址的，下一个报文段的序号应该等于该报文段的序号+该报文段的长度。<br>e. 正确。<br>f. 错误。TimeoutInterval = EstimatedRTT + 4 × DevRTT = (1-α) × EstimatedRTT + α × SampleRTT + 4 × ((1-β) × DevRTT + β × |SampleRTT - EstimatedRTT|)，无法推导出该题结论。<br>g. 错误，TCP通信双方的序号是各自决定的，因此确认号与序号没有直接的关系。</li>
<li>20字节；90</li>
<li>3个报文段：<br>Seq=43, Ack=80<br>Seq=80, Ack=44<br>Seq=44, Ack=81<h3 id="3-7"><a href="#3-7" class="headerlink" title="3.7"></a>3.7</h3></li>
<li>R/2，TCP可以通过调度使得链路中多个连接的吞吐量基本公平。</li>
<li>错误，应该被设置为门限值的一半。</li>
<li>略<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2></li>
<li>e. 可能相同。<br>f. 同一台主机不可能相同。</li>
<li>主机A连接：源端口80，目的端口26145；主机C连接：源端口80，目的端口7532</li>
<li>11010001，接收方将带有反码的4个8比特求和，结果为全1则验证完成。1比特的差错可以出来，但2比特的错误可能不能检测出来。</li>
<li>a. 00111110<br>b. 10111111<br>c. 将最低位的0改成1，1改成0。</li>
<li>不能绝对确信。</li>
<li>在发送方发送分组1时，接收方接收完成并发送一个ACK，但ACK损坏，发送方收到损坏的ACK之后重传分组1，但接收方要的不是分组1，因此会返回NAK，发送方误以为分组1传输错误就会继续重传，由此陷入死锁状态。</li>
<li>不理解题意。</li>
<li>与rdt2.2的FSM相同</li>
<li>略</li>
<li><img src="https://img-blog.csdnimg.cn/e493f4c3298f450eac99777b8cc6b5cc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAc3VwZXJtYXgyMDIw,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""><br>需要将计时器设置为最大往返时延与处理时间之和，每一次发送新的数据分组时重启计时器。</li>
<li>不能正常工作。如果在收到重复的数据包或数据包损坏的情况下不发送数据包，那么发送方就永远无法收到来自接收方的任何确认信息，就会一直等待下去，进入死锁的状态。注意rdt 3.0之前的所有版本都是没有计时器的。</li>
<li>仅有一个比特差错时，能够正常运行。如果定时器过早超时，那么对于序号为n的分组将会重传n次。流程：发送1分组，在ACK1被接收前计时器超时，重传1次1分组，然后接收到1ACK，发送2分组，在ACK2被接收前计时器超时，重传1次2分组，然后接收到来自第1次重传1分组的ACK1回应，第2次重传2分组，然后收到ACK2，发送3分组，超时第一次重传3分组，接收到两次2分组重传的回应ACK2，再重传2次3分组……可以发现1分组重传了1次，2分组重传了2次，……n分组将会重传n次。</li>
<li>如果能够重排报文顺序，首先发送老1分组，回应的老ACK1迟迟未到，重传1次老1分组，收到ACK1，然后发送0分组，接收方接收到0分组之后发送1个0分组ACK，此时链路中有1个ACK0和1个ACK1，且ACK1是先进入链路的，但如果ACK0首先被收到，那么会发送新1分组，如果此时接收到ACK1分组，注意这个分组确认的是老1分组，那么发送方就会误以为新1分组已经被收到，会继续发送新0分组，如果新1分组没能被收到，那么接收方就会产生错误，迟迟无法收到新1分组。</li>
<li>不会，因为如果只使用NAK，当发送方发送数据的频率较低时，如果编号为x的数据包没能成功接收，那么接收方只有在接收到编号为x+1的数据包时才能察觉到编号为x的数据包接收错误，才能发送NAK，这会降低效率。如果发送方要发送大量的数据，且该端到端连接很少丢包，则只使用NAK协议会比使用ACK的协议更好，因为少发送了很多的确认数据包。</li>
<li>RTT=30ms，传输时延为0.012ms，如果不考虑ACK分组的传输时延与接收方的处理时间，那么一个分组从开始发送到接收到确认信息一共需要30.012ms，其中忙的时间为0.012ms，要使得忙的时间超过90%，那么需要在前面分组还没有被确认的情况下发送新的分组，设一共需要发送x个分组才能使忙的时间超过90%，则有0.012x/30.012&gt;90%，解得x=2251，这即是窗口的最小值</li>
<li>能增加信道利用率，因为发送方能够持续不断地接收到ACK，从而发送分组的时间间隔就会短很多，但出现差错时很难检测到，且发送方的ACK会占用带宽资源。</li>
<li>略</li>
<li>报文格式与SR协议相同。</li>
<li>略</li>
<li>略</li>
<li>略</li>
<li>a. k-4~k+3都有可能。极端情况：所有分组全部被正常接收，但所有ACK全部丢失，此时接收方分组第一个序号为k，但发送方分组第一个序号为k-4；另所有分组全部传回ACK，则发送方分组第四个序号为k+3，此时发送方与接收方窗口位置相同。<br>b. k-4~k-1都有可能。发送方发送k-5，接收方收到并且返回ACK(k-5)。发送方收到之前就超时，重发k-5。 发送方收到ACK(k-5)， 发送k-4, k-3, k-2, k-1。接收方收到重发k-5，返回ACK(k-5)。收到k-4, k-3, k-2, k-1，返回ACK(k-4)，ACK(k-3)，ACK(k-2)，ACK(k-1)</li>
<li>对于GBN协议，窗口的最大值为k-1；对于SR协议，窗口的最大值为k/2。需要保证当接收方全部接收到且ACK全部丢失时，接收方能够识别出发送方重传的任何一个分组是老分组而不是新分组。</li>
<li>a. 正确。当出现超时重传时，可能会收到落在窗口前面的ACK。<br>b. 正确。同样是超时重传，另外窗口的第一个ACK丢失也可能导致收到落在窗口前面的ACK。<br>c. 正确<br>d. 正确</li>
<li>因为UDP协议是即时传输，应用程序将数据传递给UDP之后UDP协议就会尽快进行传输，而TCP可能还会对这些数据进行缓存、分片等操作，从而降低了应用程序的控制能力。因为TCP有拥塞控制，而UDP没有，应用程序使用UDP可以完全自行调节发送速度等。</li>
<li>a. 在序号不重复利用的情况下，TCP报文的序号最大值为2^32^-1，那么L的最大值应该为2^32^。<br>b. 需要使用8012999个分组来封装这么多数据，加上首部分组的长度，一共需要传输2^32^+8012999×64字节的数据，需要大约237s的时间。</li>
<li>a. 第一个报文段是由主机A发送，序号为127，含80字节数据，因此第二个报文段的序号为207。源端口号302，目的端口号80。<br>b. 第一个报文段的确认中确认号为207，源端口号80，目的端口号302。<br>c. 如果第二个报文段首先到达，则确认号为127。因为第二个报文段的序号不对。<br>d. 如果第一个确认丢失，丢失的确认报文段中确认号为207。第二个确认（确认号为247）在第一个超时间间隔之后到达，在此之前发送方重传第一个报文段，然后收到了确认号为247的第二个确认报文段，于是不再重传，接收方收到重传的第一个报文段之后再一次返回确认号为247的确认报文段。</li>
<li>本题中主机B读出数据的速率小于发送方发送的速率，因此主机B在发回来的确认报文段中会填入剩余缓存数量，表示剩余能够接受的窗口大小，当返回的窗口大小为0时，A将逐渐减缓发送数据，直到窗口为0时暂停发送。最终的传输速率不会超过50Mbps。</li>
<li>略</li>
<li>a. 当数据输入到套接字的速度过快时，容易导致丢包，进而产生很多重复的数据包占用带宽资源，降低总吞吐量。如果路由器缓存容量增加，则会增加缓存中报文的等待时延，当等待时延过大使得发送方超时是又会进行重传，进一步增加了链路中重复报文的数量，可能会导致吞吐量进一步减少。<br>b. 有助于，因为这样将不会有多余的重复报文占用带宽和缓存。</li>
<li>公式回顾：<script type="math/tex">\operatorname{EstimatedRTT}=\operatorname{EstimatedRTT}×(1-\alpha)+\operatorname{SampleRTT}\times\alpha\\
\operatorname{DevRTT}=\operatorname{DevRTT}\times(1-\beta)+|\operatorname{DevRTT}-\operatorname{EstimatedRTT}|\times\beta\\
\operatorname{TimeoutInterval}=\operatorname{EstimatedRTT}+4\times\operatorname{DevRTT}</script><br>记忆技巧：EstimatedRTT相当于通过前几个RTT加权计算出来的RTT预估值，DevRTT相当于RTT的波动情况，TimeoutInterval相当于此链路中大多数情况下不会超过的RTT值。计算略。</li>
<li>a. $\operatorname{EstimatedRTT}_i=\sum_{j=0}^{i-1}\operatorname{SampleRTT}_i\times0.9^{i+1}+0.1\times\operatorname{SampleRTT}_i$<br>b. 略<br>c. 当n趋于无穷时，可以发现越近的RTT对EstimatedRTT的影响最大。</li>
<li>如果ACK超时，那么重传之后收到的ACK可能不是对应于重传的分组而是一开始发送的分组，这样计算得到的RTT就小于正确的RTT。</li>
<li>LastByteRcvd≤SendBase-1。SendBase是最早未被确认的字节序号，LastByteRcvd是被接收方接收的最大字节序号。如果链路中没有正在传输的分组，则是等于号，否则为小于号。</li>
<li>y≤LastByteRcvd。假设TCP接收方丢弃失序的报文段的场合：在生成ACK的时间，y等于LastByteRcvd，当ACK报文传回发送方的时候，可能有新的报文到达接收方。</li>
<li>这样会导致重传更加频繁，如两个数据包反序就会导致重传，容易占用大量带宽。</li>
<li>主机A向主机B发送5个报文段且第2个丢失。<br>a. 对于GBN，A发送的第一批5个报文段收到4个，发送了4个编号为1的ACK。然后A发送4个报文段，收到4个ACK。一共有8个ACK。对于SR，A发送的第一批5个收到4个，发送了4个不同编号的ACK，然后A发送1个报文段即可，收到1个ACK，一共有5个ACK。TCP协议在发送方接收到3个重传ACK之后就即刻重发，只重发了1个报文段，一共有5个ACK。（<font color=red>注意TCP有缓存机制</font>）<br>b. TCP，因为TCP在检测到3个重复ACK之后就立即重传。</li>
<li>当出现丢包事件时，发送方发送的速率，每个RTT是必须大约等于cwnd报文段。首先发送方发送的速率不能大于cwnd，这是固定的限制条件。发送速率总是大约为cwnd/RTT。</li>
<li>对于图3-46b，即在有限缓存情况下，发送方仅当在确定了一个分组丢失之后才重传，如果$\lambda_{in}’$增加超过了R/2，$\lambda_{out}’$不能增加超过R/3。如果发送速率超过了R/2，则多余的分组一定会丢失，因此增加了链路中重传的报文数量，故接收速率不仅不能增加，还可能会下降。对于图3-46c，即发送方也许会提前发生超时并重传在队列中已经被推迟但还未丢失的分组。这种情况下初始数据分组和重传分组都可能到达接收方，此时可用的吞吐量更加有限。如果一个分组平均重传次数是固定的，那么$\lambda_{in}’$增加可能会导致$\lambda_{out}’$增加，但实际情况下发送速率增加必然会增加重传次数，因此最终$\lambda_{out}’$不会增加。</li>
<li>a. TCP慢启动运行时的时间间隔为1~6、23~26。<br>b. TCP拥塞避免运行时的时间间隔为6~16、17~22。<br>c. 在第16个传输轮回之后，拥塞窗口长度cwnd没有变为1，因此是由于发现了3个冗余ACK而导致的。<br>d. 是根据检测出超时而导致的。<br>e. ssthresh的值设置为32。<br>f. 在第18个传输轮回里，ssthresh的值设置为上一个传输轮回的cwnd的一半，即为21。<br>g. 在第24个传输轮回中，ssthresh的值被设置为上一个传输轮回的cwnd的一半，即14。<br>h. 第70个报文段是在第7个传输轮回中被发送。<br>i. 拥塞的窗口长度为ssthresh+3（因为收到了3个冗余ACK，这是快速恢复的内容，不考），ssthresh的值为4，即变为拥塞长度的一半。cwnd=7。<br>j. 如果使用TCP tahoe，则在第16个轮回后cwnd会变为1。在第19个传输轮回，ssthresh的值为21，拥塞窗口的长度为4。<br>k. 从第17个传输轮回到第22个，分别传输了：1、2、4、8、16、21个分组，一共52个。</li>
<li>TCP的AIMD算法的收敛特性。假设TCP不采用乘性减，而是采用按某一个常量减少窗口。所得的AIAD算法将不能收敛于一个平等共享算法。如果是按照某一个常量减少窗口，则不能够收敛到45°线。假设某个时刻两个连接的传输速率为(r~1~, r~2~)，在没有丢包的情况下，这个点将沿着东北方向（45°）线移动，直到穿过135°的带宽阈值线。如果此时两个连接在一个传输轮回都发生了丢包，那么这个点将沿着225°线沿着西南方向后退，没有向中线移动。如果只有其中一个传输轮回发生了丢包，那么这个点或者向正西移动，或者向正南移动。即使这个点距离传输轮回更近，也没有收敛的意思。考虑到在传输速率过大时，传输速率较大的连接更容易发生丢包，因此这里这个点向中线移动的概率更大，但不能收敛到中线。</li>
<li>如果发生了超时，不减少窗口大小，那么发送方会发送很多的重复数据包，而发生超时时链路可能已经非常拥塞，因此这会恶化情况。因此减少窗口大小可以在一定程度上缓解链路的拥塞情况。</li>
<li>本题出现的情况是，链路的传输速率小于应用程序向套接字输入数据的速度，当发送缓存满时，就无法向套接字输入数据了。考虑到链路中不会有任何分组丢失和计时器超时，因此此问题无法通过拥塞控制来解决。实际上当发送缓存满时，进程传输数据的速率自动就降下来了，因为此时发送缓存将这个进程的任务进行了阻塞。</li>
<li>a. 6RTT<br>b. 平均吞吐量为(6+7+8+9+10+11)/6=8.5MSS。</li>
<li>a. 连接速率从W/2RTT变化到W/RTT，在该周期的结束只丢失了一个分组。这个过程中一共传输了$\frac{\frac{3W}{2}(\frac{W}{2}+1)}{2}=\frac{3W^2}{8}+\frac{3W}{4}$，丢包率=这个值的倒数。<br>b. 一条连接的丢包率为L，要证明平均速率的值，即证一个RTT之内平均传输了$\frac{1.22}{\sqrt{L}}$个数据包。考虑a中出现的理想情况，当W足够大时，$L\approx\frac{8}{3W^2}$，注意W的单位是分组数。可以求出$W=\sqrt{\frac{8}{3L}}$。平均速率应该为$\frac{\frac{3W}{2}(\frac{W}{2}+1)}{2(\frac{W}{2}+1)}=\frac{3W}{4\operatorname{RTT}}\approx\frac{1.22}{\sqrt{L}}$。其中$\frac{3W}{4}$是一个周期平均传输的分组数量。</li>
<li>a. 这条TCP连接取得最大窗口长度时，该链路处于满负荷状态。一个RTT是150ms，因此10Mbps=x×1500×8/RTT，求得x=125。<br>b. 这条连接的平均窗口长度为：(125+125/2)/2=94个报文段，平均吞吐量为94×1500×8/0.15=7.52Mbps。<br>c. 从丢包恢复之后，再一次到达最大窗口一共经历了x-x/2个RTT，即63个RTT，即9.45s。</li>
<li>发送方和接收方之间的链路速率与双向传播时延之积，实际上就等于链路在一个时刻正在传输的最大的分组数量（将链路速率的单位设置为分组数量而不是比特数量）。在前一题中，在出现丢包的时候，cwnd减半，容易发现减半之后链路并没有满负荷工作。现在链路出现了缓存，当发送方的发送速率小于链路的带宽时，缓存可以同时发送分组使得链路保持饱和状态。这个缓存不能太短，否则会过早返回冗余ACK导致发送端暂缓传输（也就是该链路不忙于发送数据），所以必须足够大，大到一个RTT传输的数据量，这样，缓存区满时，再发送包会立刻引发重传。需要注意这里缓存的工作方式。如果发送方在一个RTT之内发送的数据大于一个RTT内能够传输的数据量，那么链路缓存将会缓存发送方最后发送的几个数据包，并使得在这个RTT时间内，发送方除去这几个数据包之外其他的数据包的数据量正好等于这个RTT内链路能够发送的最大数据量。在下一个RTT传输数据时，首先将缓存中的数据发送出去，然后发送发送方的前面一部分数据，再将这个RTT无法发送的数据包进行缓存。正因如此，当缓存满时，在一个RTT之内就会出现丢包的情况，发送方检测到冗余的ACK，将发送窗口减为一半，此时就需要将缓存中的数据包进行发送，逐渐减少缓存中的数据包数量以确保链路处于饱和状态。</li>
<li>a. 125000<br>b. 7.5Gbps<br>c. 156.25min，可以使用乘型增的方式增加。</li>
<li>由45题可知，使用RTT为单位度量的T与W有函数关系，即T=W/2，平均吞吐量=3W/4RTT，因此平均吞吐量可以用T表示。</li>
<li>a. 拥塞链路的带宽为每秒30个报文段，在时刻0，C1的数据速率为200个报文段/s，而C2为100，远远超过链路带宽，因此会减半，直到二者的拥塞窗口都为1时，数据速率等于链路速率。<br>b. 不会。</li>
<li>a. 时刻1，C1=15，C2=10，产生拥塞。时刻2，C1=7，C2=5，产生拥塞。时刻3，C1=3，C2=2，产生拥塞。时刻4，C1=1，C2=1，不产生拥塞。时刻5，C1=2，C2=2，产生拥塞。之后偶数时刻等于时刻4的情况，奇数时刻等于时刻5的情况。在2200ms之后情况等于时刻4的情况，拥塞窗口为1。（2100ms~2200ms时产生拥塞）<br>b. 会。<br>c. 是。<br>d. 不能。可以让两个连接交替拥塞，这样可以提高利用率。</li>
<li>这个乘型增的机制是当一个RTT内没有丢包事件发生时，窗口数量将乘以1+a。对于连续的几个RTT，记第一个RTT的编号为0，窗口长度为W/2，设最后一个RTT（编号为n）的窗口长度$\frac{W}{2}\times (1+a)^n=W$，W为链路最大传输速率（单位为分组数/RTT）。然后丢包，窗口变为一半。因此易得$(1+a)^n=2$，这些RTT一共发送了$\frac{W}{2}\times\frac{(1+a)^{n+1}-1}{a}=\frac{W}{2}\times\frac{2a+1}{a}$个分组，丢包率为其倒数：$L=\frac{2a}{(1+2a)W}$。在这个体系中，TCP连接将其拥塞窗口长度从W/2增加到W的周期时间不变。</li>
<li>使用公式，一条连接的平均吞吐量=$\frac{1.22MSS}{RTT\sqrt{L}}$，取MSS=1500，RTT=100ms，求得L的值为2×10^-12^。</li>
<li>优点：可以略过慢启动和一部分拥塞避免的过程，可以让传输速率提升地更快。缺点：二者对于新的链路环境可能需要多次调整。建议可以增加链路缓存，让链路的使用情况变化地平缓一些。</li>
<li>a. 服务器将向Y发送响应，这个响应可能无法被收到。<br>b. 可以确认。SYNACK将初始序号发送给了Y，其他人无法知道正确的初始序号。</li>
<li>a. S/R&lt;RTT&lt;3S/R</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">时刻</th>
<th style="text-align:center">事件</th>
<th style="text-align:center">窗口大小</th>
<th style="text-align:center">剩余窗口大小</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">发送SYN</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1RTT</td>
<td style="text-align:center">接收SYNACK</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1RTT+1S/R</td>
<td style="text-align:center">发送分组1完毕</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">2RTT+1S/R</td>
<td style="text-align:center">接收ACK1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">2RTT+2S/R</td>
<td style="text-align:center">发送分组2完毕</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2RTT+3S/R</td>
<td style="text-align:center">发送分组3完毕</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">3RTT+2S/R</td>
<td style="text-align:center">接收ACK2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">3RTT+3S/R</td>
<td style="text-align:center">发送分组4完毕，接收ACK3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">3RTT+4S/R</td>
<td style="text-align:center">发送分组5完毕</td>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
</div>
<p>在此之后，分组6和7将分别在3RTT+5R/S和3RTT+6R/S被发送，而考虑到4RTT+3R/S&lt;3RTT+6R/S，因此ACK4先于分组7发送被接收，因此分组7发送完毕后窗口依然不为0，同理4RTT+4R/S&lt;3RTT+7R/S（分组8发送完成的时间），因此ACK5先于分组8发送被接收，由此之后的所有时刻窗口都不会为0，于是就一直发送。最终需要时间为4RTT+14R/S。</p>
<p>b. RTT&gt;3S/R</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">时刻</th>
<th style="text-align:center">事件</th>
<th style="text-align:center">窗口大小</th>
<th style="text-align:center">剩余窗口大小</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">发送SYN</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1RTT</td>
<td style="text-align:center">接收SYNACK</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1RTT+1S/R</td>
<td style="text-align:center">发送分组1完毕</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">2RTT+1S/R</td>
<td style="text-align:center">接收ACK1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">2RTT+2S/R</td>
<td style="text-align:center">发送分组2完毕</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">2RTT+3S/R</td>
<td style="text-align:center">发送分组3完毕</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">3RTT+2S/R</td>
<td style="text-align:center">接收ACK2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">3RTT+3S/R</td>
<td style="text-align:center">发送分组4完毕，接收ACK3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">3RTT+4S/R</td>
<td style="text-align:center">发送分组5完毕</td>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">3RTT+5S/R</td>
<td style="text-align:center">发送分组6完毕</td>
<td style="text-align:center">4</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">3RTT+6S/R</td>
<td style="text-align:center">发送分组7完毕</td>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">4RTT+3S/R</td>
<td style="text-align:center">接收ACK4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">4RTT+4S/R</td>
<td style="text-align:center">发送分组8完毕，接收ACK5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">4RTT+5S/R</td>
<td style="text-align:center">发送分组9完毕，接收ACK6</td>
<td style="text-align:center">7</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">4RTT+6S/R</td>
<td style="text-align:center">发送分组10完毕，接收ACK7</td>
<td style="text-align:center">8</td>
<td style="text-align:center">5</td>
</tr>
</tbody>
</table>
</div>
<p>在此之后，发送到第15个分组之前窗口数量都不会变成0了，因此总时间为5RTT+11R/S。</p>
<p>c. RTT&lt;S/R</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">时刻</th>
<th style="text-align:center">事件</th>
<th style="text-align:center">窗口大小</th>
<th style="text-align:center">剩余窗口大小</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">发送SYN</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1RTT</td>
<td style="text-align:center">接收SYNACK</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1RTT+1S/R</td>
<td style="text-align:center">发送分组1完毕</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">2RTT+1S/R</td>
<td style="text-align:center">接收ACK1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">2RTT+2S/R</td>
<td style="text-align:center">发送分组2完毕</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">3RTT+2S/R</td>
<td style="text-align:center">接收ACK2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">2RTT+3S/R</td>
<td style="text-align:center">发送分组3完毕</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">3RTT+3S/R</td>
<td style="text-align:center">接收ACK3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">2RTT+4S/R</td>
<td style="text-align:center">发送分组4完毕</td>
<td style="text-align:center">4</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
</div>
<p>考虑到发送一个分组的传输时延大于RTT，因此分组5发送完毕之前分组4就已经确认，剩余窗口大小等于窗口大小-1，而窗口大小不断增加，因此后面所有分组都将连续发送。共需要3RTT+15S/R。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%AC%AC3%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%AC%AC3%E7%AB%A0/" class="post-title-link" itemprop="url">计算机网络——第3章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-02 23:46:08 / Modified: 23:59:49" itemprop="dateCreated datePublished" datetime="2023-03-02T23:46:08+08:00">2023-03-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>8.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>8 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Chapter-3-传输层"><a href="#Chapter-3-传输层" class="headerlink" title="Chapter 3 传输层"></a>Chapter 3 传输层</h1><h2 id="3-1-概述和运输层服务"><a href="#3-1-概述和运输层服务" class="headerlink" title="3.1 概述和运输层服务"></a>3.1 概述和运输层服务</h2><p>运输层的功能：为不同主机上运行的应用进程之间提供<font color=red>逻辑通信</font><br>工作内容：</p>
<ul>
<li>发送方：将应用数据划分为报文段，交给网络层</li>
<li>接收方：将报文段重组成应用数据，交付给应用层</li>
</ul>
<p>运输层和网络层的区别：</p>
<ul>
<li>网络层：是不同主机之间的逻辑通信，网络层只负责将一个主机上的报文成功发送到另外一个主机，至于应该由主机上的哪一个进程接收，是运输层需要考虑的事情。</li>
<li>运输层：是不同应用进程之间的逻辑通信。</li>
<li>不同的运输层协议可能提供不一样的服务</li>
<li>运输层协议能够提供的服务收受到底层网络协议的服务模型的限制</li>
<li>在网络层不提供某些服务的情况下，需要由运输层自己提供</li>
</ul>
<font color=red>端口</font>：让应用层的各种应用进程都能将其数据通过端口向下交付给运输层，以及让运输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程（或线程）。从这个意义上讲，端口是用来标志应用层的进程（或线程）。端口使用16bit端口号标识。

### 3.2 多路复用和多路分解
<font color=red>套接字：TCP连接的端点。</font>TCP使用连接而不仅仅是端口作为最基本的抽象。套接字将IP地址和端口号整合在一起。

报文段的发送：
- 主机接收到IP包
    - 每一个数据包都有源IP地址和目的IP地址
    - 每一个数据包都携带一个传输层的数据报文段
    - 每一个数据报文段都有源、目的端口号
- 主机根据“IP地址+端口号”将报文段定向到对应的套接字。

#### 无连接的运输层协议
创建的套接字具有主机本地端口，创建数据报发送到UDP套接字时，必须指定目的地IP地址和目的端口。<font color=red>UDP数据报仅有本地的端口号和远程端口号，并不包含本地和远程的IP地址。</font>
当主机接收到UDP数据报，需要检查报文段的目的地端口，然后将UDP报文段发送给该端口号的套接字。
注意<font color=red>IP数据报与UDP数据报具有相同的目的端口，但不同的源IP和/或源端口号将被发送到目的地址相同的套接字。对于UDP，发给同一个进程的数据，无论是从哪来，都只用一个套接字来接收。也即在一台主机上发送UDP报文可以修改IP报文的IP地址，让目的主机误以为有多个IP的多个主机向它发送报文，但TCP不行。</font>

<h4 id="有连接的运输层协议"><a href="#有连接的运输层协议" class="headerlink" title="有连接的运输层协议"></a>有连接的运输层协议</h4><p>TCP套接字由一个四元组标识（一个连接一组套接字），其中包含源和目的IP地址、源和目的端口号。<br>接收方主机根据这4个值将报文段定向到相应的套接字。服务器主机同时支持多个并发的TCP套接字，Web服务器为每一个客户连接都产生不同的套接字（非持久HTTP对每一个请求都会建立一个不同的套接字，会影响性能）。</p>
<h2 id="3-3-无连接传输：UDP"><a href="#3-3-无连接传输：UDP" class="headerlink" title="3.3 无连接传输：UDP"></a>3.3 无连接传输：UDP</h2><p>UDP处理数据的流程（UDP无连接）：</p>
<ul>
<li>发送方<ul>
<li>从应用进程获得数据</li>
<li>附加上为多路复用/多路分解所需的<font color=red>源和目的端口号</font>以及<font color=red>差错检查信息</font>，形成报文段。</li>
<li>递交给网络层，尽力而为地交付给接收主机</li>
</ul>
</li>
<li>接收方<ul>
<li>从网络层接收报文段</li>
<li>根据目的端口号，将数据交付给相应的应用进程</li>
</ul>
</li>
</ul>
<p>UDP的优势：</p>
<ul>
<li>无需建立连接，可以减少时延</li>
<li>简单，发送方和接收方无需维护连接状态</li>
<li>段首部开销较小，UDP段首只有8字节而TCP有20字节</li>
<li>无拥塞控制，UDP可以随时按照需要发送</li>
</ul>
<p>部分采用UDP协议的应用：</p>
<ul>
<li>远程文件服务器</li>
<li>流式多媒体</li>
<li>网络电话（SNMP）</li>
<li>选录协议（RIP）</li>
<li>域名解析（DNS）</li>
</ul>
<p>UDP滥用的后果：</p>
<ul>
<li>路由器中的大量分组溢出，使得丢包率显著增加，反过来影响到UDP本身的传输效率</li>
<li>显著减小TCP的传输速率，甚至挤垮TCP会话</li>
</ul>
<p>UDP也可以实现可靠传输，但是需要应用层进行辅助控制，需要应用层特殊的错误恢复，增加了应用进程的实现难度。</p>
<h3 id="3-3-1-UDP报文段结构"><a href="#3-3-1-UDP报文段结构" class="headerlink" title="3.3.1 UDP报文段结构"></a>3.3.1 UDP报文段结构</h3><p>UDP的报文段结构很简单，从前往后依次为：源端口号、目的端口号、长度、校验和、数据。其中长度是包含首部的长度，除了数据之外首部的4个控制结构各占16比特。</p>
<h3 id="3-3-2-UDP检验和"><a href="#3-3-2-UDP检验和" class="headerlink" title="3.3.2 UDP检验和"></a>3.3.2 UDP检验和</h3><p>UDP校验和提供差错检测功能，检验和用于确定当UDP报文段从源向目的地移动时，其中的比特是否发生了改变。</p>
<p>发送方对UDP校验和的计算方式：将报文段看做16比特一组的多组构成的序列，对报文的所有16比特字的和进行反码计算，获得校验码。<font color=red>如果在求和的过程中出现进位，需要提取进位并加到结果上。在校验和尚未计算时，校验和字段填充为全0进行计算，在计算完成后再用结果替换这里的全0。</font></p>
<p>接收方的验证方式：按照同样的方式以16比特为单位计算，如果最终结果为全1则认为没有错误（不是一定没有错误），否则认为有错误。</p>
<h2 id="3-4-可靠数据传输原理"><a href="#3-4-可靠数据传输原理" class="headerlink" title="3.4 可靠数据传输原理"></a>3.4 可靠数据传输原理</h2><p>可靠数据传输的问题不仅在运输层出现，也会在链路层以及应用层出现。可靠数据传输队上层实体提供的服务可以抽象为：数据可以通过一条<font color=red>可靠信道</font>进行传输。借助于可靠信道，传输数据比特就不会收到损坏或丢失，且所有数据都是按照发送顺序交付。</p>
<p><img src="https://img-blog.csdnimg.cn/a80b5a8cea4b428a9422558f3caba501.png" alt=""></p>
<p><img src="https://img-blog.csdnimg.cn/af6744d7c08e4c328f22d4dc54b60e8d.png" alt=""></p>
<h3 id="3-4-1-构造可靠数据传输协议"><a href="#3-4-1-构造可靠数据传输协议" class="headerlink" title="3.4.1 构造可靠数据传输协议"></a>3.4.1 构造可靠数据传输协议</h3><h4 id="经完全可靠信道的可靠数据传输：rdt-1-0"><a href="#经完全可靠信道的可靠数据传输：rdt-1-0" class="headerlink" title="经完全可靠信道的可靠数据传输：rdt 1.0"></a>经完全可靠信道的可靠数据传输：rdt 1.0</h4><p>最简单的情况：<font color=red>底层信道完全可靠</font>。在底层信道可靠的情况下，发送端和接收端不需要进行另外的操作。<br><img src="https://img-blog.csdnimg.cn/486001b84e804ddaa516a6184027b517.png" alt=""></p>
<h4 id="经具有比特差错信道的可靠数据传输：rdt-2-0"><a href="#经具有比特差错信道的可靠数据传输：rdt-2-0" class="headerlink" title="经具有比特差错信道的可靠数据传输：rdt 2.0"></a>经具有比特差错信道的可靠数据传输：rdt 2.0</h4><p>在分组的传输、传播或缓存的过程中，比特差错通常会出现在网络的物理部件中。</p>
<p>需要引入==肯定确认==和==否定确认==两种控制报文使得接收方可以让发送方知道哪些内容被正确接收。基于这种重传机制的可靠数据传输协议被称为<font color=red>自动重传请求（ARQ）协议</font>。</p>
<p>ARQ协议中还需要：</p>
<ul>
<li>差错检测：需要一种机制使得接收方检测到何时出现了比特差错。</li>
<li>接收方反馈：让接收方提供反馈信息给发送方确认。</li>
<li>重传：当接收方接收到异常的分组时发送方重传该分组。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/49e85330214e42c4892748c8aa990618.png" alt=""></p>
<p>上图解释：</p>
<ul>
<li>发送方：<ul>
<li>当上层调用时，高层调用rdt_send，低层首先计算校验值，然后发送。</li>
<li>如果接收到NAK，则重传。实现重传需要一个缓冲区保存未获得反馈的报文，长度只需要达到一个报文的大小即可。</li>
<li>如果接收到ACK，则待命。</li>
</ul>
</li>
<li>接收方：<ul>
<li>当接收到数据时，低层提取数据后传递给上层，上层计算校验值没有问题，让下层发送ACK。如果发现问题，让下层发送NAK。</li>
</ul>
</li>
</ul>
<p>注意：<font color=red>当发送方处于等待ACK或NAK的状态时，它不能从上层获得更多数据。因此发送方将不会发送一块新的数据，除非发送方确信接收方已经接收到当前分组。这种协议称为停等协议。</font></p>
<p>缺陷：没有考虑到ACK或NAK受损的可能性。<br>处理方案：</p>
<ul>
<li>发送方和接收方交替重传报文，这样会陷入死循环。</li>
<li>增加足够的检验和比特使得发送方不仅可以检测差错还可以修复差错。</li>
<li>当发送方收到含糊不清的ACK或NAK时，只重传当前数据分组即可，这样会产生冗余分组。为了将该分组与新的分组区分，需要为数据包引入编号。（下一个版本的方法）</li>
</ul>
<h4 id="第二个版本：rdt-2-1"><a href="#第二个版本：rdt-2-1" class="headerlink" title="第二个版本：rdt 2.1"></a>第二个版本：rdt 2.1</h4><ul>
<li>如果发送方接收到重复的ACK，当做NAK重传。</li>
<li>为每一个数据包加上序号。</li>
<li>接收方收到重复序号的数据会丢弃。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/4123bc776fc041debb7b36ef824b355e.png" alt=""></p>
<p>这里实际上将2个状态转换为4个状态，只是将相邻发送的数据包赋予不同的编号0和1。这样可以区分相邻两个数据包。</p>
<p><img src="https://img-blog.csdnimg.cn/2717b7f8bdd84487977dfc3a48378c78.png" alt=""></p>
<h4 id="再次改进：rdt-2-2"><a href="#再次改进：rdt-2-2" class="headerlink" title="再次改进：rdt 2.2"></a>再次改进：rdt 2.2</h4><p>去掉了NAK报文，只需要使用ACK报文即可。如果接收方接收到了受损的分组，可以对上一次正确接收的分组发送一个ACK，发送方接收到对同一个分组的两个ACK后就知道接收方有没有正确接收到跟在被确认两次的分组后面的分组。与2.1的细微变化在于：<font color=red>接收方此时必须包括由一个ACK报文所确认的分组序号（0或1），发送方此时必须检查接收到的ACK报文中被确认的分组序号</font>。</p>
<p><img src="https://img-blog.csdnimg.cn/53e387cd8b454c85a7d483a8b42ca358.png" alt=""></p>
<h4 id="信道丢包时的解决方案：rdt-3-0"><a href="#信道丢包时的解决方案：rdt-3-0" class="headerlink" title="信道丢包时的解决方案：rdt 3.0"></a>信道丢包时的解决方案：rdt 3.0</h4><p>发生丢包后的处理方法：校验和技术、序号、ACK、重传。<br>只需进行等待，就可以知道是否丢包。</p>
<p><img src="https://img-blog.csdnimg.cn/9add2f99f37f4dd68f9f45fec3891946.png" alt=""></p>
<p>相比较2.2，发送方增加了计时器，当等待时间过长时，重新发送数据包。</p>
<p>发送方需要等待：发送方与接收方之间的一个往返时延加上接收方处理一个分组的时间。这需要发送方明智地选择一个时间值来判断是否发生了丢包。</p>
<p><img src="https://img-blog.csdnimg.cn/d52ee1401d1b4b2b86c3e55b9d76357f.png" alt=""></p>
<p><img src="https://img-blog.csdnimg.cn/1debf48c03534f42ba846c60a86f51eb.png" alt=""></p>
<p>这里要尤其注意后面两种丢包情况的处理。</p>
<h3 id="3-4-2-流水线可靠数据传输协议"><a href="#3-4-2-流水线可靠数据传输协议" class="headerlink" title="3.4.2 流水线可靠数据传输协议"></a>3.4.2 流水线可靠数据传输协议</h3><h4 id="rdt-3-0性能分析"><a href="#rdt-3-0性能分析" class="headerlink" title="rdt 3.0性能分析"></a>rdt 3.0性能分析</h4><p>这是一个停等协议，如果一个数据包的传输时延为10ms，传播时延为100ms，那么一个数据包发送完成至少需要210ms（忽略ACK报文的传输时延，RTT=200ms），这会使得信道在大部分时间处于空闲状态，在这210ms中如果一直传输数据，可以传输21个数据包，但这里只传输了1个。网络协议限制了物理资源的利用率。</p>
<p>改进方法：不使用停等协议，使用<font color=red>流水线技术</font>。</p>
<p>流水线技术允许发送方发送多个数据包而无需接收方确认，因此编号不能只是0和1。如果在发送过程中出现错误需要重传，因此发送方需要缓存。如果需要处理失序的数据包，则接收方也需要一定的缓存。<font color=red>注意流水线模式中对于链路利用率的计算，分母的L/R是不用乘以分组长度的！</font></p>
<p><img src="https://img-blog.csdnimg.cn/de70862fa7f24b56aad9f39b59fb56c7.png" alt=""></p>
<p>流水线技术的工作原理：</p>
<ul>
<li>分组首部使用k-比特字段表示序号</li>
<li>未被传输和已被传输但还没有确认的分组的许可序号范围可以看做是一个在序号范围内大小为N的<font color=red>“窗口”</font>。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/ce0ac6c1284c4e9984098c2bf100ea6b.png" alt=""></p>
<p>根据流水线技术丢失分组的重传策略，可以将其分为<font color=red>GBN协议和SR协议</font>，GBN协议其后分组全部重传，SR协议仅重传该分组。</p>
<p><img src="https://img-blog.csdnimg.cn/a62cf522abb9499f9aef89697ef34c08.png" alt=""></p>
<p><img src="https://img-blog.csdnimg.cn/986eca5b7bc348e4ae8b88b47aa7e7b3.png" alt=""></p>
<h3 id="3-4-3-回退N步"><a href="#3-4-3-回退N步" class="headerlink" title="3.4.3 回退N步"></a>3.4.3 回退N步</h3><p>特点：</p>
<ul>
<li>接收方对序号n之前包括n在内的所有分组进行确认，标志着序号n以及n以前的分组已经全部接收完成。</li>
<li>允许发送方能且只能连续发送n个数据包，若窗口大小为n。同时，窗口中未被确认的分组数量不能超过n。</li>
<li>对所有已经发送但未确认的分组统一设置一个定时器，从一次流水的最“老”分组开始计时。超时时重传分组n和窗口中所有序号大于n的分组。</li>
<li>接收方收到重复的分组时，会丢弃该分组并重发ACK，因此<font color=red>GBN协议中的接收方不需要缓存</font>。</li>
<li>分组失序时，将失序的分组丢弃，并重发按序到达的最高序号分组的ACK。</li>
<li>GBN协议在发送端的滑动窗口大小为2^k^-1，在接收端的大小为1。</li>
</ul>
<h3 id="3-4-4-选择重传"><a href="#3-4-4-选择重传" class="headerlink" title="3.4.4 选择重传"></a>3.4.4 选择重传</h3><ul>
<li>发送方<ul>
<li>从上层收到数据，如果下一个可用于该分组的序号在窗口内，则将数据打包并发送。</li>
<li>为每一个分组定义计时器，超时时重传分组n并重置计时器。</li>
<li>如果收到在窗口编号范围内的ACK，则标记分组为已经接收，如果这个分组是窗口中的第一个分组，则将窗口的基序号前推到下一个未确认序号。</li>
</ul>
</li>
<li>接收方<ul>
<li>也定义一个窗口，用于接收。</li>
<li>如果接收到的数据包分组在窗口内，则发送ACK，如果失序则将其缓存。将该分组以及以前缓存的需要连续的分组一起交付给上层，将窗口前推到下一个未收到的分组。虽然曾经确认过，仍然再一次发送ACK。</li>
<li>否则忽略该分组。</li>
</ul>
</li>
</ul>
<font color=red>接收方窗口必须小于或等于序号空间大小的一半</font>，这样可以保证在窗口移动过程中，不会有相同序号的数据包在窗口内。因为如果ACK包丢失会导致接收方和发送方的窗口位置不同，全部ACK包丢失时，接收方的窗口在发送方窗口的前面，此时由于发送方没有接收到任何ACK，因此发送老编号的数据包，接收方需要保证此时其窗口中不含有对应该编号的数据包缓存。

当接收方窗口太大时，可能会导致发送方和接收方的发送和接收缺乏同步。窗口必须小于序号范围。

## 3.5 面向连接的传输：TCP
TCP是因特网运输层的面向连接的可靠的传输协议。
TCP连接仅存在于端系统，中间的路由器和交换机不知情。
TCP支持全双工服务。
TCP为点对点连接。
需要三次握手，具有最大报文段长度MSS。
### 3.5.1 TCP连接
TCP连接的建立过程：<font color=red>将发起连接的进程称为客户进程，另一个进程称为服务进程。客户首先发送一个特殊的TCP报文段，服务器使用另一个TCP报文相应，最后客户使用第三个特殊报文段响应。前两个报文不包含数据（有效载荷），第三个报文可以包含有效载荷。这被称为“三次握手”过程。</font>

<font color=red>发送缓存</font>：发起TCP三次握手期间设置的缓存之一。接下来TCP会不时从发送缓存中取出一块数据，并将数据传输到网络层。

<font color=red>最大报文段长度（MSS）</font>：通常根据最初确定的由本地发送主机发送的<font color=red>最大链路层帧长度（MTU）</font>来设置。<font color=red>二者的计算公式是：MTU=MSS+TCP头长度+IP头长度</font>。头部长度通常为40字节，以太网和PPP链路层协议的MTU均为1500字节，因此MSS的典型值为1460字节。

TCP为每块客户数据配上一个TCP首部，从而形成多个TCP报文段。

### 3.5.2 TCP报文段结构
![](https://img-blog.csdnimg.cn/81b1e82ca40448679641d7c06d34cbfb.png)

- 源端口和目的端口：各占2字节。
- 序号：占4字节，TCP数据流中的<font color=red>每一个字节</font>都会编上序号，这里的值指的是本报文段第一个字节在整个报文字节流中的序号。
- 确认号：占4字节，值为<font color=red>期望收到对方的下一个报文段的数据</font>的第一个字节的序号。
- 首部长度：4比特，以32bit为单位的首部长度，为空时默认为20字节。
- 保留字段：6比特，目前无用。
- 紧急比特URG：为1时紧急指针标识该报文中紧急数据内容的地址。
- 确认比特ACK：为1时确认号字段才有效。
- 推送比特PSH：接收 TCP 收到推送比特置 1 的报文段，就尽快地交付给接收应用进程，而不再等到整个缓存都填满了后再向上交付。
- 复位比特RST：当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。
- 同步比特SYN：同步比特 SYN 置为 1，就表示这是一个连接请求或连接接受报文。
- 终止比特FIN：用来释放一个连接。当FIN = 1 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。
- 窗口：2字节，控制对方发送的数据量，单位为字节。TCP连接的一端根据这个值设置自己的缓存窗口大小，然后通知对方以确定对方的发送窗口的上限。可用于流量控制。
- 校验和：2字节，校验包括首部和数据的所有内容，计算时需要在报文的最前面加上12字节的伪首部。
- 紧急指针字段：2字节，紧急指针指出在本报文段中的紧急数据的最后一个字节的序号。
- 选项字段：长度可变，TCP只规定一个选项：MSS。其为数据段的最大长度。
- 填充字段：填充使得长度为32比特的整数倍。

### 3.5.3 往返时间的估计和超时
<font color=red>样本RTT</font>：对报文段被发出到收到该报文段的确认之间的时间进行测量。样本RTT会有波动，要使得估算RTT更平滑，需要将最近几次的测量进行平均，而非仅仅采用最近一次的SampleRTT。

计算方式：<font color=red>估算RTT=(1-α)\*估算RTT+α\*样本RTT</font>。这里α参考值为0.125。即测量的时间越久远，对估算RTT的影响越小。

估计估算RTT与样本RTT之间的<font color=red>偏差</font>：<font color=red>偏差=(1-β)\*偏差+β\*|估算RTT-样本RTT|</font>。β的参考值为0.25。第一次计算时偏差=0.5*样本RTT。

### 3.5.4 可靠数据传输

TCP的<font color=red>超时间隔</font>设置为：<font color=red>估算RTT+4*偏差RTT</font>。注意<font color=red>TCP只使用唯一的一个超时定时器</font>。在超时时重传认为超时的定时器，并重启定时器。如果收到重复的ACK，则在更新sendbase之后，如果当前还有未确认的报文段，则也将定时器重置。<font color=red>当出现超时后，超时间隔值加倍</font>。如果已经超时，再重传分组可能会加剧拥塞，这是一种形式受限的拥塞控制。

![](https://img-blog.csdnimg.cn/0241912272cd41e687f97784074b2d8c.png)

快速重传机制：超时周期往往很长，会影响到传输速度。可以通过添加重复的ACK检测丢失报文段。如果<font color=red>重复的ACK接收了超过3个，则认为需要重传</font>。

### 3.5.5 流量控制
TCP流量控制的目标是当接收方处理速度较慢时，不至于让接收方缓存溢出。方法是接收方在反馈时将缓冲区剩余空间的大小填充在报文段首部的窗口字段中，通知发送方。

当接收方缓存满时，会通知发送方让其不再发送数据。而若接收方之后不发送任何数据给发送方，那么接收方缓存清空了发送方也无法知道。解决方法是发送方在知道接收方缓存为0之后持续发送数据长度为1的报文进行试探，如果缓存发生改变则接收方就不会发送rwnd=0的ACK。

### 3.5.6 TCP连接管理
#### TCP建立
- 客户端向服务端发送一个特殊的TCP报文段，其中不含应用层数据，但在报文段首部SYN比特置为1。这个报文被称为SYN报文段。之后客户端<font color=red>随机选择一个初始序号client_isn</font>并将该需要放置于该起始的SYN报文段的序号字段中。该报文段会被封装在IP数据报中，并发送给服务端。
- 服务端接收到TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向该TCP客户发送允许连接的报文段，该报文段不包含任何应用层数据。该报文段的SYN置为1，确认号字段置为client_isn+1。最后服务器选择自己的初始序号server_isn并放置到序号字段。该报文段被称为SYNACK报文段。
- 收到SYNACK之后，客户为该连接分配缓存和变量。客户机向服务器发送另外一个报文段，对服务器的允许连接的报文段进行了确认，SYN置为0，负载可以有数据。

#### TCP释放
- 主机中的资源被释放，如果客户打算关闭连接，则客户TCP向服务器进程发送一个特殊的TCP报文段，FIN比特置为1。服务器接收到报文后向发送方回送一个确认报文段，然后服务器发送自己的终止报文段，其FIN比特置为1，最后由客户对服务器发来的报文进行确认。这即是四次挥手。

## 3.6 拥塞控制原理
当路由器缓存溢出时，会导致网络拥塞，造成丢包和时延增加。

### 3.6.1 拥塞原因与代价

#### 情景1
两个发送方，两个接收方，一个具有无限大缓存的路由器，没有重传，忽略低层协议的影响，链路容量为R，两个发送方的发送速率相等。由于发送过程中路由器需要进行选路、缓存等操作，因此一个数据包从发送到接收并不是畅通无阻地行进在链路之中的。当链路越来越接近满负荷状态时，路由器的压力将会增加。虽然此时接收方依然可以以R的速度接收数据包，但是由于各种其他处理的时间积累，其排队的队列长度最终会积累到很大。

![](https://img-blog.csdnimg.cn/997a699de3e44bc2a0c845ce3ef2c37a.png)

 #### 情景2
两个发送方和一台具有有限缓存的路由器。发送方对丢失的分组进行重传。
由于分组出现了重传现象，发送方的发送速率将大于接收方的接收速率。理想状态下，分组仅仅在丢失时才重传，这样可以让冗余的分组数量最少，但实际上有些分组可能会超时，此时进行重传就会增加冗余，占用链路资源。

此时拥塞的开销主要有：
- 发送方必须重传以补偿因为缓存溢出而丢失的分组
- 发送方在遇到大时延时所进行的不必要重传会引起路由器转发不必要的分组拷贝而占用其链路带宽。

#### 情景3
四个发送方，每个主机都有相同的λ~i~值，具有多跳路径，链路容量为R，会产生超时和重传。
![](https://img-blog.csdnimg.cn/e614e1a5d75d4485bde28e717a6ee1f2.png)

当重传的数量过多时，既不能增加传输的速率，还占据了大量的链路资源，整个链路陷入崩溃。当分组被丢弃时，该分组曾用到的所有上游传输容量都被浪费了。

### 3.6.2 拥塞控制方法
- 网络辅助的拥塞控制：
    - 直接网络反馈：路由器以阻塞分组的形式通知发送方“网络拥塞”
    - 经由接收方的网络反馈：路由器标识从发送方流向接收方分组中的某个字段以指示拥塞的产生，由接收方通知发送方“网络拥塞”
- 端到端拥塞控制
    - 网络层不为拥塞控制提供任何帮助和支持
    - 端系统通过对网络行为的观测判断网络是否发生拥塞
    - <font color=red>目前TCP采用此方法</font>

<h2 id="3-7-TCP拥塞控制"><a href="#3-7-TCP拥塞控制" class="headerlink" title="3.7 TCP拥塞控制"></a>3.7 TCP拥塞控制</h2><p>TCP拥塞控制的方法：</p>
<ul>
<li>每个发送方自动感知网络拥塞的程度</li>
<li>发送方根据感知的结果限制外发的流量<ul>
<li>如果前方路径上出现了拥塞，则降低发送速率</li>
<li>如果前方路径上没有出现拥塞，则增加发送速率</li>
</ul>
</li>
</ul>
<h4 id="TCP发送方限制外发流量速率的方法"><a href="#TCP发送方限制外发流量速率的方法" class="headerlink" title="TCP发送方限制外发流量速率的方法"></a>TCP发送方限制外发流量速率的方法</h4><p>通过拥塞窗口控制。<br>LastByteSent-LastByteAcked&lt;=CongWin<br>发送速率=CongWin/RTT bps<br>感知拥塞的方法：</p>
<ul>
<li>超时</li>
<li>收到了三个冗余ACK</li>
</ul>
<h4 id="TCP检测到拥塞时如何控制"><a href="#TCP检测到拥塞时如何控制" class="headerlink" title="TCP检测到拥塞时如何控制"></a>TCP检测到拥塞时如何控制</h4><p>TCP拥塞控制算法（Reno算法），<font color=red>加性增，乘性减。</font></p>
<p>出现丢包事件后将当前CongWin大小减半，可以大大减少注入到网络中的分组数量。<br>当没有丢包时间发生时，每个RTT之后将CongWin增加一个MSS，使得拥塞窗口缓慢增大，以防止网络过早出现拥塞。</p>
<h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><p>建立连接时，CongWin = 1MSS<br>当可用带宽远大于MSS/RTT时，初始阶段以指数的速度增加发送速率，直到发生一个丢包事件为止。</p>
<p>即<font color=red>初始速率很低但是速率的增长速度很快</font>。</p>
<h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p>收到3个重复ACK时将CongWin减为原来的一半，线性增大拥塞窗口。<br>超时事件发生时，<font color=red>门限值设置为当前CongWin的一半</font>（门限值初始值为65KB，即16MSS）<br>将CongWin设置为1个MSS大小。<br>窗口以指数速度增大，增大到门限值之后再以线性速度增大。</p>
<p><img src="https://img-blog.csdnimg.cn/311bb6a3c348419bad5fff90f72e0299.png" alt=""></p>
<p>总结：</p>
<ul>
<li>当拥塞窗口CongWin小于门限值ssthresh时，发送方处于慢启动阶段，窗口以指数速度增大。</li>
<li>当拥塞窗口CongWin大于门限值时，发送方处于拥塞避免阶段，窗口线性增大。</li>
<li>当收到3个重复ACK时，门限值设置为拥塞窗口的1/2，而拥塞窗口CongWin设置为门限值。</li>
<li>当超时事件发生时，门限值设置为拥塞窗口的1/2，而拥塞窗口CongWin设为1个MSS。</li>
</ul>
<h4 id="TCP的吞吐量"><a href="#TCP的吞吐量" class="headerlink" title="TCP的吞吐量"></a>TCP的吞吐量</h4><p>平均而言，吞吐量是丢包率L的函数：</p>
<script type="math/tex; mode=display">\frac{1.22\times MSS}{RTT\sqrt{L}}</script><h3 id="3-7-1-公平性"><a href="#3-7-1-公平性" class="headerlink" title="3.7.1 公平性"></a>3.7.1 公平性</h3><p>目标：如果K个TCP连接共享同一个带宽为R的瓶颈链路，每个连接的平均传输速率为R/K。</p>
<p><img src="https://img-blog.csdnimg.cn/8a1c4b2e4b224eceac03f23399846015.png" alt=""></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%AC%AC2%E7%AB%A0%E4%B9%A0%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E7%AC%AC2%E7%AB%A0%E4%B9%A0%E9%A2%98/" class="post-title-link" itemprop="url">计算机网络——第2章习题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-02 23:45:36 / Modified: 23:46:04" itemprop="dateCreated datePublished" datetime="2023-03-02T23:45:36+08:00">2023-03-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="课后习题和问题"><a href="#课后习题和问题" class="headerlink" title="课后习题和问题"></a>课后习题和问题</h2><h3 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h3><ol>
<li>web应用：使用HTTP协议<br>文件传输应用：使用FTP协议<br>邮件应用：SMTP协议<br>P2P应用：BitTorrent协议<br>远程登录：telnet协议</li>
<li>网络体系结构指的是网络5层结构，应用程序体系结构由应用程序研发者设计，规定了如何在各种端系统上组织该应用程序，含P2P体系结构和CS结构。</li>
<li>对于两个进程的通信会话，先发起对话的是客户，另外一个是服务器。</li>
<li>不同意，通信会话的两方一定一方是客户，一方是服务器，只是P2P应用下一台主机在不同的通信会话中可能是不同的角色，而CS模型中的服务器一般是固定的某些主机。</li>
<li>IP地址+端口号可以唯一确定当前主机所在网络中的一个进程。</li>
<li>UDP，UDP虽然不可靠但速度比TCP快。</li>
<li>实时社交软件</li>
<li>可靠数据传输：TCP协议保证<br>吞吐量要求：都不保证<br>定时：都不保证<br>安全性：都不保证</li>
<li>应用层，UDP不能使用SSL。<h3 id="2-2-2-4"><a href="#2-2-2-4" class="headerlink" title="2.2~2.4"></a>2.2~2.4</h3></li>
<li>握手协议是指主要用来让客户端及服务器确认彼此的身份的一类网络协议。</li>
<li>因为HTTP、SMTP和POP3都是要求数据完全正确没有错误的，而TCP可以保证数据正确，但UDP不行。</li>
<li>当用户首次访问该网站时，该网站向用户发送一个独特的cookie，在用户下单时，cookie随着下单请求发送到用户，服务器由此确定发起这个请求的是哪一个用户，并记录这条购买记录。 </li>
<li>Web缓存器会保存最近请求的对象，当未来再一次请求该对象时可以直接调出来，减少对象的请求，以减少接收被请求对象的时延。只是减少其中某些对象的时延，对于缓存中没有的对象，还是需要进行常规的请求，不会减少其时延。</li>
<li>略</li>
<li>略</li>
<li>略</li>
<li>略</li>
<li>邮件不考</li>
<li>邮件不考</li>
<li>略</li>
</ol>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><ol>
<li>a. 错误，请求一些文本和3幅图像组成的Web页面，其本质还是Web图像，形式为HTTP报文，因此接收的是1个响应报文。注意<font color=red>无论是采用非持续连接还是持续连接，一个请求报文一定对应一个响应报文，不请求是不会有响应的，唯一的区别就是连接的建立和断开。对于本题而言，如果使用持续连接，那么在连接断开之前客户端还会发送3个请求给服务器请求那3幅图像。</font><br>b.  正确，因为两个地址的域名相同，因此服务器相同，可以通过一个连接发送数据。<br>c. 错误，在非持续连接中，一个TCP连接只能发送一个请求和一个响应。<br>d. 错误，Date指的是服务器产生并发送该响应报文的日期和时间。<br>e. 错误，HTTP请求可以有空报文体。</li>
<li>略</li>
<li>还需要DNS（应用层）、UDP（运输层）、TCP（运输层）。注意DNS服务使用UDP报文段封装。</li>
<li>a. gaia.cs.umass.edu<br>b. 1.1<br>c. 持续连接<br>d. 在报文段中没有找到<br>e. Mozilla/5.0(Windows;U; Windows NT 5.1; en-US; rv:1.7.2)对于不同的浏览器，服务器可能会返回不同的内容。</li>
<li>a. 能，因为请求码为200 OK，提供回答的时间为Tue, 07 Mar 2008 12:39:45 GMT（注意下面还有一个Last-Modified字段表示上一次修改的日期，不一样）<br>b. Sat 10 Dec 2005 18:27:46<br>c. 3874（Content-Length字段）<br>d. &lt;!doc，同意持续连接。</li>
<li>略</li>
<li>RTT~1~到RTT~n~的和加上2倍的RTT~0~，因为客户端与服务器连接还需要1个RTT。</li>
<li>a. 在没有并行TCP连接的非持续HTTP中，8个对象需要建立8次连接，共16RTT。<br>b. 对于配置有5个并行连接的HTTP，8个对象需要建立8次连接，注意需要首先建立连接请求主要的页面，才能够并行请求对象，因此额外的时间为4RTT。<br>c. 对于持续HTTP，不需要建立另外的连接，额外的时间为8RTT。</li>
<li>a. 平均接入时延=$\frac{\Delta}{1-\Delta\beta}$，其中$\Delta$是跨越接入链路发送一个对象的平均时间，也即一个对象的传输时延=850Kb/15Mb/s=0.0567s，$\beta$是对象对该接入链路的平均到达率，即16请求/s，故平均接入时延=0.61s，平均互联网时延为3s，故总响应时间为3.61s。<br>b. 缓存器的命中率为0.4，命中时只会有机构内网的传输时延，即0.0085s。平均响应时间为0.0085×0.4+3.61×0.6=1.8754s。</li>
<li>10米的短链路可以忽略传播时延，150bps对于200比特长的控制分组的传输时延为1.33s，如果是非持续连接非并行连接，那么RTT=2.67s，一共需要11次连接和11次数据传输，一共需要传输33个控制分组和11个数据分组，总时间为7377s。如果是并行连接，使用N个并行连接，每个连接的带宽为150/Nbps，传输的数据相同，因此总时间依然为7377s。如果是持续连接，非并行连接，一共需要1次连接和11次数据传输，传输13个控制分组和11个数据分组，总时间为7351s。持续连接和非持续连接对时延的影响不大。</li>
<li>a. 是，并行连接可以让Bob获得更多的带宽。<br>b. 是。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CoLin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">101</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Hornos3" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Hornos3" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_54218833?spm=1000.2115.3001.5343" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_54218833?spm&#x3D;1000.2115.3001.5343" rel="noopener" target="_blank"><i class="fa fa-crosshairs fa-fw"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CoLin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">889k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">13:28</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
