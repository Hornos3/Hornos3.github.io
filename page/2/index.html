<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hornos3.github.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="CoLin&#39;s BLOG">
<meta property="og:url" content="http://hornos3.github.com/page/2/index.html">
<meta property="og:site_name" content="CoLin&#39;s BLOG">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="CoLin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://hornos3.github.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-cn'
  };
</script>

  <title>CoLin's BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CoLin's BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%AC%AC12%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%AC%AC12%E7%AB%A0/" class="post-title-link" itemprop="url">软件安全——第12章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-03 09:45:23 / Modified: 09:47:34" itemprop="dateCreated datePublished" datetime="2023-03-03T09:45:23+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">软件安全</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="chapter-12-构建安全的软件"><a class="markdownIt-Anchor" href="#chapter-12-构建安全的软件"></a> Chapter 12 构建安全的软件</h1>
<h2 id="121-软件开发生命周期"><a class="markdownIt-Anchor" href="#121-软件开发生命周期"></a> 12.1 软件开发生命周期</h2>
<ol>
<li>分析阶段：软件需求分析。通过研讨或调查研究，对用户的需求进行收集，最后把它用标准的软件工程开发语言(需求规格说明书)表达出来。即<strong>建立软件的逻辑模型、编写需求规格说明书文档</strong>。</li>
<li>设计阶段：概要设计和详细设计两个阶段。将软件分解成一个个模块并将模块内部的结构设计出来。
<ul>
<li>结构化分析方法、数据流程图和数据字典等方法设计建 立相应的软件系统的体系结构</li>
<li>模块设计，给出软件的模块结构，将整个系统分解成若干个子 系统或模块</li>
<li>设计模块的程序流程、算法和数据结构，设计数据库</li>
<li>编写软件概要设计和详细设计说明书，数据库或数据结构设计说明书</li>
</ul>
</li>
<li>编码阶段：把软件设计转换成计算机可以接受的程序
<ul>
<li>基于软件产品的开发质量的要求，充分了解软件开发语言、工具的特性和编程风格</li>
<li>编码并提供源程序清单</li>
</ul>
</li>
<li>测试阶段：
<ul>
<li>白盒测试：依据的是程序内部的的逻辑结构来发现软件的编程错误、结构错误和数据错误，以较少的用例覆盖尽可能多的内部程序逻辑结果</li>
<li>黑盒测试：依据的是软件的功能或软件行为描述，发现软件的接口、功能和结构错误，以较少的用例覆盖模块输出和输入接口</li>
</ul>
</li>
<li>维护阶段：根据软件运行的情况，对软件进行适当修改，成本较高</li>
</ol>
<h2 id="122-软件设计阶段威胁建模"><a class="markdownIt-Anchor" href="#122-软件设计阶段威胁建模"></a> 12.2 软件设计阶段威胁建模</h2>
<ul>
<li>在项目组中成立一个小组专门研究安全问题</li>
<li>分解系统需求，按照需求规格说明书和设计文档中的内容，站在安全角度，分析系统在安全方面的需求</li>
<li>确定系统可能面临哪些威胁</li>
<li><strong>画出威胁树，对软件可能收到的威胁进行表达。</strong><br />
威胁树一般画3层：
<ul>
<li>第一层写受到的攻击种类</li>
<li>第二层写被攻击的原因</li>
<li>第三层写具体攻击的处理方式</li>
</ul>
</li>
<li>选择应付威胁或者缓和威胁的方法：告知用户、排查与修复问题等</li>
<li>确定最终技术：将最终选用的技术，直接在威胁树中描述或者用图表画出来</li>
</ul>
<h2 id="123-安全代码的编写"><a class="markdownIt-Anchor" href="#123-安全代码的编写"></a> 12.3 安全代码的编写</h2>
<p>在编写代码的过程中考虑安全问题。如内存安全、线程安全、处理异常等</p>
<h2 id="124-软件安全性测试"><a class="markdownIt-Anchor" href="#124-软件安全性测试"></a> 12.4 软件安全性测试</h2>
<ul>
<li>确保软件不会去完成没有预先设计的功能</li>
<li>确保软件能够完成预先设计的功能</li>
</ul>
<p>进行安全测试，需要精湛的系统分析技术和反攻击技术。其特点是：</p>
<ul>
<li>非常灵活，测试用例没有太多的预见性</li>
<li>没有固定的步骤可以遵循</li>
<li>工作量大，并且不能保证完全地加以解决</li>
</ul>
<h2 id="125-漏洞响应和产品的维护"><a class="markdownIt-Anchor" href="#125-漏洞响应和产品的维护"></a> 12.5 漏洞响应和产品的维护</h2>
<p>在发现漏洞时，要确保能够迅速确认、响应、修复漏洞，在发现漏洞后的第一时间采取措施</p>
<p>漏洞相应常规阶段：</p>
<ul>
<li>发现漏洞通知厂商</li>
<li>确认漏洞和风险评估</li>
<li>修复漏洞</li>
<li>发布补丁及安全简报对外公布安全补丁</li>
</ul>
<hr />
<p><strong>练习题</strong>：<br />
<strong>1.</strong> 某公司收到安全人员的报告，发现有一种恶意代码利用该公司编写的一款软件（需要网络连接）进行网络蠕虫传播，试画出威胁树进行分析。</p>
<p><strong>解题技巧：</strong> 威胁树不同层级常用术语汇总<br />
第一层：受到的攻击种类</p>
<ul>
<li><font color=red>网络相关：SQL注入攻击、跨站脚本攻击、木马攻击、蠕虫攻击、DDoS攻击等</font></li>
<li><font color=red>非网络相关：缓冲区溢出等二进制漏洞攻击，病毒攻击等</font></li>
</ul>
<p>第二层：受到攻击的原因</p>
<ul>
<li><font color=red>存在零日漏洞（万能句）、安全测试覆盖面不足、软件设计缺陷、内部人员不当操作（如被社工）、工程师缺乏安全意识、没有及时安装补丁等</font></li>
</ul>
<p>第三层：解决方案</p>
<ul>
<li><font color=red>及时上报安全漏洞并做出应对措施、重新进行安全测试、重新审视软件设计方案，必要时需要停服解决设计缺陷、安装最新补丁，更新软件、进行流量捕获与分析，完善服务器相关代码等</font></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%AC%AC11%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%AC%AC11%E7%AB%A0/" class="post-title-link" itemprop="url">软件安全——第11章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-03 09:45:20 / Modified: 09:47:34" itemprop="dateCreated datePublished" datetime="2023-03-03T09:45:20+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">软件安全</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>2.5k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="chapter-11-windows系统安全机制及漏洞防护技术"><a class="markdownIt-Anchor" href="#chapter-11-windows系统安全机制及漏洞防护技术"></a> Chapter 11 Windows系统安全机制及漏洞防护技术</h1>
<h2 id="111-dep"><a class="markdownIt-Anchor" href="#111-dep"></a> 11.1 DEP</h2>
<p>DEP（Data Execution Protection/NX）：禁用栈和堆区的代码执行，能够有效防止shellcode在栈和堆上执行</p>
<p>但会带来一定的兼容性和灵活性问题：如用于提取其他软件窗口上文字的软件，可能需要在栈或堆中执行代码，DEP启用后这类软件可能无法正常运行。</p>
<p>支持架构：Intel、AMD等</p>
<p>实现原理：将栈和堆的访问权限（属性）设置为NX</p>
<p>Windows选项：</p>
<ul>
<li>Optin：DEP仅用于系统服务与进程（个人版默认）</li>
<li>Optout：排除列表程序外的所有程序启用（服务器版默认）</li>
<li>AlwaysOn：所有进程全部启用</li>
<li>AlwaysOff：所有进程全部禁用</li>
</ul>
<p><strong>绕过思路</strong>：Ret2Libc、ROP、JOP、COP等</p>
<h2 id="112-栈溢出检查gs"><a class="markdownIt-Anchor" href="#112-栈溢出检查gs"></a> 11.2 栈溢出检查——GS</h2>
<p>在所有函数栈帧高处放置一个Stack Guard（Windows中称为Stack Cookie，Linux中称为Canary），这是一个随机数，且可检验其是否改变。函数结束后会检查此处的值是否被修改。可以在一定程度上防范栈溢出。</p>
<ul>
<li>以.data节的第一个DWORD作为其种子，称为原始Cookie，所有函数的Cookie均使用这个种子生成。</li>
<li>栈帧初始化后以ESP异或种子作为cookie使用，能够提升其随机性。</li>
<li>函数返回前使用esp还原出种子</li>
<li>调用<strong>Security_check_cookie</strong>函数进行校验。</li>
</ul>
<p>当满足以下情况时不使用此种保护：</p>
<ul>
<li>函数无缓冲区</li>
<li>函数被定义为具有变量参数列表（即可变参数）</li>
<li>函数使用无保护的关键字标记</li>
<li>函数第一条语句中含内嵌汇编代码</li>
<li>缓冲区不是8字节类型且不大于4字节</li>
</ul>
<p>使用#param strict_gs_check(on)选项可以强制对任意类型函数添加cookie</p>
<p>变量重排技术：将字符串变量移动到栈帧的高地址，即紧靠cookie的位置，这样一旦发生溢出能够立即发现，无论溢出多少字节。如果字符串变量距离cookie有一段距离，那么其溢出有限字节可能不会被cookie发现。</p>
<p>无法防御：</p>
<ul>
<li>未被保护的函数</li>
<li>改写函数指针类攻击</li>
<li>异常处理类攻击</li>
<li>堆溢出攻击</li>
<li>其他（如能够利用其他漏洞泄露cookie的值）</li>
</ul>
<p>绕过方法：</p>
<ul>
<li>利用未被保护的函数</li>
<li>覆盖C++虚函数指针</li>
<li>攻击异常处理机制</li>
<li>同时替换栈和data中的cookie</li>
</ul>
<h2 id="113-aslr"><a class="markdownIt-Anchor" href="#113-aslr"></a> 11.3 ASLR</h2>
<p>地址空间布局随机化，使栈和堆的基址在加载时随机确定、程序自身和关联库的基址在加载时也随机确定</p>
<p>不足：</p>
<ul>
<li>需要和DEP配合使用。否则恶意代码可以通过程序进程表结构获取DLL加载基址</li>
<li>ASLR的随机性较小（仅针对32位windows系统，32位/64位linux系统有更好的随机性）</li>
<li>兼容性问题（一些老处理器不支持等问题）</li>
<li>地址部分覆盖（对于windows 32位系统只能控制程序地址随机化后两个字节，前两个字节不变，对于Linux系统则是最低12位不变，因为内存需要4KB对齐）</li>
</ul>
<h2 id="114-safeseh"><a class="markdownIt-Anchor" href="#114-safeseh"></a> 11.4 SafeSEH</h2>
<p>保护、检测和防止堆栈中的SEH函数指针被覆盖的技术</p>
<ul>
<li>检查异常处理程序是否位于栈中</li>
<li>如果异常处理程序指针不是栈中地址，会再次检查是否属于一个Image的地址空间（mmap映射机制，不做要求）</li>
</ul>
<h2 id="115-emet"><a class="markdownIt-Anchor" href="#115-emet"></a> 11.5 EMET</h2>
<p>Enhanced Mitigation Experience Toolkit，含DEP、ASLR、SEHOP等防护措施</p>
<ul>
<li>SEHOP：结构化异常处理覆写保护，对抗覆盖SEH攻击</li>
<li>EAF：导出表地址过滤：禁止shellcode搜索API地址</li>
<li>HeapSpray Allocations：将所有有可能被堆喷射的常见内存地址首先分配掉</li>
<li>Null Page Allocation：使用提前占位的方式将空指针未初始化之前默认指向的地址首先分配掉</li>
</ul>
<hr />
<p><strong>练习题</strong>：<br />
<strong>1.</strong> 分析如下代码片段，回答下列问题：（29分）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">0x20</span>];</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">	<span class="built_in">printf</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：上述代码已开启Stack Cookie保护，未开启ASLR保护。<br />
(1) 这段代码中存在的漏洞是________________________。（2分）<br />
(2) 能否直接输入很多字符产生栈溢出？__________ ，简述Stack Cookie如何防止这一类栈溢出：___________________________________________________________________________________________________ （4分）<br />
(3) 虽然我们不能直接进行栈溢出，但因为有____________漏洞的存在，使我们有可能_______________________________，从而绕过Stack Cookie的防护。注意，本程序没有开启ASLR防护，因此我们可以获取到_______________。请简述你的利用思路及这样利用能够成功的原因：________________________________________________________________________________，在这种绕过方式中，Stack cookie应作为printf的第___个参数输出。（10分）<br />
(4) 这个函数的利用可能需要输入两次，在第一次输入后，你成功让这个函数又从头开始执行了一次，这样你就可以再一次进行输入。假设你第一次输入获取到的stack cookie为0xdeadbeef，函数第一次刚开始执行时esp=0x7f773484，则函数第二次执行时的stack cookie值应为 ____________（Stack cookie的生成方式即为GS栈溢出保护中的生成方式）（5分）</p>
<p>答案：<br />
(1) 格式化字符串漏洞、栈溢出漏洞<br />
(2) 不能；Stack cookie是一个随机数，置于函数栈帧的高地址端，栈溢出发生时可能会覆盖Stack cookie，在函数返回时对Stack cookie进行检查，若发现被修改，则会直接报错退出程序<br />
(3) 格式化字符串漏洞；泄露Stack cookie的值；foo函数的起始地址；利用格式化字符串漏洞打印出Stack cookie的值（%x）及修改返回地址（%n）；10<br />
(4) 0xdeadbeeb</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%AC%AC10%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%AC%AC10%E7%AB%A0/" class="post-title-link" itemprop="url">软件安全——第10章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-03 09:45:15 / Modified: 09:47:34" itemprop="dateCreated datePublished" datetime="2023-03-03T09:45:15+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">软件安全</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>13 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="chapter-10-漏洞利用"><a class="markdownIt-Anchor" href="#chapter-10-漏洞利用"></a> Chapter 10 漏洞利用</h1>
<h2 id="100-概念"><a class="markdownIt-Anchor" href="#100-概念"></a> 10.0 概念</h2>
<h3 id="安全事件与软件漏洞"><a class="markdownIt-Anchor" href="#安全事件与软件漏洞"></a> 安全事件与软件漏洞</h3>
<ul>
<li>安全事件：攻击者在给定时间段内，利用漏洞或其他攻击手段在攻击对象中注入并触发恶意代码，产生拒绝服务、信息泄露、信息窃取、目标控制等后果的过程。</li>
<li>漏洞：系统设计、实现或操作管理中存在的缺陷或弱点，能被利用而违背系统的安全策略。</li>
</ul>
<h3 id="漏洞分类与标准"><a class="markdownIt-Anchor" href="#漏洞分类与标准"></a> 漏洞分类与标准</h3>
<p>按照漏洞威胁可分为：</p>
<ul>
<li>提权漏洞</li>
<li>获权漏洞</li>
<li>拒绝服务漏洞</li>
<li>恶意软件植入漏洞</li>
<li>数据丢失或泄露漏洞</li>
</ul>
<p>按照漏洞成因可分为：</p>
<ul>
<li>输入验证漏洞</li>
<li>访问验证漏洞</li>
<li>竞态漏洞（竞争条件漏洞）</li>
<li>意外情况处理漏洞</li>
<li>设计漏洞</li>
<li>配置漏洞</li>
<li>环境漏洞</li>
</ul>
<p>按照漏洞的严重性可分为：</p>
<ul>
<li>A 类漏洞（高）：威胁性最大的漏洞，往往由较差的系统管理或错误设置造成。</li>
<li>B 类漏洞（中）：较为严重的漏洞，例如允许本地用户获得增加的和未授权的访问。</li>
<li>C 类漏洞（低）：严重性不是很大的漏洞，例如允许拒绝服务的漏洞。</li>
</ul>
<p>按照攻击被利用的方式可分为：</p>
<ul>
<li>本地攻击漏洞</li>
<li>远程主动攻击漏洞</li>
<li>远程被动攻击漏洞</li>
</ul>
<p>重要网站：</p>
<ul>
<li>CVE：漏洞暴露平台</li>
<li>CNVD：国家互联网应急中心</li>
<li>CNNVD：国家信息安全测评中心</li>
</ul>
<h3 id="漏洞利用对系统的威胁"><a class="markdownIt-Anchor" href="#漏洞利用对系统的威胁"></a> 漏洞利用对系统的威胁</h3>
<ul>
<li>非法获取访问权限（获权）
<ul>
<li>未经授权使用资源，如打印、读取、写、执行文件等</li>
</ul>
</li>
<li>权限提升（提权）
<ul>
<li>用户账号由低权限提升到高权限</li>
</ul>
</li>
<li>拒绝服务
<ul>
<li>使计算机软件或系统无法正常工作、无法提供正常服务</li>
<li>本地拒绝服务：运行在本地的程序无法正常工作；远程拒绝服务：发送特定网络数据报文使提供服务的程序异常或退出</li>
</ul>
</li>
<li>恶意软件植入
<ul>
<li>主动植入：利用正常功能或漏洞将恶意代码植入到目标之中，无需用户干预</li>
<li>被动植入：将恶意代码植入时需要用户配合操作（木马、病毒等）</li>
</ul>
</li>
<li>数据丢失或泄露
<ul>
<li>由于对文件访问权限设置错误导致数据被非法读取。如读取密码</li>
<li>没有充分验证用户输入导致数据被非法读取。如Web相关漏洞</li>
<li>系统漏洞，如DNS域传送漏洞</li>
</ul>
</li>
</ul>
<h3 id="漏洞产生原因"><a class="markdownIt-Anchor" href="#漏洞产生原因"></a> 漏洞产生原因</h3>
<p>逻辑错误、缺陷、社工、策略失误等，可以分为技术因素和非技术因素（大多为人为因素）</p>
<ul>
<li>技术错误：即上文提到的按漏洞成因分类的7种</li>
<li>非技术错误：缺乏规范导致维护困难、缺乏测试与维护、开发团队不稳定、缺乏进度控制等</li>
</ul>
<h3 id="漏洞利用方式"><a class="markdownIt-Anchor" href="#漏洞利用方式"></a> 漏洞利用方式</h3>
<ul>
<li>本地攻击模式：攻击者进入目标系统具有一定权限后进行的攻击。如内网渗透等</li>
<li>远程主动攻击模式：攻击者以网络连接发现目标漏洞后进行攻击</li>
<li>远程被动攻击模式：攻击者向目标发送网页、文档等点击后触发漏洞</li>
</ul>
<h3 id="font-colorblue软件漏洞生命周期font"><a class="markdownIt-Anchor" href="#font-colorblue软件漏洞生命周期font"></a> <font color=blue>软件漏洞生命周期</font></h3>
<ul>
<li>漏洞挖掘</li>
<li>漏洞重现</li>
<li>漏洞诊断</li>
<li>漏洞修复</li>
<li>补丁测试</li>
<li>补丁推送</li>
</ul>
<p>（攻击者在其中任何一个时候都能够对系统造成损失）</p>
<h3 id="典型软件漏洞"><a class="markdownIt-Anchor" href="#典型软件漏洞"></a> 典型软件漏洞</h3>
<ul>
<li>缓冲区溢出：在下面会具体说明</li>
<li>注入攻击：如SQL注入、系统命令注入、脚本注入等，多为对用户的输入检查不严格导致。</li>
<li>跨站漏洞：跨站脚本攻击（XSS），攻击者将恶意脚本代码嵌入到Web页面中，用户打开后执行其中的代码触发漏洞或获取网站权限。（被动攻击）</li>
<li>权限漏洞：访问控制机制上存在的漏洞。如Linux Kernel Pwn即利用Linux内核模块实现用户权限到root权限的提升。</li>
</ul>
<h2 id="101-栈缓冲区溢出"><a class="markdownIt-Anchor" href="#101-栈缓冲区溢出"></a> 10.1 栈缓冲区溢出</h2>
<p>一、栈</p>
<ul>
<li>栈是一段连续的地址空间，是一个后进先出的数据结构，由高地址向低地址增长。</li>
<li>每一个线程都有一个自己的栈，提供一个暂时存放数据的地方。</li>
<li>push将esp下压，pop将ebp上抬</li>
<li>esp指向栈顶，ebp指向栈帧底部。</li>
</ul>
<p><font color=red>注意：栈地址空间中保存的是程序执行时使用的局部变量，在main函数或其他函数中定义的变量均保存在栈中。代码中的字符串常量（如printf(“Hello world”)）定义于rdata段，初始化的全局变量定义于data段，未初始化的全局变量定义于bss段。</font></p>
<p><strong>栈中包含：</strong></p>
<ul>
<li>函数参数</li>
<li>函数返回地址</li>
<li>ebp的值</li>
<li>一些通用寄存器的值</li>
<li>当前执行的函数的局部变量</li>
</ul>
<p><font color=blue>函数调用过程：</font></p>
<ol>
<li>call指令执行之前，程序首先将函数需要的参数逐一push进栈中。（有几种不同的参数压入顺序）</li>
<li>执行call指令跳转eip到函数开头。call指令将eip压入栈中。</li>
<li>函数开头一般会执行指令push ebp; mov ebp, esp，保存前一个栈帧的地址。</li>
<li>之后esp可能会根据该函数中定义的所有局部变量需要占用的空间进行自减，以保证esp和ebp之间能够有充足的空间保存局部变量。</li>
<li>开始执行函数功能，函数调用过程结束。</li>
</ol>
<p><strong>函数调用类型：（32位）</strong></p>
<ul>
<li>__cdecl：C调用规则，在后面的参数首先进入堆栈，参数返回后<strong>调用者</strong>负责清除堆栈，因此这种调用常会产生较大的可执行程序</li>
<li>__stdcall：标准调用，在后面的参数首先进入堆栈，<strong>被调用</strong>的函数返回前自行清理堆栈，生成的代码比cdecl小</li>
<li>__fastcall：将函数列表前两个参数放入寄存器，其他函数压栈，后面的参数首先进入堆栈，<strong>被调用者</strong>清理堆栈</li>
<li>Pascal：基本不用，前面的参数首先进入堆栈，不支持可变参数的函数调用</li>
</ul>
<p><font color=blue>函数返回过程：</font></p>
<ol>
<li>esp上抬到达ebp的位置，局部变量不作处理全部放弃，也不会将这段内存清零。</li>
<li>ebp找到父函数栈帧的底部（函数调用时已经保存在ebp指向的内存空间）并上抬（pop ebp）。</li>
<li>retn返回，返回到父函数call指令之后一条指令。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/88b8159a0b974dec9837f74f697df1eb.png" alt="" /></p>
<p>二、栈溢出</p>
<p>特点：</p>
<ul>
<li>缓冲区在栈中分配</li>
<li>拷贝的数据过长且没有进行检查</li>
<li>覆盖了栈中的一些重要数据，如ebp、返回地址、某些关键局部变量等</li>
</ul>
<p>产生原因：</p>
<ul>
<li>C语言中有大量没有溢出保护的函数，如*scanf系列、*printf系列、gets函数、strcpy函数、strcat函数等（注：read函数理论上可以读取零字节，因此较strcpy等函数具有更高的危险性）</li>
<li>程序员缺乏安全意识</li>
</ul>
<p>shellcode和payload</p>
<ul>
<li>shellcode是能完成一种特殊任务的自包含的二进制代码，根据不同的任务可能是发出一条系统调用或是进行高权限操作。</li>
<li>payload：shellcode以及实现跳转到shellcode的那部分填充代码的统称。</li>
</ul>
<p><strong>栈溢出shellcode的NSR模式：</strong></p>
<ul>
<li>S——shellcode，首先写入栈的低地址处</li>
<li>R——return address，返回地址，通常写入jmp esp的地址，在S之上</li>
<li>N——nops，无效指令，在R之上</li>
</ul>
<p>注意：NSR模式构造的shellcode很可能会失败，原因多种多样。有时jmp esp后栈中的内容会被修改，导致shellcode执行失败。此时可以利用SEH进行攻击。</p>
<p><strong>什么是SEH？</strong><br />
结构化异常处理（StructuredExceptionHandling，SEH）是Windows操作系统处理程序错误或异常的技术。SEH是Windows操作系统的一种系统机制，与特定的程序设计语言无关。SEH的注册结构体只能作为局部变量<strong>存在于当前线程的调用栈</strong>，如果一旦结构体的地址不在当前调用栈的范围中，则在进行异常分发时，将不会进入该函数。即我们<strong>可以通过栈溢出修改SEH中函数指针的值</strong>。SEH是基于线程的一种处理机制，且依赖于栈进行存储和查找，所以被称作是基于栈帧的异常处理机制。有关于其具体实现与功能需要对windows异常处理机制有更加深入的了解，考试不做要求。</p>
<p>fs:[0]指向SEH的初始地址，通过获取该地址以确定溢出的长度，这个长度必须确定以保证能够正确覆盖关键函数指针。将指针覆盖为类似于jmp esp指令的地址，即可执行shellcode。</p>
<p><strong>shellcode的特点</strong>：</p>
<ul>
<li>长度受限（不是所有），具体问题具体分析。</li>
<li>不能使用特定字符，如’\x00’（read函数是唯一能够接收’\x00’的函数）</li>
<li>API函数自搜索和重定位能力</li>
<li>一定的兼容性（很难，windows和linux的内存空间和内核排布很不一样）</li>
</ul>
<h3 id="练习题"><a class="markdownIt-Anchor" href="#练习题"></a> 练习题</h3>
<p><strong>1.</strong> 分析如下代码片段，回答下列问题。（25分）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">guess</span><span class="params">()</span>&#123;</span><br><span class="line">	FILE* fd = open(<span class="string">&#x27;/etc/urandom&#x27;</span>, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">	<span class="type">int</span> answer = <span class="number">0</span>;</span><br><span class="line">	read(fd, (<span class="type">char</span>*)(&amp;answer), <span class="number">4</span>);</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="comment">// 此时answer是一个随机数，不可预测</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Guess a number that I&#x27;m thinking...&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;You can input something first...&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buffer);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now guess...&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;guess);</span><br><span class="line">	<span class="keyword">if</span>(guess == answer)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Congratulations!&quot;</span>);</span><br><span class="line">		system(<span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Guess incorrect, no calc!!!&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> True;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：①本函数中先定义的随机变量在栈中的地址在后定义的随机变量之上。②数字a的ASCII码为0x30+a，大写字母的ASCII码为0x40+字母序号（A为0，B为1，…，Z为25），小写字母的ASCII码为0x60+字母序号</p>
<p>(1) 简述该函数的执行流程，说明弹出计算器所需的条件。（4分）<br />
(2) 本函数中存在什么漏洞？（3分）<br />
(3) 当第一个输入为’12345678901234567890abcdefABCDEF\n’时，answer的值为_________（填16进制，2分），返回地址的值为_________（填16进制，2分），那么第二个输入为_________（3分）时可以成功弹出计算器。弹出计算器之后，这个程序很有可能会______________________(2分），原因是_______________________（2分）。<br />
(4) 请写出改进方案，修复这个漏洞使计算器不那么容易被弹出。（7分）</p>
<p>答案：<br />
(1) 本程序产生了一个随机数，之后可以在buffer中写入字符串，然后输入一个数字，如果这个数字与随机数相等，则弹出计算器。弹出计算器的条件是猜的数字与随机数相等。<br />
(2) 栈溢出漏洞<br />
(3) 0x30393837；0x42416665；809056311；崩溃；返回地址可能无效<br />
(4) 将<code>scanf(&quot;%s&quot;, buffer);</code>修改为<code>scanf(&quot;%16s&quot;, buffer);</code></p>
<p><strong>2.</strong> 分析如下代码片段，回答下列问题：（30分）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">void</span> (*exec)(<span class="type">const</span> <span class="type">char</span>*) = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">void</span> (*func)(<span class="type">const</span> <span class="type">char</span>*) = system;</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">16</span>];</span><br><span class="line">	gets(buffer);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buffer);</span><br><span class="line">	<span class="keyword">if</span>(exec != <span class="literal">NULL</span>)</span><br><span class="line">		exec(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：①通过反汇编找到vuln函数的起始地址为0x405678。②本函数中先定义的随机变量在栈中的地址在后定义的随机变量之上。</p>
<p>(1) 简述该函数的执行流程。（4分）<br />
(2) 通过反汇编可以得到该函数的汇编代码，已知前几条语句如下，请填写前两空，第三空填写的数值x一定有______________。（3分）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">mov ___, ___</span><br><span class="line">sub esp, ___</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>(3) 当输入长度为________时，程序会______________________________，从而获得system函数在内存中的地址。（4分）<br />
(4) 如果这个函数只被调用了一次，能否仅通过这个函数弹出计算器？_____ 。为什么？__________________________________ 。（4分）<br />
(5) 第一次函数调用时，你输入了第(3)题长度的payload，printf函数只显示了你输入的内容，可能的原因是_____________________________。（4分）在函数下一次调用时，你应该如何获取system函数的地址？__________________________________。（4分）<br />
(6) 通过第一次函数调用的漏洞利用，获取到system函数的地址为0x7FAD8341，在该函数第二次被调用时，能否利用漏洞弹出计算器？若能，写出一个有效的输入并简述函数执行流程；若不能，说明理由。如果system函数的地址为0x7FAD8300呢？（7分）</p>
<p>答案：<br />
(1) 函数首先接收任意长度的输入，然后检查exec函数指针是否为空，若不为空则执行到exec处。<br />
(2) ebp；esp；x&gt;=24<br />
(3) 16；在printf输出时将system函数的地址接在输入后面输出<br />
(4) 不能；无法控制exec的值，system的地址也不知道因此无法修改返回地址<br />
(5) system函数地址最低位为空字节；尝试输入17、18、19字节数据，直至能够输出system函数的高位地址<br />
(6) 能。输入为calc.exe（后接12字节空格）\x41\x83\xAD\x7F；不能，会截断。</p>
<h2 id="102-堆缓冲区溢出与格式化字符串漏洞"><a class="markdownIt-Anchor" href="#102-堆缓冲区溢出与格式化字符串漏洞"></a> 10.2 堆缓冲区溢出与格式化字符串漏洞</h2>
<p>一、堆</p>
<ul>
<li>堆是存放程序中请求操作系统分配给自己的内存段，其大小不固定，可以进行动态扩大与缩小。操作系统中采用动态链表管理，其内存不一定连续。</li>
<li>每一个<strong>进程</strong>都有一个自己的堆（区别栈是每一个<strong>线程</strong>有一个）</li>
<li>使用malloc系列函数（malloc、calloc、realloc等）/new/mmap等函数分配堆空间；使用free/delete/unmap等函数释放堆空间。（调用的系统函数基本上相同）</li>
</ul>
<p><font color=red>注意：两个程序动态申请的堆空间地址完全有可能相同。要搞清楚虚拟地址和物理地址的区别，程序中直接操作的是虚拟内存地址，由操作系统从物理地址中映射而来，并非物理内存地址。但两个程序分配的堆地址的<strong>物理地址也有可能相同</strong>。两个程序可以交错使用这块内存。</font></p>
<p><strong>结构</strong>：堆表和堆块。</p>
<ul>
<li>堆表：位于堆空间起始位置，用于索引堆区中所有堆块的重要信息。在windows堆管理机制中，将堆表分为两种：快表（Lookaside）和空表（FreeList）。
<ul>
<li>空表：共128项的数组，每个数组是一个双向链表头，除索引0的链表外每个链表中存放相同大小的堆块。其中<strong>索引为x的链表存放大小为8x的空闲堆块，因此1~127共可以存放8~1016字节的堆块。（32位）索引为0的链表存放大小大于等于1024的堆块，按照从小到大的顺序排列</strong>。在实际分配内存流程中，为防止堆空间的碎片化，会对相邻的均处于空表中的堆块进行合并与重新排列。</li>
<li>快表：共128项的数组，采用单向链表存储，其中的堆块不合并且<strong>每一个链表最多存放4个堆块。其中索引为1~127的链表存放的堆块大小与空表相同。</strong></li>
</ul>
</li>
<li>堆块：一块块分离的，碎片化的地址空间，由块首和块身构成。
<ul>
<li>块首：头部几个字节，用于标识自身信息（大小，使用情况等）</li>
<li>块身：数据存储区域，紧跟块首，内存分配得到的地址<strong>指向块身的头部。<strong>在堆块被释放时，块身的前8个字节用于存放堆表中</strong>双向链表的向前指针Flink和向后指针Blink。</strong></li>
</ul>
</li>
<li>HEAP区总体结构：
<ul>
<li>hHeap：HEAP的总体管理结构，句柄</li>
<li>双指针区：定位分配内存、释放内存的位置，存放一些成对出现的指针</li>
<li>用户分配内存区</li>
</ul>
</li>
</ul>
<p><strong>堆管理相关寄存器：</strong></p>
<ul>
<li>eax：一般代码中用作返回值</li>
<li>ecx：一般代码中用作计数器</li>
<li>mov [ecx], eax; mov [eax+4], ecx</li>
</ul>
<p><strong><font color=red>堆块关键操作：</font></strong></p>
<ul>
<li>申请堆块时的脱链操作：即双向链表的脱链操作，汇编指令为mov [ecx], eax; mov [eax+4], ecx</li>
<li>释放堆块时的入链操作：根据设计思想，应首先判断前后是否能进行堆块合并，若进行合并则需要进行脱链操作，再将合并后的堆块放入指定的链表中。</li>
</ul>
<p>二、堆溢出</p>
<p><strong>利用思路1：</strong></p>
<ul>
<li>使用mov [ecx], eax; mov [eax+4], ecx完成对任意地址的控制。</li>
<li>使用[esi+0x4C]指向下一个空闲堆块头部结构</li>
<li>当有不能处理的异常发生时，系统调用UnhandledExceptionFilter函数，其实就是call [0x77EC044c]，即执行0x77EC044c指向的异常处理程序。因此修改此处地址即可。</li>
<li><strong>随着防护措施的改进，上述思路在当前windows系统中已基本不可用。</strong></li>
</ul>
<p><strong>利用思路2：堆喷射</strong></p>
<ul>
<li>向堆中注入大量数据，使数据填满特定内存地址空间，当栈溢出时可以引导EIP到堆的空间。其中填充的数据是大量重复的nop指令，如果之后eip能够指向这段nop指令，就能够一直执行到后面的shellcode。这段nop充当类似“滑梯/滑板”的作用。</li>
<li>目前依然流行,常见于解释JavaScript的浏览器和PDF解释器</li>
<li>申请大量内存时。堆很有可能覆盖到0x0A0A0A0A（162M）、0x0C0C0C0C（192M）、0x0D0D0D0D（208M）<br />
传统的堆喷射使用JavaScript分配内存，根据堆喷射的思想，都是用同样一个指令覆盖一大片内存地址。在每块分配到的内存最后都附加shellcode。这个指令应相当于Nops的作用，且该指令指向的地址正好应落在覆盖的这片大的内存地址中。<br />
指令0C0C对应汇编代码为or al, 0C，对寄存器影响最小，可以起到Nops的作用。如果将eip指向0x0C0C0C0C这个地址（产生异常时可能可以实现），就会在这片内存中不断执行下去直到shellcode为止。</li>
<li>优点：
<ul>
<li>增加缓冲区溢出攻击的成功率</li>
<li>覆盖地址可以简单使用类NOP指令覆盖</li>
<li>可用于堆栈溢出攻击，用slidecode覆盖堆栈返回地址</li>
</ul>
</li>
<li>缺点：
<ul>
<li>会导致被攻击进程内存占用暴增，容易被发现</li>
<li>不能用于主动攻击，一般通过栈溢出利用或其他漏洞进行协同攻击</li>
<li>如果目的地址被shellcode覆盖，则shellcode执行会失败，因此不能保证一定成功</li>
</ul>
</li>
<li>检测与防范：
<ul>
<li>发现应用程序的内存大量增加，检测堆上的数据，看是否包含大量slidecode</li>
<li>浏览器的脚本解释器开始重复申请堆的时候，监控模块记录堆的大小、内容和数量，如果重复堆请求到达阈值或者覆盖指定地址则立即阻止脚本执行。</li>
<li>对于一些利用脚本进行攻击的情况，可以通过hook脚本引擎，分析脚本代码，根据一些堆喷射常见特征检测是否受到攻击</li>
<li>开启DEP</li>
</ul>
</li>
</ul>
<p><strong>利用思路3：Use After Free</strong></p>
<ul>
<li>当一块堆空间被释放，对这段内存空间进行操作即称为UAF。</li>
<li>由于windows内存空间中被释放的堆块的块身中存放有两个指针，通过UAF可以对这两个指针进行修改以破坏堆表的双向链表结构。</li>
</ul>
<p>三、格式化字符串漏洞</p>
<ul>
<li>适用于printf函数系列。</li>
<li>产生原因：
<ul>
<li>printf的不定长参数个数，且没有进行检查。</li>
<li>printf的%n能够对一段地址空间的值进行修改。（<strong>其功能是将前面已经打印出的字符个数赋给对应的地址</strong>）</li>
</ul>
</li>
<li>通过静态扫描容易发现。</li>
</ul>
<h3 id="模拟题"><a class="markdownIt-Anchor" href="#模拟题"></a> 模拟题</h3>
<p><strong>3.</strong> 分析如下代码片段，回答下列问题：（24分）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> of[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">char</span> buf1[<span class="number">0x100</span>] = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>, buf1);</span><br><span class="line">	<span class="type">char</span> buf2[<span class="number">0x100</span>] = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buf1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf1);</span><br><span class="line">	gets(of);</span><br><span class="line">	<span class="built_in">free</span>(buf2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：①本函数中先定义的随机变量在栈中的地址在后定义的随机变量之上。②执行函数发现，函数的第一个输出为0x1030000，第二个堆块紧邻第一个堆块且在第一个堆块之上。</p>
<p>(1) 本函数存在2个漏洞，分别是____________________________（2分）。<br />
(2) 本题能否直接在栈上写入shellcode？____ ，原因是__________________________。（4分）<br />
(3) 本题能否直接在buf1中写入shellcode？____ ，原因是__________________________。（4分）<br />
(4) 本题能够直接在buf2中写入shellcode，前面的地址填充无效地址？____ ，原因是___________________________。（4分）<br />
(5) 由第(2)题和第(3)题，你认为第一个输入应该输入__________________，这样可以__________________________。之后第二个输入应为____________________________________，这样可以防止___________________，由此可以_______________________。（10分）</p>
<p>答案：<br />
(1) 栈溢出漏洞、堆溢出漏洞<br />
(2) 不能，不知道jmp esp或栈的地址<br />
(3) 不能，buf1的地址后两字节均为空字节且buf的大小只有0x100。无法将返回地址覆盖为buf1中的任何地址（地址的第二个字节一定为\x00），会导致截断<br />
(4) 不能，这样会破坏buf2堆块的头部结构，在free时会产生错误<br />
(5) 0x100字节的垃圾数据，通过printf获取buf2堆块的块首信息；vuln函数的起始地址；函数异常退出；再次输入并在第二次调用时在buf2中溢出shellcode【出题漏洞：第一次申请的buf2和第二次不一样，块首信息可能不同】</p>
<h2 id="103-整数溢出与其他漏洞"><a class="markdownIt-Anchor" href="#103-整数溢出与其他漏洞"></a> 10.3 整数溢出与其他漏洞</h2>
<p>一、整数溢出</p>
<p>在程序计算过程中，有时会因为计算数值问题导致计算结果不正确。如计算int整型的0x12345678 × 0x87654321，这会导致溢出。有时这种溢出会导致严重的后果，如输入字符串长度时若不加检查输入负数，会导致过量读或过量写漏洞等。</p>
<p><strong>防范方式</strong>：</p>
<ul>
<li>整数安全意识：形成关于特殊数据输入的意识，比如之前先确定最大和最小输入，使用合适的数据类型。</li>
<li>避免隐患运算直接操作：尽量避免对两个正数相加或相乘之后，再取结果比较。</li>
<li>越界判断：在使用变量申请内存，或者作为数组下标时，注意对越界的监测。</li>
<li>代码审计、安全检测</li>
</ul>
<h3 id="模拟题-2"><a class="markdownIt-Anchor" href="#模拟题-2"></a> 模拟题</h3>
<p><strong>4.</strong>  分析如下代码片段，回答下列问题：（34分）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">0x50</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0x50</span>;</span><br><span class="line">	<span class="type">char</span> alphabet[<span class="number">0x20</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++)</span><br><span class="line">		alphabet[i] = <span class="string">&#x27;A&#x27;</span> + i;</span><br><span class="line">	read(<span class="built_in">stdin</span>, buf, len);	<span class="comment">// 最多只能读取0x50个字节</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">0x50</span>; i++)</span><br><span class="line">		buf[i] &amp;= <span class="number">0xDF</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; buf[i]!=<span class="string">&#x27;\n&#x27;</span>&amp;&amp;buf[i]!=<span class="string">&#x27;\0&#x27;</span>; i++)&#123;</span><br><span class="line">		<span class="type">int</span> temp = buf[i] - <span class="number">0x40</span>;</span><br><span class="line">		temp += <span class="number">3</span>;</span><br><span class="line">		<span class="keyword">if</span>(temp &gt;= <span class="number">26</span>)</span><br><span class="line">			temp -= <span class="number">26</span>;</span><br><span class="line">		buf[i] = alphabet[temp];</span><br><span class="line">	&#125;</span><br><span class="line">	system(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(1) <code>buf[i] &amp;= 0xDF</code>的作用是____________________，这段代码实现的功能是______________________________________________________。（6分）<br />
(2) 本题的漏洞产生的原因是_____________________________，要想执行calc.exe，首先需要解决的问题是____________________________。由于___________（填功能）的执行在___________（填功能）之前，因此可以事先______________________，这样缓冲区在读取到变量alphabet的_________（填’高地址一端’或’低地址一端’）时就能够____________________。从而将______（填一个可打印字符）成功写入system命令字符串的缓冲区buf中（参考ASCII码值：0x2B=‘+’; 0x2E=‘.’; 0x31=‘1’; 0x41=‘A’）（16分）<br />
(3) 除了(2)的漏洞外，如果输入字符的ASCII码大于______的ASCII码，就会造成溢出，读取到alphabet高地址位置的值。如果alphabet的首地址为0x6000，那么想要让buf中存放该函数的返回地址，应该输入ASCII码为_____________________（填4个16进制数）的字符。（6分）<br />
(4) 简述本题代码的漏洞修补方案，写出修改后的代码。（6分）</p>
<h2 id="104-漏洞利用与发现"><a class="markdownIt-Anchor" href="#104-漏洞利用与发现"></a> 10.4 漏洞利用与发现</h2>
<h3 id="1-漏洞利用"><a class="markdownIt-Anchor" href="#1-漏洞利用"></a> 1. 漏洞利用</h3>
<p>漏洞研究包含漏洞挖掘、漏洞分析、漏洞利用与漏洞防御四个方面。</p>
<p>漏洞的来源：黑客自行挖掘出来的漏洞，还未修复（被称为零日漏洞，即0-day漏洞）、从公开发布的POC或黑客交换漏洞得到（此类漏洞为0-day漏洞或1-day漏洞）、从已经发布的漏洞公告和漏洞补丁中获取的漏洞（又被称为n-day漏洞）。</p>
<p>漏洞利用的条件：用户没有打补丁或更新安全工具、管理员没有打补丁或更新安全工具、存在脏数据渗透路径</p>
<p><strong>Exploit的结构</strong></p>
<ul>
<li>Exploit：利用漏洞实现shellcode植入和触发的过程</li>
<li>Exploit ≈ Payload + Shellcode</li>
<li>payload是针对于特定漏洞设计的用于触发漏洞的部分，与漏洞本身紧密相关，而shellcode与漏洞本身无关，只是一段可任意执行的代码。</li>
</ul>
<p><strong>漏洞利用的目标：</strong></p>
<ul>
<li>修改内存变量 （邻接变量）</li>
<li>修改代码逻辑（代码的任意跳转）</li>
<li>修改函数的返回地址</li>
<li>修改函数指针(C++)[虚函数]（虚函数用于C++函数重载）</li>
<li>修改异常处理函数指针（SEH,VEH,UEF,TEH）</li>
<li>修改线程同步的函数指针</li>
</ul>
<p><strong>漏洞利用的过程：</strong></p>
<ul>
<li>定位漏洞点：利用静态分析和动态调试确定漏洞机理，如堆溢出、栈溢出、整数溢出的数据结构，影响的范围</li>
<li>按照利用要求，编写Shellcode</li>
<li>溢出，覆盖代码指针，使得Shellcode获得可执行权</li>
</ul>
<h3 id="2-ret2libc-rop"><a class="markdownIt-Anchor" href="#2-ret2libc-rop"></a> 2. Ret2Libc + ROP</h3>
<p>这是一种将返回地址修改到dll文件代码段的漏洞利用方式，可以不使用shellcode就能够执行指定功能。特点是向dll借代码而不是自己写shellcode，也可以通过这种利用方式完善payload。其中ROP返回到的地址可能不是函数的起始地址，而是函数中某一个位置的地址。</p>
<h4 id="ret2libc-virtualprotect"><a class="markdownIt-Anchor" href="#ret2libc-virtualprotect"></a> Ret2Libc -&gt; VirtualProtect</h4>
<p>在dll文件中有一个VirtualProtect函数可以用于关闭栈不可执行保护（NX），从而可以在栈上写入shellcode并执行。首先使用Ret2Libc将执行VirtualProtect函数，传入合适的参数。返回后转到jmp esp的地址，即可执行shellcode。</p>
<h4 id="ret2libc的防护措施ascii-armoring"><a class="markdownIt-Anchor" href="#ret2libc的防护措施ascii-armoring"></a> Ret2Libc的防护措施：ASCII armoring</h4>
<p>将所有库函数的起始地址都包含一个零字节，使得无法完整溢出。<br />
恶意代码对抗措施：Ret2plt</p>
<ul>
<li>Linux ELF文件中大多数有一个.plt节，其中存放一系列jmp指令跳转到所有需要引用的库函数。因此可以将返回地址写到.plt节中跳转到需要的库函数中。.plt节的深入原理与Linux的间接跳转原理有关，不要求掌握。</li>
</ul>
<h3 id="练习题-2"><a class="markdownIt-Anchor" href="#练习题-2"></a> 练习题</h3>
<p><strong>5.</strong> 分析如下代码片段，回答下列问题：（29分）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> key[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">(<span class="type">void</span>)(*func(<span class="type">void</span>)) = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Please input length: &quot;</span>);</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">0x40</span>];</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;len);</span><br><span class="line">	<span class="keyword">if</span>(len &gt; <span class="number">8</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;You greedy man!&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	read(<span class="built_in">stdin</span>, buf, (<span class="type">unsigned</span> <span class="type">int</span>)len);	<span class="comment">// 读取len长度输入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo1</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> a, <span class="type">unsigned</span> <span class="type">int</span> b, <span class="type">unsigned</span> <span class="type">int</span> c)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a != <span class="number">0x12345678</span> || b != <span class="number">0x87654321</span> || c != <span class="number">0xdeadbeef</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Argument error!&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">strcpy</span>(key, <span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo2</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">// 下面这一部分函数的功能是：检查eax=0x12345678且ebx=0x87654321</span></span><br><span class="line">	<span class="comment">// 如果不是则调用exit函数退出程序。</span></span><br><span class="line">	__asm__(<span class="string">&quot;cmp eax, 12345678h&quot;</span></span><br><span class="line">			<span class="string">&quot;jnz ex&quot;</span></span><br><span class="line">			<span class="string">&quot;cmp ebx, 87654321h&quot;</span></span><br><span class="line">			<span class="string">&quot;jnz ex&quot;</span></span><br><span class="line">			<span class="string">&quot;jmp foo2proc&quot;</span>);</span><br><span class="line">	ex:</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">/////////////////////////////////////</span></span><br><span class="line">	foo2proc:</span><br><span class="line">		func = system;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(0x1000)</span><br><span class="line">	pop eax</span><br><span class="line">	ret</span><br><span class="line">(0x1010)</span><br><span class="line">	xor ebx, eax</span><br><span class="line">	ret</span><br><span class="line">(0x1020)</span><br><span class="line">	mov ebx, 0cafebabeh</span><br><span class="line">	ret</span><br><span class="line">(0x1030)</span><br><span class="line">	add esp, 0ch</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>(1) 要想在全局变量key中保存字符串’calc.exe’，需要满足的条件是________________________________________；要想在全局变量func中保存函数指针system，需要满足的条件是___________________________；（4分）<br />
(2) 本题的栈溢出需要通过_______漏洞触发，在vuln函数输入len为_________，可以绕过检查，从而能够写入很长的字符串。输入字符串的第________（填16进制数）位能够覆盖vuln函数返回地址。（6分）<br />
(3) 设vuln函数的返回地址在栈中保存的位置为0x100，那么如果需要在全局变量key中保存字符串’calc.exe’，需要将这个地方覆盖为_______________，这个函数的第一个参数应该写在__________________（填’0x104’或’0x108’）的位置，原因是____________________________。（6分）<br />
(4) 如果想在全局变量func中保存函数指针system，在调用foo2函数之前需要首先使用0x1000和0x1010的两段代码碎片，这种漏洞利用方式被称为__________。（2分）<br />
(5) 写出read函数执行时你的完整输入，格式：每行按&quot;地址：值&quot;格式书写，如&quot;0x100：0x12345678&quot;。已知函数的返回地址为0x100，foo1函数的起始地址为0x4013AB，foo2函数的起始地址为0x402880，全局变量key的地址为0x602040，func的地址为0x602050，可以写入任意字节（含零字节），提示：你需要首先计算输入的起始地址然后再开始书写。（8分）<br />
(6) 修复这个漏洞最简单的修改方法是______________________。（3分）</p>
<p>答案：<br />
(1) 调用foo1函数且参数从左到右的值依次应为0x12345678、0x87654321、0xdeadbeef；调用foo2函数且调用时eax的值应为0x12345678，ebx的值应为0x87654321<br />
(2) 整型溢出漏洞；负数；0x48~0x4b<br />
(3) foo1函数起始地址（或foo1函数中strcpy语句的起始地址）；0x108；0x104应为foo1函数的返回地址<br />
(4) ROP<br />
(5)</p>
<ul>
<li>0xbc~0xff：垃圾数据</li>
<li>0x100~0x103：0x1020</li>
<li>0x104~0x107：0x1000</li>
<li>0x108~0x10b：0x4D9BF99F（0x4D9BF99F XOR 0xcafebabe = 0x87654321）</li>
<li>0x10b~0x10f：0x1010</li>
<li>0x110~0x113：0x1000</li>
<li>0x114~0x117：0x12345678</li>
<li>0x118~0x11b：0x402880（foo2函数起始地址）</li>
<li>0x11c~0x11f：0x4013AB（foo1函数起始地址）</li>
<li>0x120~0x123：0x1030（思考这里将返回地址设为0x1030的作用是什么）</li>
<li>0x124~0x127：0x12345678</li>
<li>0x128~0x12b：0x87654321</li>
<li>0x12c~0x12f：0xdeadbeef</li>
<li>0x130~0x133：0x602050</li>
<li>0x134~0x137：0xdeadbeef</li>
<li>0x138~0x13b：0x602040</li>
</ul>
<p>(6) if判断条件加上对负数的判断</p>
<p><strong>6.</strong> Ret2csu是Linux平台下一种经典的ROP利用方法，它利用了每一个linux系统中可执行文件都存在的函数__libc_csu_init函数。下面是该函数的一个片段，分析如下代码片段，回答下列问题：（20分）（注：考试中不会出64位机器的题目，这里仅做练习，必要信息都会给出）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">loc_401A50:					; 下面是每一条指令的地址</span><br><span class="line">mov     rdx, r13			; 0x401A50</span><br><span class="line">mov     rsi, r15			; 0x401A53</span><br><span class="line">mov     rdi, rbp			; 0x401A56</span><br><span class="line">call    ds:[r12+rbx*8]		; 0x401A58</span><br><span class="line">add     rbx, 1				; 0x401A5C</span><br><span class="line">cmp     r14, rbx			; 0x401A60</span><br><span class="line">jnz     short loc_401A50	; 0x401A63</span><br><span class="line">add     rsp, 8				; 0x401A65</span><br><span class="line">pop     rbx					; 0x401A69</span><br><span class="line">pop     rbp					; 0x401A6A</span><br><span class="line">pop     r12					; 0x401A6B</span><br><span class="line">pop     r13 				; 0x401A6D</span><br><span class="line">pop     r14					; 0x401A6F</span><br><span class="line">pop     r15					; 0x401A71</span><br><span class="line">retn						; 0x401A73</span><br></pre></td></tr></table></figure>
<p>(1) 经过检查机器码发现，pop r15指令占2字节，其高1字节可表示另一条指令：pop rdi。同样pop r14指令的高1字节可表示pop rsi指令。在上述汇编代码中，将rip改为___________可以执行pop rsi，改为__________可以执行pop rdi。（4分）<br />
(2) 这段代码中有一个比较判断，当使用call指令执行代码之后，如果不再需要call调用，应该跳过这个判断，需要满足_________________。（3分）<br />
(3) 在64位Linux系统中，函数调用的前6个参数分别存放在rdi，rsi，rdx，rcx，r8，r9寄存器中。若要调用某函数，其前三个参数需要是0x12345678，0x87654321，0xdeadbeef，在ROP覆盖返回地址时，可以将返回地址修改为________________，可连续设置多个寄存器的值为自己设定的任意值。（3分）<br />
(4) 设此时某关键函数foo的地址保存在0x602020处，请写出ROP的内容以执行&quot;foo(0x12345678，0x87654321，0xdeadbeef)&quot;（从返回地址开始写，返回地址保存在栈中的地址为0x100000）（10分）<br />
格式示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x100000: 0x1234567887654321</span><br><span class="line">0x100008: 0xdeadbeefdeadbeef</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>答案：<br />
(1) 0x401A70；0x401A72<br />
(2) r14==rbx+1<br />
(3) 0x401A69<br />
(4)</p>
<ul>
<li>0x100000~0x100007：0x401A69</li>
<li>0x100008~0x10000f：0（rbx）</li>
<li>0x100010~0x100017：0x12345678（rbp）</li>
<li>0x100018~0x10001f：0x602020（r12）</li>
<li>0x100020~0x100027：0xdeadbeef（r13）</li>
<li>0x100028~0x10002f：1（r14）</li>
<li>0x100030~0x100037：0x87654321（r15）</li>
<li>0x100038~0x10003f：0x401A50</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%AC%AC9%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%AC%AC9%E7%AB%A0/" class="post-title-link" itemprop="url">软件安全——第9章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-03 09:45:12 / Modified: 09:47:34" itemprop="dateCreated datePublished" datetime="2023-03-03T09:45:12+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">软件安全</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="chapter-9-恶意软件防护技术"><a class="markdownIt-Anchor" href="#chapter-9-恶意软件防护技术"></a> Chapter 9 恶意软件防护技术</h1>
<h2 id="91-检测对象与策略"><a class="markdownIt-Anchor" href="#91-检测对象与策略"></a> 9.1 检测对象与策略</h2>
<p>何为恶意软件/代码检测？</p>
<ul>
<li>将检测对象与恶意代码特征进行对比分析，定位病毒程序或代码，或检测其恶意行为。</li>
</ul>
<p><strong>检测对象：</strong></p>
<ul>
<li>引导扇区（引导区病毒、MBR木马等）</li>
<li><strong>文件系统中可能带毒的文件</strong>（主要检测对象，几乎所有形式的文件都有可能带毒）</li>
<li>内存空间（有的恶意代码只存在于内存或只在内存中被还原）</li>
<li>主板BIOS（早期的病毒如CIH会破坏BIOS）</li>
<li>网络流量、系统行为等（通过行为间接检测可能的恶意代码）</li>
</ul>
<p><strong>检测策略：</strong></p>
<ul>
<li>专用检测技术：针对特定的已知的恶意代码。必须实时更新病毒库版本（如文件特征值检测技术）</li>
<li>通用检测技术：针对已知和未知的恶意代码，以广义行为特征或一般的行为特征作为判定依据（如启发式扫描技术、主动防御技术等）</li>
</ul>
<h2 id="font-colorred92-特征值检测技术font"><a class="markdownIt-Anchor" href="#font-colorred92-特征值检测技术font"></a> <font color=red>9.2 特征值检测技术</font></h2>
<p><strong>病毒特征值</strong>：鉴别特定计算机病毒的一种标志，通常为一段或多段二进制串或字符串。</p>
<p><strong>检测思路</strong>：获取样本 --&gt; 提取样本特征 --&gt; 更新病毒库 --&gt; 查杀病毒</p>
<p><strong>特征值提取选择</strong>：</p>
<ul>
<li>特定子串：具有特殊意义的字符串等。</li>
<li>感染标记：用于防止恶意代码重复感染的标记，虽然广泛存在但各不相同。</li>
<li>从病毒代码的特定地方开始取出的连续的、不大于64且不 含空格(ASCII值为32)的字节串。</li>
</ul>
<p><strong>提取方法</strong>：</p>
<ul>
<li>人工提取</li>
<li>自动提取（容易造成误杀）</li>
</ul>
<p><strong>优点</strong>：<br />
检测速度快，误报率低，技术成熟<br />
<strong>缺点</strong>：<br />
只能检测已知恶意代码且容易被绕过</p>
<p><strong>恶意软件对抗技术</strong></p>
<ul>
<li>手工修改自身特征，利用反病毒软件检测的结果进行针对性修改</li>
<li>自动修改自身特征，如加密、多态、变形等</li>
</ul>
<h2 id="font-colorred93-校验和检测技术font"><a class="markdownIt-Anchor" href="#font-colorred93-校验和检测技术font"></a> <font color=red>9.3 校验和检测技术</font></h2>
<p><strong>校验和</strong>：文件校验，与密码学中的Hash函数相关。常见的有CRC校验、MD5校验、SHA1校验等。</p>
<p><strong>检测思路</strong>：在文件使用/系统启动过程中，检查检测对象的实际校验和与预期是否一致，因而可以发现文件/引导区是否感染。<br />
预期：正常文件内容和正常引导扇区数据</p>
<p><strong>检测方式</strong>：</p>
<ul>
<li>系统自动检测：校验和检查程序常驻内存，每次运行应用程序都进行检查，需要预先保存校验和。</li>
<li>专用检测工具：计算正常状态文件的校验和，将校验和值写入文件或检测工具后比较。</li>
<li>自检：带有校验和检测功能的程序，将正常状态校验和写入自身，应用程序启动时比较现行校验和与原校验和值完成自检。</li>
</ul>
<p><strong>检测内容</strong>：</p>
<ul>
<li>文件头部：在文件很大的情况下为节省时间只对头部进行校验</li>
<li>文件属性：检查文件长度、创建时间、读写属性、首簇号等</li>
<li>文件内容：检查整个文件</li>
<li>系统数据：检查引导扇区、中断向量表、驱动程序处理例程等</li>
</ul>
<p><strong>优点</strong>：<br />
方法简单，能够发现未知病毒，能够发现文件的微小变化<br />
<strong>缺点</strong>：<br />
必须先保存正确的校验码，容易误报，效率低，不能识别病毒类别</p>
<h2 id="font-colorred94-启发式扫描技术font"><a class="markdownIt-Anchor" href="#font-colorred94-启发式扫描技术font"></a> <font color=red>9.4 启发式扫描技术</font></h2>
<p>恶意代码检测经验和知识的软件实现。</p>
<p><strong>检测可疑的程序代码指令序列</strong>：</p>
<ul>
<li>格式化磁盘类操作（破坏）</li>
<li>搜索和定位各种可执行程序的操作（可能要感染）</li>
<li>实现驻留内存的操作（隐藏）</li>
<li>发现非常用的或未公开的系统功能调用的操作、子程序调用中只执行入栈操作（正常的函数不会这样）、远距离跳转指令(超过文件长度的三分之二) 等</li>
<li>敏感系统行为</li>
<li>敏感API函数（序列）调用功能</li>
</ul>
<p><strong>关键API函数</strong>：</p>
<ul>
<li>GetModuleHandleA：返回可执行文件句柄</li>
<li>LoadLibraryA：加载动态库</li>
<li>GetProcAddress：获取API函数内存地址</li>
<li>ExitProcess：退出进程</li>
<li>VirtualAlloc：分配堆内存空间</li>
<li>VirtualFree：释放堆内存空间</li>
</ul>
<p><strong>启发式扫描步骤</strong>：</p>
<ul>
<li>定义通用可疑特征（指令序列或行为）</li>
<li>对上述功能操作将被按照安全和可疑的等级进行排序，授以不同的<strong>权值</strong>。</li>
<li>鉴别特征，如果程序的权值总和超过一个事先定义的阈值，则认为“发现病毒”</li>
<li>（可见启发式扫描与机器学习有一定的关联）</li>
</ul>
<p><strong>优点</strong>：<br />
能够发现未知病毒<br />
<strong>缺点</strong>：<br />
误报率高</p>
<p>通常使用传统扫描+启发式扫描方式检测病毒，可降低误报率</p>
<p><strong>恶意软件对抗技术</strong></p>
<ul>
<li>直接关闭防病毒软件</li>
<li>关闭启发式机制</li>
</ul>
<h2 id="font-colorred95-虚拟机检测技术font"><a class="markdownIt-Anchor" href="#font-colorred95-虚拟机检测技术font"></a> <font color=red>9.5 虚拟机检测技术</font></h2>
<p>随着加密、加壳、病毒变形的出现，需要通过虚拟机技术进行检测。</p>
<p>虚拟机检测技术：在反病毒系统中设置的一种程序机制，它能在内存中<strong>模拟一个小的封闭程序执行环境</strong>（类似于沙箱机制），所有待查文件都以解释方式在其中被虚拟执行。（一般只需要虚拟执行一小部分代码）</p>
<p><strong>优点</strong>：能够有效处理加密类病毒，与传统检测方式结合能够有效准确率，与启发式扫描方式结合能够有效检测未知病毒。</p>
<h2 id="96-主动防御技术"><a class="markdownIt-Anchor" href="#96-主动防御技术"></a> 9.6 主动防御技术</h2>
<p><strong>动态监视</strong>所运行程序调用各种API的动作，自动分析程序动作之间的逻辑关系，自动判定程序行为的合法性。（即无论是否有恶意代码存在，都主动监控系统）</p>
<p><strong>优点</strong>：可发现未知恶意软件、可准确地发现未知恶意软件的恶意行为。<br />
<strong>缺点</strong>：可能误报警、不能识别恶意软件名称，以及在实现时有一定难度</p>
<hr />
<p><strong>练习题</strong>：<br />
<strong>1.</strong> 蜜罐技术是近年来较为热门的一种安全技术。安全运营商为了获取最新的恶意代码，会向外开放一个有某些特定漏洞的网络端口以供连接。这些网络端口不提供任何服务，因此正常的访问者不会进入此端口，而某些恶意代码会将其误认为是脆弱的可攻击对象而进入攻击。此时安全运营者就能够获取到该恶意代码的一些具体信息，如监控其攻击方式与流程、获取关键文件等，以此来扩充自己的病毒库并研究防御措施。据此回答下列问题：<br />
(1) 获取病毒样本后，研究人员发现这个病毒采用了某种加壳方式。那么最好应该使用__________方式进行恶意代码的检测，不使用特征值检测的原因是__________________________。<br />
(2) 一天，研究员在几个“蜜罐”中都发现了一种恶意代码。分析发现，代码中对字符串的一些字节进行了替换，但替换位置不同。这种恶意代码能否使用特征值检测方式进行检测？_______ （能或不能），原因是_________________________。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%AC%AC8%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%AC%AC8%E7%AB%A0/" class="post-title-link" itemprop="url">软件安全——第78章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-03 09:44:44 / Modified: 09:47:34" itemprop="dateCreated datePublished" datetime="2023-03-03T09:44:44+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">软件安全</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>586</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="chapter-8-网络蠕虫"><a class="markdownIt-Anchor" href="#chapter-8-网络蠕虫"></a> Chapter 8 网络蠕虫</h1>
<h2 id="81-定义"><a class="markdownIt-Anchor" href="#81-定义"></a> 8.1 定义</h2>
<p>蠕虫的基本特征：</p>
<ul>
<li>能够进行传播</li>
<li>能够进行自我复制</li>
</ul>
<p><strong>计算机蠕虫可以独立运行，并能把自身的一个包含所有功能的版本传播到另外的计算机上。</strong></p>
<p>第一个蠕虫：Morris蠕虫。</p>
<ul>
<li>利用的漏洞：
<ul>
<li>Rsh/exec：用户缺省认证</li>
<li>Sendmail的debug模式</li>
<li>Fingerd缓冲区溢出</li>
</ul>
</li>
</ul>
<h2 id="82-分类"><a class="markdownIt-Anchor" href="#82-分类"></a> 8.2 分类</h2>
<ul>
<li>漏洞利用类蠕虫：利用计算机系统的漏洞进行破坏与传播。如Stuxnet</li>
<li>口令破解类蠕虫：通过弱口令进入目标系统。</li>
<li>邮件传播类蠕虫</li>
<li>即时通信类蠕虫：通过即使通信进行传播。</li>
<li>其他：如USB蠕虫等</li>
</ul>
<h2 id="83-基本功能"><a class="markdownIt-Anchor" href="#83-基本功能"></a> 8.3 基本功能</h2>
<ol>
<li><strong>信息搜集</strong>：对本地和目标节点主机的信息汇集
<ul>
<li>信息搜集模块需要<strong>为发现易感染目标提供支持</strong>，搜集包括本机系统信息、用户信息、对本机的信任或者授权的主机、本机所处的网络拓朴结构、边界路由信息等。（即寻找下一个感染目标）</li>
</ul>
</li>
<li><strong>扫描探测</strong>：对具体的目标主机的服务漏洞检测
<ul>
<li>扫描探测模块完成特定目标的脆弱性检测，发现易感染目标。</li>
</ul>
</li>
<li><strong>攻击渗透</strong>：利用发现的服务漏洞实现攻击</li>
<li><strong>自我推进</strong>：完成对目标结点的感染
<ul>
<li>自我推进模块需要在本机与目标主机之间完成蠕虫副本传递，使蠕虫正式“进驻”该目标机器。</li>
</ul>
</li>
</ol>
<h2 id="84-蠕虫防护"><a class="markdownIt-Anchor" href="#84-蠕虫防护"></a> 8.4 蠕虫防护</h2>
<ul>
<li>个人用户
<ul>
<li>及时修补补丁</li>
<li>使用防火墙软件</li>
<li>关注流量的异常性</li>
</ul>
</li>
<li>网络管理者
<ul>
<li>网关阻断</li>
<li>补丁下发</li>
</ul>
</li>
<li>网络应用厂商
<ul>
<li>应用流量过滤与阻断</li>
<li>补丁自动分发与修补</li>
</ul>
</li>
<li>安全厂商
<ul>
<li>网络流量分析与提取</li>
<li>网络安全设备快速阻断</li>
<li>快速利用客户端安全软件清除蠕虫个体，进行补丁修复</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%AC%AC7%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%AC%AC7%E7%AB%A0/" class="post-title-link" itemprop="url">软件安全——第7章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-03 09:44:41 / Modified: 09:47:34" itemprop="dateCreated datePublished" datetime="2023-03-03T09:44:41+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">软件安全</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="chapter-7-木马与后门"><a class="markdownIt-Anchor" href="#chapter-7-木马与后门"></a> Chapter 7 木马与后门</h1>
<h2 id="71-木马基本概念"><a class="markdownIt-Anchor" href="#71-木马基本概念"></a> 7.1 木马基本概念</h2>
<p>通过欺骗或诱骗的方式安装，并在用户的计算机中隐藏以实现控制用户计算机的目的。<br />
<strong>属于具有远程控制、信息窃取、破坏等功能的恶意代码</strong></p>
<p>特点：欺骗性、隐藏性、非授权性、交互性</p>
<h2 id="72-木马分类"><a class="markdownIt-Anchor" href="#72-木马分类"></a> 7.2 木马分类</h2>
<ul>
<li>远程控制型木马：能够进行远程控制的木马，攻击者与被控制端有双向交互。例：灰鸽子、广外女生</li>
<li>信息获取型木马：进行信息窃取的木马，被控制端到攻击者的单向交互。</li>
<li>破坏型木马：进行数据破坏、资源消耗（包括挖矿）的木马，有攻击者到被控制者的单向交互或无交互。</li>
</ul>
<h2 id="73-木马植入方式"><a class="markdownIt-Anchor" href="#73-木马植入方式"></a> 7.3 木马植入方式</h2>
<ul>
<li>网页挂马植入：即黑客在入侵某些网站后将自己的木马嵌入到其网站的页面上，使用户点开页面后自动下载木马。</li>
<li>电子邮件植入：将木马程序以附件形式在邮件中传播。有时将电子邮件与网页挂马相结合，使得不选中附件也能传播木马。</li>
<li>文档捆绑植入：使用office和pdf文档的漏洞等进行植入。</li>
<li>伪装欺骗植入：通过修改命名、后缀、图标等欺骗电脑用户点击后植入。</li>
<li>捆绑植入：如exe捆绑、文档嵌入、多媒体文件、电子书植入等。<strong>木马捆绑是把一个有界面的正常程序，和一个后门程序捆绑在一起从而制作一个木马。</strong></li>
<li>其他：社会工程学。</li>
</ul>
<h2 id="74-木马的通信方式"><a class="markdownIt-Anchor" href="#74-木马的通信方式"></a> 7.4 木马的通信方式</h2>
<ul>
<li>传输通道构建信息：黑客获取数据等的交互需要黑客提供自己机器的IP地址、端口、第三方网址等信息才能进行</li>
<li>建立通道连接的方式有：正向连接和反向连接。
<ul>
<li>正向连接：黑客端主动连接被控制端以获取目标机器的信息。
<ul>
<li>优点：攻击者无需外部IP地址、木马样本不会泄露自身的IP地址</li>
<li>缺点：可能会被防火墙阻挡、被攻击者必须提供外部IP地址（否则被攻击者若在局域网中，则IP地址可能不固定，难以形成长期连接）、定位被攻击者相对困难（被攻击者的IP地址和上线时间不确定）</li>
</ul>
</li>
<li>反向连接：
<ul>
<li><strong>方案1</strong>：被控制端直接连接黑客控制端
<ul>
<li>优点：较容易通过防火墙、攻击目标可以实现上线即控制、可控制局域网中的目标</li>
<li>缺点：会暴露控制服务器信息、攻击者需要具备外部IP地址</li>
</ul>
</li>
<li><strong>方案2</strong>：被控制端与控制端之间由肉鸡连接，间接通信
<ul>
<li>优点：可以绕过防火墙、攻击目标可以实现上线即控制、不易被发现（因为是代理，因此不会暴露攻击者自己的信息）</li>
<li>缺点：肉鸡从哪来，需要保障肉鸡的稳定性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>使用的通信协议
<ul>
<li>TCP协议：传输稳定，但容易被发现，有正向和反向两种形式
<ul>
<li>HTTP协议伪装：如果黑客能够截取目标机器的数据包，就可以对HTTP协议包做出一定的修改，这种攻击的成功率很大，但前提是必须能够让黑客的机器充当目标机器的代理服务器。</li>
</ul>
</li>
<li>UDP协议：负载较小，但传输不稳定，有正向和反向两种形式</li>
<li>ICMP + TCP/UDP：由于ICMP报文一般由内核处理，因此一般不会被防火墙处理，可以在ICMP报文上做手脚。</li>
<li>BITS（Background Intelligent Transfer Service）：一个后门，适用于Windows2000/XP/2003，在进程管理器中不可见，平时没有端口，提供正向和反向连接两种方式</li>
</ul>
</li>
</ul>
<h2 id="75-远控木马"><a class="markdownIt-Anchor" href="#75-远控木马"></a> 7.5 远控木马</h2>
<ol>
<li>结构：木马配置程序、控制端程序（客户端）、被控制端程序（服务器）</li>
<li>功能：文件、进程、服务、注册表管理，监控摄像头、语音、键盘、桌面，开shell等</li>
</ol>
<h2 id="76-木马防御思路"><a class="markdownIt-Anchor" href="#76-木马防御思路"></a> 7.6 木马防御思路</h2>
<ul>
<li>静态文件特征检测</li>
<li>网络流量特征检测</li>
<li>系统行为特征检测</li>
<li>功能行为特征检测</li>
<li>攻击意图检测等</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%AC%AC6%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%AC%AC6%E7%AB%A0/" class="post-title-link" itemprop="url">软件安全——第6章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-03 09:44:39 / Modified: 09:47:34" itemprop="dateCreated datePublished" datetime="2023-03-03T09:44:39+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">软件安全</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.9k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="chapter-6-宏病毒和脚本病毒"><a class="markdownIt-Anchor" href="#chapter-6-宏病毒和脚本病毒"></a> Chapter 6 宏病毒和脚本病毒</h1>
<h2 id="61-宏的基本概念和使用"><a class="markdownIt-Anchor" href="#61-宏的基本概念和使用"></a> 6.1 宏的基本概念和使用</h2>
<p>宏（Macro）：能组织到一起作为独立的命令使用的一系列word命令，可以实现任务执行的自动化，简化日常工作。</p>
<h2 id="62-宏病毒"><a class="markdownIt-Anchor" href="#62-宏病毒"></a> 6.2 宏病毒</h2>
<p>存在于数据文件或模板中（字处理文档、数据表格、数据库、演示文档等），使用宏语言编写，利用宏语言的功能将自己寄生到其他数据文档。</p>
<p>在Word宏中，使用AutoOpen、AutoClose、AutoExec、AutoExit、AutoNew等函数能够自动进行文件的打开与关闭、命令的执行等操作。在Excel宏中可以使用AutoOpen、AutoClose、AutoActivate、AutoDeactivate等。</p>
<h3 id="宏病毒感染"><a class="markdownIt-Anchor" href="#宏病毒感染"></a> 宏病毒感染</h3>
<p>宏分为两种：</p>
<ul>
<li>内建宏：位于文档中，对该文档有效，如文档打开（AutoOpen）、保存、打印、关闭等。</li>
<li>全局宏：位于office模板中，为所有文档所共用，如打开Word程序（AutoExec）。</li>
</ul>
<p>其传播路线为：<br />
单个文档-&gt;office模板-&gt;多个文档<br />
在网络中多以电子邮件的形式传播（Mellisa病毒）</p>
<p>感染方案：让宏病毒在数据文档和文档模板之间互相感染。</p>
<p>宏病毒代码中包含自我保护、代码导出与导入等模块，其中自我保护指关闭警告弹窗显示、关闭进度条显示、关闭病毒防护等。代码导出即将病毒代码保存到某个位置便于后续感染该计算机上的其他文档。代码导出即从该路径导入宏病毒以进行传播。</p>
<p><strong>自我保护</strong></p>
<ol>
<li>禁止提示信息</li>
</ol>
<ul>
<li>On Error Resume Next '如果发生错误，不弹出出错窗口，继续执行下面语句</li>
<li>Application.DisplayAlerts = wdAlertsNone '不弹出警告窗口</li>
<li>Application.DisplayStatusBar = False '不显示状态栏，以免显示宏的运行状态</li>
<li>Options.VirusProtection = False '关闭病毒保护功能，运行前如果包含宏，不提示</li>
<li>Options.SaveNormalPrompt = False '如果公用模块被修改，不给用户提示窗口而直接保存</li>
<li>Application.ScreenUpdating = False '不让刷新屏幕，以免病毒运行引起速度变慢</li>
<li>Application.EnableCancelKey = wdCancelDisabled ‘不允许通过ESC键结束正在运行的宏</li>
</ul>
<ol start="2">
<li>屏蔽命令菜单，不允许查看宏</li>
</ol>
<ul>
<li>通过特定宏定义屏蔽  <figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sub ViewVBCode()</span><br><span class="line">	MsgBox <span class="string">&quot;Unexcpected error&quot;</span>,<span class="number">16</span></span><br><span class="line"><span class="keyword">End</span> Sub</span><br></pre></td></tr></table></figure>
<ul>
<li>ViewCode：该过程和ViewVBCode函数一样，如果用户按工具栏上的小图标就会执行这个过程。</li>
<li>ToolsMacro：当用户按下“ALT+F8”或者“工具—宏”时调用的过程函数。</li>
<li>FileTemplates：当显示一个模板的所有宏时，调用的过程函数。</li>
</ul>
</li>
<li>Disable或删除特定菜单项
<ul>
<li>CommandBars(“Tools”).Controls(16).Enabled = False：使“工具—宏菜单失效”</li>
<li>CommandBars(“Tools”).Controls(16).Delete：删除“工具—宏”菜单</li>
</ul>
</li>
</ul>
<ol start="3">
<li>隐藏真实代码<br />
“自动宏”中，不包括任何感染或破坏的代码，但包含了创建、执行和删除新宏（实际进行感染和破坏的宏）的代码。<br />
将宏代码字体颜色设置成与背景一样的白色等。</li>
</ol>
<h2 id="63-vbs脚本"><a class="markdownIt-Anchor" href="#63-vbs脚本"></a> 6.3 VBS脚本</h2>
<p>VBS：Visual Basic Script，VB脚本语言。</p>
<p>使用COM组件、WMI、WSH、ADSI访问系统中的元素，对系统进行管理。</p>
<p>VBScript可以通过Windows脚本宿主(Windows Scripting Host，WSH)调用COM，因而可以使用Windows操作系统中可以被使用的程序库。</p>
<h2 id="64-vbs脚本病毒"><a class="markdownIt-Anchor" href="#64-vbs脚本病毒"></a> 6.4 VBS脚本病毒</h2>
<p>用VBScript编写，能够进行自我传播的破坏性程序，其需要人工干预触发执行。</p>
<h3 id="如何感染文件"><a class="markdownIt-Anchor" href="#如何感染文件"></a> 如何感染文件</h3>
<p>直接进行自我复制，其中大多数代码可以直接附加在其他同类程序之中</p>
<h3 id="如何获得控制权"><a class="markdownIt-Anchor" href="#如何获得控制权"></a> 如何获得控制权</h3>
<ul>
<li>修改注册表启动项</li>
<li>添加程序到“开始”-“程序”-“启动”选项</li>
<li>修改系统配置文件win.ini、system.ini、wininit.ini、winstart.bat、autoexec.bat等的相关启动选项。</li>
<li>通过映射文件执行方式</li>
<li>欺骗用户，让用户自己执行</li>
<li>desktop.ini和folder.htt互相配合</li>
</ul>
<h3 id="font-colorblue对抗反病毒软件的技巧font"><a class="markdownIt-Anchor" href="#font-colorblue对抗反病毒软件的技巧font"></a> <font color=blue>对抗反病毒软件的技巧</font></h3>
<ul>
<li>自加密
<ul>
<li>为防止反病毒软件进行特定字符串的检索，对文件本身进行自加密修改其中的部分字节。</li>
</ul>
</li>
<li>运用Execute函数
<ul>
<li>Execute函数能够执行一个存在于字符串中的命令，可以避免使用FileSystemObject以绕过检查。</li>
</ul>
</li>
<li>改变某些对象的声明方法
<ul>
<li>对字符串进行拼接、编码等防止字符串检索。</li>
</ul>
</li>
<li>扫描进程并关闭反病毒软件</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%AC%AC5%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%AC%AC5%E7%AB%A0/" class="post-title-link" itemprop="url">软件安全——第5章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-03 09:44:36 / Modified: 09:47:34" itemprop="dateCreated datePublished" datetime="2023-03-03T09:44:36+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">软件安全</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>4.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="chapter-5-windows-pe病毒"><a class="markdownIt-Anchor" href="#chapter-5-windows-pe病毒"></a> Chapter 5 Windows PE病毒</h1>
<h2 id="51-基本概念"><a class="markdownIt-Anchor" href="#51-基本概念"></a> 5.1 基本概念</h2>
<p>PE病毒：以Windows PE程序为载体，能寄生于PE文件，或Windows系统的病毒程序。<br />
感染：在尽量不影响目标程序（系统）正常功能的前提下，使其具有病毒自己的功能（感染模块、触发模块、破坏模块等）。</p>
<h2 id="52-分类"><a class="markdownIt-Anchor" href="#52-分类"></a> 5.2 分类</h2>
<p>按照感染目标的类型分类：</p>
<ul>
<li>文件感染：将代码寄生在PE文件中。（传统感染型和捆绑释放型感染）
<ul>
<li>传统感染型：在PE文件中添加病毒代码段与数据段，修改节表等控制结构使程序能够首先执行病毒代码。主体是目标程序。<strong>优点：被感染后的程序主体依然是目标程序，不影响目标程序图标，隐蔽性稍好。缺点：对病毒代码的编写要求较高，通常是汇编语言编写，难以成功感染自校验程序。</strong></li>
<li>捆绑释放型：将目标程序和病毒程序捆在一起，将目标程序作为数据存储在病毒体内。主体是病毒程序。编写较容易，可使用高级语言编写。</li>
</ul>
</li>
<li>系统感染：将代码或程序寄生在Windows操作系统，不针对特定的PE文件。感染途径有：
<ul>
<li>即时通信软件</li>
<li>U盘和光盘</li>
<li>电子邮件</li>
<li>网络共享等</li>
</ul>
</li>
</ul>
<h2 id="53-传统文件感染"><a class="markdownIt-Anchor" href="#53-传统文件感染"></a> 5.3 传统文件感染</h2>
<h3 id="使用技术"><a class="markdownIt-Anchor" href="#使用技术"></a> 使用技术</h3>
<ul>
<li>重定位：病毒代码目标寄生位置不固定</li>
<li>API函数自获取：在没有引入函数表的情况下获取需要使用的API函数内存地址</li>
<li>目标程序遍历搜索：全盘查找，或者部分盘符查找以感染其他文件</li>
<li>感染模块：病毒代码插入位置选择与写入、病毒执行完毕后将控制权移交给正常的程序执行流程</li>
</ul>
<p><strong>重定位</strong></p>
<ul>
<li>在编译时，有些基于Image Base的指令会将地址固定写死在指令之中，如push 0x401215，这时修改Image Base会使得这条指令的意义丢失，因此需要重定位。在病毒代码编译后而没有植入时，其起始地址很可能不是我们想要病毒代码在HOST文件中的起始地址，需要进行移动。</li>
<li>其本质是<strong>修正实际地址与预期地址的差异</strong></li>
<li>解决方案：
<ul>
<li>逐一硬编码（较为繁琐）</li>
<li><font color=red>病毒代码运行过程中自我重定位</font>
<ul>
<li><code>call</code>指令可以将下一条要执行的指令的地址压入栈，配合pop即可得到下一条指令的地址，以此病毒就可以知道自己的地址是什么。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>API函数自获取</strong></p>
<ul>
<li>找到DLL文件的引入函数节，在其中进行遍历查找即可。</li>
<li>kernel32.dll中的关键API函数：GetProcAddress和LoadLibraryA</li>
<li>需要首先获得kernel32.dll文件的基地址，可以硬编码但是很难兼容，主要通过<strong>kernel32模块中的相应结构和特征定位</strong></li>
<li><font color=blue>获取kernel32.dll中的地址的方法：</font>
<ul>
<li>程序入口代码执行时，<strong>栈顶</strong>存储的地址<br />
系统打开一个可执行文件时，它会调用Kernel32.dll中的<strong>CreateProcess</strong>函数，CreateProcess函数在完成应用程序装载后，会先将返回地址压入到堆栈顶端。当该应用程序结束后，会将返回地址弹出放到EIP中，继续执行。这个返回地址显然位于kernel32.dll之中。在此基础上按照内存对齐（一般为0x10000）的值向前遍历直至检测到kernel32.dll的文件头 <strong>（搜索较费时且容易产生异常情况）</strong></li>
<li>SEH链末端处理函数<br />
SEH：Structured Exception Handler，异常处理模块，以链表形式存在。在链中查找<strong>prev成员等于0xFFFFFFFF（表示已经遍历到链表尾）<strong>的</strong>EXCEPTION_REGISTER结构</strong>，该结构中handler值指向<strong>系统异常处理例程，它总是位于KERNEL32模块中</strong>。根据这一特性，然后进行向前搜索就可以查找KERNEL32.DLL在内存中的基地址。</li>
<li>PEB相关数据结构指向各模块地址<br />
<strong>TEB</strong>：Thread Environment Block，线程环境块，该结构体包含进程中运行线程的各种信息，进程中的每个线程都对应一个TEB结构体。<br />
<strong>PEB</strong>：Process Environment Block，进程环境块，存放进程信息，每个进程都有自己的PEB信息。位于用户地址空间。
<ul>
<li>fs:[0]指向TEB结构，TEB结构中偏移0x30位置保存的是PEB的地址，因此可以从fs:[30h]获得PEB地址。</li>
<li>然后通过PEB[0x0c]获得PEB_LDR_DATA数据结构地址（即下面的VOID *DllList指针）</li>
</ul>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">		<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB</span> &#123;</span> <span class="comment">// Size: 0x1D8</span></span><br><span class="line"><span class="comment">/*000*/</span> UCHAR InheritedAddressSpace;</span><br><span class="line"><span class="comment">/*001*/</span> UCHAR ReadImageFileExecOptions;</span><br><span class="line"><span class="comment">/*002*/</span> UCHAR BeingDebugged;</span><br><span class="line"><span class="comment">/*003*/</span> UCHAR SpareBool; <span class="comment">// Allocation size</span></span><br><span class="line"><span class="comment">/*004*/</span> HANDLE Mutant;</span><br><span class="line"><span class="comment">/*008*/</span> HINSTANCE ImageBaseAddress; <span class="comment">// Instance</span></span><br><span class="line"><span class="comment">/*00C*/</span> VOID *DllList;</span><br><span class="line"><span class="comment">/*010*/</span> PPROCESS_PARAMETERS *ProcessParameters;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ul>
<li>然后通过从PEB_LDR_DATA[0x1c]获取InInitializationOrderModuleList.Flink地址</li>
</ul>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB_LDR_DATA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">　ULONG Length; <span class="comment">// +0x00</span></span><br><span class="line">　BOOLEAN Initialized; <span class="comment">// +0x04</span></span><br><span class="line">　PVOID SsHandle; <span class="comment">// +0x08</span></span><br><span class="line">　LIST_ENTRY InLoadOrderModuleList; <span class="comment">// +0x0c</span></span><br><span class="line">　LIST_ENTRY InMemoryOrderModuleList; <span class="comment">// +0x14</span></span><br><span class="line">　LIST_ENTRY InInitializationOrderModuleList;<span class="comment">// +0x1c</span></span><br><span class="line">&#125; PEB_LDR_DATA,*PPEB_LDR_DATA; <span class="comment">// +0x24</span></span><br></pre></td></tr></table></figure>
<ul>
<li>最后在Flink[0x08]中得到KERNEL32.DLL模块的基地址。</li>
</ul>
</li>
<li>栈区特定高端地址的数据
<ul>
<li>这种方法只适用于Windows NT操作系统，但这种方法的代码量最小，只有25B。</li>
<li>每个执行的线程都有它自己的TEB(线程环境块)，该块中存储线程的栈顶的地址，从该地址向下偏移0X1C处的地址肯定位于Kernel32.dll中。则可以通过该地址向低地址以64KB为单位来查找Kernel32.dll的基地址。</li>
</ul>
</li>
</ul>
</li>
<li><font color=red>获取指定函数内存地址的方法</font>
<ul>
<li>通过Address of Names数组查找函数名，记录索引值</li>
<li>在Address of Name Ordinals编号数组中找到这个索引值对应的编号</li>
<li>在Address of Functions数组中以编号为索引即可找到指定函数的内存地址</li>
</ul>
</li>
</ul>
<p><strong>目标程序遍历搜索</strong></p>
<ul>
<li>通常以PE文件的格式（EXE、SCR、DLL等）作为感染目标</li>
<li>对目标进行搜索通常使用FindFirstFile和FindNextFile两个API函数</li>
<li>可进行递归或非递归遍历</li>
</ul>
<p><strong>文件感染</strong></p>
<ul>
<li>感染的关键在于：
<ul>
<li>病毒代码能够运行
<ul>
<li>选择位置放入病毒代码并将控制权交由病毒代码</li>
</ul>
</li>
<li>原有的正常功能不能被破坏
<ul>
<li>记录原始的程序控制点位置，当病毒代码执行完毕后交回控制权</li>
<li>设置感染标记，避免重复感染</li>
</ul>
</li>
</ul>
</li>
<li><strong>代码插入位置选择</strong>
<ul>
<li><strong>添加新节</strong>：在新节中专门存放病毒代码，需要检查节表空间是否足够
<ul>
<li>判断该文件是否是可执行文件（检查MZ和PE标识）</li>
<li>判断该文件是否已经被感染（避免重复感染）</li>
<li>获取数据目录的个数，经过计算得到节表的起始地址</li>
<li>得到最后一个节表的偏移，并在其后写入新节的属性等控制信息</li>
<li>在病毒节中写入病毒代码和数据</li>
<li>修正文件头信息（节的数量等）</li>
</ul>
</li>
<li>碎片式感染：将病毒代码分散插入到节之间的填充部分</li>
<li>插入式感染：将病毒代码插入到HOST代码节的中间或前后（可能会导致程序无法运行）</li>
<li>伴随式感染：备份HOST程序并用自己的程序替换HOST程序，自己的代码执行完之后再去执行HOST备份程序</li>
</ul>
</li>
</ul>
<h2 id="54-捆绑式感染"><a class="markdownIt-Anchor" href="#54-捆绑式感染"></a> 5.4 捆绑式感染</h2>
<p>HOST作为数据存放在病毒程序中，执行病毒程序时还原并执行HOST文件。熊猫烧香即属于此类病毒。</p>
<p>优点：编写简单、效率高。可感染自校验程序。<br />
缺点：被感染后的程序主体是病毒程序，易被发现（程序叠加＋释放执行），程序图标问题。（需要处理好资源节，熊猫烧香就没有处理好导致暴露）</p>
<h2 id="55-系统感染"><a class="markdownIt-Anchor" href="#55-系统感染"></a> 5.5 系统感染</h2>
<p>此类病毒通常作为单独个体，不感染系统中的其他文件。</p>
<p>需要通过自启动获得控制权</p>
<ul>
<li>于计算机启动时启动：BIOS-MBR-DBR-系统内部</li>
<li>于系统内部启动：修改注册表键值、于系统中特定位置启动、以配置文件形式启动、修改特定文件以启动</li>
<li>利用系统自动播放机制（Autorun.inf）
<ul>
<li>inf文件是Winodws操作系统下用来描述设备或文件等数据信息的文件。autorun.inf是一个文本形式的配置文件，我们可以用文本编辑软件进行编辑，它只能位于驱动器的根目录下。这个文件包含了<strong>需要自动运行的命令</strong>，如改变的驱动器图标、运行的程序文件、可选快捷菜单等内容。<a target="_blank" rel="noopener" href="https://blog.csdn.net/shufac/article/details/52071945?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165396614616781483783731%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=165396614616781483783731&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2">相关资料</a></li>
</ul>
</li>
<li>在其他可执行文件中嵌入少量病毒代码</li>
<li>替换DLL文件</li>
</ul>
<p>传播方式：可移动磁盘存储与网络传播</p>
<h2 id="56-实验内容"><a class="markdownIt-Anchor" href="#56-实验内容"></a> 5.6 实验内容</h2>
<h3 id="链接命令设定代码节可写"><a class="markdownIt-Anchor" href="#链接命令设定代码节可写"></a> 链接命令——设定代码节可写：</h3>
<p><code>link /subsystem:windows /section:.text,rwe mype1.obj</code><br />
其中的/section:.text,rwe表示.text节可读可写可执行。</p>
<h3 id="手动修改入口点使两个弹窗变成一个弹窗"><a class="markdownIt-Anchor" href="#手动修改入口点使两个弹窗变成一个弹窗"></a> 手动修改入口点，使两个弹窗变成一个弹窗：</h3>
<p>将Address of Entry Point进行修改，跳过弹出第一个弹窗的指令（在实验中应为+0x16）</p>
<h3 id="代码重定位写法"><a class="markdownIt-Anchor" href="#代码重定位写法"></a> 代码重定位写法</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">call delta ;这条语句执行之后，堆栈顶端为delta在内存中的真正地址</span><br><span class="line">delta:</span><br><span class="line">pop ebp ;这条语句将delta在内存中的真正地址存放在ebp寄存器中</span><br><span class="line">sub ebp,offset delta</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">call @F</span><br><span class="line">@@:</span><br><span class="line">pop ebp</span><br><span class="line">sub ebp,offset @B</span><br></pre></td></tr></table></figure>
<p>（这里的@F指的是前面最近的一个@@标号，@B指后面最近的一个@@标号）</p>
<h3 id="kernel32dll基地址获取代码理解"><a class="markdownIt-Anchor" href="#kernel32dll基地址获取代码理解"></a> kernel32.dll基地址获取代码理解</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mov eax,[esp]  ;from stack</span><br><span class="line">xor edx,edx</span><br><span class="line">getK32Base:</span><br><span class="line">dec eax</span><br><span class="line">mov dx,word ptr[eax+IMAGE_DOS_HEADER.e_lfanew]  ;3ch</span><br><span class="line">test dx,0f000h  ;check f0</span><br><span class="line">jnz getK32Base</span><br><span class="line">cmp eax,dword ptr[eax+edx+IMAGE_NT_HEADERS.OptionalHeader.ImageBase]</span><br><span class="line">	;double check ImageBase value with eax</span><br><span class="line">jnz getK32Base</span><br><span class="line">mov [ebp+k32Base],eax ;save ImageBase into k32Base</span><br></pre></td></tr></table></figure>
<p>这里第一条语句为从栈中获取kernel32.dll中的地址保存到eax中。<br />
之后将dx保存为PE文件中new EXE Header的偏移位置（0x3C），检查dx的值是否小于0x1000。<br />
如果小于，再检查Image Base的值是否等于eax（如果eax指向dll文件头，那么Image Base的值应该等于eax）。若等于，则查找完毕，eax即为kernel32.dll的起始地址。<br />
注意上面代码对eax是逐次减1比较，由于内存对齐机制，这里可以直接按照对齐去查找，能够减少很多循环的次数。</p>
<h3 id="kernel32dll中函数内存地址的获取"><a class="markdownIt-Anchor" href="#kernel32dll中函数内存地址的获取"></a> kernel32.dll中函数内存地址的获取</h3>
<p>API’s Address  =  ( API’s Ordinal  *  4  )  +  AddressOfFunctions’ VA +  Kernel32 imagebase</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%AC%AC4%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%AC%AC4%E7%AB%A0/" class="post-title-link" itemprop="url">软件安全——第4章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-03 09:44:33 / Modified: 09:47:34" itemprop="dateCreated datePublished" datetime="2023-03-03T09:44:33+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">软件安全</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>7.5k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>7 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="chapter-4-pe文件结构"><a class="markdownIt-Anchor" href="#chapter-4-pe文件结构"></a> Chapter 4 PE文件结构</h1>
<h2 id="41-pe文件及其表示形式"><a class="markdownIt-Anchor" href="#41-pe文件及其表示形式"></a> 4.1 PE文件及其表示形式</h2>
<p>可移植的可执行文件（Portable Executable File）<br />
PE文件主要包括：.exe，.dll，.sys等，.dll是动态加载库，不能直接执行</p>
<p>在DOS系统中，可执行文件格式为MZ</p>
<h2 id="42-pe文件格式与恶意软件的关系"><a class="markdownIt-Anchor" href="#42-pe文件格式与恶意软件的关系"></a> 4.2 PE文件格式与恶意软件的关系</h2>
<p>文件感染：</p>
<ul>
<li>使PE文件具备病毒功能</li>
<li>而又不破坏PE文件原有的功能和外在形态</li>
<li>感染与控制权获取</li>
</ul>
<p>方法：</p>
<ul>
<li>代码植入</li>
<li>控制权获取</li>
<li>图标更改等（如熊猫烧香）</li>
</ul>
<p><strong>注意</strong>：PE文件感染实质上就是修改文件的内容，与修改文本文件中的内容性质相同。PE文件与文本文件同是文件，但不同的是windows系统内核已经被设计好能够识别PE文件的结构并执行其中的代码，所以PE文件与文本文件有差异。</p>
<h2 id="43-pe文件总体结构"><a class="markdownIt-Anchor" href="#43-pe文件总体结构"></a> 4.3 PE文件总体结构</h2>
<p><strong>1. MS_DOS HEADER</strong></p>
<p>PE文件开头位置，用于PE文件开头位置定位与合法性检测。长度为0x40。开头两个字符为’MZ’。，结尾4字节(0x3C)为新exe HEADER的地址。设计MS_DOS HEADER是为了<strong>向下兼容DOS系统</strong>（如果不是为了这个目的完全可以将NT HEADER作为PE文件头），在DOS系统执行此文件时会显示该文件无法在DOS模式下运行。</p>
<p><strong>2. MS_DOS Stub</strong></p>
<p>在MS_DOS下运行的程序代码与数据，一般为提醒用户’This Program cannot be run in DOS mode’</p>
<p><strong>3. NT HEADER</strong></p>
<p>分为3个部分：开头字符串’PE\0\0’、映像文件头、可选文件头</p>
<p>(1) 开头字符串：用于表示该文件是否为可执行文件<br />
(2) File Header：映像文件头，包含可执行文件的一些必要信息，一般紧跟在开头字符串后面，包含的项有：</p>
<ul>
<li>Machine：机器类型，2字节，0x14C表示x86架构</li>
<li><strong>Number of Sections</strong>：节数量，2字节，PE文件中代码、数据等分别存放于不同的节中。</li>
<li>TimeDataStamp：4字节，生成该文件的时间，指从1970年1月1日开始计算经过的秒数。</li>
<li>Pointer to Symbol Table：4字节，COFF符号表偏移（COFF文件：通用对象文件格式，PE文件便是基于COFF文件设计，不要求掌握）</li>
<li>Number of Symbols：4字节，符号数量（指COFF符号表中的符号）</li>
<li><strong>Size of Optional Header</strong>：2字节，可选头大小</li>
<li>Characteristics：4字节，表示该文件是exe文件还是dll文件</li>
</ul>
<p>(3) Optional Header：可选文件头，包含可执行文件的其他必要信息，长度由节数量等因素确定</p>
<ul>
<li><strong>Address of Entry Point (PE_HEADER+0x28, 4 bytes)</strong>：准备运行的文件的第一条指令的RVA（<strong>RVA</strong>：相对虚拟地址，相对于内存中Image Base的地址）</li>
<li><strong>Image Base (PE_HEADER+0x34, 4 bytes)</strong>：内存镜像加载地址，PE文件在内存中的优先装载地址。
<ul>
<li>病毒不能只靠修改Image Base执行自己的代码，因为原有代码中可能存在如call 0x401010的代码，其中0x401010是硬编码在指令中的，一旦Image Base发生变化，这些硬编码地址可能就将无效，程序原有的代码也将无法执行。</li>
</ul>
</li>
<li><strong>Section Alignment (PE_HEADER+0x38, 4 bytes)</strong>：内存中节对齐的粒度</li>
<li><strong>File Alignment (PE_HEADER+0x3C, 4 bytes)</strong>：文件中节对齐的粒度
<ul>
<li>注意这里内存节对齐和文件节对齐粒度的理解。内存中节与节之间的地址之差与文件中的很可能不一样，在文件中，为了减少存储空间的浪费，通常不会将节对齐粒度设置得太大，一般为0x200，而内存中节对齐一般取0x1000作为粒度。</li>
</ul>
</li>
<li><strong>Data Directory (PE_HEADER+0x78, 8n bytes)</strong>：开头记录Data Directory中节属性数量，每一条属性长度均为8字节，记录这些节的RVA和size。这些节与常用的代码节、数据节等不同，多为辅助节，如导入表、导出表、引入地址表（IAT）等，保存程序运行的关键控制信息。</li>
</ul>
<p><strong>4. Section Tables</strong></p>
<p>节表，每个节表保存了该节的长度、在文件和内存中的开始地址、节名、节属性（RWX属性等）</p>
<ul>
<li>节名：8字节</li>
<li>Virtual Size：4字节，实际长度</li>
<li>RVA：该节的RVA</li>
<li>Size of Raw Data：文件中该节所占的大小</li>
<li>Pointer to Raw Data：文件中该节的起始地址</li>
<li>Characteristics：节属性，由几个比特异或得到
<ul>
<li>bit 5：表明这个节中是否存放代码</li>
<li>bit 6：表明这个节中是否为已初始化数据</li>
<li>bit 7：表明这个节中是否为未初始化数据（bss段）</li>
<li>bit 9：表明这个节中是否包含注释或其他信息</li>
<li>bit 11：表明这个节中的内容是否应该被放入最终的exe文件中</li>
<li>bit 25：表明这个块是否可以丢弃（通常为重定位节.reloc）</li>
<li>bit 28：表明这个块是否可以共享</li>
<li>bit 29：表明这个块是否可执行</li>
<li>bit 30：表明这个块是否可读</li>
<li>bit 31：表明这个块是否可写</li>
</ul>
</li>
</ul>
<p><strong>5. Sections</strong></p>
<ul>
<li>.text / CODE：代码节，保存全部代码。每个PE文件均存在</li>
<li>.data / DATA：数据节，保存已初始化数据（编译时已经确定的数据）</li>
<li>.bbs：数据节，保存未初始化数据（未初始化的全局和静态变量）</li>
<li>.rdata：引入函数节，保留引入函数的信息（函数名及所属dll文件名等）这些函数位于一个或多个dll文件中。
<ul>
<li><strong>Import Address Table (IAT)</strong>：一系列<strong>Image_Thunk_Data</strong>结构数组（4字节），每一个结构都定义了一个指向导入函数的Hint和名字的指针或Hint或其他值，而导入函数的Hint和名字实际保存于Import Hints/Names &amp; DLL Names中。<strong>在磁盘文件中，IAT与INT保存的内容相同；在内存中，这里保存所有引入函数在内存中的地址。</strong>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_THUNK_DATA STRUCT</span><br><span class="line">	union u1</span><br><span class="line">		ForwarderString DWORD ?		; 转向者RVA</span><br><span class="line">		Function DWORD ?			; 被引入的函数的内存地址(IAT表)</span><br><span class="line">		Ordinal DWORD ?				; 被引入API的函数序号(INT表)</span><br><span class="line">		AddressOfData DWORD ?		; 被引入API的hint/name RVA(INT表)</span><br><span class="line">	ends</span><br><span class="line">IMAGE_THUNK_DATA ENDS</span><br></pre></td></tr></table></figure>
</li>
<li><strong>Import Directory Table (IDT)</strong>：引入目录表，其地址存放在NT HEADER可选头的第二个属性之中便于获取，由<strong>IMAGE_IMPORT_DESCRIPTOR</strong>结构体（长度20字节）数组组成，其数量取决于使用的DLL文件的数量，每一个结构对应一个DLL文件。所有DLL结构体后有一个全0的结构体用于表示这部分结束。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_IMPORT_DESCRIPTOR STRUCT</span><br><span class="line">	union</span><br><span class="line">		Characteristics dd ?</span><br><span class="line">		OriginalFirstThunk dd ?	; 指向INT中对应DLL的RVA</span><br><span class="line">	Ends</span><br><span class="line">	TimeDateStamp dd ?</span><br><span class="line">	ForwarderChain dd ?</span><br><span class="line">	Name1 dd ?			; 指向dll文件名字符串的RVA</span><br><span class="line">	FirstThunk dd ?		; 指向IAT中对应DLL的RVA</span><br><span class="line">IMAGE_IMPORT_DESCRIPTOR ENDS</span><br></pre></td></tr></table></figure>
<strong>OriginalFirstThunk</strong>是指向Import Name(lookup) Table中的指针<br />
<strong>FirstThunk</strong>是指向Import Address Table中的指针</li>
<li><strong>Import Name table</strong>：一系列<strong>Image_Thunk_Data</strong>结构数组，在Import Name Table中，data最高位为0时表示通过函数名引入，为1表示通过序号引入。不同DLL文件的结构体之间通过一个全0的DWORD分隔。</li>
<li><strong>Import Hints/Names &amp; DLL Names</strong>：保存每个函数的Hint和名字，Hint为2字节，名字紧跟在Hint之后。一个DLL文件的所有引入函数列举完毕后在后面附上DLL的名字，下一个DLL文件的函数信息写在后面，需要4字节对齐。</li>
</ul>
</li>
<li>.edata：导出函数节，本文件向其他程序提供调用函数的列表、函数所在地址和具体代码实现，多见于DLL文件。
<ul>
<li><strong>Image Export Directory</strong>：导出目录表，其起始地址保存在NT HEADER可选头的第一个属性之中便于获取  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_EXPORT_DIRECTORY STRUCT</span><br><span class="line">&#123;</span><br><span class="line">	DWORD Characteristics</span><br><span class="line">	DWORD TimeDateStamp			; 文件生成时间</span><br><span class="line">	WORD MajorVersion</span><br><span class="line">	WORD MinorVersion</span><br><span class="line">	DWORD Name					; 指向DLL的名字（RVA）</span><br><span class="line">	DWORD Base					; ExportAddress开始序号，一般为1</span><br><span class="line">	DWORD NumberOfFunctions		; 函数的数量</span><br><span class="line">	DWORD NumberOfNames</span><br><span class="line">	DWORD AddressOfFunctions	; Address Table RVA, 函数地址数组</span><br><span class="line">	DWORD AddressOfNames		; Name Pointer RVA, 函数名所在地址数组</span><br><span class="line">	DWORD AddressOfNameOrdinals	; Ordinal RVA, 函数索引序列号数组</span><br><span class="line">&#125;;IMAGE_EXPORT_DIRECTORY ENDS</span><br></pre></td></tr></table></figure>
</li>
<li>Export Address Table：导出地址表，多用于保存导出函数地址  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Typedef <span class="class"><span class="keyword">struct</span> _<span class="title">image_Export_address_Table</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">		DWORD dwExportRVA;		<span class="comment">// 指向导出地址</span></span><br><span class="line">		DWORD dwForwarderRVA;	<span class="comment">// 指向另外DLL中某个API函数名</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;IMAGE_Export_Address_Table, *pIMAGE_Export_Address_Table</span><br></pre></td></tr></table></figure>
</li>
<li>Export Name Pointer Table：导出名字指针表，保存导出函数名字字符串的地址  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Typedef <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_Export_Name_Pointer_Table_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	DWORD dwPointer;</span><br><span class="line">&#125;IMAGE_Export_Name_Pointer_Table;</span><br></pre></td></tr></table></figure>
</li>
<li>Export Ordinal Table：导出符号表，保存导出函数的编号。  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Typedef <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_Export_Ordinal_Table_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	DWORD dwOrdinal;</span><br><span class="line">&#125;_IMAGE_Export_Ordinal_Table_;</span><br></pre></td></tr></table></figure>
<strong>注意</strong>：由于代码段中可能存在无名函数、重载函数等，因此导出函数的编号与导出函数名可能并不是一一对应，因此需要导出函数编号为每一个函数进行编号，唯一确定一个函数。<br />
<font color=red>根据导出函数表定位函数内存地址的方法：</font>
<ul>
<li>从AddressOfNames中获取到需要定位的函数的名字（记下函数名的索引）</li>
<li>从AddressOfNameOrdinals中获取到该函数的编号（以索引定位）</li>
<li>从AddressOfFunctions中获取该编号对应函数的地址（编号值就是数组索引值）</li>
</ul>
</li>
</ul>
</li>
<li>.rsrc：资源节，存放图标、对话框等程序需要用到的资源。<strong>树形结构</strong>，有一个主目录，下有嵌套子目录或数据。Windows通常有3层目录(资源类型、资源标识符、资源语言)，第4层是具体的资源。具体结构不做要求。</li>
<li>.reloc：重定位节，存放了一个重定位表。若装载器不是把程序装到程序编译时默认的基地址时，就需要这个重定位表来做一些调整。</li>
</ul>
<p><strong>练习题</strong><br />
由于本章内容多为记忆内容，这里只给出少数需要计算的例题供参考。<br />
<strong>1.</strong> 一个exe文件的Image Base=0x400000，Address of Entry Point=0x1000，那么该程序的第一条指令在内存中的地址为________。<br />
<strong>2.</strong> 在导入名称表（INT）中有一个指针的值为0x20A4，这个指针在________（填“内存”或“磁盘”）中的有效，已知IAT的Raw Data Address=0x800，RVA=0x1800，则0x20A4指向的内存地址在磁盘中的原像为________。<br />
<strong>3.</strong> exe文件本身也属于文件，要想找到一个exe文件的某个导入函数的内存地址，首先应该在exe文件中找到可选头中存放的_______________，通过这个来定位到_________的地址，在这里可以通过遍历所有结构的________________字段来获取到这个函数的索引，接着在_____________________中找到这个索引下的地址值，即为目标函数在内存中的地址。<br />
<strong>4.</strong> 下面是一个PE文件的头部数据，据此回答下列问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">0x000 4D 5A 90 00 03 00 00 00 04 00 00 00 FF FF 00 00</span><br><span class="line">0x010 B8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00</span><br><span class="line">0x020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">0x030 00 00 00 00 00 00 00 00 00 00 00 00 00 01 00 00</span><br><span class="line">0x040 0E 1F BA 0E 00 B4 09 CD 21 B8 01 4C CD 21 54 68</span><br><span class="line">0x050 69 73 20 70 72 6F 67 72 61 6D 20 63 61 6E 6E 6F</span><br><span class="line">0x060 74 20 62 65 20 72 75 6E 20 69 6E 20 44 4F 53 20</span><br><span class="line">0x070 6D 6F 64 65 2E 0D 0D 0A 24 00 00 00 00 00 00 00</span><br><span class="line">0x080 9F 32 0F AA DB 53 61 F9 DB 53 61 F9 DB 53 61 F9</span><br><span class="line">0x090 D2 2B F2 F9 D7 53 61 F9 CF 38 60 F8 D3 53 61 F9</span><br><span class="line">0x0A0 B7 27 65 F8 D6 53 61 F9 B7 27 62 F8 DF 53 61 F9 </span><br><span class="line">0x0B0 B7 27 64 F8 FB 53 61 F9 DB 53 60 F9 FF 52 61 F9 </span><br><span class="line">0x0C0 B7 27 60 F8 DC 53 61 F9 0D 27 64 F8 DF 53 61 F9 </span><br><span class="line">0x0D0 0D 27 65 F8 DA 53 61 F9 0D 27 9E F9 DA 53 61 F9 </span><br><span class="line">0x0E0 DB 53 F6 F9 DA 53 61 F9 0D 27 63 F8 DA 53 61 F9 </span><br><span class="line">0x0F0 52 69 63 68 DB 53 61 F9 00 00 00 00 00 00 00 00 </span><br><span class="line">0x100 50 45 00 00 4C 01 05 00 9B C0 42 62 00 00 00 00 </span><br><span class="line">0x110 00 00 00 00 E0 00 02 01 0B 01 0E 1C 00 8C 00 00 </span><br><span class="line">0x120 00 98 00 00 00 00 00 00 A2 80 00 00 00 10 00 00 </span><br><span class="line">0x130 00 A0 00 00 00 00 40 00 00 10 00 00 00 02 00 00 </span><br><span class="line">0x140 06 00 00 00 00 00 00 00 06 00 00 00 00 00 00 00 </span><br><span class="line">0x150 00 60 01 00 00 04 00 00 00 00 00 00 02 00 40 81 </span><br><span class="line">0x160 00 00 10 00 00 10 00 00 00 00 10 00 00 10 00 00 </span><br><span class="line">0x170 00 00 00 00 10 00 00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">0x180 70 ED 00 00 18 01 00 00 00 20 01 00 B8 13 00 00 </span><br><span class="line">0x190 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">0x1A0 00 40 01 00 50 13 00 00 CC DD 00 00 54 00 00 00 </span><br><span class="line">0x1B0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">0x1C0 08 DF 00 00 18 00 00 00 20 DE 00 00 40 00 00 00 </span><br><span class="line">0x1D0 00 00 00 00 00 00 00 00 00 A0 00 00 C4 04 00 00 </span><br><span class="line">0x1E0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">0x1F0 00 00 00 00 00 00 00 00 2E 74 65 78 74 00 00 00 </span><br></pre></td></tr></table></figure>
<p>(1) 最开头两个字节表示的字符是_______，这是PE文件的____________结构。（4分）<br />
(2) NT HEADER的起始地址为_______，你是通过__________（填16进制地址）的值得到的。（4分）<br />
(3) PE文件头的标志在_______（填16进制地址）处，代表的字符为________。（4分）<br />
(4) 这个PE文件有______个节，通过______（填16进制地址）处的值可以知道。（4分）<br />
(5) 这个PE文件的Image Base为___________，通过______（填16进制地址）处的值可以知道。（4分）<br />
(6) 这个PE文件的Address of Entry Point为___________，通过______（填16进制地址）处的值可以知道。（4分）<br />
(7) 导入表的RVA是__________，通过______（填16进制地址）处的值可以知道。（4分）<br />
<strong>5.</strong> 阅读某PE文件中.rdata节的IMAGE_SECTION_HEADER，回答下列问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_SECTION_HEADER .rdata</span><br><span class="line">0x220 2E 72 64 61 74 61 00 00 A2 5C 00 00 00 A0 00 00 </span><br><span class="line">0x230 00 5E 00 00 00 90 00 00 00 00 00 00 00 00 00 00 </span><br><span class="line">0x240 00 00 00 00 40 00 00 40</span><br></pre></td></tr></table></figure>
<p>已知该PE文件的Image Base=0x400000，导入表的RVA=0xED70<br />
(1) .rdata节的RVA=<em><strong><strong><strong><strong>，通过</strong></strong></strong>（填16进制地址）处的值可以知道。（4分）<br />
(2) .rdata节在磁盘中的文件偏移为</strong></em>______，通过______（填16进制地址）处的值可以知道。（4分）<br />
(3) 导入表在磁盘中的文件偏移应为_________。（3分）</p>
<p>答案：</p>
<ol>
<li>
<p>0x401000</p>
</li>
<li>
<p>内存；0x10A4</p>
</li>
<li>
<p>IDT的RVA；IDT；OriginalFirstThunk；IAT</p>
</li>
<li>
<p>(1) MZ；DOS头<br />
(2) 0x100；0x3C<br />
(3) 0x100；PE<br />
(4) 5；0x106<br />
(5) 0x400000；0x134<br />
(6) 0x80A2；0x128<br />
(7) 0xED70；0x180</p>
</li>
<li>
<p>(1) 0xA000；0x22C<br />
(2) 0x9000；0x234<br />
(3) 0xDD70（.rdata节的VA=0x400000+0xA000=0x40A000，IDT的VA-IDT的磁盘偏移=.rdata的VA-.rdata的磁盘偏移，故IDT的磁盘偏移=IDT的VA-(0x40A000-0x900)=0x400000+0xED70-0x401000=0xDD70）</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%AC%AC3%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%AC%AC3%E7%AB%A0/" class="post-title-link" itemprop="url">软件安全——第3章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-03 09:44:29 / Modified: 09:47:34" itemprop="dateCreated datePublished" datetime="2023-03-03T09:44:29+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">软件安全</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="chapter-3-恶意代码及其分类"><a class="markdownIt-Anchor" href="#chapter-3-恶意代码及其分类"></a> Chapter 3 恶意代码及其分类</h1>
<h2 id="31-定义"><a class="markdownIt-Anchor" href="#31-定义"></a> 3.1 定义</h2>
<p>恶意代码，指为达到恶意目的而专门设计的程序或代码<br />
<strong>注意</strong>：正常的软件也会引发安全问题，但大多数情况下都并非是作者有意为之。<br />
<strong>分类</strong>：病毒、蠕虫、木马、后门、Rootkit、流氓软件、僵尸、Exploit等。</p>
<p><strong>练习题</strong><br />
<strong>1.</strong> 某公司开发了一款社交软件，为了在该软件产生bug时能够更加及时反馈信息，该公司在这款软件中设计了一个后门，并同时开发另一款配套软件用于将bug信息（程序产生bug时的内存状态等）上报至该公司的服务器。软件的后门就是为这个配套软件准备的。这款配套软件______（填是或不是）恶意代码，理由是________________。某黑客组织通过逆向分析发现了这款社交软件的漏洞并编写程序用于远程控制计算机，这个程序_______（填是或不是）恶意代码。</p>
<p>答案：不是；该配套软件的目的并非恶意；是</p>
<h2 id="32-功能"><a class="markdownIt-Anchor" href="#32-功能"></a> 3.2 功能</h2>
<h3 id="恶意代码的攻击目的"><a class="markdownIt-Anchor" href="#恶意代码的攻击目的"></a> 恶意代码的攻击目的：</h3>
<ul>
<li>恶作剧，炫耀自己的技术（如熊猫烧香病毒）</li>
<li>经济利益（如WannaCry病毒）</li>
<li>商业竞争</li>
<li>政治目的</li>
<li>军事目的等</li>
</ul>
<p><strong>练习题</strong><br />
<strong>2.</strong> 上世纪末，美国在塞尔维亚进行军事行动时轰炸我南联盟大使馆，令无数国人愤慨。消息传出，中国红客联盟应声出动，对美国政府网站发动了DDoS攻击，并成功在政府网页上贴上了中国国旗的图片。这个过程中涉及的恶意代码的攻击目的是_________________。</p>
<p>答案：政治目的</p>
<h3 id="攻击目标"><a class="markdownIt-Anchor" href="#攻击目标"></a> 攻击目标：</h3>
<ul>
<li>个人计算机</li>
<li>服务器</li>
<li>移动智能终端（如手机平板等）</li>
<li>智能设备（如车联网、智能家居、手环等）</li>
<li>通信设备（路由器、交换机等）</li>
<li>安全设备等（如防火墙、IDS、IPS、VDS等）
<ul>
<li>IDS：intrusion detection system，入侵检测系统，是一种对网络传输进行即时监视，在发现可疑传输时发出警报或者采取主动反应措施的网络安全设备。</li>
<li>IPS：Intrusion Prevention System，入侵防御系统，能够监视网络或网络设备的网络资料传输行为的计算机网络安全设备，能够及时的中断、调整或隔离一些不正常或是具有伤害性的网络资料传输行为。</li>
<li>VDS：Virus Detection System，病毒检测系统，能够对网络传输中的数据进行计算机病毒相关检测的设备型产品形态的总称。</li>
</ul>
</li>
</ul>
<h3 id="攻击目标范围"><a class="markdownIt-Anchor" href="#攻击目标范围"></a> 攻击目标范围：</h3>
<ul>
<li>定点攻击（指定邮件、域名、IP、QQ等，或服务器列表等）</li>
<li>群体攻击（如可传播的病毒、木马、蠕虫，钓鱼攻击等）</li>
</ul>
<p><strong>练习题</strong><br />
<strong>3.</strong> 某黑客组织攻破了某公司的服务器，获取了其产品所有用户的用户名与密码信息。由于很多人习惯在多个平台的账户使用同一个密码，黑客于是拿着这些密码在QQ、网易等平台上尝试登录这些用户的其他账户，这被称为撞库攻击。这种攻击属于___________（填“定点攻击”或“群体攻击”）</p>
<p>答案：定点攻击<br />
<strong>注意</strong>：定点攻击和群体攻击的区分<strong>不是通过攻击的个体数量来区分，而是通过被攻击的个体是否能够被提前确定来区分</strong>。群体攻击中，无论是会传播的病毒木马还是钓鱼攻击，黑客在病毒、木马等被制作出来时不知道被攻击的对象是谁。</p>
<h3 id="恶意代码的攻击功能"><a class="markdownIt-Anchor" href="#恶意代码的攻击功能"></a> 恶意代码的攻击功能：</h3>
<ul>
<li>获取数据
<ul>
<li>静态数据，如文件、数据库数据等</li>
<li>动态数据，如口令、内存、计算机网络流量、通信网络数据、可移动存储介质、隔离电脑等</li>
</ul>
</li>
<li>破坏系统
<ul>
<li>删除或修改数据</li>
<li>破坏系统服务，如通用Web服务系统、数据库系统、特定行业服务系统（如工控系统）</li>
<li>破坏支撑设备，如网络设备，线路等</li>
</ul>
</li>
<li>动态控制与渗透拓展攻击路径等
<ul>
<li>中间系统</li>
<li>相关人员</li>
</ul>
</li>
</ul>
<p><strong>静态数据和动态数据的区别</strong>：静态数据是指在运行过程中主要作为控制或参考用的数据,它们在很长的一段时间内不会变化，一般不随运行而变。动态数据包括所有在运行中发生变化的数据以及在运行中需要输入、输出的数据及在联机操作中要改变的数据。（来源：百度百科）</p>
<h2 id="33-恶意代码的分类"><a class="markdownIt-Anchor" href="#33-恶意代码的分类"></a> 3.3 恶意代码的分类</h2>
<h3 id="1计算机病毒"><a class="markdownIt-Anchor" href="#1计算机病毒"></a> 1.计算机病毒</h3>
<p>一组<strong>能够进行自我传播</strong>、<strong>需要用户干预</strong>来触发执行的破坏性程序或代码。</p>
<p>例：CIH（破坏BIOS系统）、熊猫烧香等</p>
<h3 id="2-网络蠕虫"><a class="markdownIt-Anchor" href="#2-网络蠕虫"></a> 2. 网络蠕虫</h3>
<p>一组<strong>能够进行自我传播</strong>、<strong>不需要用户干预</strong>即可触发执行的破坏性程序或代码。</p>
<p>例：SQL蠕虫王、震网病毒（攻击工控系统）、Stuxnet等</p>
<p><font color=red>病毒和蠕虫最大的区别就是是否需要用户干预才能执行。“计算机蠕虫可以独立运行，并能把自身的一个包含所有功能的版本传播到另外的计算机上”，“计算机病毒是一段代码，能把自身加到其他程序包括操作系统上；它不能独立运行，需要由它的宿主程序运行来激活它”，可以将二者与生物界的蠕虫和病毒联系起来理解。</font></p>
<h3 id="3-木马特洛伊木马"><a class="markdownIt-Anchor" href="#3-木马特洛伊木马"></a> 3. 木马（特洛伊木马）</h3>
<p>是指一类<strong>看起来具有正常功能</strong>，但实际上隐藏着很多用户不希望功能的程序。通常由控制端和被控制端两端组成。</p>
<p>例：灰鸽子（能够监控摄像头、桌面、键盘输入等）、冰河等</p>
<p><font color=red>木马和前两种恶意代码的主要区别在于表面的伪装能力。实际上破坏的能力与前两种相当。百度百科给出的定义是：木马病毒是指<strong>隐藏在正常程序中</strong>的一段具有特殊功能的恶意代码，是具备破坏和删除文件、发送密码、记录键盘和攻击Dos等特殊功能的后门程序。</font></p>
<h3 id="4-后门"><a class="markdownIt-Anchor" href="#4-后门"></a> 4. 后门</h3>
<p>使得攻击者可以对系统进行非授权访问的一类程序。</p>
<p>例：Bits、WinEggDrop、Tini等</p>
<p><font color=red>木马和后门的区别在于隐蔽性和欺骗性上。后门存在本来就是要隐藏自身，便于攻击者随时访问；而木马有时甚至会诱惑用户去运行某些程序。</font></p>
<h3 id="5rootkit"><a class="markdownIt-Anchor" href="#5rootkit"></a> 5.RootKit</h3>
<p>通过修改现有的操作系统软件，使攻击者获得访问权并隐藏在计算机中的程序。</p>
<p>例：RootKit、Hkdef、ByShell等</p>
<h3 id="6-僵尸程序恶意网页拒绝服务程序黑客工具广告软件间谍软件等其他恶意代码"><a class="markdownIt-Anchor" href="#6-僵尸程序恶意网页拒绝服务程序黑客工具广告软件间谍软件等其他恶意代码"></a> 6. 僵尸程序，恶意网页，拒绝服务程序，黑客工具，广告软件，间谍软件等其他恶意代码</h3>
<ul>
<li>僵尸程序：是指恶意控制功能的程序代码，能够自动执行预定义的功能、可以被预定义的命令控制</li>
<li>间谍软件：以主动收集用户个人信息、相关机密文件或隐私数据为主，搜集到的数据会主动传送到指定服务器。</li>
<li>广告软件：未经用户允许，下载并安装或与其他软件捆绑通过弹出式广告或以其他形式进行商业广告宣传的程序。</li>
<li>流氓软件：具有一定的实用价值但具备电脑病毒和黑客软件的部分特征的软件（特别是难以卸载），处在合法软件和电脑病毒之间的灰色地带。</li>
<li>Exploit：精心设计的用于利用特定漏洞以对目标系统进行控制的程序。</li>
<li>黑客工具：各类直接或间接用于网络和主机渗透的软件，如各类扫描器、后门植入工具、密码嗅探器、权限提升工具等</li>
</ul>
<p><font color=red>注意诸如黑客工具、广告软件等也属于恶意代码。很多广告软件强行向用户推送广告，以此来获得收益，在用户眼中算是可见的比较“流氓”的一种行为。而黑客工具也是恶意代码的原因是其“恶意”的对象可能不是本机而是被攻击的对象。要注意广告软件和流氓软件的区别：流氓软件——虽然流氓，但你还是需要，即存在一定价值；广告软件：可能没有价值，而且还随便下东西弹窗。<font></p>
<p><strong>练习题</strong><br />
<strong>4.</strong> 根据下列对于恶意代码的描述，判断其属于哪种恶意代码：<br />
(1) 某同学将U盘插入学校工程实训中心的电脑后，发现U盘中所有文件夹后标注文件类型为“exe可执行文件”，点击后电脑中关键数据被窃取。__________<br />
(2) 某人在手机上通过QQ邮箱下载apk文件并安装后，QQ号被盗。__________<br />
(3) 专门用于向指定IP地址发动DDoS攻击的程序__________<br />
(4) 各大高校频频爆出的“O泡果奶事件”中涉及的程序__________<br />
(5) 能够在后台下载各类广告游戏软件的某款盗版软件__________<br />
(6) 某人打开电脑后发现鼠标与键盘无法控制电脑，似乎有人远程控制电脑进行各种违法操作。经过紧急处理后发现有一个恶意代码程序将自身设置为开机自启动。__________<br />
(7) 某公司企业员工运行某个常用程序后发现服务器突然遭受大量DDoS攻击，电脑中弹出索要钱财的对话框。__________<br />
(8) 某同学在靶场攻击服务器靶机的某个含有漏洞的服务时专门编写的程序__________<br />
(9) 由某国政府开发的用于窃听电脑语音通话的软件__________</p>
<p>答案：木马、木马、黑客工具、木马、广告软件、蠕虫、病毒、Exploit、间谍软件</p>
<h2 id="34-相关法律条文"><a class="markdownIt-Anchor" href="#34-相关法律条文"></a> 3.4 相关法律条文</h2>
<p>第二百八十五条 违反国家规定，侵入国家事务、国防建设、尖端科学技术领域的计算机信息系统的，处三年以下有期徒刑或者拘役。</p>
<p>第二百八十六条 违反国家规定，对计算机信息系统功能进行删除、修改、增加、干扰，造成计算机信息系统不能正常运行，后果严重的，<strong>处五年以下有期徒刑或者拘役；后果特别严重的，处五年以上有期徒刑。</strong></p>
<p>违反国家规定，对计算机信息系统中存储、处理或者传输的数据和应用程序进行删除、修改、增加的操作，后果严重的，依照前款的规定处罚。</p>
<p>故意制作、传播计算机病毒等破坏性程序，影响计算机系统正常运行，后果严重的，依照第一款的规定处罚。</p>
<p>刑法修正案（七）：在刑法第二百八十五条中增加两款作为第二款、第三款：“违反国家规定，侵入前款规定以外的计算机信息系统或者采用其他技术手段，获取该计算机信息系统中存储、处理或者传输的数据，或者对该计算机信息系统实施非法控制，<strong>情节严重的，处三年以下有期徒刑或者拘役，并处或者单处罚金；情节特别严重的，处三年以上七年以下有期徒刑，并处罚金。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CoLin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">140</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Hornos3" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Hornos3" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_54218833?spm=1000.2115.3001.5343" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_54218833?spm&#x3D;1000.2115.3001.5343" rel="noopener" target="_blank"><i class="fa fa-crosshairs fa-fw"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CoLin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">1.2m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">18:50</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
