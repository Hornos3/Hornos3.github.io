<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hornos3.github.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="CoLin&#39;s BLOG">
<meta property="og:url" content="http://hornos3.github.com/page/4/index.html">
<meta property="og:site_name" content="CoLin&#39;s BLOG">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="CoLin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://hornos3.github.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-cn'
  };
</script>

  <title>CoLin's BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CoLin's BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC7%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC7%E7%AB%A0/" class="post-title-link" itemprop="url">操作系统原理——第7章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-03 09:12:35 / Modified: 09:16:17" itemprop="dateCreated datePublished" datetime="2023-03-03T09:12:35+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">操作系统原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>10 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="chapter-7-存储管理"><a class="markdownIt-Anchor" href="#chapter-7-存储管理"></a> Chapter 7 存储管理</h1>
<h2 id="71-存储管理概述"><a class="markdownIt-Anchor" href="#71-存储管理概述"></a> 7.1 存储管理概述</h2>
<h3 id="711-多级存储体系"><a class="markdownIt-Anchor" href="#711-多级存储体系"></a> 7.1.1 多级存储体系</h3>
<p>理想的存储系统：</p>
<ul>
<li>容量足够大</li>
<li>速度足够快</li>
<li>信息永久保存</li>
<li>廉价</li>
</ul>
<p>计算机中实际的存储体系往往由高速缓存、主存和辅存3种不同存储设备构成。</p>
<ul>
<li>寄存器位于CPU内部，不同架构的CPU有不同数量的寄存器，寄存器的存取速度最快。</li>
<li>内存可以存放程序和数据，容量比寄存器大很多，RAM掉电会丢失数据，ROM可长期保存数据。</li>
<li>高速缓存位于CPU与内存之间，速度比内存更快，容量较小，仅复制内存极少量的数据。</li>
<li>辅存以硬盘为主，用于长期保存指令和数据，可联机和脱机存放数据，容量较大，还可以为内存提供交换空间。</li>
</ul>
<p>在三级存储体系中，最上层为高速缓存，虽然价格贵容量小，但速度快；往下是内存，价格和容量适中，但是内容易丢失；最下面是辅存，容量最大价格最便宜但速度最慢。</p>
<p>有关于内存模块换入换出的问题：如果一次换入换出前后内存模块地址不变，那么有利于模块中的程序运行，程序设计简单，但是容易造成地址冲突；如果前后地址可以不一样，那么可以使内存使用更加灵活，缺点是需要进行地址重定位。</p>
<h3 id="712-存储管理的功能"><a class="markdownIt-Anchor" href="#712-存储管理的功能"></a> 7.1.2 存储管理的功能</h3>
<p>存储管理系统主要包含<font color=red>地址映射、虚拟存储、内存分配、存储共享和保护</font>这4个部分。</p>
<h4 id="地址映射"><a class="markdownIt-Anchor" href="#地址映射"></a> 地址映射</h4>
<p>内存管理系统需要将虚拟地址转换为内存物理地址，即将程序中的地址（虚拟地址、逻辑地址）转换为真实的内存地址（实地址、物理地址），其方式有<font color=red>固定地址映射、静态地址映射和动态地址映射</font>3种。</p>
<h4 id="虚拟存储"><a class="markdownIt-Anchor" href="#虚拟存储"></a> 虚拟存储</h4>
<p>为了解决内存不足的问题，内存管理系统借助辅存在逻辑上扩充内存，使用户觉得内存足够大。将程序代码从内存迁出到辅存中称为迁出，从辅存迁入到内存中称为迁入。</p>
<p><font color=red>程序局部性原理：包含时间局部性和空间局部性，一段代码在刚刚访问后很有可能被再一次访问，这段代码的邻近空间也很可能在短时间内被访问。</font>因此将程序的一小部分装入内存中通常也可以让其运行一段时间。</p>
<p>实现虚拟存储的前提：</p>
<ul>
<li>适当容量的内存</li>
<li>足够大的辅存</li>
<li>地址变换机构</li>
</ul>
<h4 id="内存分配"><a class="markdownIt-Anchor" href="#内存分配"></a> 内存分配</h4>
<p>为每一道程序分配足够的内存空间，同时应该尽量减少无法利用的内存零头或者碎片出现，提高系统内存空间的利用率。</p>
<p>内存分配需要解决：</p>
<ul>
<li>放置策略，即程序应该分配到什么地方</li>
<li>调入策略，即如何将要运行的程序调入内存</li>
<li>淘汰策略，即迁出哪些代码以腾出内存空间</li>
</ul>
<h4 id="存储共享与保护"><a class="markdownIt-Anchor" href="#存储共享与保护"></a> 存储共享与保护</h4>
<p>内存中一些用户或系统程序段可以进行不同进程共享，以提高内存的利用率，防止访问越界和越权。</p>
<p>具体的保护方式：</p>
<ul>
<li>设置界址寄存器，规定一个段的上界和下界，程序每一次访问内存均进行检查。</li>
<li>基址寄存器和限长寄存器，适用于连续分配的物理内存。</li>
<li>存储键保护，适用于不连续分配的内存，也可以用于共享中的权限。</li>
</ul>
<h2 id="72-地址映射"><a class="markdownIt-Anchor" href="#72-地址映射"></a> 7.2 地址映射</h2>
<h3 id="721-地址映射的概念"><a class="markdownIt-Anchor" href="#721-地址映射的概念"></a> 7.2.1 地址映射的概念</h3>
<p>程序员写在程序中的地址被称为逻辑地址，产生的前提是内存是理想的存储空间，是该进程独占的。逻辑地址一般使用相对地址计数，参考的起始地址是程序第一条指令或数据。地址映射又称为地址重定位、地址转换，是将程序中的逻辑地址变成真实内存中的物理地址的过程。</p>
<h3 id="722-地址映射的方法"><a class="markdownIt-Anchor" href="#722-地址映射的方法"></a> 7.2.2 地址映射的方法</h3>
<h4 id="固定地址映射"><a class="markdownIt-Anchor" href="#固定地址映射"></a> 固定地址映射</h4>
<p><font color=red>在编程或编译时确定虚拟地址和物理地址的映射关系</font>，程序员直接在源代码中指定目标数据的物理地址或指令跳转的目标地址的物理地址。采用固定地址映射编译的可执行程序在运行前必须放在指定的内存区域中。</p>
<p>缺点：程序加载时必须放在指定内存区域，容易导致运行失败，容易产生地址冲突，不能适应多道程序编程环境。</p>
<h4 id="静态地址映射"><a class="markdownIt-Anchor" href="#静态地址映射"></a> 静态地址映射</h4>
<p><font color=red>程序装入内存时由操作系统完成逻辑地址到物理地址的映射</font>，程序装入内存时整体装入，占用一片连续的内存空间。</p>
<p>静态地址映射公式：MA=BA+VA，其中MA为程序在内存中的物理地址，VA为程序的逻辑地址，BA为程序在内存中的装入基址。</p>
<ul>
<li>程序运行前确定全部逻辑地址的映射关系。</li>
<li>程序装入后不能再移动，如果必须移动，需要在再次运行之前将其放回原来位置。</li>
<li>程序在内存中占用连续的内存空间。</li>
</ul>
<h4 id="动态地址映射"><a class="markdownIt-Anchor" href="#动态地址映射"></a> 动态地址映射</h4>
<p><font color=red>程序执行过程中将逻辑地址转换为物理地址</font>，当程序运行到一条访问内存的指令时，临时将逻辑地址转化为物理地址。</p>
<p>动态地址映射的计算公式与静态地址映射相同。</p>
<p>动态地址映射需要借助重定位寄存器，其值由进程调度程序根据进程当前实际分配到的主存空间的起始地址决定。切换进程的同时需要切换基址寄存器BAR的值。</p>
<p>动态地址映射的实现思路：<font color=red>程序按照段进行编译，执行时不同的段被分配到不同的地址</font>，虚拟地址的格式应该为段地址+段内偏移，每一段维护一个段寄存器用于段重定位、段式存储管理、段的切换。</p>
<p>特点：</p>
<ul>
<li>程序占用的内存空间可以动态变化</li>
<li>程序不要求占用连续的内存空间</li>
<li>便于多个进程共享代码</li>
</ul>
<p>缺点：需要硬件支持（MMU内存管理单元）、设计软件复杂。</p>
<h2 id="73-分区存储管理系统"><a class="markdownIt-Anchor" href="#73-分区存储管理系统"></a> 7.3 分区存储管理系统</h2>
<h3 id="731-分区存储的概念"><a class="markdownIt-Anchor" href="#731-分区存储的概念"></a> 7.3.1 分区存储的概念</h3>
<p>分区管理将内存划分为若干大小不等的区域，除了操作系统占用一个区域之外其他分区由多道程序环境下的各个并发进程共享。</p>
<h3 id="732-单一分区管理"><a class="markdownIt-Anchor" href="#732-单一分区管理"></a> 7.3.2 单一分区管理</h3>
<p>单一分区管理方式<font color=red>将整个内存空间分为用户区和系统区，系统区存放操作系统，用户区不分区</font>，全部归一个用户作业占用。</p>
<p>单一分区管理需要一个栅栏寄存器记录两个区之间的界限，这种管理方式下任何一个时刻主存中只能由一道程序，各个作业的程序只能够按照次序逐一加载进内存运行。</p>
<ul>
<li>单一分区管理仅适用于单用户的情况。</li>
<li>单一分区管理系统地址转换多采用静态地址映射</li>
<li>单一分区管理系统也可以采用动态地址映射</li>
</ul>
<p>优点：模式简单，不需要硬件支持，适合于单用户单任务OS<br />
缺点：浪费内存，内存利用率低</p>
<h3 id="733-固定分区管理"><a class="markdownIt-Anchor" href="#733-固定分区管理"></a> 7.3.3 固定分区管理</h3>
<p>固定分区<font color=red>将用户区划分为若干大小不等的分区，供不同子程序使用</font>。<font color=red>固定分区在系统初始化时就已经被分割完成，一旦初始化完成每一个区域的大小和位置就被固定下来</font>。每一个分区在任何一个时刻只能装入一道程序执行。</p>
<p>支持将多个作业装入内存运行，支持并发运行。系统需要维护一个<font color=red>分区表</font>，记录每一个分区的区号、大小、起始位置、占用标志。</p>
<ul>
<li>在程序装入前，内存已经被分区不再改变</li>
<li>每个分区大小不同，适用于不同大小的程序</li>
<li>系统需要维护分区表</li>
</ul>
<p>缺点：浪费内存，大程序可能无法运行（当程序比最大分区大时），作业的内存无法被动态扩充，各个分区的作业需要共享程序和数据很难实现，可以并发运行的程序数量收到分区数量的限制。</p>
<p>在应用时应该尽量让程序大小与数量与分区划分保持一致</p>
<p>示例：IBM OS/360最多有15个分区15个程序</p>
<h3 id="734-动态内存管理"><a class="markdownIt-Anchor" href="#734-动态内存管理"></a> 7.3.4 动态内存管理</h3>
<p>动态分区管理<font color=red>在程序装入时创建分区，使得分区的大小和程序大小相等</font>。动态分区的大小、位置和数量都是动态的。</p>
<p>动态分区管理有利于减少内存的浪费，有利于多道程序设计，可以实现多个作业对内存的共享，进一步提高的内存的利用率，但容易产生过小的内存碎片无法利用。</p>
<h3 id="735-内存碎片"><a class="markdownIt-Anchor" href="#735-内存碎片"></a> 7.3.5 内存碎片</h3>
<p>内存碎片是指内存被反复分割之后剩下的一些小的空闲区，这些小的空闲区由于太小以至于无法被其他任何程序使用，因此成为内存碎片。过多的内存碎片会减少有效内存空间，降低内存使用率。</p>
<p><font color=red>内存碎片分为外部碎片和内部碎片</font>。</p>
<ul>
<li>分区内部出现的碎片称为内部碎片。固定分区法容易产生内部碎片。</li>
<li>所有分区之外新增的碎片称为外部碎片，一般碎片问题指的是外部碎片问题。</li>
</ul>
<p><font color=red>解决碎片问题的方法</font>：</p>
<ul>
<li>内存拼接技术，即移动内存内容，让所有空闲区空间移动到一起，最后合并为一整块。该技术不能应用于使用固定地址映射和静态地址映射的系统中。拼接时需要关闭系统进行离线拼接，会大大降低系统效率。</li>
<li>设置分割门槛技术，即设置门限值，当一次分配剩余的大小小于门限值时，不分割该空闲区而是直接全部分配给用户。这种方式容易产生内部碎片。</li>
<li>分段装入技术，将程序分为几个部分装入不同的分区，以便充分利用碎片。</li>
</ul>
<h3 id="736-分区回收管理"><a class="markdownIt-Anchor" href="#736-分区回收管理"></a> 7.3.6 分区回收管理</h3>
<p>分区回收将已经结束程序的分区进行回收，将其适当处理后放入空闲区表中，以便再一次进行分配。如果没有任何空闲区与该分区相邻，则直接登记后插入到空闲区表中；如果有空闲区与该分区相邻，则首先进行合并后再进行登记。</p>
<h3 id="737-分区分配与放置策略"><a class="markdownIt-Anchor" href="#737-分区分配与放置策略"></a> 7.3.7 分区分配与放置策略</h3>
<p>分区分配指选择一个合适的空闲区并从中分割出需要的大小分配给程序。选择空闲区一般参考空闲区表，通过遍历空闲区表选择一个大小不低于程序要求的空闲区进行分割。根据空闲区表不同排序规则将放置策略分为<font color=red>首次适应算法、最佳适应算法、最坏适应算法</font>。</p>
<h4 id="首次适应算法"><a class="markdownIt-Anchor" href="#首次适应算法"></a> 首次适应算法</h4>
<p>在空闲区表中<font color=red>选择第一个大小不低于程序要求的空闲区</font>，分割出需要的大小给用户。首次适应算法一般优先使用主存低地址区域的空闲区，尽量保留高地址区域的大空闲区。在较大程序运行时可以从高地址区域获得大空闲区。同时该算法会在低地址区域留下很多内存碎片。</p>
<p>该算法中<font color=red>空闲区表的排序顺序是地址大小</font>。</p>
<h4 id="最佳适应算法"><a class="markdownIt-Anchor" href="#最佳适应算法"></a> 最佳适应算法</h4>
<p>最佳适应算法<font color=red>将空闲区的大小进行递增排序，选择第一个大小不低于最低程序要求的空闲区</font>分割出程序要求的大小给用户。剩下的部分留在空闲区表中。该算法能够保证较大程序能找到合适大小的空闲区，但也会留下很多微小的内存碎片。</p>
<h4 id="最坏适应算法"><a class="markdownIt-Anchor" href="#最坏适应算法"></a> 最坏适应算法</h4>
<p>最坏适应算法<font color=red>按照空闲区大小进行递减排序，从排好序的空闲区中选择第一个不小于程序要求的分区</font>，该算法尽量选择最大的空闲区分割给用户，确保被分割之后的空闲区还是很大，该算法可能无法保证大的程序能够分配到合适大小的空闲区。</p>
<h2 id="75-页式存储管理系统"><a class="markdownIt-Anchor" href="#75-页式存储管理系统"></a> 7.5 页式存储管理系统</h2>
<p>通过物理内存进行内存的直接管理有很多缺点：</p>
<ul>
<li>源程序全部使用物理内存运行容易导致内存访问冲突</li>
<li>程序必须全部装入内存才能运行，内存小时容易产生冲突</li>
<li>程序占用连续的内存地址，容易产生内存碎片</li>
<li>多程序同时运行容易产生干扰</li>
</ul>
<p>因此引入虚拟内存进行内存管理。<br />
虚拟内存是面向用户的存储空间，是线性的存储空间、封闭的存储空间，容量4GB（32位系统），是程序员编程时使用的地址，其与物理地址分离，进程之间的地址不会产生冲突。</p>
<h3 id="751-页式管理的概念"><a class="markdownIt-Anchor" href="#751-页式管理的概念"></a> 7.5.1 页式管理的概念</h3>
<p>页式存储管理将程序分拆为多个模块以装入不同的内存区域。页式存储管理将进程空间和内存空间都划分为等大的小片，进程的小片称为<font color=red>页</font>，内存的小片称为<font color=red>页框</font>。页框与页的大小一致，一个进程由多个页构成。内存被划分为多个页框，页框之间没有空隙。</p>
<p>根据程序的局部性原则，进程以页为单位装入内存，进程被装入内存时<font color=red>只需要将进程的部分页面装入内存即可运行</font>，进程在内存中的多个页框不必相邻。需要新的页时按需从硬盘中调入新的页，而将内存中已经存放的且不再需要运行的页面及时删除，以腾出内存空间。因此进程将页装入内存的原则是<font color=red>局部装入，不断更新</font>。</p>
<h3 id="752-页面调入策略"><a class="markdownIt-Anchor" href="#752-页面调入策略"></a> 7.5.2 页面调入策略</h3>
<h4 id="预调策略"><a class="markdownIt-Anchor" href="#预调策略"></a> 预调策略</h4>
<p>页面在需要前已经被调入内存，进程映像存放于外存之中，当调入其中一页时往往会将后续的连续多页一起调入。</p>
<h4 id="请求调页策略"><a class="markdownIt-Anchor" href="#请求调页策略"></a> 请求调页策略</h4>
<p>进程在运行时发现需要访问的页面不在内存时，临时提出调页请求由内核将所需的页面调入内存。</p>
<h3 id="753-页式虚拟地址"><a class="markdownIt-Anchor" href="#753-页式虚拟地址"></a> 7.5.3 页式虚拟地址</h3>
<p>进程空间的页式虚拟地址是一维线性地址，从0开始线性增加，若<font color=red>页式虚拟地址的宽度为m位，页大小为2<sup>n</sup>字节，那么虚拟地址的低n位为页内偏移地址，高m-n位为页号</font>。</p>
<h3 id="754-页面映射表"><a class="markdownIt-Anchor" href="#754-页面映射表"></a> 7.5.4 页面映射表</h3>
<p>系统建立页面映射表，记录进程的页和内存的页框之间的对应关系，页表用于记录每一个页面在内存中所占用页框的页框号以及其他使用特性（如信息保护、权限等）。</p>
<p>每一条记录需要描述页号、页框号和其他属性。</p>
<p>操作系统为每一个进程建立一个页表，页表长度和首地址存放在该进程的PCB中，当前运行进程的页表必须驻留在内存，页表长度和首地址由特殊的寄存器记录。</p>
<h3 id="755-页式地址映射过程"><a class="markdownIt-Anchor" href="#755-页式地址映射过程"></a> 7.5.5 页式地址映射过程</h3>
<p>页式地址映射就是将页式虚拟地址转化为物理内存地址的过程。</p>
<p><font color=red>物理地址MA=页框号P’×页大小+页内偏移地址W</font></p>
<h3 id="756-空闲页框管理"><a class="markdownIt-Anchor" href="#756-空闲页框管理"></a> 7.5.6 空闲页框管理</h3>
<h3 id="757-快表"><a class="markdownIt-Anchor" href="#757-快表"></a> 7.5.7 快表</h3>
<p>页表的实现方式将影响系统的效率，页表可以放在内存中，也可以放在cache中实现。</p>
<p>实践中将页表中最近常用的部分条目（页表的一个子集，一般为16条）复制到快表中，进行地址映射时首先访问快表，如果在快表中找到数据则称为<font color=red>命中</font>。如果没有找到则访问慢表，并将慢表中的结果更新到快表中。页表的更新策略影响页表的命中率。</p>
<h3 id="758-页面共享"><a class="markdownIt-Anchor" href="#758-页面共享"></a> 7.5.8 页面共享</h3>
<p>页式存储管理共享内存的思想：将<font color=red>共享代码的页框映射到相关不同进程的页表中</font>，从而实现页面共享。共享页面在内存中只存储一份，可以有效节省内存。</p>
<h3 id="759-缺页中断"><a class="markdownIt-Anchor" href="#759-缺页中断"></a> 7.5.9 缺页中断</h3>
<h4 id="页表的扩充"><a class="markdownIt-Anchor" href="#页表的扩充"></a> 页表的扩充</h4>
<p>实际上的页表除了页号和页框号之外还有其他的域：</p>
<ul>
<li>访问位：记录当前页面在一定时间内是否被访问过</li>
<li>修改位：记录当前页面在一点时间内是否被修改过（脏位）</li>
<li>中断位：记录当前页面是否已经装入内存</li>
</ul>
<h4 id="缺页中断"><a class="markdownIt-Anchor" href="#缺页中断"></a> 缺页中断</h4>
<p>当进程需要新的页面，而该页面没有被加载到内存时，就会产生缺页异常。缺页中断指地址映射过程中，当<font color=red>所要访问的目的页不在内存中时系统产生的异常</font>。</p>
<p>缺页中断处理程序在遇到缺页中断时<font color=red>将所缺的页从页表指出的辅存地址调入到内存某个页框中，并更新页表中该页对应的页框号以及修改中断位</font>。</p>
<p>定义<font color=red>缺页率=缺页次数/访问页面总次数</font>，<font color=red>命中率=1-缺页率</font>。</p>
<p>缺页中断和普通中断的异同点：</p>
<ul>
<li>处理过程均为保护现场、中断处理、恢复现场。</li>
<li>普通中断在指令执行结束后响应，缺页中断在指令执行过程中发生；一条指令可能造成多次缺页中断。</li>
</ul>
<h3 id="7510-多级页表"><a class="markdownIt-Anchor" href="#7510-多级页表"></a> 7.5.10 多级页表</h3>
<p>在多个进程并发的时候，多个页表将占据大量的内存，且页表必须连续存放，有时可能难以找到一块足够大的连续内存空间存放页表。因此引出多级页表的设计思路。</p>
<p>二级页表的设计思路是将页表本身划分为若干个页面，每一个页面都是一个小的页表，小的页表可以离散保存在内存中。为了对小页表进行索引和查找，需要另外设置一个称为页目录的表存放每一个小页表所在的页框。<font color=red>页目录又称为外层页表或一级页表，小页表称为内层页表或二级页表</font>。</p>
<p>页目录本身就是一个特殊的页表，不过每一个表项记录的是二级页表的序号与所在页框的关系。</p>
<p>使用二级页表的好处就是不必将所有页表都保存在内存中。</p>
<h3 id="7511-页面淘汰算法"><a class="markdownIt-Anchor" href="#7511-页面淘汰算法"></a> 7.5.11 页面淘汰算法</h3>
<p>当缺页中断程序将所缺的页从辅存地址调入内存时，如果当前内存恰好没有空闲页框，就需要将内存中已有的页面淘汰一页。</p>
<p>选择淘汰哪一页的算法称为页面淘汰算法。</p>
<p>定义<font color=red>页面抖动为页面频繁在内存和辅存之间交换的现象</font>。页面抖动会导致系统效率降低。好的淘汰策略应该保证较少的抖动和较高的命中率。</p>
<h4 id="最佳淘汰算法opt算法"><a class="markdownIt-Anchor" href="#最佳淘汰算法opt算法"></a> 最佳淘汰算法（OPT算法）</h4>
<p><font color=red>淘汰以后不再需要的或最远的将来将要需要的页面</font>。采用这种算法可以保证最低的缺页率，但难以判断到底哪一页是最远的将来将会使用的页面，因此只能多用于理论分析。</p>
<h4 id="先进先出淘汰算法fifo算法"><a class="markdownIt-Anchor" href="#先进先出淘汰算法fifo算法"></a> 先进先出淘汰算法（FIFO算法）</h4>
<p><font color=red>该算法淘汰内存中已经停留时间最长的页面</font>。</p>
<p>实现起来比较简单，只需要将各个页面按照装入顺序挂接在FIFO队列的末尾即可（实际上也可以使用每一页添加一个装入时间标志来判断，但是这样的话每一次淘汰都需要遍历所有的页，效率太低）</p>
<p>优点：实现简单，进程按照顺序访问页面地址空间时页面抖动较少，缺页率较低<br />
缺点：对于一些特定的访问序列，分配页框越多，缺页率越高</p>
<h4 id="最久未使用淘汰算法lru算法"><a class="markdownIt-Anchor" href="#最久未使用淘汰算法lru算法"></a> 最久未使用淘汰算法（LRU算法）</h4>
<p><font color=red>淘汰内存中最长时间未被使用的页面</font>。</p>
<p>近似实现算法：利用页表访问位，页被访问时由硬件置1。页表访问位周期性被软件清零，当访问位为1时不可淘汰，访问位为0时表示可以淘汰。</p>
<p>缺点：软件周期性清零的周期难以确定，如果太小则有很多页访问位都为0，如果太大则有很多页访问位都为1，都无法确定到底淘汰哪一页。</p>
<h4 id="最不经常使用淘汰算法lfu算法"><a class="markdownIt-Anchor" href="#最不经常使用淘汰算法lfu算法"></a> 最不经常使用淘汰算法（LFU算法）</h4>
<p><font color=red>淘汰当前时间为止访问次数最少的页面</font>。</p>
<p>对每一页设置一个访问计数器，每当页面被访问时，访问计数器+1。发生缺页中断时查找计数器最小的页淘汰并将所有页的计数器清零。</p>
<p>影响缺页次数的因素：</p>
<ul>
<li>页面越小，越容易缺页。</li>
<li>分配给进程的页框数量越少，越容易缺页。</li>
</ul>
<p>因此程序局部性越好越不容易缺页，跳转越多越容易缺页。</p>
<p>页面的常见大小为1KB、2KB、4KB<br />
如果页面过大，则会浪费内存<br />
如果页面过小，则会导致页表长度增加，浪费内存，且换页次数多，影响系统效率</p>
<p>页式存储系统的不足：</p>
<ul>
<li>页面划分没有逻辑含义</li>
<li>页面的共享不灵活</li>
<li>页内碎片</li>
</ul>
<h2 id="76-段式存储管理系统"><a class="markdownIt-Anchor" href="#76-段式存储管理系统"></a> 7.6 段式存储管理系统</h2>
<h3 id="761-段式管理的概念"><a class="markdownIt-Anchor" href="#761-段式管理的概念"></a> 7.6.1 段式管理的概念</h3>
<p>段式存储管理系统允许程序员将进程按照逻辑意义划分为多个段，每一段有段名，长度不定。一个进程由多个段构成，一般一个进程都有代码段、数据段、堆栈段。</p>
<p><font color=red>每个段的段内都从0开始编址，并占用一段连续的地址空间。每一个段的长度取决于段自身的内容，所以各个段的大小可以不等。</font></p>
<h3 id="762-段式地址和段表"><a class="markdownIt-Anchor" href="#762-段式地址和段表"></a> 7.6.2 段式地址和段表</h3>
<p>段式存储管理系统中的<font color=red>虚拟地址VA包含段号S和段内偏移地址W两个部分</font>。进程以段为单位装入内存，每一段分配连续的内存，段和段之间不要求相邻。</p>
<p>进程的段在进行地址映射时，必须知道每一段内存中存放的位置，<font color=red>段表用于支持地址映射</font>的数据结构，类似于页式系统的页表。</p>
<p>段表中记录每一段在内存中的映射的位置和相关的存取属性。段表的典型类型包含<font color=red>段号S、基址B、段长L</font>、可读R、可写W、可执行X、访问位、修改位、中断位等属性。</p>
<h3 id="763-段式地址映射"><a class="markdownIt-Anchor" href="#763-段式地址映射"></a> 7.6.3 段式地址映射</h3>
<p>进程执行一条指令时</p>
<ul>
<li>首先获取指令中的虚拟地址的段号S和段内偏移地址W，</li>
<li>其次以段号S为索引，查找段表，找到对应表项中基址字段和段长字段，分别获得该段在内存中的起始地址B和段长L。</li>
<li>利用段长L和偏移地址W进行合法性检查：如果W&lt;0或W&gt;L说明访问越界。</li>
<li>计算物理地址，物理地址=基址B+段内偏移地址W。</li>
</ul>
<p>段的共享</p>
<ul>
<li>共享段在内存中只保存一份。</li>
<li>共享段被进程映射到自己的内存空间（需要写入该进程的段表）。</li>
<li>需要共享的模块都可以设置为单独的段。</li>
</ul>
<p>段式系统的缺点：段需要连续存储空间，最大尺寸受到内存大小的限制，在辅存中管理可变尺寸的段比较困难。</p>
<p><font color=red>段式系统和页式系统的异同点</font>：</p>
<ul>
<li>页式系统是一维地址空间，段式系统是二维地址空间（段是一个维度，段内是一个维度）</li>
<li>段长可变而一页的大小固定</li>
<li>段的划分有意义，而页的划分无意义</li>
<li>相对而言段更容易共享</li>
<li>段对于用户可见，而页对于用户不可见</li>
<li>段偏移存在溢出问题，而页偏移不存在</li>
</ul>
<h2 id="77-段页式存储管理系统"><a class="markdownIt-Anchor" href="#77-段页式存储管理系统"></a> 7.7 段页式存储管理系统</h2>
<h3 id="771-段页式存储的概念"><a class="markdownIt-Anchor" href="#771-段页式存储的概念"></a> 7.7.1 段页式存储的概念</h3>
<p>段页式系统的基本原理是段式存储和页式存储的组合，<font color=red>首先将用户程序分为若干个段，每一个段赋予一个段名，然后将每个段分为若干页</font>。</p>
<h3 id="772-段页式地址和地址映射"><a class="markdownIt-Anchor" href="#772-段页式地址和地址映射"></a> 7.7.2 段页式地址和地址映射</h3>
<p>段页式存储管理系统中，进程中各个段依然具有二维地址空间：段号和段内偏移。段内偏移被分解为页号和页内偏移地址。因此<font color=red>段页式地址由3部分组成：段号、页号和页内偏移地址</font>。</p>
<p>段页式地址的映射机构：</p>
<ul>
<li>内存按照页进行划分，按照页进行装入</li>
<li>同时采用段表和页表进行地址映射
<ul>
<li>系统为每一个进程创建一个段表，为每一个段创建一个页表</li>
<li>段表给出每一段的长度和起始地址</li>
<li>页表给出每一页对应的页框</li>
</ul>
</li>
</ul>
<h2 id="78-ia-32-cpu内存管理机制"><a class="markdownIt-Anchor" href="#78-ia-32-cpu内存管理机制"></a> 7.8 IA-32 CPU内存管理机制</h2>
<h3 id="781-实模式和保护模式"><a class="markdownIt-Anchor" href="#781-实模式和保护模式"></a> 7.8.1 实模式和保护模式</h3>
<h4 id="实模式"><a class="markdownIt-Anchor" href="#实模式"></a> 实模式</h4>
<p>计算机在加电前的一段短时间内处于实模式。</p>
<p>实模式内存空间为20位，即1MB物理地址空间，分段机制为段地址16位+偏移地址16位，<font color=red>物理地址=段地址左移4位+偏移地址</font>。</p>
<h4 id="保护模式"><a class="markdownIt-Anchor" href="#保护模式"></a> 保护模式</h4>
<p>保护模式下依然为段地址16位+偏移地址16位的形式，但物理地址计算方式不同，书中原话：操作系统会通过一定的方法从这个“段地址”里面辗转多次获得真正的“段地址”，再和偏移地址相加获得物理地址。</p>
<p>保护模式优化的分段管理机制，支持分页管理机制，共可寻址4GB空间。CPU支持多任务，支持特权级机制，可以使用扩展寄存器和一些新增的寄存器。</p>
<p><font color=red>可以使用的5个控制寄存器：CR0~CR4</font>。</p>
<ul>
<li>CR0含有控制CPU操作模式的控制位和表示系统状态的标志位。第0位是PE位用于切换保护模式和实模式，第31位为PG位用于启动分页机制。</li>
<li>CR1保留未用。</li>
<li>CR2含有缺页中断的线性地址，又称页故障线性地址寄存器。缺页中断时CPU将引起缺页异常的线性地址保存在CR2中，由缺页中断处理程序对其进行处理。</li>
<li>CR3含有页目录的物理内存基地址，又称页目录基地址寄存器PDBR，CR3仅有高20位用于标识地址，低12位用于其他用途。</li>
<li>CR4包含虚拟8086模式扩展位、保护模式虚拟中断位、禁止RDTSC指令位等较为特殊的控制位。</li>
</ul>
<h3 id="782-段与段描述符"><a class="markdownIt-Anchor" href="#782-段与段描述符"></a> 7.8.2 段与段描述符</h3>
<p>段是保护模式下一个重要的概念，指一段连续的内存。在保护模式下，对于任何一个内存单元的存取，都会被系统使用这个单元所在段的存取属性对该操作进行检验。</p>
<p><font color=red>段的属性称为段描述符</font>，共8字节，描述有段的段基址、段限长和段属性（段类型、访问该段需要的最小特权级、是否在内存中等）。</p>
<p><img src="https://img-blog.csdnimg.cn/57fb31ee58fd46f78df07fdc3e490a1a.png" alt="" /></p>
<h4 id="段基地址域"><a class="markdownIt-Anchor" href="#段基地址域"></a> 段基地址域</h4>
<p>第2、3、4、7字节，指明段在4GB的线性地址空间中所处的位置。其可以是0~4GB范围内任意地址。</p>
<h4 id="段限长域"><a class="markdownIt-Anchor" href="#段限长域"></a> 段限长域</h4>
<p>第0、1字节和第6字节低4位，实际上是由段描述符中两个分离的字段组合成一个20位的值。段限长实际上是最大的段内偏移值，其仅仅是一个数字，<font color=red>长度单位由段属性域中的颗粒度标识域G指定</font>。如果G=0，则该域中数字的单位是字节，此时段长最大为1MB；如果G=1，则数字的单位是页，此时段长最大可以为4GB。</p>
<h4 id="段属性域"><a class="markdownIt-Anchor" href="#段属性域"></a> 段属性域</h4>
<p><font color=red>描述符特权级别DPL</font>：描述符的特权级，范围从0到3。<br />
<font color=red>描述符类型标志域S</font>：仅1位，描述段的类型是存储段还是非存储段。存储段指的是这个段存放的是可以由程序直接访问的代码或数据，因此存储段含代码段和数据段两种。存储段描述符也分为代码段描述符和数据段描述符两种（堆栈段属于数据段），S=0表示是系统描述符，描述一段特殊的内存。<br />
<font color=red>描述符访问类型标志域TYPE</font>：4位，指定段或者门的类型，段的访问种类以及段的扩展方向。具体含义依赖于描述符类型域S。<br />
<font color=red>段存在标志域P</font>：指出一个段是否在内存中，=1表示在内存中。</p>
<h3 id="783-描述符表与段选择子"><a class="markdownIt-Anchor" href="#783-描述符表与段选择子"></a> 7.8.3 描述符表与段选择子</h3>
<p>所有段在使用之前都需要建立描述符表，每一个段描述符占用8KB空间，所有的段描述符集中存放于内存某个区域中，一个接着一个构成描述符表。IA-32 CPU中有3种描述符表，只介绍前面两种：<font color=red>全局描述符表GDT和局部描述符表LDT</font>。</p>
<h4 id="全局描述符表"><a class="markdownIt-Anchor" href="#全局描述符表"></a> 全局描述符表</h4>
<p>GDT中包含所有进程可以共用的段的描述符。每个CPU只能有1个GDT，其包含的内存段往往是全局性的，是每一个进程都能够访问的段或者用于系统全局管理的段。</p>
<p>GDTR：48位的寄存器，保存GDT的入口，即全局描述符表寄存器。高32位为GDT在内存中的起始地址，低16位在数值上等于GDT的大小-1。</p>
<h4 id="段选择子"><a class="markdownIt-Anchor" href="#段选择子"></a> 段选择子</h4>
<p>GDT中有多个段描述符，如果需要选择其中的一个并通过该段描述符选择对应的段，则需要知道该段描述符在GDT的位置。</p>
<p><font color=red>段选择子是记录段描述符在描述符表中索引的数据结构</font>，共16位包含3个域。</p>
<ul>
<li>索引域，高13位，记录描述符在描述符表中的索引，索引值从0开始。</li>
<li>TI域，中间1位，指明所在描述符表是GDT还是LDT。TI=1从LDT中选择，否则从GDT中选择。</li>
<li>特权级域，低2位，描述对请求者最低特权级的限制。</li>
</ul>
<p><font color=red>保护模式中，段寄存器记录的是段描述符的索引，通过该索引找到段描述符，然后通过段描述符中的段基址域找到该段。</font></p>
<h4 id="局部描述符表"><a class="markdownIt-Anchor" href="#局部描述符表"></a> 局部描述符表</h4>
<p>LDT与特定任务相关，<font color=red>用于容纳仅属于该任务的段描述符</font>。每个进程/任务都有一个LDT，LDT本身也有对应的描述符称为LDT描述符，描述LDT的基地址，<font color=red>LDT描述符是全局性的，存放于GDT中</font>。因此如果需要找到LDT的基地址需要首先从GDT中找到LDT描述符。</p>
<p>CPU中有一个局部描述符表寄存器LDTR，16位，存放LDT描述符对应的段选择子，通过该段选择子可以在GDT中找到LDT描述符，然后找到LDT。</p>
<h2 id="79-linux内存管理"><a class="markdownIt-Anchor" href="#79-linux内存管理"></a> 7.9 Linux内存管理</h2>
<h3 id="791-linux内存管理概述"><a class="markdownIt-Anchor" href="#791-linux内存管理概述"></a> 7.9.1 Linux内存管理概述</h3>
<p>Linux使用三级页表机制，从最外层到最里层依次是<font color=red>页全局目录PGD、页中间目录PMD和页表PT</font>。</p>
<p>线性地址从高到低被分为<font color=red>PGD索引域（10位）、PMD索引域（在32位系统中为0位，在64位系统中才使用）、PT索引域（10位）和页内偏移域（12位）</font>4个部分。当前进程的PGD基址存放于CR3寄存器中。</p>
<h2 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h2>
<p>本章的例题涉及计算的部分比较多。</p>
<h3 id="1-分区分配策略问题"><a class="markdownIt-Anchor" href="#1-分区分配策略问题"></a> 1. 分区分配策略问题</h3>
<p>某计算机内存大小为1MB，某时刻其内存使用情况如下：<br />
00000H~1EFFFH（124KB）：正在使用<br />
1F000H~1FFFFH（4KB）：空闲<br />
20000H~27FFFH（32KB）：正在使用<br />
28000H~2FFFFH（32KB）：空闲<br />
30000H~32FFFH（12KB）：正在使用<br />
33000H~34FFFH（8KB）：空闲<br />
35000H~37FFFH（12KB）：正在使用<br />
38000H~5FFFFH（160KB）：空闲<br />
60000H~EFFFFH（576KB）：正在使用<br />
F0000H~FFFFFH（64KB）：空闲</p>
<p>画出3种分区分配策略（首次适应、最佳适应、最坏适应）对应于该内存环境的空闲区表，并处理下列内存分配请求：2KB、48KB、128KB、20KB。</p>
<p>解：<br />
首次适应算法按照地址排序——</p>
<table>
<thead>
<tr>
<th style="text-align:center">地址</th>
<th style="text-align:center">大小</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1F000H~1FFFFH</td>
<td style="text-align:center">4KB</td>
</tr>
<tr>
<td style="text-align:center">28000H~2FFFFH</td>
<td style="text-align:center">32KB</td>
</tr>
<tr>
<td style="text-align:center">33000H~34FFFH</td>
<td style="text-align:center">8KB</td>
</tr>
<tr>
<td style="text-align:center">38000H~5FFFFH</td>
<td style="text-align:center">160KB</td>
</tr>
<tr>
<td style="text-align:center">F0000H~FFFFFH</td>
<td style="text-align:center">64KB</td>
</tr>
</tbody>
</table>
<p>首次适应算法顺序查找，使用第一个大小大于请求的内存块进行分配。</p>
<p>2KB分配到1F000H~1F7FFH。<br />
48KB分配到38000H~43FFFH。<br />
128KB无法分配。<br />
20KB分配到28000H~2CFFFH。</p>
<p>分配后空闲区表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">地址</th>
<th style="text-align:center">大小</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1F800H~1FFFFH</td>
<td style="text-align:center">2KB</td>
</tr>
<tr>
<td style="text-align:center">2D000H~2FFFFH</td>
<td style="text-align:center">12KB</td>
</tr>
<tr>
<td style="text-align:center">33000H~34FFFH</td>
<td style="text-align:center">8KB</td>
</tr>
<tr>
<td style="text-align:center">44000H~5FFFFH</td>
<td style="text-align:center">112KB</td>
</tr>
<tr>
<td style="text-align:center">F0000H~FFFFFH</td>
<td style="text-align:center">64KB</td>
</tr>
</tbody>
</table>
<p>最佳适应算法按照空闲块从小到大排序：</p>
<table>
<thead>
<tr>
<th style="text-align:center">地址</th>
<th style="text-align:center">大小</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1F000H~1FFFFH</td>
<td style="text-align:center">4KB</td>
</tr>
<tr>
<td style="text-align:center">33000H~34FFFH</td>
<td style="text-align:center">8KB</td>
</tr>
<tr>
<td style="text-align:center">28000H~2FFFFH</td>
<td style="text-align:center">32KB</td>
</tr>
<tr>
<td style="text-align:center">F0000H~FFFFFH</td>
<td style="text-align:center">64KB</td>
</tr>
<tr>
<td style="text-align:center">38000H~5FFFFH</td>
<td style="text-align:center">160KB</td>
</tr>
</tbody>
</table>
<p>2KB分配到1F000H~1F7FFH。<br />
48KB分配到F0000H~FBFFFH。<br />
128KB分配到38000H~57FFFH。<br />
20KB分配到28000H~2CFFFH。</p>
<p>分配后空闲区表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">地址</th>
<th style="text-align:center">大小</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1F800H~1FFFFH</td>
<td style="text-align:center">2KB</td>
</tr>
<tr>
<td style="text-align:center">33000H~34FFFH</td>
<td style="text-align:center">8KB</td>
</tr>
<tr>
<td style="text-align:center">2D000H~2FFFFH</td>
<td style="text-align:center">12KB</td>
</tr>
<tr>
<td style="text-align:center">FC000H~FFFFFH</td>
<td style="text-align:center">16KB</td>
</tr>
<tr>
<td style="text-align:center">58000H~5FFFFH</td>
<td style="text-align:center">32KB</td>
</tr>
</tbody>
</table>
<p>最坏适应算法按照空闲区从大到小排序：</p>
<table>
<thead>
<tr>
<th style="text-align:center">地址</th>
<th style="text-align:center">大小</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">38000H~5FFFFH</td>
<td style="text-align:center">160KB</td>
</tr>
<tr>
<td style="text-align:center">F0000H~FFFFFH</td>
<td style="text-align:center">64KB</td>
</tr>
<tr>
<td style="text-align:center">28000H~2FFFFH</td>
<td style="text-align:center">32KB</td>
</tr>
<tr>
<td style="text-align:center">33000H~34FFFH</td>
<td style="text-align:center">8KB</td>
</tr>
<tr>
<td style="text-align:center">1F000H~1FFFFH</td>
<td style="text-align:center">4KB</td>
</tr>
</tbody>
</table>
<p>2KB分配到38000H~387FFH。<br />
48KB分配到38800H~447FFH。<br />
128KB无法分配。<br />
20KB分配到44800H~497FFH。</p>
<p>分配后空闲区表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">地址</th>
<th style="text-align:center">大小</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">49800H~5FFFFH</td>
<td style="text-align:center">90KB</td>
</tr>
<tr>
<td style="text-align:center">F0000H~FFFFFH</td>
<td style="text-align:center">64KB</td>
</tr>
<tr>
<td style="text-align:center">28000H~2FFFFH</td>
<td style="text-align:center">32KB</td>
</tr>
<tr>
<td style="text-align:center">33000H~34FFFH</td>
<td style="text-align:center">8KB</td>
</tr>
<tr>
<td style="text-align:center">1F000H~1FFFFH</td>
<td style="text-align:center">4KB</td>
</tr>
</tbody>
</table>
<h3 id="2-页面淘汰算法"><a class="markdownIt-Anchor" href="#2-页面淘汰算法"></a> 2. 页面淘汰算法</h3>
<p>某计算机的快表可以保存4页内容，接下来计算机的页访问序列为：1、3、2、5、4、5、3、3、2、1、4、2、3、2，求出4种页面淘汰算法的快表命中率。（一开始快表均为空）</p>
<p>最优淘汰算法：</p>
<ul>
<li>1 3 2 5 4 5 3 3 2 1 4 2 3 2</li>
<li>× × × × × √ √ √ √ x √ √ √ √</li>
<li>1 1 1 1 4 4 4 4 4 4 4 4 4 4</li>
<li>0 3 3 3 3 3 3 3 3 3 3 3 3 3</li>
<li>0 0 2 2 2 2 2 2 2 2 2 2 2 2</li>
<li>0 0 0 5 5 5 5 5 5 1 1 1 1 1</li>
</ul>
<p>命中率为8/14。</p>
<p>先进先出淘汰算法：</p>
<ul>
<li>1 3 2 5 4 5 3 3 2 1 4 2 3 2</li>
<li>× × × × × √ √ √ √ x √ √ x x</li>
<li>1 1 1 1 4 4 4 4 4 4 4 4 4 4</li>
<li>0 3 3 3 3 3 3 3 3 1 1 1 1 1</li>
<li>0 0 2 2 2 2 2 2 2 2 2 2 3 3</li>
<li>0 0 0 5 5 5 5 5 5 5 5 5 5 2</li>
</ul>
<p>命中率为6/14。</p>
<p>最久未使用淘汰算法：</p>
<ul>
<li>1 3 2 5 4 5 3 3 2 1 4 2 3 2</li>
<li>× × × × × √ √ √ √ x x √ √ √</li>
<li>1 1 1 1 4 4 4 4 4 1 1 1 1 1</li>
<li>0 3 3 3 3 3 3 3 3 3 3 3 3 3</li>
<li>0 0 2 2 2 2 2 2 2 2 2 2 2 2</li>
<li>0 0 0 5 5 5 5 5 5 5 4 4 4 4</li>
</ul>
<p>命中率为7/14。</p>
<p>最不经常使用淘汰算法</p>
<ul>
<li>1 3 2 5 4 5 3 3 2 1 4 2 3 2</li>
<li>× × × × × √ √ √ √ x x x √ √</li>
<li>1 1 1 1 4 4 4 4 4 1 1 1 1 1</li>
<li>0 3 3 3 3 3 3 3 3 3 3 3 3 3</li>
<li>0 0 2 2 2 2 2 2 2 2 4 2 2 2</li>
<li>0 0 0 5 5 5 5 5 5 5 5 5 5 5</li>
</ul>
<p>命中率为6/14。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC6%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC6%E7%AB%A0/" class="post-title-link" itemprop="url">操作系统原理——第6章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-03 09:12:31 / Modified: 09:16:18" itemprop="dateCreated datePublished" datetime="2023-03-03T09:12:31+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">操作系统原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="chapter-6-进程调度"><a class="markdownIt-Anchor" href="#chapter-6-进程调度"></a> Chapter 6 进程调度</h1>
<h2 id="61-调度概念"><a class="markdownIt-Anchor" href="#61-调度概念"></a> 6.1 调度概念</h2>
<h3 id="611-调度的定义"><a class="markdownIt-Anchor" href="#611-调度的定义"></a> 6.1.1 调度的定义</h3>
<p>调度广义上是指在一个队列中，按照某种策略从中选择一个最合适的个体。</p>
<h3 id="612-调度的分类"><a class="markdownIt-Anchor" href="#612-调度的分类"></a> 6.1.2 调度的分类</h3>
<p>按照调度层次和原因可分为长程调度、中程调度、短程调度和I/O调度。</p>
<ul>
<li>长程调度是从多个作业构成的后备作业队列中，根据调度算法选取一个合适的作业调入内存。当一个作业结束退出系统时，需要执行长程调度从磁盘上选择一个后备作业投入执行。</li>
<li>中程调度主要是短期调节系统的负荷，对象为进程，将进程在内存和磁盘交换空间之间进行交换。这样做可能因为内存资源紧张需要挂起一些进程，另外是为系统减少并发性而降低系统开销。</li>
<li>短程调度即进程调度，决定哪一个进程将被执行、哪些进程将处于就绪状态。即进程在运行、就绪、阻塞这3个状态之间的转换调度由短程调度完成。其目的是让整个队列被调度的延迟最小，优化系统效率。</li>
<li>I/O调度为当I/O设备可用时调度相应的等待队列中的进程使用该设备。属于设备管理模块的功能，确定一个合适的顺序来执行来自进程的I/O请求。可以改善系统整体性能。</li>
</ul>
<h2 id="62-调度的原则"><a class="markdownIt-Anchor" href="#62-调度的原则"></a> 6.2 调度的原则</h2>
<h3 id="621-调度的宏观原则"><a class="markdownIt-Anchor" href="#621-调度的宏观原则"></a> 6.2.1 调度的宏观原则</h3>
<p>用户期望的调度原则应该包括：</p>
<ul>
<li>响应速度尽可能快</li>
<li>进程处理时间尽可能短</li>
<li>系统吞吐量尽可能大</li>
<li>资源利用率尽可能高</li>
<li>对所有进程公平</li>
<li>避免饥饿</li>
<li>避免死锁</li>
</ul>
<p>但上面几条原则本身就存在矛盾，操作系统一般采取折中的方式采纳其中的部分原则。</p>
<h3 id="622-调度的时间性能测度"><a class="markdownIt-Anchor" href="#622-调度的时间性能测度"></a> 6.2.2 调度的时间性能测度</h3>
<p><font color=red>周转时间和平均周转时间</font>：周转时间指作业从提交到计算机开始到给出结果花费的时间，包括在后备队列中等待的时间、对应进程在内存就绪队列中等待时间、对应进程在CPU上真正运行的时间、对应进程等待I/O操作完成的阻塞时间等。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span>表示周转时间，则$$t=t_c-t_s$$其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">t_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示作业的提交时刻，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">t_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示作业的完成时刻，也可以计算为$$t=t_w+t_r$$其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">t_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示作业等待时间，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">t_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示作业运行时间。<font color=red>周转时间越短越好</font>。</p>
<p>平均周转时间指一批作业周转时间的平均值。</p>
<p><font color=red>带权周转时间和平均带权周转时间</font>：考虑作业大小对周转时间的影响，带权周转时间指作业周转时间和执行时间的比值：$$w=\frac{t}{t_r}$$其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span>为进程周转时间，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">t_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为进程执行时间。</p>
<p>带权周转时间的意义是表明作业在系统中的相对停留时间，消除因为作业大小不同而导致的绝对周转时间缺少比较价值的问题。</p>
<p>平均带权周转时间指一组作业中带权周转时间的平均值。</p>
<h2 id="63-进程调度过程"><a class="markdownIt-Anchor" href="#63-进程调度过程"></a> 6.3 进程调度过程</h2>
<h3 id="631-进程调度的功能"><a class="markdownIt-Anchor" href="#631-进程调度的功能"></a> 6.3.1 进程调度的功能</h3>
<ul>
<li>记录和管理全部进程的工作状态</li>
<li>按照调度策略选择合适的进程</li>
<li>进行进程上下文切换</li>
</ul>
<h3 id="632-进程调度的时机"><a class="markdownIt-Anchor" href="#632-进程调度的时机"></a> 6.3.2 进程调度的时机</h3>
<p>主要的调度时机有：</p>
<ul>
<li>时钟中断</li>
<li>I/O中断</li>
<li>异常</li>
<li>进程结束</li>
<li>系统调用</li>
<li>主动调度</li>
</ul>
<h2 id="63-进程调度的方式"><a class="markdownIt-Anchor" href="#63-进程调度的方式"></a> 6.3 进程调度的方式</h2>
<p>进程调度的方式可以分为非抢占方式和抢占方式。区别为当有优先级更高的进程到来时，进程调度程序是否会将当前进程立即切出而切入新进程。抢占方式将首先执行高优先级进程，将低优先级进程暂时挂起；非抢占方式将低优先级进程执行完再去执行高优先级进程。</p>
<h2 id="64-作业调度算法"><a class="markdownIt-Anchor" href="#64-作业调度算法"></a> 6.4 作业调度算法</h2>
<h3 id="641-先来先服务调度算法"><a class="markdownIt-Anchor" href="#641-先来先服务调度算法"></a> 6.4.1 先来先服务调度算法</h3>
<p>FCFS调度算法容易理解，容易实现，但是效率不高。该算法只考虑了作业的等待时间而没有考虑作业的执行时间，因此算法<font color=red>不利于晚到但是短的作业</font>。</p>
<h3 id="642-短作业优先调度算法"><a class="markdownIt-Anchor" href="#642-短作业优先调度算法"></a> 6.4.2 短作业优先调度算法</h3>
<p>SJF算法参考运行时间从后备作业中选择运行时间最短的作业优先投入运行。易于实现，但<font color=red>不利于早到却很长的作业</font>。</p>
<h3 id="643-响应比高者优先调度算法"><a class="markdownIt-Anchor" href="#643-响应比高者优先调度算法"></a> 6.4.3 响应比高者优先调度算法</h3>
<p>RRHF算法考虑作业的响应比。<font color=red>响应比=响应时间/运行时间=1+等待时间/运行时间</font>。该调度算法有利于短作业，对于等待时间相同的作业，短作业的响应比高于长作业。该算法有利于等待已久的作业，等待时间越长越容易被调度。</p>
<h2 id="65-进程调度算法"><a class="markdownIt-Anchor" href="#65-进程调度算法"></a> 6.5 进程调度算法</h2>
<h3 id="651-优先数高者优先调度算法"><a class="markdownIt-Anchor" href="#651-优先数高者优先调度算法"></a> 6.5.1 优先数高者优先调度算法</h3>
<p>HPF调度算法根据进程的优先数将CPU分配给优先数最高的进程。优先数是一个人为定义的参数，包括<font color=red>静态优先数和动态优先数</font>。静态优先数在进程创建时确定，动态优先数在进程运行期间根据环境动态指定。</p>
<p>静态优先数的确定需要考虑以下因素：</p>
<ul>
<li>进程需要资源的多少，一般进程申请的资源越多，优先数越低，但如果涉及的I/O设备与人机交互有关则可以获得较高的优先数以提升用户体验。</li>
<li>进程运行时间长短，一般较大的进程运行时间较长，可以分配较低的优先数。</li>
<li>进程的类型，偏I/O的进程可以比偏CPU的进程获得更高的优先数，前台进程可以比后台进程获得更高的优先数，普通用户进程可以比核心进程获得更高的优先数等。</li>
</ul>
<p>动态优先数的确定需要考虑以下因素：</p>
<ul>
<li>当使用CPU超过一定时长时，可以考虑降低其优先数。</li>
<li>当进程等待时间超过一定时长时，可以考虑提高其优先数。</li>
<li>当进行I/O操作时，可以提高其优先数。</li>
</ul>
<p>在Linux系统中，普通用户的进程可以将进程数设置为0~19，内核进程可以设置进程数为-20~19。</p>
<p>缺点：当低优先级进程占用高优先级进程资源时反而需要高优先级进程等待低优先级进程完成，这被称为优先级反转。解决方案有：临时设置高优先级、继承高优先级、临时使用中断禁止。</p>
<h3 id="652-时间片轮转调度算法"><a class="markdownIt-Anchor" href="#652-时间片轮转调度算法"></a> 6.5.2 时间片轮转调度算法</h3>
<p>时间片轮转调度算法将所有就绪进程排成一个队列，新来进程加到队列末尾，进程以时间片q为单位轮流使用CPU，刚使用完CPU的进程排到队列末尾，队列在逻辑上是环形的。</p>
<p>该算法需要合理选择时间片q的大小，时间片太短则会导致进程切换频繁，增加系统开销，时间片太长则可能会退化为FCFS算法。</p>
<h3 id="653-多重时间片轮转调度算法"><a class="markdownIt-Anchor" href="#653-多重时间片轮转调度算法"></a> 6.5.3 多重时间片轮转调度算法</h3>
<p>这是对时间片轮转调度算法的一种改进，设置多个就绪队列，每一个队列对应一个优先级，每个就绪队列使用的时间片大小不同，高优先级的时间片短而低优先级的时间片长。通常优先级每提高一级时间片缩短一半。这样可以提高系统吞吐量，缩短平均周转时间。</p>
<h2 id="66-linux进程调度"><a class="markdownIt-Anchor" href="#66-linux进程调度"></a> 6.6 Linux进程调度</h2>
<h3 id="661-linux调度机制"><a class="markdownIt-Anchor" href="#661-linux调度机制"></a> 6.6.1 Linux调度机制</h3>
<p>Linux进程调度的基本特点：</p>
<ul>
<li>基于优先级调度，优先级由静态优先级和动态优先级构成</li>
<li>支持普通进程和实时进程</li>
<li>实时进程优先于普通进程</li>
<li>普通进程公平使用CPU时间</li>
</ul>
<p>Linux进程控制块task_struct中的priority成员指的是进程的静态优先级，counter成员指的是动态优先级，还有一个nice值，可以通过修改nice值修改进程的静态优先级。nice值的设置范围为-20~19。静态优先级表示该进程被允许连续运行的最长时间，实时进程使用静态优先级调度。counter指的是该进程在当前时间片结束后还能够连续运行多少个时间片，其值越大优先级越高。在新一轮调度开始时，counter=priority，时钟中断服务程序执行后其值自减1，当所有进程的counter都减到0时开始新一轮的调度。</p>
<p>rt_priority成员表示实时进程特有的优先级，policy表示进程的调度策略，用于区分实时进程和普通进程，可选SCHED_OTHER、SCHED_FIFO、SCHED_RR三种。</p>
<p>Linux的调度函数为schedule函数，其在可运行队列中选择一个具有最高优先数的进程并将CPU切换给它。</p>
<h2 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h2>
<p>本章的例题大多与计算有关，即计算调度时间。</p>
<p>例-1：下面是各个任务的到达时间和任务长度，试写出3种作业调度算法下这些任务的开始时间，以及各自的周转时间、平均周转时间、带权周转时间和平均带权周转时间。</p>
<p>对于FCFS算法：</p>
<table>
<thead>
<tr>
<th style="text-align:center">任务</th>
<th style="text-align:center">到达时间</th>
<th style="text-align:center">持续时间</th>
<th style="text-align:center">开始时间</th>
<th style="text-align:center">周转时间</th>
<th style="text-align:center">带权周转时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">10</td>
<td style="text-align:center">30</td>
<td style="text-align:center">60</td>
<td style="text-align:center">80</td>
<td style="text-align:center">2.33</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">0</td>
<td style="text-align:center">20</td>
<td style="text-align:center">0</td>
<td style="text-align:center">20</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">0</td>
<td style="text-align:center">40</td>
<td style="text-align:center">20</td>
<td style="text-align:center">60</td>
<td style="text-align:center">1.5</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">60</td>
<td style="text-align:center">10</td>
<td style="text-align:center">90</td>
<td style="text-align:center">40</td>
<td style="text-align:center">4</td>
</tr>
</tbody>
</table>
<p>该算法的平均周转时间为50，平均带权周转时间为2.21。</p>
<p>对于SJF算法：</p>
<table>
<thead>
<tr>
<th style="text-align:center">任务</th>
<th style="text-align:center">到达时间</th>
<th style="text-align:center">持续时间</th>
<th style="text-align:center">开始时间</th>
<th style="text-align:center">周转时间</th>
<th style="text-align:center">带权周转时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">10</td>
<td style="text-align:center">30</td>
<td style="text-align:center">20</td>
<td style="text-align:center">40</td>
<td style="text-align:center">1.33</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">0</td>
<td style="text-align:center">20</td>
<td style="text-align:center">0</td>
<td style="text-align:center">20</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">0</td>
<td style="text-align:center">40</td>
<td style="text-align:center">50</td>
<td style="text-align:center">90</td>
<td style="text-align:center">2.25</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">60</td>
<td style="text-align:center">10</td>
<td style="text-align:center">90</td>
<td style="text-align:center">40</td>
<td style="text-align:center">4</td>
</tr>
</tbody>
</table>
<p>该算法的平均周转时间为47.5，平均带权周转时间为2.15。</p>
<p>对于RRHF算法：</p>
<table>
<thead>
<tr>
<th style="text-align:center">任务</th>
<th style="text-align:center">到达时间</th>
<th style="text-align:center">持续时间</th>
<th style="text-align:center">开始时间</th>
<th style="text-align:center">周转时间</th>
<th style="text-align:center">带权周转时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">10</td>
<td style="text-align:center">30</td>
<td style="text-align:center">20</td>
<td style="text-align:center">40</td>
<td style="text-align:center">1.33</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">0</td>
<td style="text-align:center">20</td>
<td style="text-align:center">0</td>
<td style="text-align:center">20</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">0</td>
<td style="text-align:center">40</td>
<td style="text-align:center">50</td>
<td style="text-align:center">90</td>
<td style="text-align:center">2.25</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">60</td>
<td style="text-align:center">10</td>
<td style="text-align:center">90</td>
<td style="text-align:center">40</td>
<td style="text-align:center">4</td>
</tr>
</tbody>
</table>
<p>该算法的平均周转时间为47.5，平均带权周转时间为2.15。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC5%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC5%E7%AB%A0/" class="post-title-link" itemprop="url">操作系统原理——第5章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-03 09:12:28 / Modified: 09:16:18" itemprop="dateCreated datePublished" datetime="2023-03-03T09:12:28+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">操作系统原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.4k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="chapter-5-死锁"><a class="markdownIt-Anchor" href="#chapter-5-死锁"></a> Chapter 5 死锁</h1>
<h2 id="51-进程饥饿"><a class="markdownIt-Anchor" href="#51-进程饥饿"></a> 5.1 进程饥饿</h2>
<p>系统不能保证进程的等待时间上限，从而使该进程长时间等待，当等待时间给进程推进和响应带来明显不利影响时，称发生了进程饥饿。</p>
<h2 id="52-死锁的概念"><a class="markdownIt-Anchor" href="#52-死锁的概念"></a> 5.2 死锁的概念</h2>
<p>死锁是指两个或多个进程已经陷入阻塞，都在无限期地等待永远不会发生的条件的一种系统状态。进程进入死锁之后，永远都被阻塞而无法运行。</p>
<p>死锁的另一种定义是在两个或多个进程中，每一个进程都已经持有某一些资源，而在申请其他进程持有的资源。每一个进程都拥有部分资源，但又不足以运行，导致每一个进程都不能向前推进。</p>
<h2 id="53-死锁的起因"><a class="markdownIt-Anchor" href="#53-死锁的起因"></a> 5.3 死锁的起因</h2>
<h3 id="531-资源的分类"><a class="markdownIt-Anchor" href="#531-资源的分类"></a> 5.3.1 资源的分类</h3>
<p>将系统中的资源分为两类：<font color=red>可抢占资源和不可抢占资源</font>。</p>
<p>可抢占资源指的是该类资源可以被多个进程同时访问，即被一个进程占用使用完之前可以被其他进程抢占，但不影响进程运行结果。如CPU和内存。<br />
不可抢占资源指的是该资源被一个进程占用之后除非该进程已经使用完毕，否则其他进程不能强行抢占该资源，否则进程运行可能会出错。如大多数硬件和软件资源。</p>
<h3 id="532-死锁的起因"><a class="markdownIt-Anchor" href="#532-死锁的起因"></a> 5.3.2 死锁的起因</h3>
<p>引起系统死锁的原因：</p>
<ul>
<li>系统资源不足，这是引起死锁的根本原因。</li>
<li>进程并发推进顺序不当。</li>
</ul>
<p>关于死锁的一些结论：</p>
<ul>
<li>陷入死锁的进程至少有2个。</li>
<li>参与死锁的进程至少有2个已经占有资源。</li>
<li>参与死锁的所有进程都在等待资源。</li>
<li>参与死锁的进程是当前所有进程的子集。</li>
<li>死锁会浪费大量系统资源，甚至导致系统崩溃。</li>
</ul>
<h3 id="533-死锁的必要条件"><a class="markdownIt-Anchor" href="#533-死锁的必要条件"></a> 5.3.3 死锁的必要条件</h3>
<p><font color=red>死锁的必要条件</font>：</p>
<ul>
<li><font color=red>互斥条件</font>，即进程竞争的资源均为不可抢占资源，进程需要互斥地使用这些资源。</li>
<li><font color=red>不剥夺条件</font>，进程释放资源之前不能被其他任何进程剥夺。</li>
<li><font color=red>部分分配条件</font>，进程运行全过程的所需的资源逐步分配，每一个资源在访问之前临时申请。</li>
<li><font color=red>环路条件</font>，多个进程因为资源的申请和占用的关系构成一个逻辑环路，如进程A占用进程B需要的资源，进程B占用进程C需要的资源，进程C占用进程A需要的资源。</li>
</ul>
<h2 id="54-死锁的解决"><a class="markdownIt-Anchor" href="#54-死锁的解决"></a> 5.4 死锁的解决</h2>
<h3 id="541-解决死锁的4种方法"><a class="markdownIt-Anchor" href="#541-解决死锁的4种方法"></a> 5.4.1 解决死锁的4种方法</h3>
<ul>
<li>预防：通过设置多个限制条件，使得死锁发生的必要条件中有几条不成立。其中破坏互斥条件几乎不可能，破坏不剥夺条件花销较大，破坏部分分配条件需要将资源进行预先静态分配，破坏环路条件需要资源的有序分配。但由于限制过于严格，导致资源利用率和吞吐量降低。</li>
<li>避免：用某种方法分析某种分配方式是否会造成死锁，可能导致算法过于复杂而不实用。</li>
<li>检测：检测当前系统中是否有发生死锁，难度和复杂程度较大。</li>
<li>恢复：撤销或者挂起一些进程以回收一些资源，实现难度大。</li>
</ul>
<h3 id="542-预先静态分配法"><a class="markdownIt-Anchor" href="#542-预先静态分配法"></a> 5.4.2 预先静态分配法</h3>
<p>预先静态分配法破坏了部分分配条件，保证死锁不会发生。其采用全部分配法的策略，在进程运行之前就将其所需的资源一次性全部分配给它。如果资源不够则该进程无法运行。</p>
<p>缺点：浪费资源且资源利用率低，需要资源多的进程可能会被推迟，适应性有局限（某些进程需要如信号量这样的同步信号资源无法提前准备），应用程序设计开销较大。</p>
<h3 id="543-有序资源分配法"><a class="markdownIt-Anchor" href="#543-有序资源分配法"></a> 5.4.3 有序资源分配法</h3>
<p>有序资源分配法破坏环路条件，使得环路无法构成。采用的策略是给系统中的每一个资源分配一个序号，且进程每一次申请资源时只能申请比上次申请的资源的序号更大的资源。由于每一个进程只能按照资源序号递增顺序申请资源，因此系统对资源编号时可以按照从小到大的顺序编号，一般是输入设备较小，输出设备较大。</p>
<p>缺点：资源浪费，资源编号不易合理化（难以保证资源使用顺序满足每一个进程的资源使用顺序）</p>
<h3 id="544-鸵鸟算法"><a class="markdownIt-Anchor" href="#544-鸵鸟算法"></a> 5.4.4 鸵鸟算法</h3>
<p>一句话，不管，如果真的发生了死锁，可以由用户手动去清除。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC4%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC4%E7%AB%A0/" class="post-title-link" itemprop="url">操作系统原理——第4章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-03 09:12:26 / Modified: 09:16:18" itemprop="dateCreated datePublished" datetime="2023-03-03T09:12:26+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">操作系统原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>6.3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>6 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="chapter-4-进程管理"><a class="markdownIt-Anchor" href="#chapter-4-进程管理"></a> Chapter 4 进程管理</h1>
<h2 id="41-进程的概念"><a class="markdownIt-Anchor" href="#41-进程的概念"></a> 4.1 进程的概念</h2>
<p>定义：程序在并发环境下在一个数据集下的一次运行过程。</p>
<p>特征：</p>
<ul>
<li>动态性：是程序的一次执行过程，其动态产生和消亡。</li>
<li>并发性：进程可以同其他进程一起向前推进。</li>
<li>异步性：进程按照各自速度向前推进。</li>
<li>独立性：进程是系统分配资源和调度CPU的单位。</li>
</ul>
<p><font color=red>一个程序可能有多个进程对应。</font></p>
<ul>
<li>进程是动态的，程序是静态的</li>
<li>进程是暂存的，程序是长久的</li>
</ul>
<h2 id="42-进程的状态和转换"><a class="markdownIt-Anchor" href="#42-进程的状态和转换"></a> 4.2 进程的状态和转换</h2>
<p>进程的3个基本运行状态：</p>
<ul>
<li><font color=red>运行状态</font>：进程占用CPU正在CPU上运行的状态。</li>
<li><font color=red>就绪状态</font>：进程已经可以运行但是还没有获得CPU，暂时还无法运行的状态。</li>
<li><font color=red>阻塞状态</font>：进程因为缺少某个运行所需的必要条件（资源或信号）而进入等待的状态，如IO操作等。</li>
</ul>
<p>进程状态的改变：</p>
<ul>
<li>运行→阻塞：需要等待信号、服务结束或某个资源时</li>
<li>阻塞→就绪：信号到来、服务结束或所需资源有空闲</li>
<li>就绪→运行：通过进程调度使得该进程获得了CPU</li>
<li>运行→就绪：CPU被抢占</li>
</ul>
<p>扩展进程状态：</p>
<ul>
<li>新建状态：操作系统创建进程的过程，创建完毕后进入就绪状态。</li>
<li>终止状态：进程退出后的状态，虽不能运行但仍保留一些信息。只能由运行状态转换而来。</li>
</ul>
<p>具有挂起和解挂操作的进程状态：</p>
<ul>
<li>将就绪状态拆分为静止就绪和活跃就绪状态，将阻塞状态拆分为静止阻塞状态和活跃阻塞状态。处于静止状态时表示挂起状态，便于操作系统进行资源调度。</li>
<li>运行→静止就绪，活动就绪→静止就绪，活动阻塞→静止阻塞：进程挂起</li>
<li>静止就绪→活跃就绪，静止阻塞→活跃阻塞：解挂</li>
<li>静止阻塞→静止就绪：期待活动完成</li>
</ul>
<h2 id="43-进程控制块pcb"><a class="markdownIt-Anchor" href="#43-进程控制块pcb"></a> 4.3 进程控制块——PCB</h2>
<p>进程控制块至少应该包含以下信息：</p>
<ul>
<li>进程ID（PID）：标识进程的编号</li>
<li>进程起始地址：进程的可执行映像在内存（物理内存）中的起始地址</li>
<li>进程状态：当前状态</li>
<li>优先级：进程优先级别，用于进程调度</li>
<li>CPU现场保护区：发生中断时对CPU状态的拷贝区，便于下一次将进程加载进CPU继续执行</li>
<li>进程间通信区：记录进程之间通信的控制信息、信号和信息缓冲区</li>
<li>资源列表：进程拥有的资源清单，主要为外设的占用信息</li>
<li>文件列表：进程打开的文件列表</li>
<li>内存列表：进程占用的内存空间（虚拟空间和物理空间）</li>
</ul>
<p>创建进程时创建PCB，进程撤销时PCB应该同时撤销。</p>
<h2 id="44-linux进程控制块task_struct"><a class="markdownIt-Anchor" href="#44-linux进程控制块task_struct"></a> 4.4 Linux进程控制块——task_struct</h2>
<p>进程状态：</p>
<ul>
<li>TASK_RUNNING：运行态和就绪态。</li>
<li>TASK_UNINTERRUPTIBLE：不可中断，不可被其他进程通过信号和时钟中断唤醒，只有资源得到满足才会进入就绪状态，一般非常短暂。</li>
<li>TASK_INTERRUPTIBLE：可以被其他进程通过信号和时钟中断唤醒。</li>
<li>TASK_ZOMBIE：进程终止执行，释放大部分资源。</li>
<li>TASK_STOPPED：进程被挂起。</li>
</ul>
<p>ps命令：可查看当前进程状态<br />
<code>ps aux</code>，输出有多行。其中STAT行表示进程状态，字段含义：</p>
<ul>
<li>R：TASK_RUNNING</li>
<li>S：TASK_INTERRUPTIBLE</li>
<li>I：空闲</li>
<li>Z：TASK_ZOMBIE</li>
<li>D：TASK_UNINTERRUPTIBLE</li>
<li>T：TASK_STOPPED/TASK_TRACED，停止或被调试</li>
</ul>
<p><font color=red>task_struct中的重要字段：</font></p>
<ul>
<li>进程状态</li>
<li>进程调度信息</li>
<li>标识符：包含自身的ID（<code>getpid()</code>获取）、父进程ID（<code>getppid()</code>获取）、进程组ID</li>
<li>进程通信信息</li>
<li>链接信息</li>
<li>时间和计时器</li>
<li>文件系统</li>
<li>虚拟内存信息</li>
<li>处理器信息/现场保留区</li>
<li>进程链表：<code>struct *next_task, prev_task</code>，所有进程在一个双向链表之中。</li>
</ul>
<h2 id="45-进程基本控制"><a class="markdownIt-Anchor" href="#45-进程基本控制"></a> 4.5 进程基本控制</h2>
<h3 id="451-进程创建"><a class="markdownIt-Anchor" href="#451-进程创建"></a> 4.5.1 进程创建</h3>
<p>参数：进程标识、优先级、进程起始地址、CPU初始状态、资源清单等<br />
步骤：</p>
<ul>
<li>分配PCB</li>
<li>分配并赋值PID</li>
<li>分配内存空间</li>
<li>初始化PCB（CPU状态、内存、优先级、进程状态、链表队列）</li>
<li>插入相应的进程队列</li>
<li>调度程序</li>
</ul>
<h3 id="452-进程阻塞"><a class="markdownIt-Anchor" href="#452-进程阻塞"></a> 4.5.2 进程阻塞</h3>
<p>当需要等待外设IO操作、等待系统服务完成、等待请求资源、等待其他进程的约束、服务进程没有新任务可做时进行阻塞。<br />
步骤：</p>
<ul>
<li>进程停止运行（需要保存现场等）</li>
<li>修改PCB状态</li>
<li>插入相应阻塞队列</li>
<li>调度程序</li>
</ul>
<h3 id="453-进程唤醒"><a class="markdownIt-Anchor" href="#453-进程唤醒"></a> 4.5.3 进程唤醒</h3>
<p>时机与进程阻塞相反。<br />
步骤：</p>
<ul>
<li>修改PCB状态</li>
<li>插入相应就绪队列</li>
<li>调度程序</li>
</ul>
<h3 id="454-进程撤销"><a class="markdownIt-Anchor" href="#454-进程撤销"></a> 4.5.4 进程撤销</h3>
<p>终止此进程的运行。<br />
步骤：</p>
<ul>
<li>在队列中查找该进程</li>
<li>获取进程状态</li>
<li>如果该进程正在运行则立即终止</li>
<li>释放进程资源</li>
<li>将进程从队列中移除</li>
</ul>
<h3 id="455-原语"><a class="markdownIt-Anchor" href="#455-原语"></a> 4.5.5 原语</h3>
<p>进程控制涉及底层的操作，为提高系统的稳定性和效率，进程操作由操作系统内核完成，且加以特殊保护。</p>
<p><font color=red>原语</font>是由若干条指令组成的一段小程序，用于实现某个特定操作，原语具有不可分割性，要么全部运行成功，要么彻底失败，执行过程不可中断。一个操作如果为原语则称该操作具有原子性，称该操作为原子操作。</p>
<p>主要的控制原语除了上述的创建原语、撤销原语、阻塞原语、唤醒原语外还包括挂起原语、激活原语等。</p>
<h2 id="46-windows进程控制"><a class="markdownIt-Anchor" href="#46-windows进程控制"></a> 4.6 Windows进程控制</h2>
<p>windows创建进程可以使用多个API实现：</p>
<ul>
<li>system</li>
<li>WinExec</li>
<li>ShellExecute</li>
<li>CreateProcess，前面3个最终都需要调用CreateProcess</li>
</ul>
<p>CreateProcess有很多参数，其中包含可执行程序名、程序参数、执行选项等。其执行步骤：</p>
<ul>
<li>创建进程内核对象，创建虚拟地址空间</li>
<li>装载exe文件和dll文件到虚拟内存中</li>
<li>创建主线程和线程内核对象</li>
<li>启动主线程，进入主函数</li>
</ul>
<p>结束进程：</p>
<ul>
<li>ExitProcess</li>
<li>TerminateProcess</li>
</ul>
<h2 id="47-linux进程控制"><a class="markdownIt-Anchor" href="#47-linux进程控制"></a> 4.7 Linux进程控制</h2>
<h3 id="471-linux进程分类"><a class="markdownIt-Anchor" href="#471-linux进程分类"></a> 4.7.1 Linux进程分类</h3>
<p>用户在Linux中执行一条命令就是创建了一个新的进程。</p>
<p>Linux进程可分为交互式进程、批处理进程、实时进程、守护进程等。</p>
<h3 id="472-linux进程创建"><a class="markdownIt-Anchor" href="#472-linux进程创建"></a> 4.7.2 Linux进程创建</h3>
<p>Linux中可以使用fork函数创建一个进程。创建出来的进程是一个子进程，创建进程的进程即为父进程。<font color=red>这里的子进程是父进程的复制，父进程和子进程并发运行</font>。</p>
<p>fork函数的返回值是一个整数，表示进程号。<font color=red>在子进程中，该函数返回的值为0，父进程中返回一个大于0的值，如果创建进程错误则返回-1</font>。在fork函数之后可以通过判断fork函数返回值的方法实现父进程和子进程分别执行不同的代码，让二者执行的分支不同。</p>
<h3 id="473-fork函数实现过程"><a class="markdownIt-Anchor" href="#473-fork函数实现过程"></a> 4.7.3 fork函数实现过程</h3>
<p>fork函数的执行流程：</p>
<ul>
<li>分配task_struct结构体</li>
<li>拷贝父进程，复制正文段、数据段以及系统数据段（复制父进程task_struct的大部分内容，而修改小部分内容）</li>
<li>将新进程的task_struct保存到队列中</li>
<li>新进程置于就绪状态</li>
</ul>
<p>fork函数的特殊机制：<font color=red>写时复制（COW）</font>，即父进程的资源被设置为只读，当父进程或子进程试图修改某些内容时，内核才在修改前对部分内容进行拷贝。</p>
<p>fork函数的实际开销主要就在于复制父进程页表以及给子进程创建PCB。</p>
<p>Linux启动的第一个进程是init进程（进程号为1），其余进程均为init的子孙进程。</p>
<h3 id="475-execve函数创建进程"><a class="markdownIt-Anchor" href="#475-execve函数创建进程"></a> 4.7.5 execve函数创建进程</h3>
<p>exec族函数可用于在子进程空间指定要执行的可执行程序。</p>
<p>首先根据文件名找到可执行程序，然后将可执行程序的内容填充入子进程的地址空间中。若exec调用成功则进入新的进程不再返回，若调用失败则继续从调用点向下进行。</p>
<p>除了execve外，还有execl、execlp、execle、execv、execvp等。</p>
<h3 id="476-linux进程撤销"><a class="markdownIt-Anchor" href="#476-linux进程撤销"></a> 4.7.6 Linux进程撤销</h3>
<p>exit函数用于终结此进程，终结进程后需要释放资源并向父进程报告。终结该进程后，该进程变成僵尸状态，保留部分PCB信息供wait函数进行收集。</p>
<p>进程结束时可调用schedule函数选择新进程运行。</p>
<h3 id="477-linux的wait函数"><a class="markdownIt-Anchor" href="#477-linux的wait函数"></a> 4.7.7 Linux的wait()函数</h3>
<p>wait函数用于进行<font color=red>进程的阻塞</font>，通过wait函数可以阻塞自身，其会监测是否有子进程结束，如果没有则一直阻塞，如果有则停止阻塞，收集该结束的子进程信息并将其彻底终止，返回。wait函数有一个整型参数int&amp; status接收子进程退出时的退出代码。若忽略子进程退出信息则参数填NULL。</p>
<p>sleep函数也可以用于进程阻塞，阻塞当前进程暂停执行多少秒，系统暂停调度该进程。</p>
<h2 id="48-线程"><a class="markdownIt-Anchor" href="#48-线程"></a> 4.8 线程</h2>
<h3 id="481-线程概念"><a class="markdownIt-Anchor" href="#481-线程概念"></a> 4.8.1 线程概念</h3>
<p>线程是进程内部的一个相对独立的运行路径，一个进程可以有多个线程。线程是进程内创建的可运行模块，能够执行指定的任务。线程和线程之间可以并发进行。</p>
<p><font color=red>在具有线程概念的操作系统中，线程是操作系统进行调度的最小单位，如windows系统。</font></p>
<ul>
<li>线程能够提高系统的并发性能，其并发粒度比进程更细，能够充分发挥CPU的性能。</li>
<li>线程的应用成本更低，更灵活。<font color=red>进程为线程提供地址空间和资源</font>，线程与线程之间的通信比进程之间更加灵活。</li>
<li>大多数操作系统都采用了线程技术。</li>
</ul>
<p>下面场景适用多线程：</p>
<ul>
<li>多个功能需要并发</li>
<li>需要改善窗口交互性</li>
<li>需要改善程序结构</li>
<li>多核CPU之间的应用</li>
</ul>
<p>现代操作系统中，进程=资源集+线程组。</p>
<p>线程的缺点：难以调试，容易造成线程安全问题，并发过程难以控制。</p>
<h3 id="482-windows线程"><a class="markdownIt-Anchor" href="#482-windows线程"></a> 4.8.2 Windows线程</h3>
<p>windows中可以通过CreateThread函数创建线程，并为其指定一个任务。</p>
<h2 id="49-进程相互制约关系"><a class="markdownIt-Anchor" href="#49-进程相互制约关系"></a> 4.9 进程相互制约关系</h2>
<h3 id="491-互斥关系"><a class="markdownIt-Anchor" href="#491-互斥关系"></a> 4.9.1 互斥关系</h3>
<p>在进程运行过程中互相排斥地访问一个具有独占性的公共资源，必须协调各个进程对资源的存取顺序，确保没有任何两个或两个以上的进程同时进行资源存取。</p>
<p>将一次只允许一个进程独占访问的资源称为<font color=red>临界资源</font>，访问临界资源的代码段称为<font color=red>临界区</font>。</p>
<h3 id="492-同步关系"><a class="markdownIt-Anchor" href="#492-同步关系"></a> 4.9.2 同步关系</h3>
<p>合作进程中某些操作之间需要满足某种先后关系或某个操作能否进行取决于某个前提条件是否满足，否则只能等待。互斥关系是特殊的同步关系。</p>
<h3 id="493-同步机制"><a class="markdownIt-Anchor" href="#493-同步机制"></a> 4.9.3 同步机制</h3>
<p>有效的同步机制满足：</p>
<ul>
<li>当进程即将要执行的某个操作的运行条件不满足时，能够让该进程立即暂停执行该操作。</li>
<li>当被暂停的操作的运行条件满足时，相应进程能够被尽快唤醒以便继续运行。</li>
<li>同步机制在实现上也属于原子操作。</li>
</ul>
<p>有关于多个进程不能同时访问临界区的问题，在硬件上可以通过中断屏蔽来完成，进入临界区时关中断，离开临界区时开中断。在软件上可以通过<font color=red>锁和信号量</font>来解决。</p>
<h2 id="410-锁"><a class="markdownIt-Anchor" href="#410-锁"></a> 4.10 锁</h2>
<h3 id="4101-临界资源和临界区"><a class="markdownIt-Anchor" href="#4101-临界资源和临界区"></a> 4.10.1 临界资源和临界区</h3>
<h3 id="4102-锁的概念"><a class="markdownIt-Anchor" href="#4102-锁的概念"></a> 4.10.2 锁的概念</h3>
<p>锁机制通过设置标志来标识临界区是否可以进入或临界资源是否可用。如果为不可用状态，则程序在临界区之外进行等待，若为可用状态，则进入临界区并将临界资源设置为不可用状态。</p>
<p>上锁操作：检测锁S的状态，如果S=0则返回继续检测，如果S=1则设置S=0<br />
开锁操作：将S设置为1<br />
上锁和开锁都应该是原语。</p>
<p>锁可以保证临界区中最多只能有1个进程能够进入其中，在进入临界区之前执行上锁操作，在退出临界区时执行开锁操作。</p>
<p><font color=red>设置临界区访问机制的4个原则</font>：</p>
<ul>
<li><font color=red>忙则等待</font>：临界区忙时其他的进程应该在外面等待</li>
<li><font color=red>空闲让进</font>：没有进程位于临界区时允许其他进程抢占临界区</li>
<li><font color=red>有限等待</font>：进程进入临界区的请求应该在有限时间内得到满足</li>
<li><font color=red>让权等待</font>：等待进程放弃CPU，以让其他进程有机会得到CPU</li>
</ul>
<p>锁机制满足上面4个原则中的前三个。</p>
<h2 id="411-信号量与p-v操作"><a class="markdownIt-Anchor" href="#411-信号量与p-v操作"></a> 4.11 信号量与P-V操作</h2>
<h3 id="4111-信号量概念"><a class="markdownIt-Anchor" href="#4111-信号量概念"></a> 4.11.1 信号量概念</h3>
<p>信号量的核心数据结构是一个二元组（S,Q），其中S是一个初值非负的整型变量，Q是初始为空的队列。S可以表示某一类资源的可用数量，可以指某些条件等。当由于信号量的变化而导致某一个合作进程被阻塞，它将被挂接在队列Q中，而当信号量的变化导致满足了进程的运行条件时该进程将被唤醒，并离开队列Q。</p>
<h3 id="4112-p-v操作的定义"><a class="markdownIt-Anchor" href="#4112-p-v操作的定义"></a> 4.11.2 P-V操作的定义</h3>
<p>P操作指通过：</p>
<ul>
<li>S自减1</li>
<li>如果S大于或等于0，则函数返回，且调用者进程继续执行</li>
<li>如果S小于0，则函数返回，且调用者进程阻塞并插入到等待队列Q中，并由调度程序调度其他进程执行</li>
</ul>
<p>S操作指释放：</p>
<ul>
<li>S自增1</li>
<li>若S大于0，则函数返回，且调用者进程继续执行</li>
<li>若S小于或等于0，则函数返回，调用者进程继续执行，并同时从等待队列Q中唤醒某一个等待进程</li>
</ul>
<p>这两个操作在内核中均使用原语控制。</p>
<p>总结而言，P操作可能会阻塞某一个进程，V操作可能会唤醒某一个进程。<font color=red>对于S的初始值设置要合理</font>。信号量实际上就是可以控制多个进程中最多可以有几个进程同时在临界区中运行。</p>
<p>在关键操作之前执行P操作，在关键操作之后执行V操作。</p>
<h2 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h2>
<h3 id="1-进程之间的互斥模型"><a class="markdownIt-Anchor" href="#1-进程之间的互斥模型"></a> 1. 进程之间的互斥模型</h3>
<p>进程之间的互斥模型几乎是必考的题型，需要理解锁与信号量控制进程之间互斥的原理。</p>
<p><font color=red>技巧</font>：</p>
<ul>
<li>对于那些总量有限制的资源，需要定义两个信号量，一个信号量表示当前该资源剩余量，另一个信号量表示当前该资源最多还能够产生几个。</li>
<li>对于那些临界资源，临界区可能修改临界资源的值，需要加锁处理，或者使用一个初值为1的信号量代替锁。</li>
</ul>
<p>例-1：生产者-消费者模型，一共有10个生产者生产5种资源，一个资源由2个生产者负责。另外有2个消费者，第1个消费者需要资源1、2、3循环进行操作A，第2个消费者需要资源3、4、5循环进行操作B。写出代码，实现10个生产者与2个消费者之间的进程互斥。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">semaphore res1 = <span class="number">0</span>, res2 = <span class="number">0</span>, res3 = <span class="number">0</span>, res4 = <span class="number">0</span>, res5 = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">producer_12</span><span class="params">()</span>&#123;V(res1);&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">producer_34</span><span class="params">()</span>&#123;V(res2);&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">producer_56</span><span class="params">()</span>&#123;V(res3);&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">producer_78</span><span class="params">()</span>&#123;V(res4);&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">producer_90</span><span class="params">()</span>&#123;V(res5);&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer_1</span><span class="params">()</span>&#123;</span><br><span class="line">	P(res1);</span><br><span class="line">	P(res2);</span><br><span class="line">	P(res3);</span><br><span class="line">	A();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer_2</span><span class="params">()</span>&#123;</span><br><span class="line">	P(res3);</span><br><span class="line">	P(res4);</span><br><span class="line">	P(res5);</span><br><span class="line">	B();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	corun&#123;</span><br><span class="line">		producer_12</span><br><span class="line">		producer_12</span><br><span class="line">		producer_34</span><br><span class="line">		producer_34</span><br><span class="line">		producer_56</span><br><span class="line">		producer_56</span><br><span class="line">		producer_78</span><br><span class="line">		producer_78</span><br><span class="line">		producer_90</span><br><span class="line">		producer_90</span><br><span class="line">		consumer_1</span><br><span class="line">		consumer_2</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例-2 某高速出口设有若干人工服务区和ETC服务区，不断有汽车从高速到达出口，其中货车只能选择人工通道，轿车可以选择人工通道也可以选择ETC通道，一辆轿车到达时优先选择ETC通道，如果ETC通道均在排队则选择人工通道。现设人工通道有1个，ETC通道有1个，要求写出代码，能够实时统计每一个通道前排队的车辆数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> queuep = <span class="number">0</span>, queueetc = <span class="number">0</span>;</span><br><span class="line">semaphore p = <span class="number">1</span>, etc = <span class="number">1</span>, mutex_p = <span class="number">1</span>, mutex_etc = <span class="number">1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">car</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(queueetc)&#123;</span><br><span class="line">			P(etc);</span><br><span class="line">			P(mutex_etc);</span><br><span class="line">			queueetc++;</span><br><span class="line">			V(mutex_etc);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			P(p);</span><br><span class="line">			P(mutex_p);</span><br><span class="line">			queuep++;</span><br><span class="line">			V(mutex_p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">person</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(queuep &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			V(p);</span><br><span class="line">			P(mutex_p);</span><br><span class="line">			queuep--;</span><br><span class="line">			V(mutex_p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">etc</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(queueetc &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			V(etc);</span><br><span class="line">			P(mutex_etc);</span><br><span class="line">			queueetc--;</span><br><span class="line">			V(mutex_etc);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC3%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC3%E7%AB%A0/" class="post-title-link" itemprop="url">操作系统原理——第3章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-03 09:12:22 / Modified: 09:16:18" itemprop="dateCreated datePublished" datetime="2023-03-03T09:12:22+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">操作系统原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="chapter-3-用户界面"><a class="markdownIt-Anchor" href="#chapter-3-用户界面"></a> Chapter 3 用户界面</h1>
<h2 id="31-用户环境"><a class="markdownIt-Anchor" href="#31-用户环境"></a> 3.1 用户环境</h2>
<p>用户环境指的是计算机用户工作的<font color=red>软件环境</font>，包括命令行环境、桌面环境、相关的用户使用手册。</p>
<p><font color=red>用户环境的构造</font>指的是按照用户的要求和硬件特性，安装和配置好操作系统，为用户提供必要的操作命令或图形界面，并使其工作方式和交互方式合理高效，方便用户使用计算机完成相应的工作。</p>
<h2 id="32-用户界面概念"><a class="markdownIt-Anchor" href="#32-用户界面概念"></a> 3.2 用户界面概念</h2>
<p>用户界面（UI）是用户与操作系统内核进行交互和信息交换的媒介，其目的是让用户能够更加方便、高效、安全、可靠地操作计算机的软件和硬件，并完成预期的工作。用户界面通常分为<font color=red>操作界面和系统调用</font>。</p>
<h2 id="33-操作命令"><a class="markdownIt-Anchor" href="#33-操作命令"></a> 3.3 操作命令</h2>
<p>操作界面：用户可以通过操作界面直接或间接地控制自己的作业或获得操作系统提供的服务。操作界面包括<font color=red>操作命令、批处理命令和图形用户界面</font>三种典型形式。</p>
<ul>
<li>图形用户界面，GUI，包含窗口、图标、按钮等元素。</li>
<li>操作命令，一般通过命令行完成，用户在控制台输入命令与操作系统交互。</li>
<li>批处理与脚本程序，在控制台环境下自动处理一批命令，如执行windows批处理程序或linux shell脚本程序。</li>
</ul>
<p>shell是操作系统与用户交互的页面，其本身不执行命令，而仅仅是组织和管理命令，shell脚本是Shell上可执行命令序列的集合。</p>
<p>Linux Bash有代码的自动补全功能（Tab键），Bash不区分变量类型，其中所有变量均为字符串，只有当变量中全为数字时其才为一个整数变量。</p>
<p><font color=red>重定向与管道</font>：在Linux中，标准输入输出以文件形式存在，分别为0（标准输入）、1（标准输出）、2（标准错误）。命令的输入缺省来自于键盘（文件0），输出缺省到达控制台命令行（文件1、2）。通过重定向可以将输入输出定向到其他地方如文件中。</p>
<ul>
<li>&lt; 为输入重定向符号，将命令输入由键盘改为由其他文件等，相当于将文件中的内容输入到了控制台。</li>
<li>&gt; 为输出重定向符号</li>
<li>&gt;&gt; 符号也是输出重定向，与&gt;不同的是一个符号重定向到文件时会首先清空文件，而两个符号会在后面追加。</li>
<li>2&gt;和2&gt;&gt;均为错误重定向，将命令的错误重定向到某个文件中。</li>
<li>&amp;&gt;为输出与错误组合重定向，即将原来输出到文件1和2的内容均重定向到别的位置。</li>
</ul>
<p>管道：将一个程序的输出作为另一个程序的输入。管道操作符&quot;|&quot;。</p>
<p>脚本（Script）通过类似程序的方式执行具有一定逻辑顺序的命令序列完成较复杂的功能和人机交互。脚本程序保存在文本文件中，是Shell命令语句的集合。脚本文件中所有命令按照顺序执行，凡是能够在shell中直接执行的命令，都可以写在脚本中，脚本中还可以使用一些shell中不能使用的命令。执行shell脚本需要可执行权限：chmod +x。<br />
运行脚本程序的方法：</p>
<ul>
<li>直接运行（缺省版本的shell）</li>
<li>使用某一个特定版本的shell运行脚本</li>
<li>在脚本文件首行指定文件shell（<code>#!/bin/bash</code>）</li>
</ul>
<p>脚本文件中支持变量定义、流程控制、函数、调试方法。</p>
<h2 id="34-系统调用"><a class="markdownIt-Anchor" href="#34-系统调用"></a> 3.4 系统调用</h2>
<p>系统调用是操作系统内核为应用程序提供的服务，是应用程序与操作系统之间的接口。</p>
<p>系统调用一般涉及核心资源或硬件的操作，运行于核态，在调用时产生中断，这种中断是自愿中断、软件中断、内部中断。</p>
<p>系统调用的形式：通过访管指令SVC N，N即为系统调用编号，调用过程发生中断。执行该指令后CPU首先保护现场，然后由中断服务程序查找N号系统调用的入口地址，接着去执行这个系统调用，执行完之后恢复现场。在DOS系统中使用INT 21H进行系统调用（AH寄存器存放系统调用号，这里的INT指令就相当于SVC指令），Linux中为INT 80H（EAX存放系统调用号）。</p>
<p>Linux系统调用的工作原理：</p>
<ul>
<li>应用程序使用隐式方式调用系统调用，这个系统调用将被编译器编译为含有INT 80H的代码。</li>
<li>在内核system_call函数部分查找系统调用的入口地址。</li>
<li>具体实现系统调用。</li>
</ul>
<p>系统调用处理函数指针表sys_call_table[]。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC2%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC2%E7%AB%A0/" class="post-title-link" itemprop="url">操作系统原理——第2章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-03 09:12:19 / Modified: 09:16:18" itemprop="dateCreated datePublished" datetime="2023-03-03T09:12:19+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">操作系统原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>3.7k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="chapter-2-操作系统的硬件基础"><a class="markdownIt-Anchor" href="#chapter-2-操作系统的硬件基础"></a> Chapter 2 操作系统的硬件基础</h1>
<h2 id="21-计算机三总线硬件结构"><a class="markdownIt-Anchor" href="#21-计算机三总线硬件结构"></a> 2.1 计算机三总线硬件结构</h2>
<p>计算机硬件结构主要包括CPU、内存和外设。三者通过<font color=red>地址总线、数据总线、控制总线</font>3条总线进行连接。外设需要有IO接口的模块才能连接到总线上。</p>
<h2 id="22-cpu结构"><a class="markdownIt-Anchor" href="#22-cpu结构"></a> 2.2 CPU结构</h2>
<p>CPU的主要功能是按照一定的逻辑流程分析和执行指令流。CPU在逻辑上可以被划分为3个部分：</p>
<ul>
<li>控制单元：由指令寄存器、指令解码器、指令计数器等构成。根据用户事先编写好的程序，依次从存储器中取出每一条指令放在指令寄存器中，通过指令解码器分析确定好应该执行什么样的操作，然后按照确定的时序向相应的部件发出微操作控制信号，并更新指令计数器的地址。</li>
<li>运算单元：执行算术运算和逻辑运算。接受控制单元的命令而进行动作。</li>
<li>寄存器单元：主要指寄存器组，即CPU中暂存数据的地方，保存等待处理的数据或已经处理过的数据。寄存器起到一个缓存的作用，可以减少CPU访问内存的次数，提高其工作速度。寄存器分为通用寄存器和专用寄存器，通用寄存器数量因处理器而异。</li>
</ul>
<h2 id="23-cpu的态"><a class="markdownIt-Anchor" href="#23-cpu的态"></a> 2.3 CPU的态</h2>
<p>CPU不同的态支持不同的指令集和资源：</p>
<ul>
<li><font color=red>核态</font>：具有最高特权级，也称为特权态、系统态、内核态或核心态。可以执行所有包括特权级指令，使用所有资源，且能够改变处理器状态。</li>
<li><font color=red>用户态</font>：具有较低特权级，不能使用特权指令，不能直接使用系统资源，不能改变CPU工作状态，只能访问用户程序的存储空间。</li>
<li>管态：一个模棱两可的中间状态，介于上面两个状态之间，也可以理解为核态。</li>
</ul>
<p>特权指令包括：能够改变CPU状态的指令、能够修改特殊寄存器的指令、涉及外部设备的输入输出指令。</p>
<p><font color=red>硬件按“态”区分CPU的状态，操作系统通过“态”区分进程的状态。</font></p>
<p>特权级：Intel架构的CPU支持4个特权级，即0-3级，0级最高3级最低。对于一段连续内存（称为段），其头部有段描述符明确规定这段内存的访问特权级，称为<font color=red>描述符特权级（DPL）</font>。UNIX和Linux只支持0、1、3特权级，其中1为管态，Windows只支持0、3级。</p>
<p>CPU的态从用户态向内核态进行转换的方法：</p>
<ul>
<li>系统调用：用户态进程通过系统调用申请使用操作系统提供的服务完成工作。</li>
<li>异常：CPU运行时发现不可预知的异常，使当前进程被切换到处理该异常的内核相关程序中。</li>
<li><font color=red>外部设备中断</font>：外部设备发送数据或接收数据就绪后向CPU发出中断信号，CPU暂停执行原来的指令转而去执行与中断信号相关的处理程序。</li>
</ul>
<p>内核态向用户态转换一般都是IRET的中断返回指令完成的。</p>
<h2 id="24-内存"><a class="markdownIt-Anchor" href="#24-内存"></a> 2.4 内存</h2>
<p>内存又称为主存储器，是计算机系统存放指令和数据的存储器单元。通常分为只读存储器（ROM）、随机存储器（RAM）和高速缓存存储器（Cache）3种类型。</p>
<p>按照与CPU的联系可以分为主存和辅存，主存可以直接与CPU交换信息而辅存不行。<br />
按照存储元的材料可以分为半导体存储器（常用主存）、磁存储器（磁盘等）、光存储器（光盘等）<br />
按照读写工作方式可以分为RAM和ROM。</p>
<p>高速缓存位于CPU和内存之间，容量比内存小但存取速度比内存快，其为内存中一小部分数据的复制，这一小部分数据可能是CPU短时间内访问较为频繁的，CPU访问高速缓存中有的数据时可以减少内存的访问次数，提高CPU速度。</p>
<p>理想的存储系统速度快、容量大、成本低，但现实中不可能实现。现实中将存储系统分层管理，最上层为寄存器，速度最快，容量最小，价格最贵，往下依次为高速缓存、内存、辅存，速度依次降低，容量依次增加，价格依次降低。</p>
<p>CPU访问指令或数据时的访问顺序：</p>
<ul>
<li>访问缓存命中为HIT</li>
<li>访问内存命中为MISS</li>
<li>访问辅存命中为缺页（PAGE FAULT）</li>
</ul>
<h2 id="26-中断系统"><a class="markdownIt-Anchor" href="#26-中断系统"></a> 2.6 中断系统</h2>
<p>中断是指CPU收到外部信号后停止当前工作，自动转去调用事先准备好的中断服务程序处理外部事件，待处理完毕后再回到原来的中断处继续工作的过程或机制。</p>
<p>引入中断的目的是实现并发活动、实现实时处理、故障自动处理。</p>
<p>引起中断的程序被称为<font color=red>中断源</font></p>
<p>中断类型可分为：</p>
<ul>
<li><font color=red>强迫中断和自愿中断</font>，强迫中断是程序没有预期地进行中断，如外部中断；而自愿中断是程序有预期地中断，如访管指令</li>
<li><font color=red>外中断和内中断</font>：外中断由CPU外部事件引起，内中断由CPU内部事件引起。</li>
<li><font color=red>可屏蔽中断和不可屏蔽中断</font>：二者均属于外部中断，不可屏蔽的中断是CPU必须进行响应的，可屏蔽中断CPU可以不响应。</li>
</ul>
<p>程序中断的地方被称为<font color=red>断点</font>，也即为将要执行的下一条指令的地址。</p>
<p>程序正确运行依赖的信息集合被称为<font color=red>现场</font>，在进入中断程序之前需要进行现场保护，即将CPU的重要信息暂时保存到栈上，中断程序结束后需要恢复现场，即将栈中的CPU信息加载到CPU中。</p>
<p>中断流程：<font color=red>识别中断源→保护断点→保护现场→进入中断服务程序→恢复现场→中断返回</font>。</p>
<p>触发中断使用INT指令实现，从中断返回使用IRET指令实现。</p>
<p>中断响应的实质是交换指令执行地址、交换CPU的态。</p>
<h2 id="27-基本输入输出系统"><a class="markdownIt-Anchor" href="#27-基本输入输出系统"></a> 2.7 基本输入输出系统</h2>
<p>BIOS，固化到计算机中的一类程序，是计算机加电后运行的第一个软件，为计算机提供最初级的最直接的硬件操控。</p>
<ul>
<li>加电自检及初始化：加电自检（POST）用于计算机刚接通电源时对硬件部分的检测，通常是对CPU、内存等进行测试。发现问题会直接警告。然后会查找其他设备的BIOS并执行这些设备的BIOS。</li>
<li>设置CMOS参数：用于帮助用户设置基本的系统参数，如系统日期等。</li>
<li>系统启动：根据用户指定顺序从硬盘或光驱等媒介启动操作系统，为用户建立用户环境，OS启动后就由OS接管计算机。</li>
<li>基本输入输出处理程序：为应用程序和操作系统提供硬件接口服务，这些服务主要与输入输出设备有关，如键盘操作等。BIOS使用的基本中断号为10H-1FH，如13H表示软盘调用，INT 13标号为02的子功能为读扇区。</li>
</ul>
<p>系统BIOS的位置为F0000H-FFFFFH。</p>
<h2 id="28-操作系统启动过程"><a class="markdownIt-Anchor" href="#28-操作系统启动过程"></a> 2.8 操作系统启动过程</h2>
<h3 id="281-操作系统启动概述"><a class="markdownIt-Anchor" href="#281-操作系统启动概述"></a> 2.8.1 操作系统启动概述</h3>
<p><font color=red>实模式</font>：程序按照8086方式进行寻址，寻址位一共20位，共可以访问1MB的地址空间，由CPU单任务进行。实模式前640KB（00000H-9FFFFH）为基本内存，中128KB（A0000H-BFFFFH）为显卡显存，后256KB（C0000H-FFFFFH）为BIOS系统。</p>
<p><font color=red>保护模式</font>：内存保护模式，地址寻址共32位，可寻址4GB空间。在该模式下段具有了新的含义和工作机制，且新增了多个寄存器可以操作。其中的地址均为虚拟地址，应用程序和操作系统的运行均被保护。此时CPU支持多任务。</p>
<p>操作系统的启动过程：</p>
<ul>
<li><font color=red>初始引导</font>：用于将OS内核加载到内存的指定位置，从BIOS的启动代码开始执行开始。按下电源开关后电源开始供电，控制芯片组让CPU恢复到初始状态。之后CPU开始执行FFFF0处的代码，BIOS开始进行加电自检。自检完成后开始运行BIOS启动代码，主要用于寻找可用的启动设备，并将其中的引导程序加载到内存中。引导程序可以加载操作系统到内存中的适当位置，并将CPU使用权交给OS内核。</li>
<li><font color=red>核心初始化</font>：用于OS内核初始化系统的核心数据，并继续加载操作系统除了内核之外的部分到内存中。该过程还包含初始化存储系统和页表、构建核心进程、引导内核运行等，最终控制权将被交给内核，进入系统初始化阶段。</li>
<li><font color=red>系统初始化</font>：继续初始化操作系统，并最终准备好操作系统的桌面和控制台，该过程主要包含初始化文件系统、初始化网格系统、初始化控制台、初始化图形界面，最终处于待命状态。</li>
</ul>
<p>DOS系统的启动过程：</p>
<ul>
<li>POST，BIOS自检。</li>
<li>初始引导，BIOS从MBR（主引导记录）中读取引导程序，并加载到内存，引导程序将io.sys和msdos.sys加载到内存中，DOS系统开始运行并接管系统。</li>
<li>核心初始化，操作系统读取config.sys配置系统核心。</li>
<li>系统初始化，操作系统读入 <a target="_blank" rel="noopener" href="http://Command.com">Command.com</a>，执行autoexec.bat，系统待命。</li>
</ul>
<p>Windows的启动过程：</p>
<ul>
<li>POST，BIOS自检。</li>
<li>初始引导，BIOS从MBR（主引导记录）中读取引导程序，并加载到内存，引导程序启动DOS7.0，调入操作系统核心，然后由Windows接管系统。</li>
<li>核心初始化</li>
<li>系统初始化</li>
</ul>
<h3 id="282-linux启动过程"><a class="markdownIt-Anchor" href="#282-linux启动过程"></a> 2.8.2 Linux启动过程</h3>
<ul>
<li>POST</li>
<li>MBR</li>
<li>KERNEL映像</li>
<li>KERNEL映像自解压并执行</li>
<li>内核初始化</li>
<li>内核启动</li>
</ul>
<p>在内核完成引导后需要加载init程序，init进程是所有进程的祖先，进程号为1。init首先使用/etc/inittab脚本文件进行系统初始化，然后执行一系列文件设置其他选项，最后设置键盘、字体等。</p>
<p>操作系统的安装过程：首先需要将OS映像拷贝到存储空间，后写启动相关代码和数据（MBR中的PBR）。对于多操作系统的安装需要修改MBR，进行重写或追加。</p>
<p>MBR：主引导记录，又称为主启动扇区，是计算机开机后访问硬盘必须访问的第一个扇区，操作系统启动相关数据和代码就保存在主启动扇区中。大小为512字节，最后两个字节为0x55和0xAA表明该设备可以用于启动。主引导记录中主要包含有磁盘分区信息、启动参数、操作系统内核位置信息、引导代码等。</p>
<h2 id="210-操作系统的生成"><a class="markdownIt-Anchor" href="#210-操作系统的生成"></a> 2.10 操作系统的生成</h2>
<p>一些操作系统可以根据用户需要进行配置和构建。其前提是：</p>
<ul>
<li>由可以拆装的模块生成</li>
<li>有交互式配置工具</li>
<li>有映像构建工具</li>
</ul>
<p>对于Linux系统即可以通过下载内核、选择和启动配置程序进行配置内核模块和参数、编译新的内核、安装和启动内核这些步骤来完成操作系统的生成。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC1%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC1%E7%AB%A0/" class="post-title-link" itemprop="url">操作系统原理——第1章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-03 09:12:14 / Modified: 09:16:18" itemprop="dateCreated datePublished" datetime="2023-03-03T09:12:14+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">操作系统原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>3.2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="chapter-1-操作系统概述"><a class="markdownIt-Anchor" href="#chapter-1-操作系统概述"></a> Chapter 1 操作系统概述</h1>
<h2 id="11-操作系统直观认识和定义"><a class="markdownIt-Anchor" href="#11-操作系统直观认识和定义"></a> 1.1 操作系统直观认识和定义</h2>
<h3 id="111-操作系统的直观认识"><a class="markdownIt-Anchor" href="#111-操作系统的直观认识"></a> 1.1.1 操作系统的直观认识</h3>
<p>操作系统提供以下几种直观功能：</p>
<ul>
<li>提供操作界面，用户可以利用一些可视化的元素来操作计算机，展示计算机的执行结果。</li>
<li>控制程序运行，利用图形化或命令行的方式启动一个程序、结束一个程序、强制结束没有响应的程序等。</li>
<li>管理系统资源，用户可以更新驱动程序或安装新的驱动、卸载不再需要的设备，访问打印机、硬盘等资源。</li>
<li>配置系统参数，设置或改变系统参数。</li>
<li>监控系统状态，通过任务管理器等可以观察系统的实时工作情况。</li>
<li>工具软件集合，提供用于系统管理的辅助工具和内置命令便于用户进行个性化配置、调优或测试。</li>
</ul>
<h3 id="112-操作系统的定义"><a class="markdownIt-Anchor" href="#112-操作系统的定义"></a> 1.1.2 操作系统的定义</h3>
<p>操作系统是一个大型的系统程序，它<font color=red>管理和分配计算机系统中软、硬件资源</font>，控制和协调并发活动，<font color=red>为用户提供接口</font>和良好的工作环境。</p>
<h2 id="12-操作系统的发展历史"><a class="markdownIt-Anchor" href="#12-操作系统的发展历史"></a> 1.2 操作系统的发展历史</h2>
<h3 id="121-手动操作阶段"><a class="markdownIt-Anchor" href="#121-手动操作阶段"></a> 1.2.1 手动操作阶段</h3>
<p>即电子管时代（1946-1955），此时没有操作系统，一个程序需要程序员通过打孔的方式写在纸带上，然后将纸带装入到设备中，启动输入设备将程序和数据输入到计算机内存中，然后控制台开关启动程序开始处理数据。整个过程中计算机被一个程序员占用。</p>
<p>特点：用户独占、缺少交互、效率低下（如运行一次程序可能需要提前几十分钟将设备全部装好，运行完之后还需要几十分钟将设备全部拆卸）</p>
<h3 id="122-单道批处理系统"><a class="markdownIt-Anchor" href="#122-单道批处理系统"></a> 1.2.2 单道批处理系统</h3>
<p>即晶体管时代（1955-1965）。单道批处理能够控制计算机自动处理一批作业，逐个加载、运行和撤出其中的每一个作业，直到全部作业处理完毕。批处理系统的特点：<font color=red>成批、自动、单道</font>。缺点是平均周转时间长、无交互能力。</p>
<p>单道批处理系统两种实现方式：<font color=red>联机批处理系统和脱机批处理系统</font>。联机批处理系统的输入输出过程都由主机控制，主机和输入设备之间添加一个磁带作为存储设备。运行于主机上的监督程序控制成批地将输入机上的用户作业读入磁带并形成作业队列，然后依次将磁带上的用户作业逐个装入主机运行并将结果输出到输出机，直到该批作业完成。脱机批处理系统增加一台与主机不直接相连而专门用于输入输出的卫星机，主机的作用是利用批处理方式自动按批处理磁带上的作业并将结果存放到输出磁带上。</p>
<h3 id="123-多道批处理系统"><a class="markdownIt-Anchor" href="#123-多道批处理系统"></a> 1.2.3 多道批处理系统</h3>
<p>集成电路时代（1965-1980），多道批处理系统利用多道程序处理技术，在内存中存放多道程序，当某道程序因为某种原因不能继续运行时监控程序会调度另一个程序运行，使得CPU尽量处于忙碌状态。多道批处理系统可以让CPU与外设，外设与外设之间处于并行状态。缺点是作业处理时间长，运行过程不确定，交互能力差。</p>
<h3 id="124-分时操作系统"><a class="markdownIt-Anchor" href="#124-分时操作系统"></a> 1.2.4 分时操作系统</h3>
<p>60年代中断技术的出现、80年代后大规模集成电路的出现、事务性程序和任务的出现允许CPU进行更加复杂的作业调度。现在的操作系统要求能够进行多任务多用户的调度。主机采用分时技术轮流为每一个终端服务，每一个终端都认为自己独占了整台计算机。</p>
<p>主机<font color=red>以很短的时间片为单位将CPU循环地轮流分配给每一个作业使用</font>，直到全部作业运行完毕。时间片是较短的时间间隔，使得主机的响应时间较短。分时系统的特点：多路调制性、独占性（用户认为独占计算机）、交互性（能够及时响应用户请求）</p>
<h3 id="125-分时操作系统衍化"><a class="markdownIt-Anchor" href="#125-分时操作系统衍化"></a> 1.2.5 分时操作系统衍化</h3>
<ul>
<li>微型计算机操作系统</li>
<li>实时操作系统（可靠性、安全性、强调作业完成时限和可预测性）
<ul>
<li>硬实时系统：必须按时完成</li>
<li>软实时系统：尽量按时完成</li>
</ul>
</li>
<li>嵌入式操作系统</li>
<li>网络操作系统</li>
<li>分布式操作系统</li>
</ul>
<h2 id="13-操作系统的功能"><a class="markdownIt-Anchor" href="#13-操作系统的功能"></a> 1.3 操作系统的功能</h2>
<h3 id="131-处理机管理"><a class="markdownIt-Anchor" href="#131-处理机管理"></a> 1.3.1 处理机管理</h3>
<p>处理机是计算机系统的核心资源，处理机管理即为进程管理或CPU管理。一个操作系统应该能够进行<font color=red>进程控制、进程同步、进程通信与进程调度</font>。</p>
<ul>
<li>进程控制：为一个作业创建一个或多个进程，并分配必要的资源。进程运行结束后应该撤销该进程并回收该进程占用的各种资源。主要功能是为作业创建进程、撤销已经结束的进程。</li>
<li>进程同步：保证进程之间有条不紊地进行，协调多个进程之间的运行。</li>
<li>进程通信：用于合作进程之间交换信息，操作系统使用合适的机制完成信息传输。</li>
<li>进程调度：操作系统需要根据某种策略选择合适的进程占用CPU。</li>
</ul>
<h3 id="132-存储管理"><a class="markdownIt-Anchor" href="#132-存储管理"></a> 1.3.2 存储管理</h3>
<p>操作系统需要能够合理调度内存，内存管理需要支持多道程序设计，包含<font color=red>内存分配、内存共享、内存保护、地址映射和虚拟存储</font>。</p>
<ul>
<li>内存分配：程序运行需要将其存放在内存中，在程序运行前和运行时需要为其分配一定大小的内存。</li>
<li>内存共享：允许多道程序存放在内存中，实现内存的共享。另外实现多个进程共用一块内存空间，如dll文件所在的内存。</li>
<li>内存保护：保证进程在自己的内存空间中运行而不互相干扰，需要检查进程对内存的访问是否越界或越权。</li>
<li>地址映射：操作系统提供地址映射机构将进程地址空间的逻辑地址转化为内存空间对应的物理地址，地址映射可以使用户不必关心物理存储空间的分配细节。</li>
<li>虚拟存储：内存扩充功能，避免因为物理内存太小而导致大型程序无法运行或限制了多个进程的并发运行。实现了物理内存在逻辑上进行扩充，在不增加物理内存的情况下使用虚拟存储技术获得内存扩充的效果。</li>
</ul>
<h3 id="133-设备管理"><a class="markdownIt-Anchor" href="#133-设备管理"></a> 1.3.3 设备管理</h3>
<p>操作系统不能让用户直接使用这些设备，这会使得用户的使用变得困难，因此操作系统需要使用合适的方式为进程分配这些资源，提高CPU和设备的使用率。操作系统<font color=red>提供统一规范的接口给应用程序使用</font>，完成进程对设备的输入输出请求并方便用户添加新设备或删除旧设备。</p>
<ul>
<li>分配设备：为申请设备的进程分配设备，记录设备的使用情况。</li>
<li>设备控制：通过合适的方式完成设备与CPU之间的数据传输。</li>
<li>设备映射：使用所谓的逻辑设备而不是物理设备，可以极大提高程序的灵活性、可移植性和可阅读性。用户可以使用友好名和不同的配置选项选择一个逻辑设备。</li>
<li>缓冲区管理：提高CPU的利用率，提高系统吞吐量，在内存中设置缓冲区并对缓冲区中的读写更新等操作进行有效管理以获得更好的系统性能。</li>
</ul>
<h3 id="134-文件管理"><a class="markdownIt-Anchor" href="#134-文件管理"></a> 1.3.4 文件管理</h3>
<p>操作系统需要实现按名存取文件和目录，并向用户提供一条存取文件和目录的标准操作接口。除了基本的文件操作（如读写复制删除等）还需要实现文件的共享、保护和保密，保证文件的安全性和不被越权访问。</p>
<h2 id="15-操作系统评价指标"><a class="markdownIt-Anchor" href="#15-操作系统评价指标"></a> 1.5 操作系统评价指标</h2>
<ul>
<li>吞吐量：系统在单位时间内处理信息的能力或可以处理的任务数量。是用于衡量系统性能的重要指标。操作系统合理分配和调度资源可以提高系统的吞吐量。</li>
<li>响应能力：表现为系统从接收数据到输出结果的时间间隔长短，时间间隔越长说明响应能力越差。系统响应时间与用户数量和时间片的大小有关。用户数量越多响应时间越长，时间片越短响应时间越短。</li>
<li>资源利用率：设备在单位时间内被利用的百分比。</li>
<li>可移植性：改变硬件环境，操作系统仍能正常工作的能力。一般在新的硬件环境中需要改写或增加一些代码来使得操作系统能够在新的环境下工作，这个修改工作中的<font color=red>代码修改量</font>越少说明可移植性越好。</li>
<li>可靠性：即系统发生错误的概率大小和操作系统发现、诊断和恢复系统故障能力的大小。错误率越小可靠性越高。</li>
</ul>
<h2 id="17-操作系统的逻辑结构"><a class="markdownIt-Anchor" href="#17-操作系统的逻辑结构"></a> 1.7 操作系统的逻辑结构</h2>
<h3 id="171-整体式结构"><a class="markdownIt-Anchor" href="#171-整体式结构"></a> 1.7.1 整体式结构</h3>
<p>整体式结构又称为模块化结构或宏内核结构，操作系统的常用设计模式和应用软件的基本设计模式。以模块为基本单位进行构建，系统中每一个过程都有明确的入口参数列表和返回值列表，大多数过程可以相互调用不受约束。如UNIX系统、Linux系统的单体内核。<br />
优点：模块设计、编码和调试独立，模块之间可以自由调用<br />
缺点：错误容易扩散，开发和维护困难，可伸缩性差</p>
<h3 id="172-层次式结构"><a class="markdownIt-Anchor" href="#172-层次式结构"></a> 1.7.2 层次式结构</h3>
<p>层次式结构将操作系统中所有功能模块按照调用次序分别排成若干层，确保各层之间只能单向依赖或单向调用。分层原则主要：</p>
<ul>
<li>硬件相关放在最底层</li>
<li>与用户策略和交互有关的放在最顶层</li>
<li>中间各层按照调用次序或消息传递顺序安排</li>
<li>共性的和活跃的服务放在较低的层次</li>
</ul>
<p>优点：结构清晰、整体问题局部化、有利于维护扩充和移植。</p>
<h3 id="173-微内核结构"><a class="markdownIt-Anchor" href="#173-微内核结构"></a> 1.7.3 微内核结构</h3>
<p>微内核结构又称为客户-服务机结构，分为两个部分：微内核和核外服务器。微内核足够小，只提供最基本的OS核心功能和服务，核外服务器完成OS绝大部分功能，等待客户提出请求。如Harmony-OS、Windows-NT（分层结构+微内核）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC6%E7%AB%A0%E4%B9%A0%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC6%E7%AB%A0%E4%B9%A0%E9%A2%98/" class="post-title-link" itemprop="url">计算机组成原理——第6章习题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-03 00:02:25 / Modified: 00:05:10" itemprop="dateCreated datePublished" datetime="2023-03-03T00:02:25+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="61"><a class="markdownIt-Anchor" href="#61"></a> 6.1</h3>
<ul>
<li>指令周期：一条指令从取出到执行完成所需要的时间。</li>
<li>数据通路：数据在各功能部件之间传送的路径。</li>
<li>机器周期：将指令周期划分为多个机器周期（又称CPU周期）。</li>
<li>时钟周期：每个机器周期包含若干个时钟周期。</li>
</ul>
<h3 id="62"><a class="markdownIt-Anchor" href="#62"></a> 6.2</h3>
<ol>
<li>B</li>
<li>B<br />
三个寄存器都是通用寄存器，因此需要通用寄存器组。加法运算需要使用算数逻辑单元。寻址需要向存储器中获取数据。指令译码器不是在取数和执行过程中使用的，译码发生在取数之前。</li>
<li>B<br />
主存空间为4GB，字长32位，因为指令按字边界对齐保存，所以PC至少为30位，指令寄存器IR的位数至少为32位，它是用来保存当前指令的内容的。</li>
<li>D<br />
A正确，B正确，C正确，时钟周期不能太短，D错误，一条指令可能需要不止一个时钟脉冲信号完成（多周期处理器），因此不是所有的时钟脉冲信号都开始执行一条新的指令。</li>
<li>A<br />
A错误，因为单总线结构数据通路无法让某些指令在一个时钟周期内完成。应该采用专用数据通路结构。B正确，要想在一个时钟周期之内完成一条指令的联系，因此一个时钟周期需要时间稍长一些，其时长取决于执行速度最慢的指令。C正确，在指令执行过程中控制信号不变。D正确，每个时钟周期执行一条指令，故CPI=1。</li>
<li>B<br />
A正确。B错误，CS在CPU内部，存放的是微指令，按照微指令地址进行访问。C正确。D正确。</li>
<li>D<br />
硬布线控制器的指令执行速度快，指令功能的修改和扩展难。</li>
<li>C</li>
<li>C</li>
<li>C</li>
</ol>
<h3 id="63"><a class="markdownIt-Anchor" href="#63"></a> 6.3</h3>
<ol>
<li>CPU的基本功能有程序控制、操作控制、时序控制、数据加工、中断处理。</li>
<li>CPU内部有：</li>
</ol>
<ul>
<li>IR寄存器保存当前执行的指令的内容</li>
<li>PC寄存器保存将要执行指令的字节地址</li>
<li>AR存储器地址寄存器保存CPU访问主存的单元地址</li>
<li>DR存储器数据寄存器保存从主存中读取或将向主存写入的数据</li>
<li>GR通用寄存器组</li>
<li>PSW保存由运算指令创建的各种条件标志</li>
</ul>
<p>其中GR、PSW是程序员可见的，AR、DR、IR不是必需的。<br />
3. 取指周期是从开始取指令到取指令完成的一段周期，完成的操作：访问PC指定的主存地址处的指令，形成后续指令地址。<br />
4. 计算机设计时序系统的原因是指令执行过程中的所有操作必需遵守严格的顺序，对操作的开始时间和持续时间有严格的控制，以保证指令的正确执行。机器周期是指主存取出一条指令的最短时间。<br />
5. 传统三级时序采用时钟周期、节拍电位和节拍脉冲来对操作控制信号进行定时控制，其中状态周期用电位来表示当前处于指令执行的哪个机器周期，节拍电位用电位表示当前处于机器周期的第几个节拍。采用三级时序的好处是可以简化控制器的设计。完成了时序发生器的设计后，所有控制信号都是状态周期电位、节拍电位、指令译码信号、状态反馈信号的组合逻辑。<br />
现代时序系统的定时信号就是基本时钟，一个时钟周期就是一个节拍，指令需要多少个时钟周期就分配多少个时钟周期。其采用有限状态机来描述指令的执行过程，将不同指令执行的每个时钟周期均对应一个状态，每一个状态会对应特定的微操作控制信号。控制器的核心模块是有限状态机，由一个状态寄存器和有限状态机组合逻辑控制单元构成。有限状态机组合逻辑控制单元的输入包括现态、指令的译码信号和反馈信号，输出为次态，送入状态寄存器输入端，在时钟信号的作用下输入状态寄存器中，作为下一时刻的现态；所有操作控制信号的输出都只与现态有关。<br />
6. 略<br />
7. 组合逻辑控制器又称微程序控制器，控制器由各种类型的逻辑门电路和触发器构成，与微程序控制器相比，组合逻辑控制器具有结构复杂但速度快的特点，但指令功能修改和扩展较难。<br />
微程序控制器的设计采用存储技术和程序设计技术，使复杂的控制逻辑得到简化，计算机通过读出存放在微程序控制器中微指令产生指令执行过程中所需要的控制信号，与硬布线控制器相比速度较慢。<br />
8. 微程序是多条微指令的集合，用于实现指令的功能，属于机器指令级别，对用户透明，存放在CPU内的控制存储器中；程序则是为了完成某一应用功能所编写的指令（包括机器语言指令或高级语言指令）集合，运行时存放在计算机的主存中。<br />
指令是指挥计算机执行某种功能的命令，是构成程序的基本单位，由操作码和地址字段构成；而微指令则用于微程序控制器中产生指令执行过程中所需要的微指令，是构成微程序的基本单位，由操作控制字段、判别测试字段和下址字段等组成。<br />
9. 微指令编码方法有直接表示法、编码表示法和混合表示法3种。<br />
10. 微程序控制器设计方法：</p>
<ul>
<li>分析指令执行的数据通路，列出每一条指令在所有寻址方式下的执行操作流程和每一步需要的控制信号。</li>
<li>对指令的操作流程进行细化，将每条指令的每个微操作分配到具体机器周期的各个时间节拍信号上。</li>
<li>以时钟周期为单位，构建指令执行状态图。</li>
<li>设计微指令格式、微命令编码方法。</li>
<li>根据指令执行状态图编制每条指令的微程序，按照状态机组织微程序并存放到控制寄存器中。</li>
<li>根据微程序组织方式构建微程序控制器中的地址转移逻辑、微地址寄存器、控制存储器之间的通路，实现微程序控制器。</li>
</ul>
<p>硬布线控制器设计方法：</p>
<ul>
<li>分析指令执行的数据通路，列出每条指令在所有寻址方式下的执行操作流程和每一步需要的控制信号。</li>
<li>对指令的操作流程细化，将每条指令的每个微操作分配到具体机器周期的具体时间节拍信号上，即对操作控制信号进行同步控制。</li>
<li>根据控制信号同步控制方式构造合适的时序发生器。</li>
<li>对每一个控制信号进行逻辑综合，得到每个控制信号的逻辑表达式。</li>
<li>采用逻辑门、PLA或ROM实现逻辑表达式的功能。</li>
</ul>
<ol start="11">
<li>略</li>
<li>略</li>
<li>略</li>
</ol>
<h3 id="64"><a class="markdownIt-Anchor" href="#64"></a> 6.4</h3>
<ol>
<li>观察到d旁边有一个+1，推断其是PC。d有箭头指向c，c有箭头指向主存，因此推断c为AR，故a为DR，b为IR。</li>
<li>取指阶段：PC→AR→主存M→DR→IR；PC++<br />
执行阶段：IR(A)→AR→主存M→DR→AC</li>
</ol>
<h3 id="65"><a class="markdownIt-Anchor" href="#65"></a> 6.5</h3>
<p>略</p>
<h3 id="66"><a class="markdownIt-Anchor" href="#66"></a> 6.6</h3>
<ol>
<li>当RegWrite出现恒0故障时，寄存器组全部不可写，因此会导致所有需要写回寄存器的指令故障。当RegWrite出现恒1故障时，寄存器组全部可写，会导致所有不需要写回寄存器的指令故障。</li>
<li>RegDst出现恒0故障时，写入寄存器的编号无法传入，导致所有需要写回rd的指令出现故障（无法写回）。RegDst出现恒1故障时，会错误地传入rd寄存器编号，所有需要写回rt的指令会出现故障（选择写入的寄存器不是rt而错误地变成了rd）。</li>
<li>MemWrite出现恒0故障时，数据存储器全部不可写，所有需要写存的指令会出现故障。MemWrite出现恒1故障时，所有不需要写存的指令会引起写存故障。</li>
</ol>
<h3 id="67"><a class="markdownIt-Anchor" href="#67"></a> 6.7</h3>
<p>略</p>
<h3 id="68"><a class="markdownIt-Anchor" href="#68"></a> 6.8</h3>
<p>略</p>
<h3 id="69"><a class="markdownIt-Anchor" href="#69"></a> 6.9</h3>
<p>略</p>
<h3 id="610"><a class="markdownIt-Anchor" href="#610"></a> 6.10</h3>
<p>对于单总线CPU，数据通路的最小时钟周期必须大于T<sub>clk_to_q</sub>+T<sub>max</sub>+T<sub>setup</sub>，即180ps。最大频率为5.56GHz。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC5%E7%AB%A0%E4%B9%A0%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC5%E7%AB%A0%E4%B9%A0%E9%A2%98/" class="post-title-link" itemprop="url">计算机组成原理——第5章习题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-03 00:02:13 / Modified: 00:05:10" itemprop="dateCreated datePublished" datetime="2023-03-03T00:02:13+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="52"><a class="markdownIt-Anchor" href="#52"></a> 5.2</h3>
<ol>
<li>A<br />
三地址指令29条，需要18位作为地址和至少5位作为地址码。二地址指令107条，需要12位作为地址和至少7位作为地址码。指令字长至少应该是24（按照字节编址）</li>
<li>A<br />
寄存器直接寻址需要4位寄存器标号，基址寻址也需要4位寄存器标号，剩余16位可用于表示偏移量，使用补码表示则范围为-32768~32767。</li>
<li>A<br />
16位定长指令，48条指令至少需要6位指令码，4种寻址方式需要2位标识，剩余8位可寻址范围为0~255。</li>
<li>C</li>
<li>C</li>
<li>A</li>
<li>D</li>
<li>D</li>
<li>D<br />
注意本题为大端序，LSB位于高地址处。</li>
<li>B</li>
<li>C<br />
无符号整数大于则ZF=0，CF=0。</li>
<li>A</li>
<li>略</li>
</ol>
<h3 id="53"><a class="markdownIt-Anchor" href="#53"></a> 5.3</h3>
<ol>
<li>指令是用户使用计算机与计算机本身运行的基本功能单位。指令系统是计算机系统性能的几种体现，是计算机软、硬件的设计基础。</li>
<li>计算机设计多种操作数寻址方式是为了提升寻址的灵活性，同时可以在一定程度上减少地址寻址所使用的指令位数。</li>
<li>作为寻址方式字段给出。</li>
<li>基址寻址面向系统，用于程序的重定位和扩展程序空间。变址寻址面向用户，主要解决程序循环问题。二者在计算有效地址的方式上相似，但基址寄存器的基址值一般不变且形式地址表示的偏移量位数较短，偏移范围较小；而变址寄存器的值可以改变，偏移量位数足以表示整个存储空间。</li>
<li>略</li>
<li>定长指令便于机器解码执行，结构规整，有利于设计硬件，但不容易扩展。变长指令灵活，但不易解码。</li>
<li>指令的地址码指的是指令中用于寻址的地址值，通常指定操作数的地址，地址码的字段的作用随着指令类型和寻址方式的不同而不同。指令中的操作码用于区分不同功能的指令，标识指令的种类。</li>
</ol>
<h3 id="54"><a class="markdownIt-Anchor" href="#54"></a> 5.4</h3>
<ol>
<li>立即数</li>
<li>直接</li>
<li>寄存器</li>
<li>寄存器间接</li>
</ol>
<p>注：寻址方式区分技巧<br />
需要两次找其他值的是间接。间接寻址指的是操作数地址的地址在主存，寄存器间接寻址指的是操作数地址在寄存器，前一个需要两次访问主存，后一个需要首先访问寄存器再访问主存。</p>
<h3 id="55"><a class="markdownIt-Anchor" href="#55"></a> 5.5</h3>
<ol>
<li>操作数地址码由寻址方式字段和寄存器号字段组成。16个通用寄存器需要4位标识，8种寻址方式需要3位标识，剩余字段数量为9位，故单操作数指令最多为512条。</li>
<li>4条。</li>
<li>0~7，对于直接寻址，应该是使用寻址方式这3位来寻址。</li>
<li>变址寻址考虑到寄存器16位，因此寻址范围为2<sup>16</sup>个字即64KW。</li>
</ol>
<h3 id="56"><a class="markdownIt-Anchor" href="#56"></a> 5.6</h3>
<ol>
<li>若操作码字段不固定，已经设计出m条双操作数指令，n条无操作数指令。对于双操作数指令，有4位可用于标识指令码，现在已经设计了m条，还剩下16-m种前4位的组合可以用于单操作数指令和无操作数指令。对于单操作数指令，有10位可用于标识指令码，去除前4位，不管无操作数指令，可知单操作数指令对于指令前10位一共有(16-m)×64种组合可用。还需要考虑到无操作数指令，无操作数指令全部16位都可以用于标识指令码，则前10位的一种组合可设计64条无操作数指令，那么n条无操作数指令一共需要占用单操作数指令前10位组合中的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mfrac><mi>n</mi><mn>64</mn></mfrac><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil\frac{n}{64}\rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌉</span></span></span></span>种组合，故单操作数指令一共可以设计<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>16</mn><mo>−</mo><mi>m</mi><mo stretchy="false">)</mo><mo>×</mo><mn>64</mn><mo>−</mo><mo stretchy="false">⌈</mo><mfrac><mi>n</mi><mn>64</mn></mfrac><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">(16-m)\times 64-\lceil\frac{n}{64}\rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.095em;vertical-align:-0.345em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌉</span></span></span></span>条。</li>
<li>双操作数指令取最大数为15，因为要留出一种前4位的组合给单操作数指令和无操作数指令，单操作数指令取最大数为63，因为要留出一种前10位的组合给无操作数指令。此时无操作数指令最多只能设计64条。</li>
</ol>
<h3 id="57"><a class="markdownIt-Anchor" href="#57"></a> 5.7</h3>
<ol>
<li>290-256-3=31，转移指令第二个字节为0x1F，第三个字节为0。</li>
<li>110-128-3=-31，转移指令第二个字节为0xE1，第三个字节为0xFF。</li>
</ol>
<h3 id="58"><a class="markdownIt-Anchor" href="#58"></a> 5.8</h3>
<ol>
<li>4420H=0100 0100 0010 0000=010001 00 00100000，寻址方式为直接寻址，形式地址为0x20，有效地址为0x20。</li>
<li>2244H=0010 0010 0100 0100=001000 10 01000100，寻址方式为变址寄存器X2变址，形式地址为0x44，有效地址为0x1122+0x44=0x1166。</li>
<li>1322H=0001 0011 0010 0010=000100 11 00100010，寻址方式为相对寻址，形式地址为0x22，有效地址为0x1234+2+0x22=0x1258。</li>
<li>3521H=0011 0101 0010 0001=001101 01 00100001，寻址方式为变址寄存器X1变址，形式地址为0x21，有效地址为0x37+0x21=0x58。</li>
</ol>
<h3 id="59"><a class="markdownIt-Anchor" href="#59"></a> 5.9</h3>
<ol>
<li>增加的32条指令中的前6位不能与原来的60条指令中的任意一条的前6位相等，否则会冲突，因此这32条指令的前6位只有4种可能的值，每一种可能的值需要设计8条指令，因此扩展操作码总共9位，这32条指令的操作码为111100000~111111111。</li>
<li>平均长度为(60×6+32×9)/92≈7.04。</li>
</ol>
<h3 id="510"><a class="markdownIt-Anchor" href="#510"></a> 5.10</h3>
<p>add $s0, $a1, $t7。</p>
<h3 id="511"><a class="markdownIt-Anchor" href="#511"></a> 5.11</h3>
<p>略</p>
<h3 id="512"><a class="markdownIt-Anchor" href="#512"></a> 5.12</h3>
<ol>
<li>最多有16条指令，该计算机最多有8个通用寄存器。</li>
<li>16位，因为主存空间128KB，含64KW。</li>
<li>0~2<sup>16</sup>-1</li>
<li>0010 0011 0001 0101=2315H。</li>
</ol>
<h3 id="513"><a class="markdownIt-Anchor" href="#513"></a> 5.13</h3>
<p>略</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC4%E7%AB%A0%E4%B9%A0%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E7%AC%AC4%E7%AB%A0%E4%B9%A0%E9%A2%98/" class="post-title-link" itemprop="url">计算机组成原理——第4章习题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-03 00:02:09 / Modified: 00:05:10" itemprop="dateCreated datePublished" datetime="2023-03-03T00:02:09+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">计算机组成原理</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>5k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>5 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="41"><a class="markdownIt-Anchor" href="#41"></a> 4.1</h2>
<ul>
<li>存取时间：存取器的访问时间，指一次存储器操作到该操作完成所经历的时间。读写时间可能不同。</li>
<li>存取周期：连续两次启动访问操作之间的最短时间间隔。</li>
<li>存储器带宽：单位时间内存储器能够传输的信息量，注意<font color=red>不能理解为存储器一个存储单元能够存储的比特位数，存储器带宽指的是速度，与网络带宽可以类比</font>。</li>
<li>存储单元：存储器中的最小存储单位。也称为存储元。</li>
<li>边界对齐的数据存放：按照数据类型的大小进行边界对齐。不同数据类型的变量都会包含一个或多个字节单元，这些变量在进行主存地址空间分配时从理论上讲可以从任何字节地址开始，但当一个多字节变量分布在不同的字存储单元时，访问该变量就需要多个存储周期，为了提高访问效率对数据进行边界对齐存放。</li>
<li>大端存储：数据的高位位于地址的低位。</li>
<li>小端存储：数据的低位位于地址的低位。</li>
<li>静态存储器：存储体以静态存储元构成的存储器。</li>
<li>动态存储器：存储体以动态存储元构成的存储器。</li>
<li>刷新：在动态存储器中，由于存储元内部构造问题，数据只能保持较短的时间，为避免数据丢失需要定期采用类似读操作的方式对存储单元补充电荷，称为刷新。</li>
<li>刷新周期：动态存储器连续两次刷新的时间间隔。</li>
<li>字扩展：为增加存储器存储容量增加一个字的比特数量的扩展方式，又称为容量扩展或地址总线扩展。</li>
<li>位扩展：增加存储器可寻址的范围，而不改变字长的扩展方式。</li>
<li>高速缓冲存储器：为进一步提升CPU的性能在CPU和内存之间添加的小块SRAM。</li>
<li>相联存储器：一种按内容访问的存储器，用于存放查找表，其内部存储数据的基本单位是键值对。</li>
<li>时间局部性：同一块地址的存储数据如果在一个时刻被访问，那么在这个时刻未来的短时间内很有可能还会被访问。</li>
<li>地址映射：将主存地址映射到cache的地址空间，将存放在主存中的程序或数据块载入cache块的规则。<font color=red>注意这里的地址映射指的不是虚拟地址与内存物理地址的映射</font>。</li>
<li>直接相联映射：每一个主存块地址只能被映射到cache中固定的行。</li>
<li>全相联映射：每一个主存块地址可以被映射到cache中的任意行。</li>
<li>组相联映射：每一个主存块地址可以被映射到cache中的某些行。</li>
<li>命中率：主存访问时能够通过cache访问成功的概率。</li>
<li>虚拟存储器：包含虚拟地址空间、主存地址空间和辅存地址空间，将虚拟地址空间映射到主存空间，建立虚地址和实地址之间的对应关系。可便于编程、解决主存容量不足的问题。</li>
<li>页框号：主存地址空间中的一页空间的编号。</li>
<li>页表（慢表）：一张保存虚拟页号和物理页号对应关系的查找表。</li>
<li>页表项：页表中的一条记录。</li>
<li>TLB（快表）：转换旁路缓冲区，用于缓冲经常访问的页表项，本质是一个容量较小的cache，可以提高页表的查找速度。</li>
<li>LRU算法：近期最少使用算法，淘汰最久远使用的项。</li>
<li>LFU算法：最不经常使用算法。</li>
<li>cache一致性：cache中的数据需要与对应地址的主存数据相同。</li>
<li>写回法：写cache时不同时修改主存的内容，每一个cache行必须设置一个脏位判断该位是否被修改。某行被换出时根据脏位决定是否需要更新主存。</li>
<li>写穿法：写cache的同时写主存。</li>
</ul>
<h3 id="42"><a class="markdownIt-Anchor" href="#42"></a> 4.2</h3>
<ol>
<li>A<br />
分析：RAM是易失性存储器，ROM是非易失性存储器，正确。RAM作为随机存储器一般用于内存等，只有在上电时才能够保存数据，而ROM作为只读存储器，其内容是在烧录时写死的，即使掉电也不会丢失数据。RAM和ROM都可以使用随机存取方式进行信息访问，正确。ROM不能用于cache，且不需要刷新。</li>
<li>A<br />
分析：DRAM芯片为4M×8位，一块芯片容量为4MB，存储器容量为256MB，故一共有64块芯片。假设其为位扩展，一块芯片有4M个字，故地址线宽度为11位。数据引脚为8位。注意<font color=red>DRAM地址线一般采用复用技术，即CPU分时传送行、列地址，并分别由行选通信号RAS和列选通信号CAS连通</font>。原本4M需要22位地址才能寻址，但将其看做一个矩阵，行和列都只有2<sup>11</sup>行，因此复用只需要11位地址线。</li>
<li>D<br />
4KB的ROM需要2块ROM芯片，4K×4的RAM芯片一块只能存储2KB，因此需要30块。</li>
<li>D<br />
需要进行字位扩展，将字长从4比特扩展为8比特，一共需要8个芯片，分为4组，一组两个进行位扩展。第2组可以寻址0800H~0FFFH的地址，其最小地址为0800H。</li>
<li>C<br />
为了保证其地址引脚数量最少，行数与列数的最大值需要尽可能小，2K=32×64，因此可以选择32行64列或64行32列，又需要考虑减少刷新开销，因此行数应该尽可能少，选择32行64列。</li>
<li>B<br />
工作频率1333MHz，即每秒可以访存1333M次，总线宽度64位，一次访存可获得8字节数据。又因为采用的是3通道地址总线，因此总带宽为1333M×3×8 B/s=32GB/s。</li>
<li>D</li>
<li>B</li>
<li>B<br />
注意CDROM指的是光盘，是顺序存储。</li>
<li>A</li>
<li>A</li>
<li>C<br />
cache有16块用2路组相联，因此一共有8组，一组32B，因此主存第129号单元所在的主存块应该位于第4组。</li>
<li>C</li>
<li>C<br />
分析：主存块大小4个字，一个字32位，能存放4K字数据，就有1K行，每一行保存的信息有：直接相联映射应该主存映射地址的区地址18位1个字，4个字的数据。考虑到采用写回的方式，需要1位有效位和1位脏位，一行一共有18+128+2=148位数据，1K行就有148K位。本题易错点：<font color=red>求的是位数不是字数，写回方式有脏位，直接相联映射应该保存地址的多少位</font>。</li>
<li>D</li>
<li>B<br />
分析：采用页式存储管理方式，且有TLB，那么该指令首先需要访问x处的数据。首先访问TLB，如果TLB命中，则物理地址已知，然后访问cache。如果cache命中，则写cache，同时需要写主存，这个过程访存次数为1（注意TLB和cache不属于主存）。不妨可以另外计算最多需要多少次访问主存：如果TLB没有命中，那么首先需要访问主存中的页表（假设为一级页表），获取物理地址之后到cache中查找没有找到，还需要从主存中调入这部分数据到cache，然后写cache写主存，一共访存3次。</li>
<li>D<br />
cache就是主存中内容的部分复制，cache如果命中page一定会命中。</li>
<li>A</li>
<li>D<br />
缺页中断处理完成之后应该重新执行触发缺页中断的那条指令。</li>
</ol>
<h3 id="43"><a class="markdownIt-Anchor" href="#43"></a> 4.3</h3>
<ol>
<li>采用层次化体系可以在提高CPU的性能同时最大限度地降低成本。</li>
<li>用于进行位扩展。</li>
<li>其中的数据不稳定，长时间不刷新会丢失。进行一次类似读操作让其电容重新充电。</li>
<li>略</li>
<li>cache对程序员不可见。</li>
<li>因为直接相联映射规定一块主存地址只能被映射到唯一的一个cache行，如果映射时产生冲突直接换掉即可。</li>
<li>防止cache与主存中数据不一致问题。</li>
<li>略</li>
</ol>
<h3 id="44"><a class="markdownIt-Anchor" href="#44"></a> 4.4</h3>
<p>32KB容量按照16位字编址则有16K个字，地址寄存器应为14位，数据寄存器为16位。</p>
<h3 id="45"><a class="markdownIt-Anchor" href="#45"></a> 4.5</h3>
<p>可以设计出32K×32位、64K×16位、128K×8位。图略。</p>
<h3 id="46"><a class="markdownIt-Anchor" href="#46"></a> 4.6</h3>
<p>256K×8位存储器中最高64KB为只读，低192KB可读可写，因此考虑使用6片32K×8位RAM位扩展加2片64K×4位字扩展。</p>
<h3 id="47"><a class="markdownIt-Anchor" href="#47"></a> 4.7</h3>
<p>128K字中最高32K字只读，低96K字可读可写，考虑使用12片16K×8位静态RAM芯片进行字位扩展，1组2片共6组；加2片16K×16位ROM芯片进行位扩展。</p>
<h3 id="48"><a class="markdownIt-Anchor" href="#48"></a> 4.8</h3>
<p>DRAM是时分复用的地址线，64K=256×256，即一共有256行，每个芯片需要在2ms之内将这256行全部刷新至少一次，按照异步刷新的规则，间隔时间应该为2ms/256=7.8125μs。<br />
如果采用集中刷新方式，则存储器刷新一次需要使用256个读写周期，CPU的“死”时间为0.5×256=128ms。</p>
<h3 id="49"><a class="markdownIt-Anchor" href="#49"></a> 4.9</h3>
<p>DRAM芯片时分复用，有256行256列，故地址线输入需要8个引脚，数据线1个引脚，加上读写标志2个引脚，共11个。</p>
<h3 id="410"><a class="markdownIt-Anchor" href="#410"></a> 4.10</h3>
<p>异步刷新。<br />
16K=128×128，刷新周期为2ms/128=15.625μs。</p>
<h3 id="411"><a class="markdownIt-Anchor" href="#411"></a> 4.11</h3>
<p>cache容量为2<sup>14</sup>块，每块32位字。<br />
按照全相联映射，将这些数据按照地址顺序依次装入cache后cache的内容：<br />
000000 87568756<br />
000002 87792301<br />
004001 9ABEFCD0<br />
007FFF 4FFFFC68<br />
3FFFFE 01BF2460<br />
按照直接相联映射：<br />
00 0000 87568756<br />
01 0001 9ABEFCD0<br />
00 0002 87792301<br />
01 3FFF 4FFFFC68<br />
FF 3FFE 01BF2460<br />
按照四路组相联映射：<br />
000 000 87568756<br />
000 002 87792301<br />
001 001 9ABEFCD0<br />
001 FFF 4FFFFC68<br />
3FF FFE 01BF2460</p>
<h3 id="412"><a class="markdownIt-Anchor" href="#412"></a> 4.12</h3>
<p>主存4096×128=512K个字，地址19位。<br />
cache 64×128=8K个字，地址13位。<br />
主存地址分为3个部分，组内偏移7位，标识一个组中的128个字。组号4位，标识cache中的16个组。组标记8位，标识地址的最高8位。</p>
<h3 id="413"><a class="markdownIt-Anchor" href="#413"></a> 4.13</h3>
<p>cache容量16KB，一块8个字，每个字32位，即32B，则cache共有512行。映射方式采用4路组相联，可分为128组。<br />
CPU每一次读一个字，其中第0~7号单元应该在同一块，8~15号单元在同一块，以此类推，100个字只在第一次访问第0、8、16、…、96号单元时没有命中，共13次没有命中，共访问了1000次，没有使用LRU算法淘汰某一行，因此命中率为98.7%。<br />
若cache比主存快10倍，其访问时间就是0.1倍。设主存一次访问时间为t，则使用cache后一次访问的平均时间为t×1.3%+0.1t×98.7%=11.17%t，速度提升了8.95倍。</p>
<h3 id="414"><a class="markdownIt-Anchor" href="#414"></a> 4.14</h3>
<ol>
<li>对于第一段代码，数组访问按行优先访问，对于内存空间而言是线性按序访问，具有较好的空间局部性。但每一个数组元素只使用一次，因此对于数组元素而言没有时间局部性。第二段代码数组按照列优先访问，在内存空间中的访问是跳跃式的，因此没有很好的空间局部性，同样也不存在时间局部性。</li>
<li>在两段代码中，变量sum均被频繁访问，因此具有很好的时间局部性，由于变量sum是单个变量，与其邻近地址空间的数据没有直接关系，因此不存在空间局部性。</li>
<li>for循环体对指令访问具有时间局部性，一条指令会被循环执行多次，而for循环有多条指令，这些指令之间具备一定的空间局部性。</li>
</ol>
<h3 id="415"><a class="markdownIt-Anchor" href="#415"></a> 4.15</h3>
<p>VPN：虚拟页号数量为2GB/4KB=512M，需要29位<br />
VPO：虚拟页偏移4KB，需要12位<br />
PPN：物理页号数量为8MB/4KB=2K，需要11位<br />
PPO：物理页偏移位数与虚拟页偏移相等，12位</p>
<h3 id="416"><a class="markdownIt-Anchor" href="#416"></a> 4.16</h3>
<ol>
<li>失效的有2、3、5、7页</li>
<li>分别为3072、无效、4095、无效、3072、无效</li>
</ol>
<h3 id="417"><a class="markdownIt-Anchor" href="#417"></a> 4.17</h3>
<p>TLB采用4路组相联技术，共16项，可分为4组。cache容量16KB，每块32B，共512组，采用4路组相联，共128组。</p>
<ol>
<li>页大小为128KB，需要使用17位保存页内偏移，虚拟页号需要使用14位保存。虚拟页号中高12位表示TLB标记，低2位表示TLB索引。</li>
<li>物理地址中18位表示物理页号，14位表示偏移地址。</li>
<li>要使得物理地址与cache建立映射，cache中每一组存放32字节，行内地址偏移为物理地址的最低5位。往上7位是组索引，用于标识cache中的128组，其余的20位为组标记。</li>
</ol>
<h3 id="418"><a class="markdownIt-Anchor" href="#418"></a> 4.18</h3>
<ol>
<li>页式虚拟存储管理中一页大小8KB，需要13位表示页内偏移，虚拟地址其余的19位表示页号，即A=19。TLB采用全相联映射，因此B与A的位数相同，B=19。物理地址中高11位表示页框号，C=11。低13位表示物理地址页内偏移，D=13。cache采用二路组相联，数据区大小64KB，主存块大小64B，需要块内索引6位，G=6。cache一共有1024行，512组，需要9位标识块索引，F=H=9。剩余的9位用于物理地址块标识，E=9。B存放的是虚拟页号。</li>
<li>cache组号为4099 mod 512=3。H字段的值为4099 / 512 = 8。</li>
<li>缺页处理的开销大，因为缺页需要从辅存中调入页面，访问速度比访问主存速度慢很多。</li>
<li>提高效率。</li>
</ol>
<h3 id="419"><a class="markdownIt-Anchor" href="#419"></a> 4.19</h3>
<ol>
<li>主存的实页号共16位，页内地址12位，物理地址占28位。</li>
<li>TLB采用的是全相联映射方式，使用SRAM实现。</li>
<li>2路组相联映射。共8组，数据位32B。还需要添加脏位和1位LRU位用于标识LRU淘汰块。总容量：数据512B，tag有20×16/8=40B，脏位和有效位、LRU位3×16/8=6B，共558B。</li>
<li>首先找到tag=0008C的页框号，为0040H，那么物理地址为40040H。其tag为400，不命中（有效位为0）。虚拟地址为0007C260H时，低位页偏移为260，应该映射到第3组。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CoLin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">138</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Hornos3" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Hornos3" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_54218833?spm=1000.2115.3001.5343" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_54218833?spm&#x3D;1000.2115.3001.5343" rel="noopener" target="_blank"><i class="fa fa-crosshairs fa-fw"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CoLin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">1.2m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">18:27</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
