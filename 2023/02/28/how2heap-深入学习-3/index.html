<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hornos3.github.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="how2heap下载网址: 传送门 Glibc源码查看网址：传送门 参考书籍：CTF竞赛权威指南-pwn篇 测试环境：Ubuntu 16.04 Glibc版本：Ubuntu GLIBC 2.23-0ubuntu11.3 前两周事情比较多，暂停了pwn的复习，今天继续。 按照顺序，本文分析glibc 2_23文件夹中的第9~11个源码。  9. house_of_roman 这是一种需要进行暴力猜解">
<meta property="og:type" content="article">
<meta property="og:title" content="how2heap 深入学习(3)">
<meta property="og:url" content="http://hornos3.github.com/2023/02/28/how2heap-%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-3/index.html">
<meta property="og:site_name" content="CoLin&#39;s BLOG">
<meta property="og:description" content="how2heap下载网址: 传送门 Glibc源码查看网址：传送门 参考书籍：CTF竞赛权威指南-pwn篇 测试环境：Ubuntu 16.04 Glibc版本：Ubuntu GLIBC 2.23-0ubuntu11.3 前两周事情比较多，暂停了pwn的复习，今天继续。 按照顺序，本文分析glibc 2_23文件夹中的第9~11个源码。  9. house_of_roman 这是一种需要进行暴力猜解">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://hornos3.github.com/2023/02/28/how2heap-%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-3/1.png">
<meta property="article:published_time" content="2023-02-28T14:20:00.000Z">
<meta property="article:modified_time" content="2023-03-02T08:17:06.740Z">
<meta property="article:author" content="CoLin">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://hornos3.github.com/2023/02/28/how2heap-%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-3/1.png">

<link rel="canonical" href="http://hornos3.github.com/2023/02/28/how2heap-%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-cn'
  };
</script>

  <title>how2heap 深入学习(3) | CoLin's BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CoLin's BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/02/28/how2heap-%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          how2heap 深入学习(3)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-28 22:20:00" itemprop="dateCreated datePublished" datetime="2023-02-28T22:20:00+08:00">2023-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-02 16:17:06" itemprop="dateModified" datetime="2023-03-02T16:17:06+08:00">2023-03-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/glibc-%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">glibc 系列</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>9.4k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>9 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>how2heap下载网址: <a target="_blank" rel="noopener" href="https://github.com/shellphish/how2heap">传送门</a><br />
Glibc源码查看网址：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/glibc-2.23/source">传送门</a><br />
参考书籍：CTF竞赛权威指南-pwn篇</p>
<p>测试环境：Ubuntu 16.04<br />
Glibc版本：Ubuntu GLIBC 2.23-0ubuntu11.3</p>
<p>前两周事情比较多，暂停了pwn的复习，今天继续。<br />
按照顺序，本文分析glibc 2_23文件夹中的第9~11个源码。</p>
<h1 id="9-house_of_roman"><a class="markdownIt-Anchor" href="#9-house_of_roman"></a> 9. house_of_roman</h1>
<p>这是一种需要进行暴力猜解的漏洞，在开启PIE时仍然有效。我们来看下源码是如何操作的。</p>
<h2 id="step-1-控制__malloc_hook"><a class="markdownIt-Anchor" href="#step-1-控制__malloc_hook"></a> Step 1: 控制__malloc_hook</h2>
<p>首先创建了4个chunk，大小分别为0x70, 0x90, 0x90, 0x70。</p>
<table>
<thead>
<tr>
<th style="text-align:center">number</th>
<th style="text-align:center">size</th>
<th style="text-align:center">name</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0x70</td>
<td style="text-align:center">fastbin_victim</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">0x90</td>
<td style="text-align:center">&lt;anonymous&gt;</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">0x90</td>
<td style="text-align:center">main_arena_use</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">0x70</td>
<td style="text-align:center">relative_offset_heap</td>
</tr>
</tbody>
</table>
<p>之后将第3个chunk释放，其fd和bk指针将指向main_arena + 0x68的位置。</p>
<p>接下来再分配一个0x70大小的chunk(name: fake_libc_chunk)，分配后原先的unsorted bin会被分割一部分，剩下0x21大小仍为unsorted bin，而此时在fake_libc_chunk中已经有了main_arena + 0x68的地址了。</p>
<p>后面，依次释放relative_offset_heap和fastbin_victim。此时bins的结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x555555757000 &lt;fastbin_victim&gt; —▸ 0x555555757190 &lt;relative_offset_heap&gt;◂— 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x555555757170 &lt;main_arena_use的一部分&gt; —▸ 0x7ffff7bcdb78 (main_arena+88) ◂— 0x555555757170 /* &#x27;pquUUU&#x27; */</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<p>堆的结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Free chunk (fastbins) | PREV_INUSE</span><br><span class="line">Addr: 0x555555757000</span><br><span class="line">Size: 0x71</span><br><span class="line">fd: 0x555555757190</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x555555757070</span><br><span class="line">Size: 0x91</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x555555757100</span><br><span class="line">Size: 0x71</span><br><span class="line"></span><br><span class="line">Free chunk (unsortedbin) | PREV_INUSE</span><br><span class="line">Addr: 0x555555757170</span><br><span class="line">Size: 0x21</span><br><span class="line">fd: 0x7ffff7bcdb78</span><br><span class="line">bk: 0x7ffff7bcdb78</span><br><span class="line"></span><br><span class="line">Free chunk (fastbins)</span><br><span class="line">Addr: 0x555555757190</span><br><span class="line">Size: 0x70</span><br><span class="line">fd: 0x00</span><br></pre></td></tr></table></figure>
<p>之后，将第一个chunk的fd指针部分覆盖（覆盖最低1字节为0），那么此时第一个chunk指向的就是0x555555757100处，也就是刚分配的0x70空间的首部。此操作完成之后，堆结构变为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Free chunk (fastbins) | PREV_INUSE</span><br><span class="line">Addr: 0x555555757000</span><br><span class="line">Size: 0x71</span><br><span class="line">fd: 0x555555757100</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x555555757070</span><br><span class="line">Size: 0x91</span><br><span class="line"></span><br><span class="line">Free chunk (fastbins) | PREV_INUSE</span><br><span class="line">Addr: 0x555555757100</span><br><span class="line">Size: 0x71</span><br><span class="line">fd: 0x7ffff7bcdbf8</span><br><span class="line"></span><br><span class="line">Free chunk (unsortedbin) | PREV_INUSE</span><br><span class="line">Addr: 0x555555757170</span><br><span class="line">Size: 0x21</span><br><span class="line">fd: 0x7ffff7bcdb78</span><br><span class="line">bk: 0x7ffff7bcdb78</span><br><span class="line"></span><br><span class="line">Allocated chunk</span><br><span class="line">Addr: 0x555555757190</span><br><span class="line">Size: 0x70</span><br></pre></td></tr></table></figure>
<p>bins的结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x555555757000 —▸ 0x555555757100 —▸ 0x7ffff7bcdbf8 (main_arena+216) ◂— 0x7ffff7bcdbf8</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x555555757170 —▸ 0x7ffff7bcdb78 (main_arena+88) ◂— 0x555555757170 /* &#x27;pquUUU&#x27; */</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<p>之后，我们就可以将0x555555757100（此时实际上并不是freed chunk）的fd指针修改为malloc_hook - 0x23。但是由于开启了PIE，因此需要爆破4个比特位，即16选1。</p>
<font color=red>
注意：PIE会对地址进行随机化处理，但是一页之内的地址还是一样的，也就是说，开启和不开启PIE时地址的最低12bit是完全相同的。我们可以获取libc中malloc_hook的相对地址，其低12bit可以获得，但覆盖是整个字节覆盖，因此我们需要猜解随机化地址的倒数第2低字节中的高4位。
</font>
<p>覆盖地址为0x555555757100的chunk的fd指针的低2字节，如果爆破成功，后面连续分配两个0x70大小chunk后再分配一个即将fastbin挟持到__malloc_hook。</p>
<p>这是__malloc_hook前面一部分内存空间的情况。</p>
<table>
<thead>
<tr>
<th style="text-align:center">addr</th>
<th style="text-align:center">+0</th>
<th style="text-align:center">+1</th>
<th style="text-align:center">+2</th>
<th style="text-align:center">+3</th>
<th style="text-align:center">+4</th>
<th style="text-align:center">+5</th>
<th style="text-align:center">+6</th>
<th style="text-align:center">+7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0x7ffff7bcdae8</td>
<td style="text-align:center">00</td>
<td style="text-align:center">00</td>
<td style="text-align:center">00</td>
<td style="text-align:center">00</td>
<td style="text-align:center">00</td>
<td style="text-align:center">00</td>
<td style="text-align:center">00</td>
<td style="text-align:center">00</td>
</tr>
<tr>
<td style="text-align:center">0x7ffff7bcdaf0(_IO_wide_data_0+304)</td>
<td style="text-align:center">60</td>
<td style="text-align:center">c2</td>
<td style="text-align:center">bc</td>
<td style="text-align:center">f7</td>
<td style="text-align:center">ff</td>
<td style="text-align:center"><font color=red>7f</font></td>
<td style="text-align:center"><font color=red>00</font></td>
<td style="text-align:center"><font color=red>00</font></td>
</tr>
<tr>
<td style="text-align:center">0x7ffff7bcdaf8</td>
<td style="text-align:center"><font color=red>00</font></td>
<td style="text-align:center"><font color=red>00</font></td>
<td style="text-align:center"><font color=red>00</font></td>
<td style="text-align:center"><font color=red>00</font></td>
<td style="text-align:center"><font color=red>00</font></td>
<td style="text-align:center">00</td>
<td style="text-align:center">00</td>
<td style="text-align:center">00</td>
</tr>
<tr>
<td style="text-align:center">0x7ffff7bcdb00(__memalign_hook)</td>
<td style="text-align:center">a0</td>
<td style="text-align:center">ee</td>
<td style="text-align:center">88</td>
<td style="text-align:center">f7</td>
<td style="text-align:center">ff</td>
<td style="text-align:center">7f</td>
<td style="text-align:center">00</td>
<td style="text-align:center">00</td>
</tr>
<tr>
<td style="text-align:center">0x7ffff7bcdb08(__realloc_hook)</td>
<td style="text-align:center">70</td>
<td style="text-align:center">ea</td>
<td style="text-align:center">88</td>
<td style="text-align:center">f7</td>
<td style="text-align:center">ff</td>
<td style="text-align:center">7f</td>
<td style="text-align:center">00</td>
<td style="text-align:center">00</td>
</tr>
<tr>
<td style="text-align:center">0x7ffff7bcdb10(__malloc_hook)</td>
<td style="text-align:center">00</td>
<td style="text-align:center">00</td>
<td style="text-align:center">00</td>
<td style="text-align:center">00</td>
<td style="text-align:center">00</td>
<td style="text-align:center">00</td>
<td style="text-align:center">00</td>
<td style="text-align:center">00</td>
</tr>
</tbody>
</table>
<p>我们现在解释为什么要将地址挟持到__malloc_hook - 0x23处。</p>
<font color=red>
fastbin的重新分配会进行一个检查：后面一个fastbin的大小是否在fastbin可以容纳的chunk的大小范围之内。因此我们需要转移到一个这样一个地址，这个地址后面对应的size域有一个0x20~0x80的值。看到上面的表，我们想借用7f。如何借用？注意到0x7ffff7bcdaf5处有一个7f（这个7f一般是固定不变的），而且这之后有10个字节都是0，如果我们从这里开始读8个字节，那值就正好是0x7f，不会超过0x80。所以考虑将0x7ffff7bcdaed作为chunk的头部，这样读取到的size就可以通过检查。
</font>
<h2 id="step-2-unsorted-bin-attack"><a class="markdownIt-Anchor" href="#step-2-unsorted-bin-attack"></a> Step 2: Unsorted bin attack</h2>
<p>在第一步中，我们成功将fastbin挟持到了__malloc_hook处。但是由于libc的加载地址仍然未知，现在我们能做的仍然非常有限。因此下一步我们准备进行一次unsorted bin attack。</p>
<p>首先分配一个0x90大小的chunk(name: unsorted_bin_ptr)，之后分配一个0x30大小的chunk防止unsorted bin与top chunk合并。下面就是常规的unsorted bin attack流程：</p>
<p>释放unsorted_bin_ptr，利用UAF将其bk指针修改为__malloc_hook - 0x10（这里只需要修改最低2字节，而且这在第一步已经通过爆破获取）。然后将这个unsorted bin分配出来，这样main_arena + 0x68被修改为__malloc_hook - 0x10，同时__malloc_hook被修改为main_arena + 0x68（这是双向链表中元素脱链的标准操作，即要脱链的为chunk，则需将chunk-&gt;bk-&gt;fd指向main_arena + 0x68，main_arena + 0x68指向chunk-&gt;bk，图示如下）</p>
<p><img src="1.png" alt="" /></p>
<h2 id="step-3-getshell"><a class="markdownIt-Anchor" href="#step-3-getshell"></a> Step 3: getshell</h2>
<p>之后，我们需要利用挟持到__malloc_hook的chunk部分修改__malloc_hook的值。首先，我们在第一步已经通过爆破获取了__malloc_hook地址的低2字节，根据这低2字节，我们可以在libc中获取到system加载地址的低2字节。</p>
<p>例如，libc6_2.23-0ubuntu11.3_amd64版本中system地址为0x453a0，__malloc_hook地址为0x3c4b10。假如爆破成功时__malloc_hook加载地址的低2字节为0x8b10，那么说明加载地址等于相对地址加上(0x400 + n * 0x1000)。即system加载地址的低2字节应为0x93a0。</p>
<p>我们获取到system地址的低2字节后，需要爆破system地址第3小的字节。注意到0x3c4b10 - 0x453a0 = 0x37f770，system的地址和__malloc_hook的地址除低3字节外剩余部分很有可能相等。因此只对第3小的字节进行爆破即可。</p>
<p>随机猜解system地址如果成功，在之后进行malloc，参数可以填one_gadget，这样就可以成功获取shell。</p>
<p>综上所述，house_of_roman一共需要爆破12比特位，加上加载地址可能造成的影响，爆破成功的概率应该略低于 1 / 2^12，多试几次就可以getshell。</p>
<h1 id="10-house_of_spirit"><a class="markdownIt-Anchor" href="#10-house_of_spirit"></a> 10. house_of_spirit</h1>
<p>这是一种常用的堆漏洞，核心思想也很简单：在目标地址伪造一个chunk并引导libc将这块内存释放，下一次malloc即可分配到目标地址处。</p>
<p>这里需要注意的就是伪造堆块的方法。</p>
<h2 id="重要_int_free函数的fastbin检查"><a class="markdownIt-Anchor" href="#重要_int_free函数的fastbin检查"></a> 重要：_int_free函数的fastbin检查：</h2>
<ol>
<li>
<p>检查堆块的size是否过大到不切实际</p>
</li>
<li>
<p>检查chunk是否对齐（x64的chunk头必须是0x8对齐的，即最低4bit只能为0或8）</p>
</li>
</ol>
<p>上述两种检查如果没有通过，直接报错中止，源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">size = chunksize (p);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect ((<span class="type">uintptr_t</span>) p &gt; (<span class="type">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">      || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;free(): invalid pointer&quot;</span>;</span><br><span class="line">    errout:</span><br><span class="line">      <span class="keyword">if</span> (!have_lock &amp;&amp; locked)</span><br><span class="line">        (<span class="type">void</span>) mutex_unlock (&amp;av-&gt;mutex);</span><br><span class="line">      malloc_printerr (check_action, errstr, chunk2mem (p), av);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>检查size是否过小以及size是否对齐，即size不能小于0x20且在x64中也要是0x8对齐，否则报错中止。源码如下：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>检查下一个chunk的大小，不能小于<code>2 * SIZE_SZ</code>（即0x10），也不能大于<code>av-&gt;system_mem</code>（应该是一个很大的值），源码如下：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">	|| __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">			     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">	   of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">	   after getting the lock.  */</span></span><br><span class="line">	<span class="keyword">if</span> (have_lock</span><br><span class="line">	    || (&#123; assert (locked == <span class="number">0</span>);</span><br><span class="line">		  mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">		  locked = <span class="number">1</span>;</span><br><span class="line">		  chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">		    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">	      &#125;))</span><br><span class="line">	  &#123;</span><br><span class="line">	    errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">	    <span class="keyword">goto</span> errout;</span><br><span class="line">	  &#125;</span><br><span class="line">	<span class="keyword">if</span> (! have_lock)</span><br><span class="line">	  &#123;</span><br><span class="line">	    (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">	    locked = <span class="number">0</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>检查fastbin的第一个chunk是否是当前释放的chunk，防止double free。源码如下：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fb = &amp;fastbin (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">	<span class="comment">/* Check that the top of the bin is not the record we are going to add</span></span><br><span class="line"><span class="comment">	   (i.e., double free).  */</span></span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">	  &#123;</span><br><span class="line">	    errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">	    <span class="keyword">goto</span> errout;</span><br><span class="line">	  &#125;</span><br><span class="line">	<span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">	   size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">	   only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">	   deallocated.  See use of OLD_IDX below for the actual check.  */</span></span><br><span class="line">	<span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">	  old_idx = fastbin_index(chunksize(old));</span><br><span class="line">	p-&gt;fd = old2 = old;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);</span><br></pre></td></tr></table></figure>
<p>在house_of_spirit中，第2个检查一般都是满足的，绕过第1个检查需要将目标地址看做一个chunk，对应size的地址处应该写入一个0x20~0x80且能够被0x8整除的数，以绕过第1, 3个检查。第4个检查的绕过需要一些小技巧。假设在目标地址处我们可以控制0x60的空间，那么我们的size不应该写成0x60而是小于0x60，这样方便我们在后面伪造next chunk的size。第5个检查一般没有问题。</p>
<p>所有这些工作做好之后，就可以先释放再分配了。分配完成后就可以在目标地址处获取一个chunk。一般来说house_of_spirit是作为跳板来使用的，在目标地址获取chunk能够很好地为其他攻击手段做准备。</p>
<h1 id="11-house_of_storm"><a class="markdownIt-Anchor" href="#11-house_of_storm"></a> 11. house_of_storm</h1>
<p>关于此利用方式，源码中的说明是可以向用户返回任意一个chunk。</p>
<p>首先，程序分配了两个chunk，一个进入unsorted bin，一个进入large bins，且unsorted bin中的chunk大小大于large bins中的chunk。在源码中，unsorted bin chunk的大小设定为0x4f0，同时分配一个小chunk防止其在释放时与top chunk合并。</p>
<p>之后，源码中以这个chunk的最高非0字节为参考，计算了需要分配的chunk的大小。将最低1bit置0（因为这里在chunk的size中代表的是prev_in_use标志位），这里需要进行检查：最低1字节的bit-3不能为1，若bit-2为1则bit-1不能为0，至于原因，后面会提到。</p>
<p>如果上述检查通过，则进行接下来的操作。分配一个大小为0x4e0的chunk，再加上一个小chunk防止与top chunk合并。之后释放0x4e0大小的chunk和0x4f0大小的chunk（这里注意要首先释放较小的chunk），然后分配一个0x4f0大小的chunk。这样由于<font color=red><strong>unsorted bin在malloc时遵循先进先出的队列结构</strong></font>，会首先检查到小chunk，而小chunk大小不足，会被链入到large bins中。然后再将0x4f0大小的chunk释放，返还到unsorted bin中，bins的环境就构造完成了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x603000 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x603000</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">0x4c0: 0x603510 —▸ 0x7ffff7dd1f98 (main_arena+1144) ◂— 0x603510</span><br></pre></td></tr></table></figure>
<p>然后，我们需要使用unsorted bin attack，覆盖unsorted bin chunk的bk指针为(目标地址 - 0x10)处，覆盖large bin chunk的bk指针到(目标地址 - 0x8)处，覆盖large bin chunk的bk_nextsize。之后，malloc即可获取目标地址的chunk。</p>
<p>但是，为什么会这样呢？这需要从_int_malloc函数中寻找答案。</p>
<h2 id="本漏洞利用中_int_malloc函数中重要步骤"><a class="markdownIt-Anchor" href="#本漏洞利用中_int_malloc函数中重要步骤"></a> 本漏洞利用中_int_malloc函数中重要步骤：</h2>
<p>参考博客（有分析全过程）：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41453285/article/details/99005759?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164652688616780265470085%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164652688616780265470085&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-99005759.pc_search_result_control_group&amp;utm_term=int_malloc&amp;spm=1018.2226.3001.4187">_int_malloc函数详解</a></p>
<ol>
<li>
<p>如果申请大小在fastbin范围则从fastbin中查找是否有合适的chunk。</p>
</li>
<li>
<p>如果申请大小在small bins范围则从small bins中查找是否有合适的chunk。</p>
</li>
<li>
<p>前2步没有找到调用malloc_consolidate函数整理堆块</p>
</li>
<li>
<p>大循环：</p>
<p>(1) 从unsorted bin中获取当前遍历到的chunk<br />
(2) 如果申请大小在small bins范围且last remainder可以切割一部分给申请堆块，则切割后返回<br />
(3) 如果申请大小正好等于当前遍历到chunk的大小，则直接返回<br />
<font color=red><br />
(4) 将当前unsorted bin chunk放入small bins或large bins中：<br />
如果当前遍历到的unsorted bin chunk的大小属于small bins范围则放入对应的small bin中。<br />
如果属于large bins范围，则需要进行一些处理：<br />
因为large bins中的每一个bin里面的chunk大小均是一个范围值而不是固定值，所以libc会对每一个large bin中的chunk按照大小进行排序，large bin chunk的fd和bk指针指向前后chunk，而fd_nextsize和bk_nextsize指向前后第一个与该chunk大小不同的chunk，便于遍历。所以，libc会遍历该large bin并将这个原本在unsorted bin中的chunk放入正确的位置。在house of storm中，至关重要的就是下面的入链操作：<br />
</font></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">victim-&gt;fd_nextsize = fwd;</span><br><span class="line">victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">fwd-&gt;bk_nextsize = victim;</span><br><span class="line">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure>
<p>这里要尤其注意第4条语句，这是唯一一条修改目标地址值的语句。<br />
（victim = unsorted bin chunk，fwd = large bin chunk）</p>
<p>在此之前，分别位于unsorted bin和large bins的两个chunk的构造如下：</p>
<p>unsorted bin chunk:</p>
<table>
<thead>
<tr>
<th style="text-align:center">addr</th>
<th style="text-align:center">+0x0</th>
<th style="text-align:center">+0x8</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0x603000</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0x4f1(size)</td>
</tr>
<tr>
<td style="text-align:center">0x603010</td>
<td style="text-align:center">main_arena + 0x68</td>
<td style="text-align:center">target-0x10</td>
</tr>
<tr>
<td style="text-align:center">0x603020</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<p>large bin chunk:</p>
<table>
<thead>
<tr>
<th style="text-align:center">addr</th>
<th style="text-align:center">+0x0</th>
<th style="text-align:center">+0x8</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0x603510</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0x4e1(size)</td>
</tr>
<tr>
<td style="text-align:center">0x603520</td>
<td style="text-align:center">main_arena + 1144</td>
<td style="text-align:center">target-0x8</td>
</tr>
<tr>
<td style="text-align:center">0x603530</td>
<td style="text-align:center">0x603510(fd_nextsize)</td>
<td style="text-align:center">target-0x2a(bk_nextsize)</td>
</tr>
</tbody>
</table>
<p>在执行完上述4步之后，结构变为：</p>
<p>unsorted bin chunk:</p>
<table>
<thead>
<tr>
<th style="text-align:center">addr</th>
<th style="text-align:center">+0x0</th>
<th style="text-align:center">+0x8</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0x603000</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0x4f1(size)</td>
</tr>
<tr>
<td style="text-align:center">0x603010</td>
<td style="text-align:center">main_arena + 0x68</td>
<td style="text-align:center">target-0x8</td>
</tr>
<tr>
<td style="text-align:center">0x603020</td>
<td style="text-align:center"><font color=red>0x603510</font></td>
<td style="text-align:center"><font color=red>target-0x2a</font></td>
</tr>
</tbody>
</table>
<p>large bin chunk:</p>
<table>
<thead>
<tr>
<th style="text-align:center">addr</th>
<th style="text-align:center">+0x0</th>
<th style="text-align:center">+0x8</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0x603510</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0x4e1(size)</td>
</tr>
<tr>
<td style="text-align:center">0x603520</td>
<td style="text-align:center">main_arena + 1144</td>
<td style="text-align:center">target-0x8</td>
</tr>
<tr>
<td style="text-align:center">0x603530</td>
<td style="text-align:center">0x603510</td>
<td style="text-align:center"><font color=red>0x603000</font></td>
</tr>
</tbody>
</table>
<p>同时(target-0x2a)-&gt;fd_nextsize被写入为0x603000，也即target-0xa处被写入为0x603000：</p>
<table>
<thead>
<tr>
<th style="text-align:center">addr</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">target-0x10</td>
<td style="text-align:center">–</td>
<td style="text-align:center">–</td>
<td style="text-align:center">–</td>
<td style="text-align:center">–</td>
<td style="text-align:center">–</td>
<td style="text-align:center">–</td>
<td style="text-align:center"><font color=red>00</font></td>
<td style="text-align:center"><font color=red>30</font></td>
</tr>
<tr>
<td style="text-align:center">target-0x8</td>
<td style="text-align:center"><font color=red>60</font></td>
<td style="text-align:center">00</td>
<td style="text-align:center">00</td>
<td style="text-align:center">00</td>
<td style="text-align:center">00</td>
<td style="text-align:center">00</td>
<td style="text-align:center">00</td>
<td style="text-align:center">00</td>
</tr>
<tr>
<td style="text-align:center">target</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">target+0x8</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>如果将target-0x10看做chunk头，那么这里正好写入了一个正确的size，即0x60！这也就能够解释为什么源代码一开始要将unsorted bin chunk地址的高位作为size，且需要通过一系列检查了。通过了一系列检查，然后像这样错位写入，就正好能够伪造正确的size！这样，_int_malloc函数就能够为我们返回这个地方的地址了。</p>
<p>对于这个漏洞的利用的理解需要对_int_malloc函数有充分的理解，利用unsorted bin chunk被链入到large bins的过程对堆结构进行攻击。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/02/28/how2heap-%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-2/" rel="prev" title="how2heap 深入学习(2)">
      <i class="fa fa-chevron-left"></i> how2heap 深入学习(2)
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/02/28/how2heap-%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-4/" rel="next" title="how2heap 深入学习(4)">
      how2heap 深入学习(4) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#9-house_of_roman"><span class="nav-number">1.</span> <span class="nav-text"> 9. house_of_roman</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#step-1-%E6%8E%A7%E5%88%B6__malloc_hook"><span class="nav-number">1.1.</span> <span class="nav-text"> Step 1: 控制__malloc_hook</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#step-2-unsorted-bin-attack"><span class="nav-number">1.2.</span> <span class="nav-text"> Step 2: Unsorted bin attack</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#step-3-getshell"><span class="nav-number">1.3.</span> <span class="nav-text"> Step 3: getshell</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-house_of_spirit"><span class="nav-number">2.</span> <span class="nav-text"> 10. house_of_spirit</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E8%A6%81_int_free%E5%87%BD%E6%95%B0%E7%9A%84fastbin%E6%A3%80%E6%9F%A5"><span class="nav-number">2.1.</span> <span class="nav-text"> 重要：_int_free函数的fastbin检查：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-house_of_storm"><span class="nav-number">3.</span> <span class="nav-text"> 11. house_of_storm</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B8%AD_int_malloc%E5%87%BD%E6%95%B0%E4%B8%AD%E9%87%8D%E8%A6%81%E6%AD%A5%E9%AA%A4"><span class="nav-number">3.1.</span> <span class="nav-text"> 本漏洞利用中_int_malloc函数中重要步骤：</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CoLin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">139</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Hornos3" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Hornos3" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_54218833?spm=1000.2115.3001.5343" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_54218833?spm&#x3D;1000.2115.3001.5343" rel="noopener" target="_blank"><i class="fa fa-crosshairs fa-fw"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CoLin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">1.2m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">18:34</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
