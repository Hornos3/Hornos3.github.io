<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hornos3.github.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Chapter 10 漏洞利用  10.0 概念  安全事件与软件漏洞  安全事件：攻击者在给定时间段内，利用漏洞或其他攻击手段在攻击对象中注入并触发恶意代码，产生拒绝服务、信息泄露、信息窃取、目标控制等后果的过程。 漏洞：系统设计、实现或操作管理中存在的缺陷或弱点，能被利用而违背系统的安全策略。   漏洞分类与标准 按照漏洞威胁可分为：  提权漏洞 获权漏洞 拒绝服务漏洞 恶意软件植入漏洞 数">
<meta property="og:type" content="article">
<meta property="og:title" content="软件安全——第10章">
<meta property="og:url" content="http://hornos3.github.com/2023/03/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%AC%AC10%E7%AB%A0/index.html">
<meta property="og:site_name" content="CoLin&#39;s BLOG">
<meta property="og:description" content="Chapter 10 漏洞利用  10.0 概念  安全事件与软件漏洞  安全事件：攻击者在给定时间段内，利用漏洞或其他攻击手段在攻击对象中注入并触发恶意代码，产生拒绝服务、信息泄露、信息窃取、目标控制等后果的过程。 漏洞：系统设计、实现或操作管理中存在的缺陷或弱点，能被利用而违背系统的安全策略。   漏洞分类与标准 按照漏洞威胁可分为：  提权漏洞 获权漏洞 拒绝服务漏洞 恶意软件植入漏洞 数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/88b8159a0b974dec9837f74f697df1eb.png">
<meta property="article:published_time" content="2023-03-03T01:45:15.000Z">
<meta property="article:modified_time" content="2023-03-03T01:47:34.089Z">
<meta property="article:author" content="CoLin">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/88b8159a0b974dec9837f74f697df1eb.png">

<link rel="canonical" href="http://hornos3.github.com/2023/03/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%AC%AC10%E7%AB%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>软件安全——第10章 | CoLin's BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CoLin's BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2023/03/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%AC%AC10%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          软件安全——第10章
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-03 09:45:15 / 修改时间：09:47:34" itemprop="dateCreated datePublished" datetime="2023-03-03T09:45:15+08:00">2023-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课内笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E5%86%85%E7%AC%94%E8%AE%B0/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">软件安全</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="chapter-10-漏洞利用"><a class="markdownIt-Anchor" href="#chapter-10-漏洞利用"></a> Chapter 10 漏洞利用</h1>
<h2 id="100-概念"><a class="markdownIt-Anchor" href="#100-概念"></a> 10.0 概念</h2>
<h3 id="安全事件与软件漏洞"><a class="markdownIt-Anchor" href="#安全事件与软件漏洞"></a> 安全事件与软件漏洞</h3>
<ul>
<li>安全事件：攻击者在给定时间段内，利用漏洞或其他攻击手段在攻击对象中注入并触发恶意代码，产生拒绝服务、信息泄露、信息窃取、目标控制等后果的过程。</li>
<li>漏洞：系统设计、实现或操作管理中存在的缺陷或弱点，能被利用而违背系统的安全策略。</li>
</ul>
<h3 id="漏洞分类与标准"><a class="markdownIt-Anchor" href="#漏洞分类与标准"></a> 漏洞分类与标准</h3>
<p>按照漏洞威胁可分为：</p>
<ul>
<li>提权漏洞</li>
<li>获权漏洞</li>
<li>拒绝服务漏洞</li>
<li>恶意软件植入漏洞</li>
<li>数据丢失或泄露漏洞</li>
</ul>
<p>按照漏洞成因可分为：</p>
<ul>
<li>输入验证漏洞</li>
<li>访问验证漏洞</li>
<li>竞态漏洞（竞争条件漏洞）</li>
<li>意外情况处理漏洞</li>
<li>设计漏洞</li>
<li>配置漏洞</li>
<li>环境漏洞</li>
</ul>
<p>按照漏洞的严重性可分为：</p>
<ul>
<li>A 类漏洞（高）：威胁性最大的漏洞，往往由较差的系统管理或错误设置造成。</li>
<li>B 类漏洞（中）：较为严重的漏洞，例如允许本地用户获得增加的和未授权的访问。</li>
<li>C 类漏洞（低）：严重性不是很大的漏洞，例如允许拒绝服务的漏洞。</li>
</ul>
<p>按照攻击被利用的方式可分为：</p>
<ul>
<li>本地攻击漏洞</li>
<li>远程主动攻击漏洞</li>
<li>远程被动攻击漏洞</li>
</ul>
<p>重要网站：</p>
<ul>
<li>CVE：漏洞暴露平台</li>
<li>CNVD：国家互联网应急中心</li>
<li>CNNVD：国家信息安全测评中心</li>
</ul>
<h3 id="漏洞利用对系统的威胁"><a class="markdownIt-Anchor" href="#漏洞利用对系统的威胁"></a> 漏洞利用对系统的威胁</h3>
<ul>
<li>非法获取访问权限（获权）
<ul>
<li>未经授权使用资源，如打印、读取、写、执行文件等</li>
</ul>
</li>
<li>权限提升（提权）
<ul>
<li>用户账号由低权限提升到高权限</li>
</ul>
</li>
<li>拒绝服务
<ul>
<li>使计算机软件或系统无法正常工作、无法提供正常服务</li>
<li>本地拒绝服务：运行在本地的程序无法正常工作；远程拒绝服务：发送特定网络数据报文使提供服务的程序异常或退出</li>
</ul>
</li>
<li>恶意软件植入
<ul>
<li>主动植入：利用正常功能或漏洞将恶意代码植入到目标之中，无需用户干预</li>
<li>被动植入：将恶意代码植入时需要用户配合操作（木马、病毒等）</li>
</ul>
</li>
<li>数据丢失或泄露
<ul>
<li>由于对文件访问权限设置错误导致数据被非法读取。如读取密码</li>
<li>没有充分验证用户输入导致数据被非法读取。如Web相关漏洞</li>
<li>系统漏洞，如DNS域传送漏洞</li>
</ul>
</li>
</ul>
<h3 id="漏洞产生原因"><a class="markdownIt-Anchor" href="#漏洞产生原因"></a> 漏洞产生原因</h3>
<p>逻辑错误、缺陷、社工、策略失误等，可以分为技术因素和非技术因素（大多为人为因素）</p>
<ul>
<li>技术错误：即上文提到的按漏洞成因分类的7种</li>
<li>非技术错误：缺乏规范导致维护困难、缺乏测试与维护、开发团队不稳定、缺乏进度控制等</li>
</ul>
<h3 id="漏洞利用方式"><a class="markdownIt-Anchor" href="#漏洞利用方式"></a> 漏洞利用方式</h3>
<ul>
<li>本地攻击模式：攻击者进入目标系统具有一定权限后进行的攻击。如内网渗透等</li>
<li>远程主动攻击模式：攻击者以网络连接发现目标漏洞后进行攻击</li>
<li>远程被动攻击模式：攻击者向目标发送网页、文档等点击后触发漏洞</li>
</ul>
<h3 id="font-colorblue软件漏洞生命周期font"><a class="markdownIt-Anchor" href="#font-colorblue软件漏洞生命周期font"></a> <font color=blue>软件漏洞生命周期</font></h3>
<ul>
<li>漏洞挖掘</li>
<li>漏洞重现</li>
<li>漏洞诊断</li>
<li>漏洞修复</li>
<li>补丁测试</li>
<li>补丁推送</li>
</ul>
<p>（攻击者在其中任何一个时候都能够对系统造成损失）</p>
<h3 id="典型软件漏洞"><a class="markdownIt-Anchor" href="#典型软件漏洞"></a> 典型软件漏洞</h3>
<ul>
<li>缓冲区溢出：在下面会具体说明</li>
<li>注入攻击：如SQL注入、系统命令注入、脚本注入等，多为对用户的输入检查不严格导致。</li>
<li>跨站漏洞：跨站脚本攻击（XSS），攻击者将恶意脚本代码嵌入到Web页面中，用户打开后执行其中的代码触发漏洞或获取网站权限。（被动攻击）</li>
<li>权限漏洞：访问控制机制上存在的漏洞。如Linux Kernel Pwn即利用Linux内核模块实现用户权限到root权限的提升。</li>
</ul>
<h2 id="101-栈缓冲区溢出"><a class="markdownIt-Anchor" href="#101-栈缓冲区溢出"></a> 10.1 栈缓冲区溢出</h2>
<p>一、栈</p>
<ul>
<li>栈是一段连续的地址空间，是一个后进先出的数据结构，由高地址向低地址增长。</li>
<li>每一个线程都有一个自己的栈，提供一个暂时存放数据的地方。</li>
<li>push将esp下压，pop将ebp上抬</li>
<li>esp指向栈顶，ebp指向栈帧底部。</li>
</ul>
<p><font color=red>注意：栈地址空间中保存的是程序执行时使用的局部变量，在main函数或其他函数中定义的变量均保存在栈中。代码中的字符串常量（如printf(“Hello world”)）定义于rdata段，初始化的全局变量定义于data段，未初始化的全局变量定义于bss段。</font></p>
<p><strong>栈中包含：</strong></p>
<ul>
<li>函数参数</li>
<li>函数返回地址</li>
<li>ebp的值</li>
<li>一些通用寄存器的值</li>
<li>当前执行的函数的局部变量</li>
</ul>
<p><font color=blue>函数调用过程：</font></p>
<ol>
<li>call指令执行之前，程序首先将函数需要的参数逐一push进栈中。（有几种不同的参数压入顺序）</li>
<li>执行call指令跳转eip到函数开头。call指令将eip压入栈中。</li>
<li>函数开头一般会执行指令push ebp; mov ebp, esp，保存前一个栈帧的地址。</li>
<li>之后esp可能会根据该函数中定义的所有局部变量需要占用的空间进行自减，以保证esp和ebp之间能够有充足的空间保存局部变量。</li>
<li>开始执行函数功能，函数调用过程结束。</li>
</ol>
<p><strong>函数调用类型：（32位）</strong></p>
<ul>
<li>__cdecl：C调用规则，在后面的参数首先进入堆栈，参数返回后<strong>调用者</strong>负责清除堆栈，因此这种调用常会产生较大的可执行程序</li>
<li>__stdcall：标准调用，在后面的参数首先进入堆栈，<strong>被调用</strong>的函数返回前自行清理堆栈，生成的代码比cdecl小</li>
<li>__fastcall：将函数列表前两个参数放入寄存器，其他函数压栈，后面的参数首先进入堆栈，<strong>被调用者</strong>清理堆栈</li>
<li>Pascal：基本不用，前面的参数首先进入堆栈，不支持可变参数的函数调用</li>
</ul>
<p><font color=blue>函数返回过程：</font></p>
<ol>
<li>esp上抬到达ebp的位置，局部变量不作处理全部放弃，也不会将这段内存清零。</li>
<li>ebp找到父函数栈帧的底部（函数调用时已经保存在ebp指向的内存空间）并上抬（pop ebp）。</li>
<li>retn返回，返回到父函数call指令之后一条指令。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/88b8159a0b974dec9837f74f697df1eb.png" alt="" /></p>
<p>二、栈溢出</p>
<p>特点：</p>
<ul>
<li>缓冲区在栈中分配</li>
<li>拷贝的数据过长且没有进行检查</li>
<li>覆盖了栈中的一些重要数据，如ebp、返回地址、某些关键局部变量等</li>
</ul>
<p>产生原因：</p>
<ul>
<li>C语言中有大量没有溢出保护的函数，如*scanf系列、*printf系列、gets函数、strcpy函数、strcat函数等（注：read函数理论上可以读取零字节，因此较strcpy等函数具有更高的危险性）</li>
<li>程序员缺乏安全意识</li>
</ul>
<p>shellcode和payload</p>
<ul>
<li>shellcode是能完成一种特殊任务的自包含的二进制代码，根据不同的任务可能是发出一条系统调用或是进行高权限操作。</li>
<li>payload：shellcode以及实现跳转到shellcode的那部分填充代码的统称。</li>
</ul>
<p><strong>栈溢出shellcode的NSR模式：</strong></p>
<ul>
<li>S——shellcode，首先写入栈的低地址处</li>
<li>R——return address，返回地址，通常写入jmp esp的地址，在S之上</li>
<li>N——nops，无效指令，在R之上</li>
</ul>
<p>注意：NSR模式构造的shellcode很可能会失败，原因多种多样。有时jmp esp后栈中的内容会被修改，导致shellcode执行失败。此时可以利用SEH进行攻击。</p>
<p><strong>什么是SEH？</strong><br />
结构化异常处理（StructuredExceptionHandling，SEH）是Windows操作系统处理程序错误或异常的技术。SEH是Windows操作系统的一种系统机制，与特定的程序设计语言无关。SEH的注册结构体只能作为局部变量<strong>存在于当前线程的调用栈</strong>，如果一旦结构体的地址不在当前调用栈的范围中，则在进行异常分发时，将不会进入该函数。即我们<strong>可以通过栈溢出修改SEH中函数指针的值</strong>。SEH是基于线程的一种处理机制，且依赖于栈进行存储和查找，所以被称作是基于栈帧的异常处理机制。有关于其具体实现与功能需要对windows异常处理机制有更加深入的了解，考试不做要求。</p>
<p>fs:[0]指向SEH的初始地址，通过获取该地址以确定溢出的长度，这个长度必须确定以保证能够正确覆盖关键函数指针。将指针覆盖为类似于jmp esp指令的地址，即可执行shellcode。</p>
<p><strong>shellcode的特点</strong>：</p>
<ul>
<li>长度受限（不是所有），具体问题具体分析。</li>
<li>不能使用特定字符，如’\x00’（read函数是唯一能够接收’\x00’的函数）</li>
<li>API函数自搜索和重定位能力</li>
<li>一定的兼容性（很难，windows和linux的内存空间和内核排布很不一样）</li>
</ul>
<h3 id="练习题"><a class="markdownIt-Anchor" href="#练习题"></a> 练习题</h3>
<p><strong>1.</strong> 分析如下代码片段，回答下列问题。（25分）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">guess</span><span class="params">()</span>&#123;</span><br><span class="line">	FILE* fd = open(<span class="string">&#x27;/etc/urandom&#x27;</span>, <span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">	<span class="type">int</span> answer = <span class="number">0</span>;</span><br><span class="line">	read(fd, (<span class="type">char</span>*)(&amp;answer), <span class="number">4</span>);</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="comment">// 此时answer是一个随机数，不可预测</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Guess a number that I&#x27;m thinking...&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;You can input something first...&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buffer);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now guess...&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;guess);</span><br><span class="line">	<span class="keyword">if</span>(guess == answer)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Congratulations!&quot;</span>);</span><br><span class="line">		system(<span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Guess incorrect, no calc!!!&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> True;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：①本函数中先定义的随机变量在栈中的地址在后定义的随机变量之上。②数字a的ASCII码为0x30+a，大写字母的ASCII码为0x40+字母序号（A为0，B为1，…，Z为25），小写字母的ASCII码为0x60+字母序号</p>
<p>(1) 简述该函数的执行流程，说明弹出计算器所需的条件。（4分）<br />
(2) 本函数中存在什么漏洞？（3分）<br />
(3) 当第一个输入为’12345678901234567890abcdefABCDEF\n’时，answer的值为_________（填16进制，2分），返回地址的值为_________（填16进制，2分），那么第二个输入为_________（3分）时可以成功弹出计算器。弹出计算器之后，这个程序很有可能会______________________(2分），原因是_______________________（2分）。<br />
(4) 请写出改进方案，修复这个漏洞使计算器不那么容易被弹出。（7分）</p>
<p>答案：<br />
(1) 本程序产生了一个随机数，之后可以在buffer中写入字符串，然后输入一个数字，如果这个数字与随机数相等，则弹出计算器。弹出计算器的条件是猜的数字与随机数相等。<br />
(2) 栈溢出漏洞<br />
(3) 0x30393837；0x42416665；809056311；崩溃；返回地址可能无效<br />
(4) 将<code>scanf(&quot;%s&quot;, buffer);</code>修改为<code>scanf(&quot;%16s&quot;, buffer);</code></p>
<p><strong>2.</strong> 分析如下代码片段，回答下列问题：（30分）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">void</span> (*exec)(<span class="type">const</span> <span class="type">char</span>*) = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">void</span> (*func)(<span class="type">const</span> <span class="type">char</span>*) = system;</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">16</span>];</span><br><span class="line">	gets(buffer);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buffer);</span><br><span class="line">	<span class="keyword">if</span>(exec != <span class="literal">NULL</span>)</span><br><span class="line">		exec(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：①通过反汇编找到vuln函数的起始地址为0x405678。②本函数中先定义的随机变量在栈中的地址在后定义的随机变量之上。</p>
<p>(1) 简述该函数的执行流程。（4分）<br />
(2) 通过反汇编可以得到该函数的汇编代码，已知前几条语句如下，请填写前两空，第三空填写的数值x一定有______________。（3分）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">mov ___, ___</span><br><span class="line">sub esp, ___</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>(3) 当输入长度为________时，程序会______________________________，从而获得system函数在内存中的地址。（4分）<br />
(4) 如果这个函数只被调用了一次，能否仅通过这个函数弹出计算器？_____ 。为什么？__________________________________ 。（4分）<br />
(5) 第一次函数调用时，你输入了第(3)题长度的payload，printf函数只显示了你输入的内容，可能的原因是_____________________________。（4分）在函数下一次调用时，你应该如何获取system函数的地址？__________________________________。（4分）<br />
(6) 通过第一次函数调用的漏洞利用，获取到system函数的地址为0x7FAD8341，在该函数第二次被调用时，能否利用漏洞弹出计算器？若能，写出一个有效的输入并简述函数执行流程；若不能，说明理由。如果system函数的地址为0x7FAD8300呢？（7分）</p>
<p>答案：<br />
(1) 函数首先接收任意长度的输入，然后检查exec函数指针是否为空，若不为空则执行到exec处。<br />
(2) ebp；esp；x&gt;=24<br />
(3) 16；在printf输出时将system函数的地址接在输入后面输出<br />
(4) 不能；无法控制exec的值，system的地址也不知道因此无法修改返回地址<br />
(5) system函数地址最低位为空字节；尝试输入17、18、19字节数据，直至能够输出system函数的高位地址<br />
(6) 能。输入为calc.exe（后接12字节空格）\x41\x83\xAD\x7F；不能，会截断。</p>
<h2 id="102-堆缓冲区溢出与格式化字符串漏洞"><a class="markdownIt-Anchor" href="#102-堆缓冲区溢出与格式化字符串漏洞"></a> 10.2 堆缓冲区溢出与格式化字符串漏洞</h2>
<p>一、堆</p>
<ul>
<li>堆是存放程序中请求操作系统分配给自己的内存段，其大小不固定，可以进行动态扩大与缩小。操作系统中采用动态链表管理，其内存不一定连续。</li>
<li>每一个<strong>进程</strong>都有一个自己的堆（区别栈是每一个<strong>线程</strong>有一个）</li>
<li>使用malloc系列函数（malloc、calloc、realloc等）/new/mmap等函数分配堆空间；使用free/delete/unmap等函数释放堆空间。（调用的系统函数基本上相同）</li>
</ul>
<p><font color=red>注意：两个程序动态申请的堆空间地址完全有可能相同。要搞清楚虚拟地址和物理地址的区别，程序中直接操作的是虚拟内存地址，由操作系统从物理地址中映射而来，并非物理内存地址。但两个程序分配的堆地址的<strong>物理地址也有可能相同</strong>。两个程序可以交错使用这块内存。</font></p>
<p><strong>结构</strong>：堆表和堆块。</p>
<ul>
<li>堆表：位于堆空间起始位置，用于索引堆区中所有堆块的重要信息。在windows堆管理机制中，将堆表分为两种：快表（Lookaside）和空表（FreeList）。
<ul>
<li>空表：共128项的数组，每个数组是一个双向链表头，除索引0的链表外每个链表中存放相同大小的堆块。其中<strong>索引为x的链表存放大小为8x的空闲堆块，因此1~127共可以存放8~1016字节的堆块。（32位）索引为0的链表存放大小大于等于1024的堆块，按照从小到大的顺序排列</strong>。在实际分配内存流程中，为防止堆空间的碎片化，会对相邻的均处于空表中的堆块进行合并与重新排列。</li>
<li>快表：共128项的数组，采用单向链表存储，其中的堆块不合并且<strong>每一个链表最多存放4个堆块。其中索引为1~127的链表存放的堆块大小与空表相同。</strong></li>
</ul>
</li>
<li>堆块：一块块分离的，碎片化的地址空间，由块首和块身构成。
<ul>
<li>块首：头部几个字节，用于标识自身信息（大小，使用情况等）</li>
<li>块身：数据存储区域，紧跟块首，内存分配得到的地址<strong>指向块身的头部。<strong>在堆块被释放时，块身的前8个字节用于存放堆表中</strong>双向链表的向前指针Flink和向后指针Blink。</strong></li>
</ul>
</li>
<li>HEAP区总体结构：
<ul>
<li>hHeap：HEAP的总体管理结构，句柄</li>
<li>双指针区：定位分配内存、释放内存的位置，存放一些成对出现的指针</li>
<li>用户分配内存区</li>
</ul>
</li>
</ul>
<p><strong>堆管理相关寄存器：</strong></p>
<ul>
<li>eax：一般代码中用作返回值</li>
<li>ecx：一般代码中用作计数器</li>
<li>mov [ecx], eax; mov [eax+4], ecx</li>
</ul>
<p><strong><font color=red>堆块关键操作：</font></strong></p>
<ul>
<li>申请堆块时的脱链操作：即双向链表的脱链操作，汇编指令为mov [ecx], eax; mov [eax+4], ecx</li>
<li>释放堆块时的入链操作：根据设计思想，应首先判断前后是否能进行堆块合并，若进行合并则需要进行脱链操作，再将合并后的堆块放入指定的链表中。</li>
</ul>
<p>二、堆溢出</p>
<p><strong>利用思路1：</strong></p>
<ul>
<li>使用mov [ecx], eax; mov [eax+4], ecx完成对任意地址的控制。</li>
<li>使用[esi+0x4C]指向下一个空闲堆块头部结构</li>
<li>当有不能处理的异常发生时，系统调用UnhandledExceptionFilter函数，其实就是call [0x77EC044c]，即执行0x77EC044c指向的异常处理程序。因此修改此处地址即可。</li>
<li><strong>随着防护措施的改进，上述思路在当前windows系统中已基本不可用。</strong></li>
</ul>
<p><strong>利用思路2：堆喷射</strong></p>
<ul>
<li>向堆中注入大量数据，使数据填满特定内存地址空间，当栈溢出时可以引导EIP到堆的空间。其中填充的数据是大量重复的nop指令，如果之后eip能够指向这段nop指令，就能够一直执行到后面的shellcode。这段nop充当类似“滑梯/滑板”的作用。</li>
<li>目前依然流行,常见于解释JavaScript的浏览器和PDF解释器</li>
<li>申请大量内存时。堆很有可能覆盖到0x0A0A0A0A（162M）、0x0C0C0C0C（192M）、0x0D0D0D0D（208M）<br />
传统的堆喷射使用JavaScript分配内存，根据堆喷射的思想，都是用同样一个指令覆盖一大片内存地址。在每块分配到的内存最后都附加shellcode。这个指令应相当于Nops的作用，且该指令指向的地址正好应落在覆盖的这片大的内存地址中。<br />
指令0C0C对应汇编代码为or al, 0C，对寄存器影响最小，可以起到Nops的作用。如果将eip指向0x0C0C0C0C这个地址（产生异常时可能可以实现），就会在这片内存中不断执行下去直到shellcode为止。</li>
<li>优点：
<ul>
<li>增加缓冲区溢出攻击的成功率</li>
<li>覆盖地址可以简单使用类NOP指令覆盖</li>
<li>可用于堆栈溢出攻击，用slidecode覆盖堆栈返回地址</li>
</ul>
</li>
<li>缺点：
<ul>
<li>会导致被攻击进程内存占用暴增，容易被发现</li>
<li>不能用于主动攻击，一般通过栈溢出利用或其他漏洞进行协同攻击</li>
<li>如果目的地址被shellcode覆盖，则shellcode执行会失败，因此不能保证一定成功</li>
</ul>
</li>
<li>检测与防范：
<ul>
<li>发现应用程序的内存大量增加，检测堆上的数据，看是否包含大量slidecode</li>
<li>浏览器的脚本解释器开始重复申请堆的时候，监控模块记录堆的大小、内容和数量，如果重复堆请求到达阈值或者覆盖指定地址则立即阻止脚本执行。</li>
<li>对于一些利用脚本进行攻击的情况，可以通过hook脚本引擎，分析脚本代码，根据一些堆喷射常见特征检测是否受到攻击</li>
<li>开启DEP</li>
</ul>
</li>
</ul>
<p><strong>利用思路3：Use After Free</strong></p>
<ul>
<li>当一块堆空间被释放，对这段内存空间进行操作即称为UAF。</li>
<li>由于windows内存空间中被释放的堆块的块身中存放有两个指针，通过UAF可以对这两个指针进行修改以破坏堆表的双向链表结构。</li>
</ul>
<p>三、格式化字符串漏洞</p>
<ul>
<li>适用于printf函数系列。</li>
<li>产生原因：
<ul>
<li>printf的不定长参数个数，且没有进行检查。</li>
<li>printf的%n能够对一段地址空间的值进行修改。（<strong>其功能是将前面已经打印出的字符个数赋给对应的地址</strong>）</li>
</ul>
</li>
<li>通过静态扫描容易发现。</li>
</ul>
<h3 id="模拟题"><a class="markdownIt-Anchor" href="#模拟题"></a> 模拟题</h3>
<p><strong>3.</strong> 分析如下代码片段，回答下列问题：（24分）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> of[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">char</span> buf1[<span class="number">0x100</span>] = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>, buf1);</span><br><span class="line">	<span class="type">char</span> buf2[<span class="number">0x100</span>] = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buf1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf1);</span><br><span class="line">	gets(of);</span><br><span class="line">	<span class="built_in">free</span>(buf2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：①本函数中先定义的随机变量在栈中的地址在后定义的随机变量之上。②执行函数发现，函数的第一个输出为0x1030000，第二个堆块紧邻第一个堆块且在第一个堆块之上。</p>
<p>(1) 本函数存在2个漏洞，分别是____________________________（2分）。<br />
(2) 本题能否直接在栈上写入shellcode？____ ，原因是__________________________。（4分）<br />
(3) 本题能否直接在buf1中写入shellcode？____ ，原因是__________________________。（4分）<br />
(4) 本题能够直接在buf2中写入shellcode，前面的地址填充无效地址？____ ，原因是___________________________。（4分）<br />
(5) 由第(2)题和第(3)题，你认为第一个输入应该输入__________________，这样可以__________________________。之后第二个输入应为____________________________________，这样可以防止___________________，由此可以_______________________。（10分）</p>
<p>答案：<br />
(1) 栈溢出漏洞、堆溢出漏洞<br />
(2) 不能，不知道jmp esp或栈的地址<br />
(3) 不能，buf1的地址后两字节均为空字节且buf的大小只有0x100。无法将返回地址覆盖为buf1中的任何地址（地址的第二个字节一定为\x00），会导致截断<br />
(4) 不能，这样会破坏buf2堆块的头部结构，在free时会产生错误<br />
(5) 0x100字节的垃圾数据，通过printf获取buf2堆块的块首信息；vuln函数的起始地址；函数异常退出；再次输入并在第二次调用时在buf2中溢出shellcode【出题漏洞：第一次申请的buf2和第二次不一样，块首信息可能不同】</p>
<h2 id="103-整数溢出与其他漏洞"><a class="markdownIt-Anchor" href="#103-整数溢出与其他漏洞"></a> 10.3 整数溢出与其他漏洞</h2>
<p>一、整数溢出</p>
<p>在程序计算过程中，有时会因为计算数值问题导致计算结果不正确。如计算int整型的0x12345678 × 0x87654321，这会导致溢出。有时这种溢出会导致严重的后果，如输入字符串长度时若不加检查输入负数，会导致过量读或过量写漏洞等。</p>
<p><strong>防范方式</strong>：</p>
<ul>
<li>整数安全意识：形成关于特殊数据输入的意识，比如之前先确定最大和最小输入，使用合适的数据类型。</li>
<li>避免隐患运算直接操作：尽量避免对两个正数相加或相乘之后，再取结果比较。</li>
<li>越界判断：在使用变量申请内存，或者作为数组下标时，注意对越界的监测。</li>
<li>代码审计、安全检测</li>
</ul>
<h3 id="模拟题-2"><a class="markdownIt-Anchor" href="#模拟题-2"></a> 模拟题</h3>
<p><strong>4.</strong>  分析如下代码片段，回答下列问题：（34分）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">0x50</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0x50</span>;</span><br><span class="line">	<span class="type">char</span> alphabet[<span class="number">0x20</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++)</span><br><span class="line">		alphabet[i] = <span class="string">&#x27;A&#x27;</span> + i;</span><br><span class="line">	read(<span class="built_in">stdin</span>, buf, len);	<span class="comment">// 最多只能读取0x50个字节</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">0x50</span>; i++)</span><br><span class="line">		buf[i] &amp;= <span class="number">0xDF</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; buf[i]!=<span class="string">&#x27;\n&#x27;</span>&amp;&amp;buf[i]!=<span class="string">&#x27;\0&#x27;</span>; i++)&#123;</span><br><span class="line">		<span class="type">int</span> temp = buf[i] - <span class="number">0x40</span>;</span><br><span class="line">		temp += <span class="number">3</span>;</span><br><span class="line">		<span class="keyword">if</span>(temp &gt;= <span class="number">26</span>)</span><br><span class="line">			temp -= <span class="number">26</span>;</span><br><span class="line">		buf[i] = alphabet[temp];</span><br><span class="line">	&#125;</span><br><span class="line">	system(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(1) <code>buf[i] &amp;= 0xDF</code>的作用是____________________，这段代码实现的功能是______________________________________________________。（6分）<br />
(2) 本题的漏洞产生的原因是_____________________________，要想执行calc.exe，首先需要解决的问题是____________________________。由于___________（填功能）的执行在___________（填功能）之前，因此可以事先______________________，这样缓冲区在读取到变量alphabet的_________（填’高地址一端’或’低地址一端’）时就能够____________________。从而将______（填一个可打印字符）成功写入system命令字符串的缓冲区buf中（参考ASCII码值：0x2B=‘+’; 0x2E=‘.’; 0x31=‘1’; 0x41=‘A’）（16分）<br />
(3) 除了(2)的漏洞外，如果输入字符的ASCII码大于______的ASCII码，就会造成溢出，读取到alphabet高地址位置的值。如果alphabet的首地址为0x6000，那么想要让buf中存放该函数的返回地址，应该输入ASCII码为_____________________（填4个16进制数）的字符。（6分）<br />
(4) 简述本题代码的漏洞修补方案，写出修改后的代码。（6分）</p>
<h2 id="104-漏洞利用与发现"><a class="markdownIt-Anchor" href="#104-漏洞利用与发现"></a> 10.4 漏洞利用与发现</h2>
<h3 id="1-漏洞利用"><a class="markdownIt-Anchor" href="#1-漏洞利用"></a> 1. 漏洞利用</h3>
<p>漏洞研究包含漏洞挖掘、漏洞分析、漏洞利用与漏洞防御四个方面。</p>
<p>漏洞的来源：黑客自行挖掘出来的漏洞，还未修复（被称为零日漏洞，即0-day漏洞）、从公开发布的POC或黑客交换漏洞得到（此类漏洞为0-day漏洞或1-day漏洞）、从已经发布的漏洞公告和漏洞补丁中获取的漏洞（又被称为n-day漏洞）。</p>
<p>漏洞利用的条件：用户没有打补丁或更新安全工具、管理员没有打补丁或更新安全工具、存在脏数据渗透路径</p>
<p><strong>Exploit的结构</strong></p>
<ul>
<li>Exploit：利用漏洞实现shellcode植入和触发的过程</li>
<li>Exploit ≈ Payload + Shellcode</li>
<li>payload是针对于特定漏洞设计的用于触发漏洞的部分，与漏洞本身紧密相关，而shellcode与漏洞本身无关，只是一段可任意执行的代码。</li>
</ul>
<p><strong>漏洞利用的目标：</strong></p>
<ul>
<li>修改内存变量 （邻接变量）</li>
<li>修改代码逻辑（代码的任意跳转）</li>
<li>修改函数的返回地址</li>
<li>修改函数指针(C++)[虚函数]（虚函数用于C++函数重载）</li>
<li>修改异常处理函数指针（SEH,VEH,UEF,TEH）</li>
<li>修改线程同步的函数指针</li>
</ul>
<p><strong>漏洞利用的过程：</strong></p>
<ul>
<li>定位漏洞点：利用静态分析和动态调试确定漏洞机理，如堆溢出、栈溢出、整数溢出的数据结构，影响的范围</li>
<li>按照利用要求，编写Shellcode</li>
<li>溢出，覆盖代码指针，使得Shellcode获得可执行权</li>
</ul>
<h3 id="2-ret2libc-rop"><a class="markdownIt-Anchor" href="#2-ret2libc-rop"></a> 2. Ret2Libc + ROP</h3>
<p>这是一种将返回地址修改到dll文件代码段的漏洞利用方式，可以不使用shellcode就能够执行指定功能。特点是向dll借代码而不是自己写shellcode，也可以通过这种利用方式完善payload。其中ROP返回到的地址可能不是函数的起始地址，而是函数中某一个位置的地址。</p>
<h4 id="ret2libc-virtualprotect"><a class="markdownIt-Anchor" href="#ret2libc-virtualprotect"></a> Ret2Libc -&gt; VirtualProtect</h4>
<p>在dll文件中有一个VirtualProtect函数可以用于关闭栈不可执行保护（NX），从而可以在栈上写入shellcode并执行。首先使用Ret2Libc将执行VirtualProtect函数，传入合适的参数。返回后转到jmp esp的地址，即可执行shellcode。</p>
<h4 id="ret2libc的防护措施ascii-armoring"><a class="markdownIt-Anchor" href="#ret2libc的防护措施ascii-armoring"></a> Ret2Libc的防护措施：ASCII armoring</h4>
<p>将所有库函数的起始地址都包含一个零字节，使得无法完整溢出。<br />
恶意代码对抗措施：Ret2plt</p>
<ul>
<li>Linux ELF文件中大多数有一个.plt节，其中存放一系列jmp指令跳转到所有需要引用的库函数。因此可以将返回地址写到.plt节中跳转到需要的库函数中。.plt节的深入原理与Linux的间接跳转原理有关，不要求掌握。</li>
</ul>
<h3 id="练习题-2"><a class="markdownIt-Anchor" href="#练习题-2"></a> 练习题</h3>
<p><strong>5.</strong> 分析如下代码片段，回答下列问题：（29分）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> key[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">(<span class="type">void</span>)(*func(<span class="type">void</span>)) = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Please input length: &quot;</span>);</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">0x40</span>];</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;len);</span><br><span class="line">	<span class="keyword">if</span>(len &gt; <span class="number">8</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;You greedy man!&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	read(<span class="built_in">stdin</span>, buf, (<span class="type">unsigned</span> <span class="type">int</span>)len);	<span class="comment">// 读取len长度输入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo1</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> a, <span class="type">unsigned</span> <span class="type">int</span> b, <span class="type">unsigned</span> <span class="type">int</span> c)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a != <span class="number">0x12345678</span> || b != <span class="number">0x87654321</span> || c != <span class="number">0xdeadbeef</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Argument error!&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">strcpy</span>(key, <span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo2</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">// 下面这一部分函数的功能是：检查eax=0x12345678且ebx=0x87654321</span></span><br><span class="line">	<span class="comment">// 如果不是则调用exit函数退出程序。</span></span><br><span class="line">	__asm__(<span class="string">&quot;cmp eax, 12345678h&quot;</span></span><br><span class="line">			<span class="string">&quot;jnz ex&quot;</span></span><br><span class="line">			<span class="string">&quot;cmp ebx, 87654321h&quot;</span></span><br><span class="line">			<span class="string">&quot;jnz ex&quot;</span></span><br><span class="line">			<span class="string">&quot;jmp foo2proc&quot;</span>);</span><br><span class="line">	ex:</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">/////////////////////////////////////</span></span><br><span class="line">	foo2proc:</span><br><span class="line">		func = system;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(0x1000)</span><br><span class="line">	pop eax</span><br><span class="line">	ret</span><br><span class="line">(0x1010)</span><br><span class="line">	xor ebx, eax</span><br><span class="line">	ret</span><br><span class="line">(0x1020)</span><br><span class="line">	mov ebx, 0cafebabeh</span><br><span class="line">	ret</span><br><span class="line">(0x1030)</span><br><span class="line">	add esp, 0ch</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>
<p>(1) 要想在全局变量key中保存字符串’calc.exe’，需要满足的条件是________________________________________；要想在全局变量func中保存函数指针system，需要满足的条件是___________________________；（4分）<br />
(2) 本题的栈溢出需要通过_______漏洞触发，在vuln函数输入len为_________，可以绕过检查，从而能够写入很长的字符串。输入字符串的第________（填16进制数）位能够覆盖vuln函数返回地址。（6分）<br />
(3) 设vuln函数的返回地址在栈中保存的位置为0x100，那么如果需要在全局变量key中保存字符串’calc.exe’，需要将这个地方覆盖为_______________，这个函数的第一个参数应该写在__________________（填’0x104’或’0x108’）的位置，原因是____________________________。（6分）<br />
(4) 如果想在全局变量func中保存函数指针system，在调用foo2函数之前需要首先使用0x1000和0x1010的两段代码碎片，这种漏洞利用方式被称为__________。（2分）<br />
(5) 写出read函数执行时你的完整输入，格式：每行按&quot;地址：值&quot;格式书写，如&quot;0x100：0x12345678&quot;。已知函数的返回地址为0x100，foo1函数的起始地址为0x4013AB，foo2函数的起始地址为0x402880，全局变量key的地址为0x602040，func的地址为0x602050，可以写入任意字节（含零字节），提示：你需要首先计算输入的起始地址然后再开始书写。（8分）<br />
(6) 修复这个漏洞最简单的修改方法是______________________。（3分）</p>
<p>答案：<br />
(1) 调用foo1函数且参数从左到右的值依次应为0x12345678、0x87654321、0xdeadbeef；调用foo2函数且调用时eax的值应为0x12345678，ebx的值应为0x87654321<br />
(2) 整型溢出漏洞；负数；0x48~0x4b<br />
(3) foo1函数起始地址（或foo1函数中strcpy语句的起始地址）；0x108；0x104应为foo1函数的返回地址<br />
(4) ROP<br />
(5)</p>
<ul>
<li>0xbc~0xff：垃圾数据</li>
<li>0x100~0x103：0x1020</li>
<li>0x104~0x107：0x1000</li>
<li>0x108~0x10b：0x4D9BF99F（0x4D9BF99F XOR 0xcafebabe = 0x87654321）</li>
<li>0x10b~0x10f：0x1010</li>
<li>0x110~0x113：0x1000</li>
<li>0x114~0x117：0x12345678</li>
<li>0x118~0x11b：0x402880（foo2函数起始地址）</li>
<li>0x11c~0x11f：0x4013AB（foo1函数起始地址）</li>
<li>0x120~0x123：0x1030（思考这里将返回地址设为0x1030的作用是什么）</li>
<li>0x124~0x127：0x12345678</li>
<li>0x128~0x12b：0x87654321</li>
<li>0x12c~0x12f：0xdeadbeef</li>
<li>0x130~0x133：0x602050</li>
<li>0x134~0x137：0xdeadbeef</li>
<li>0x138~0x13b：0x602040</li>
</ul>
<p>(6) if判断条件加上对负数的判断</p>
<p><strong>6.</strong> Ret2csu是Linux平台下一种经典的ROP利用方法，它利用了每一个linux系统中可执行文件都存在的函数__libc_csu_init函数。下面是该函数的一个片段，分析如下代码片段，回答下列问题：（20分）（注：考试中不会出64位机器的题目，这里仅做练习，必要信息都会给出）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">loc_401A50:					; 下面是每一条指令的地址</span><br><span class="line">mov     rdx, r13			; 0x401A50</span><br><span class="line">mov     rsi, r15			; 0x401A53</span><br><span class="line">mov     rdi, rbp			; 0x401A56</span><br><span class="line">call    ds:[r12+rbx*8]		; 0x401A58</span><br><span class="line">add     rbx, 1				; 0x401A5C</span><br><span class="line">cmp     r14, rbx			; 0x401A60</span><br><span class="line">jnz     short loc_401A50	; 0x401A63</span><br><span class="line">add     rsp, 8				; 0x401A65</span><br><span class="line">pop     rbx					; 0x401A69</span><br><span class="line">pop     rbp					; 0x401A6A</span><br><span class="line">pop     r12					; 0x401A6B</span><br><span class="line">pop     r13 				; 0x401A6D</span><br><span class="line">pop     r14					; 0x401A6F</span><br><span class="line">pop     r15					; 0x401A71</span><br><span class="line">retn						; 0x401A73</span><br></pre></td></tr></table></figure>
<p>(1) 经过检查机器码发现，pop r15指令占2字节，其高1字节可表示另一条指令：pop rdi。同样pop r14指令的高1字节可表示pop rsi指令。在上述汇编代码中，将rip改为___________可以执行pop rsi，改为__________可以执行pop rdi。（4分）<br />
(2) 这段代码中有一个比较判断，当使用call指令执行代码之后，如果不再需要call调用，应该跳过这个判断，需要满足_________________。（3分）<br />
(3) 在64位Linux系统中，函数调用的前6个参数分别存放在rdi，rsi，rdx，rcx，r8，r9寄存器中。若要调用某函数，其前三个参数需要是0x12345678，0x87654321，0xdeadbeef，在ROP覆盖返回地址时，可以将返回地址修改为________________，可连续设置多个寄存器的值为自己设定的任意值。（3分）<br />
(4) 设此时某关键函数foo的地址保存在0x602020处，请写出ROP的内容以执行&quot;foo(0x12345678，0x87654321，0xdeadbeef)&quot;（从返回地址开始写，返回地址保存在栈中的地址为0x100000）（10分）<br />
格式示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x100000: 0x1234567887654321</span><br><span class="line">0x100008: 0xdeadbeefdeadbeef</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>答案：<br />
(1) 0x401A70；0x401A72<br />
(2) r14==rbx+1<br />
(3) 0x401A69<br />
(4)</p>
<ul>
<li>0x100000~0x100007：0x401A69</li>
<li>0x100008~0x10000f：0（rbx）</li>
<li>0x100010~0x100017：0x12345678（rbp）</li>
<li>0x100018~0x10001f：0x602020（r12）</li>
<li>0x100020~0x100027：0xdeadbeef（r13）</li>
<li>0x100028~0x10002f：1（r14）</li>
<li>0x100030~0x100037：0x87654321（r15）</li>
<li>0x100038~0x10003f：0x401A50</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/03/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%AC%AC9%E7%AB%A0/" rel="prev" title="软件安全——第9章">
      <i class="fa fa-chevron-left"></i> 软件安全——第9章
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/03/03/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E2%80%94%E2%80%94%E7%AC%AC11%E7%AB%A0/" rel="next" title="软件安全——第11章">
      软件安全——第11章 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#chapter-10-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text"> Chapter 10 漏洞利用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#100-%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text"> 10.0 概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E4%B8%8E%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E"><span class="nav-number">1.1.1.</span> <span class="nav-text"> 安全事件与软件漏洞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E7%B1%BB%E4%B8%8E%E6%A0%87%E5%87%86"><span class="nav-number">1.1.2.</span> <span class="nav-text"> 漏洞分类与标准</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%AF%B9%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A8%81%E8%83%81"><span class="nav-number">1.1.3.</span> <span class="nav-text"> 漏洞利用对系统的威胁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.1.4.</span> <span class="nav-text"> 漏洞产生原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">1.1.5.</span> <span class="nav-text"> 漏洞利用方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#font-colorblue%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9Ffont"><span class="nav-number">1.1.6.</span> <span class="nav-text"> 软件漏洞生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E"><span class="nav-number">1.1.7.</span> <span class="nav-text"> 典型软件漏洞</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#101-%E6%A0%88%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA"><span class="nav-number">1.2.</span> <span class="nav-text"> 10.1 栈缓冲区溢出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="nav-number">1.2.1.</span> <span class="nav-text"> 练习题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#102-%E5%A0%86%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E4%B8%8E%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E"><span class="nav-number">1.3.</span> <span class="nav-text"> 10.2 堆缓冲区溢出与格式化字符串漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E9%A2%98"><span class="nav-number">1.3.1.</span> <span class="nav-text"> 模拟题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#103-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%85%B6%E4%BB%96%E6%BC%8F%E6%B4%9E"><span class="nav-number">1.4.</span> <span class="nav-text"> 10.3 整数溢出与其他漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E9%A2%98-2"><span class="nav-number">1.4.1.</span> <span class="nav-text"> 模拟题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#104-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%B8%8E%E5%8F%91%E7%8E%B0"><span class="nav-number">1.5.</span> <span class="nav-text"> 10.4 漏洞利用与发现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="nav-number">1.5.1.</span> <span class="nav-text"> 1. 漏洞利用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-ret2libc-rop"><span class="nav-number">1.5.2.</span> <span class="nav-text"> 2. Ret2Libc + ROP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ret2libc-virtualprotect"><span class="nav-number">1.5.2.1.</span> <span class="nav-text"> Ret2Libc -&gt; VirtualProtect</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ret2libc%E7%9A%84%E9%98%B2%E6%8A%A4%E6%8E%AA%E6%96%BDascii-armoring"><span class="nav-number">1.5.2.2.</span> <span class="nav-text"> Ret2Libc的防护措施：ASCII armoring</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98-2"><span class="nav-number">1.5.3.</span> <span class="nav-text"> 练习题</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CoLin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">157</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Hornos3" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Hornos3" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_54218833?spm=1000.2115.3001.5343" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_54218833?spm&#x3D;1000.2115.3001.5343" rel="noopener" target="_blank"><i class="fa fa-crosshairs fa-fw"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CoLin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">1.5m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">22:02</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
