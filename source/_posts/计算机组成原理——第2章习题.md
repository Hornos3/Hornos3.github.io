---
title: 计算机组成原理——第2章习题
date: 2023-03-03 00:02:03
categories:
- 课内笔记
- 计算机组成原理
---
### 2.1
- 真值：使用加号或减号表示数据符号的数据书写格式被称为真值。<font color=red>注意真值指的不是数据的值，而是数据的一种书写格式。一个数据必须要有一个书写格式才能展示出来。</font>
- 机器码：在计算机中采用0或1表示数据的正负，由符号和数值一起编码表示的二进制数称为机器数或机器码。
- 原码：符号化的数值，正数符号位为0，负数为1，其余为与真值表示相同。
- 反码：又称1的补码，符号位与原码相同，真值为正数时，反码与原码相同；真值为负数时，反码数值与真值数值位相反。
- 补码：当真值为正数时，补码等于真值；当真值为负数时，真值加上模数即为补码，或者是反码加1。
- 移码：只用于定点整数的表示，通常用于表示浮点数阶码。编码方式是直接将真值x加上一个常数偏移量。移码可以直接比较大小。
- 模：模数，数值计量系统的计量范围。
- 定点数：约定计算机中所有数据的小数点位置固定。将小数点的位置固定在数据的最高数位之前的数据称为定点小数，将小数点固定在最低数位之后的数据称为定点整数。
- 浮点数：浮点数中的小数位不固定。
- 溢出：当数据超过计算机能够表示的数据范围时产生了溢出。
- 精度溢出：数轴上所有不在数值刻度上面的纯小数都超过了定点小数所能够表示的精度，无法表示，此时定点小数发生精度溢出。
- 浮点数规格化：使得浮点数的尾数真值最高有效位为1，即尾数的绝对值应该大于0.1~2~。
- 隐藏位：在规格化浮点数中由于尾数的最高有效位一定为1，因此这一位可以不用保存到数据中，这就是被隐藏的一位，即隐藏位。
- 码距：在编码系统中，两个编码一一对应的所有二进制位中不同的二进制位数，又称海明距离。
- 校验码：具有发现错误或纠正错误能力的数据编码，用于提升数据在时间和空间两个维度上的可靠性传输的机制。
- 多重奇偶校验：对数据中的某一位数据位都有多个奇偶校验码对其进行校验的校验方式。
- 海明码：一种既能检错又能纠错的校验码。
- CRC码：循环冗余校验码。

### 2.2
1. B
3个1和5个0能够表示的最小整数为10000011，值为131-256=-125。
2. A
3. B
65530是无符号数，这里进行无符号扩展后真值依然为65530，因此为0000FFFAH
4. C
5. A
IEEE754标注规定32位浮点数含1位符号位、8位阶码和23位尾数位。-8.25=-1000.01~2~=-1.00001×2^11^（二进制），因此符号位为1，阶码为3+127=130=10000010，尾数为00001000 00000000 0000000。因此存储的值为：11000001 00000100 00000000 00000000，即C1040000H。
6. A
C6400000即为1100 0110 0100 0000 0000 0000 0000 0000，符号位1，阶码为10001100=140，阶数为13，尾数为0.1，加上1变成1.1~2~。因此值为-1.5×2^13^。
7. D
按照IEEE754标准，float型能够表示最大整数时，阶码对应的阶数为254-127=127，尾数为1.111...，易知尾数+2^-23^=2，因此尾数的值为2-2^23^。最终的值为2^127^×(2-2^23^)=2^128^-2^104^。
8. A
按照IEEE754标准，最小的规格化正数阶码对应的阶数为1-127=-126，尾数全0，最终的值为2^-126^。
9. A
CC900000的符号为1，阶码为10011001=152。B0C00000的符号为1，阶码为01100001=97，二者均为负数，且前者绝对值更大，因此前者小于后者。
10.  B
将浮点数类型转换为int类型之后小数部分会丢失，但i本来就没有小数部分，因此A正确，B错误。C由于f的表示范围在float之内，因此转为double之后再转回到float没有影响，C正确。D错误，d比f大得多，会导致f+d时f丢失。
11. C

### 2.3
- 1. 因为二进制的数据使用硬件表示较为方便，其容易与简单的物理状态对应，算数逻辑运算电路更容易实现。
- 2. 首先最为明显的一点代价就是校验码的位数大大增加。单纯的奇偶校验只需要1位校验码，而交叉奇偶校验需要行数+列数个校验位。其次就是校验过程较普通的奇偶校验复杂，需要提取每一行每一列的数据进行校验。
- 3. 补码计算加减法较原码和反码更方便。
- 4. 表示范围由阶码位数决定，精度由尾数位数决定。
- 8. 浮点数的正负只需要看最高位符号位即可。
- 9. 浮点数有两个0指的是浮点数的尾数采用原码表示，因此存在正0和负0两种0。在比较上需要另外进行判断，增加了硬件和软件设计的复杂性。
- 10. 选择一个合适的信息多项式，需要满足多项式最高次数r（也是校验位数）与原始数据信息之和k小于2^r^-1，将原来的数据左移r位之后进行模2除法运算，将余数填入最终数据的最低r位作为校验位。在校验时依然进行模2除法，如果余数为0认为没有错误，否则发现错误。CRC可以纠正一位错误。

### 2.4
|真值|原码|反码|补码|
|:-:|:-:|:-:|:-:|
|0|0.000...|0.000...|0.000...|
|-0|1.000...|1.111...|0.000...|
|0.10101|0.10101|0.10101|0.10101|
|-0.10101|1.10101|1.01010|1.01011|
|0.11111|0.11111|0.11111|0.11111|
|-0.11111|1.11111|1.00000|1.00001|
|-0.10000|1.10000|1.01111|1.10000|
|0.10000|0.10000|0.10000|0.10000|

### 2.5
- 0.10010的真值为0.10010
- 1.00000的真值为-1.00000（减2，反码无法表示这个数）
- 1.10010的真值为-0.01110
- 0.10001的真值为0.10001
- 1.11111的真值为-0.00001
- 1.00001的真值为-0.11111

### 2.6
略

### 2.7
16位无符号数：0-65535
16位原码定点小数：1位作为符号位，数据范围为-32767/32768-32767/32768
16位补码定点小数：数据范围为-1-32767/32768
16位补码定点整数：数据范围为-32768-32767

### 2.8
补码的模为2^最高位的进位位权值^=256

### 2.9
-6.625=-110.101，符号位1，阶码127+2=10000001~2~，尾数10101000...，结果：11000000 11010100 0...=C0D40000~16~

3.1415927需要首先计算尾数。尾数省略最高的1后为10010010 00011111 1011010，后面一位为1，因此进位为1011011。

64000=11111010 00000000

### 2.10
单精度浮点数43940000H=0100 0011 1001 0100 0...，符号位0，阶码10000111=135，阶数8，位数0010100...，结果为1.00101×2^8^=100101000=296。

### 2.11
单精度浮点数能够表示的最大数为2^128^-2^104^，能够表示的最小数是上面数字的相反数。最小正数为非规格化浮点数，尾数为00...01，阶码为0，阶数为<font color=red>-126（不是-127！）</font>。表示的数为2^-126^×2^-23^=2^-149^。

### 2.12
1. 可能
2. 不可能

### 2.13
3位阶码，移码为4。（尾数中没有隐藏位的设定，尾数和阶码均为补码）
最大正数为2^3^×(1-2^6^)
最小正数为2^-4^×2^-6^
最大负数为-2^-4^×2^-6^
最小负数为2^-3^

### 2.14
57=111001，57/128=0.0111001，阶码为-2=1110，尾数为01.11001，最高的0为符号位，结果为1110 0111001000，第二个数略。

### 2.15
01011011的奇校验码为0，偶校验码为1。将收到的信息中的所有位统计1的个数或进行异或运算，奇校验异或结果为1则没有错误，偶校验异或结果为0则没有错误。

### 2.16
略

### 2.17
01101110计算海明校验码：
海明校验码前面几位的第1、2、4、8位为校验码位，其余为数据位。
因此结果必然为：??0?110?1110。
第1位校验码校验第3、5、7、9、11位数据位，值为1。
第2位校验码校验第3、6、7、10、11位数据位，值为1。
第3位校验码校验第5、6、7、12位数据位，值为0
第4位校验码校验第9、10、11、12位数据位，值为1。
结果为110011011110。

如果第8位数据位出错，那么第3和第4个指错字值为1出错，定位到海明码中的第12位，即第8位数据位出错，将对应位取反即可。

### 2.18
数据为1001，生成多项式1101。
对数据左移3位为1001000，除以1101的余数为011，故校验值为011。
若接收到的数据信息为1101，则使用1101011除以011余数不为0，错误。纠错方法：对余数补零继续除获得余数，直到余数为1未知，除的次数即为错误的比特位的位置（左起第几位）。

原理：总校验码的第i位出错时，相除得到的余数补零再除得到的余数等于总校验码的第i+1位出错时相除得到的余数值。